<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>思忆技术</title>
  
  <subtitle>代码即艺术</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://hackycy.github.io/"/>
  <updated>2021-10-09T02:19:57.225Z</updated>
  <id>http://hackycy.github.io/</id>
  
  <author>
    <name>hackycy</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>JSON.stringify()知识点总结</title>
    <link href="http://hackycy.github.io/2021/08/09/JSON-stringify-%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/"/>
    <id>http://hackycy.github.io/2021/08/09/JSON-stringify-知识点总结/</id>
    <published>2021-08-09T10:46:37.000Z</published>
    <updated>2021-10-09T02:19:57.225Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>JSON是一种轻量级数据格式，可以方便地表示复杂数据结构。JSON对象有两个方法：stringify()和parse()。在简单的情况下，这两个方法分别可以将JavaScript序列化为JSON字符串，以及将JSON解析为原生JavaScript值。</p><a id="more"></a><h1 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h1><h2 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h2><p><code>JSON.stringify()</code>可以把一个JavaScript对象序列化为一个JSON字符串。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> json1 = &#123;</span><br><span class="line">  title: <span class="string">"Json.stringify"</span>,</span><br><span class="line">  author: [</span><br><span class="line">    <span class="string">"浪里行舟"</span></span><br><span class="line">  ],</span><br><span class="line">  year: <span class="number">2021</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> jsonText = <span class="built_in">JSON</span>.stringify(json1);</span><br></pre></td></tr></table></figure><p>默认情况下，JSON.stringify()会输出不包含空格或缩进的JSON字符串，因此jsonText的值是这样的：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"&#123;"</span>title<span class="string">":"</span>Json.stringify<span class="string">","</span>author<span class="string">":["</span>浪里行舟<span class="string">"],"</span>year<span class="string">":2021&#125;"</span></span><br></pre></td></tr></table></figure><p>在序列化JavaScript对象时，所有函数和原型成员都会有意地在结果中省略。此外，值为<code>undefined</code>的任何属性也会被跳过。最终得到的就是所有实例属性均为有效JSON数据类型的表示。</p><p>在<code>JSON.stringify()</code>方法一共能接受3个参数，其中两个可选的参数（分别是第二、第三个参数）。这两个可选参数可以用于指定其他序列化JavaScript对象的方式。<strong>第二个参数是过滤器</strong>，可以是数组或函数；<strong>第三个参数是用于缩进结果JSON字符串的选项</strong>。单独或组合使用这些参数可以更好地控制JSON序列化。</p><h2 id="第二个参数–过滤器"><a href="#第二个参数–过滤器" class="headerlink" title="第二个参数–过滤器"></a>第二个参数–过滤器</h2><p>如果第二个参数是一个数组，那么<code>JSON.stringify()</code>返回的结果只会包含该数组中列出的对象属性。比如下面的例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> json1 = &#123;</span><br><span class="line">  title: <span class="string">"Json.stringify"</span>,</span><br><span class="line">  author: [</span><br><span class="line">    <span class="string">"浪里行舟"</span></span><br><span class="line">  ],</span><br><span class="line">  year: <span class="number">2021</span>,</span><br><span class="line">  like: <span class="string">'frontend'</span>,</span><br><span class="line">  weixin: <span class="string">'frontJS'</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> jsonText = <span class="built_in">JSON</span>.stringify(json1, [<span class="string">'weixin'</span>]);</span><br></pre></td></tr></table></figure><p>在这个例子中，JSON.stringify()方法的第二个参数是一个包含一个字符串的数组：”weixin”。它对应着要序列化的对象中的属性，因此结果JSON字符串中只会包含这个属性：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"&#123;"</span>weixin<span class="string">":"</span>frontJS<span class="string">"&#125;"</span></span><br></pre></td></tr></table></figure><p>如果第二个参数是一个函数，则行为又有不同。提供的函数接收两个参数：属性名（key）和属性值（value）。可以根据这个key决定要对相应属性执行什么操作。这个key始终是字符串，只是在值不属于某个键/值对时会是空字符串。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> students = [</span><br><span class="line">  &#123;</span><br><span class="line">    name: <span class="string">'james'</span>,</span><br><span class="line">    score: <span class="number">100</span>,</span><br><span class="line">  &#125;, &#123;</span><br><span class="line">    name: <span class="string">'jordon'</span>,</span><br><span class="line">    score: <span class="number">60</span>,</span><br><span class="line">  &#125;, &#123;</span><br><span class="line">    name: <span class="string">'kobe'</span>,</span><br><span class="line">    score: <span class="number">90</span>,</span><br><span class="line">  &#125;</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">replacer</span> (<span class="params">key, value</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (key === <span class="string">'score'</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (value === <span class="number">100</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">'S'</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (value &gt;= <span class="number">90</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">'A'</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (value &gt;= <span class="number">70</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">'B'</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (value &gt;= <span class="number">50</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">'C'</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">'E'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">JSON</span>.stringify(students, replacer, <span class="number">4</span>))</span><br></pre></td></tr></table></figure><p>上面的代码，我们通过replacer将成绩从百分制替换为成绩等级。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">"name"</span>: <span class="string">"james"</span>,</span><br><span class="line">        <span class="string">"score"</span>: <span class="string">"S"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">"name"</span>: <span class="string">"jordon"</span>,</span><br><span class="line">        <span class="string">"score"</span>: <span class="string">"C"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">"name"</span>: <span class="string">"kobe"</span>,</span><br><span class="line">        <span class="string">"score"</span>: <span class="string">"A"</span></span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>值得注意的是，如果stringify的第二个参数为函数那么它的返回值<strong>如果是undefined，那么对应的属性不会被序列化</strong>，如果返回其他的值，那么用返回的值替代原来的值进行序列化。</p><h2 id="第三个参数–字符串缩进"><a href="#第三个参数–字符串缩进" class="headerlink" title="第三个参数–字符串缩进"></a>第三个参数–字符串缩进</h2><p><code>JSON.stringify()</code>方法的第三个参数控制缩进和空格。在这个参数是数值时，表示每一级缩进的空格数。例如，每级缩进4个空格，可以这样：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> json1 = &#123;</span><br><span class="line">  title: <span class="string">"Json.stringify"</span>,</span><br><span class="line">  author: [</span><br><span class="line">    <span class="string">"浪里行舟"</span></span><br><span class="line">  ],</span><br><span class="line">  year: <span class="number">2021</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> jsonText = <span class="built_in">JSON</span>.stringify(json1, <span class="literal">null</span>, <span class="number">4</span>);</span><br></pre></td></tr></table></figure><p>这样得到的jsonText格式如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">"title"</span>: <span class="string">"Json.stringify"</span>,</span><br><span class="line">    <span class="string">"author"</span>: [</span><br><span class="line">        <span class="string">"浪里行舟"</span></span><br><span class="line">    ],</span><br><span class="line">    <span class="string">"year"</span>: <span class="number">2021</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>JSON.stringify()</code>在处理数据的时候同时考虑了数据转换和方便阅读，只不过，<strong>方便阅读这一点，常常被人忽略</strong>。</p><h2 id="toJSON-方法–自定义JSON序列化"><a href="#toJSON-方法–自定义JSON序列化" class="headerlink" title="toJSON()方法–自定义JSON序列化"></a>toJSON()方法–自定义JSON序列化</h2><p><strong>有时候，对象需要在<code>JSON.stringify()</code>之上自定义JSON序列化</strong>。此时，可以在要序列化的对象中添加<code>toJSON()</code>方法，序列化时会基于这个方法返回适当的JSON表示。</p><p>下面的对象为自定义序列化而添加了一个toJSON()方法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> json1 = &#123;</span><br><span class="line">  title: <span class="string">"Json.stringify"</span>,</span><br><span class="line">  author: [</span><br><span class="line">    <span class="string">"浪里行舟"</span></span><br><span class="line">  ],</span><br><span class="line">  year: <span class="number">2021</span>,</span><br><span class="line">  like: <span class="string">'frontend'</span>,</span><br><span class="line">  weixin: <span class="string">'frontJS'</span>,</span><br><span class="line">  toJSON: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.author</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">JSON</span>.stringify(json1)); <span class="comment">// ["浪里行舟"]</span></span><br></pre></td></tr></table></figure><p>注意，<strong>箭头函数不能用来定义toJSON()方法</strong>。主要原因是箭头函数的词法作用域是全局作用域，在这种情况下不合适。</p><h1 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h1><h2 id="判断数组是否包含某对象，或者判断对象是否相等。"><a href="#判断数组是否包含某对象，或者判断对象是否相等。" class="headerlink" title="判断数组是否包含某对象，或者判断对象是否相等。"></a>判断数组是否包含某对象，或者判断对象是否相等。</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//判断数组是否包含某对象</span></span><br><span class="line"><span class="keyword">let</span> data = [</span><br><span class="line">    &#123;<span class="attr">name</span>:<span class="string">'浪里行舟'</span>&#125;,</span><br><span class="line">    &#123;<span class="attr">name</span>:<span class="string">'前端工匠'</span>&#125;,</span><br><span class="line">    &#123;<span class="attr">name</span>:<span class="string">'前端开发'</span>&#125;,</span><br><span class="line">    ],</span><br><span class="line">    val = &#123;<span class="attr">name</span>:<span class="string">'浪里行舟'</span>&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">JSON</span>.stringify(data).indexOf(<span class="built_in">JSON</span>.stringify(val)) !== <span class="number">-1</span>);<span class="comment">//true</span></span><br></pre></td></tr></table></figure><p>我们还可以使用<code>JSON.stringify()</code>方法,来判断两个对象是否相等。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 判断对象是否相等</span></span><br><span class="line"><span class="keyword">let</span> obj1 = &#123;</span><br><span class="line">    a: <span class="number">1</span>,</span><br><span class="line">    b: <span class="number">2</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> obj2 = &#123;</span><br><span class="line">    a: <span class="number">1</span>,</span><br><span class="line">    b: <span class="number">2</span>,</span><br><span class="line">  &#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">JSON</span>.stringify(obj1) === <span class="built_in">JSON</span>.stringify(obj2)) <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>不过这种方式存在着较大的局限性，<strong>对象如果调整了键的顺序，就会判断出错！</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 调整对象键的位置后</span></span><br><span class="line"><span class="keyword">let</span> obj1 = &#123;</span><br><span class="line">    a: <span class="number">1</span>,</span><br><span class="line">    b: <span class="number">2</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> obj2 = &#123;</span><br><span class="line">    b: <span class="number">2</span>,</span><br><span class="line">    a: <span class="number">1</span>,</span><br><span class="line">  &#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">JSON</span>.stringify(obj1) === <span class="built_in">JSON</span>.stringify(obj2)) <span class="comment">// false</span></span><br></pre></td></tr></table></figure><h2 id="使用localStorage-sessionStorage时"><a href="#使用localStorage-sessionStorage时" class="headerlink" title="使用localStorage/sessionStorage时"></a>使用localStorage/sessionStorage时</h2><p><code>localStorage/sessionStorage</code>默认只能存储字符串，而实际开发中，我们往往需要存储对象类型，那么此时我们需要在存储时利用<code>json.stringify()</code>将对象转为字符串，在取本地缓存时，使用<code>json.parse()</code>转回对象即可。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 存数据</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setLocalStorage</span>(<span class="params">key,val</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">window</span>.localStorage.setItem(key, <span class="built_in">JSON</span>.stringify(val));</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 取数据</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getLocalStorage</span>(<span class="params">key</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> val = <span class="built_in">JSON</span>.parse(<span class="built_in">window</span>.localStorage.getItem(key));</span><br><span class="line">    <span class="keyword">return</span> val;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 测试</span></span><br><span class="line">setLocalStorage(<span class="string">'Test'</span>,[<span class="string">'前端工匠'</span>,<span class="string">'浪里行舟'</span>]);</span><br><span class="line"><span class="built_in">console</span>.log(getLocalStorage(<span class="string">'Test'</span>));</span><br></pre></td></tr></table></figure><h2 id="实现对象深拷贝"><a href="#实现对象深拷贝" class="headerlink" title="实现对象深拷贝"></a>实现对象深拷贝</h2><p>开发中，有时候怕影响原数据，我们常深拷贝出一份数据做任意操作，使用<code>JSON.stringify()</code>与<code>JSON.parse()</code>来实现深拷贝是很不错的选择。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr1 = [<span class="number">1</span>, <span class="number">3</span>, &#123;</span><br><span class="line">    username: <span class="string">' kobe'</span></span><br><span class="line">&#125;];</span><br><span class="line"><span class="keyword">let</span> arr2 = <span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(arr1));</span><br><span class="line">arr2[<span class="number">2</span>].username = <span class="string">'duncan'</span>; </span><br><span class="line"><span class="built_in">console</span>.log(arr1, arr2)</span><br></pre></td></tr></table></figure><p>这是利用<code>JSON.stringify</code>将对象转成JSON字符串，再用<code>JSON.parse</code>把字符串解析成对象，一去一来，新的对象产生了，新对象会开辟新的栈，实现深拷贝。</p><p>这种方法虽然可以实现数组或对象深拷贝,<strong>但不能处理函数和正则</strong>，因为这两者基于<code>JSON.stringify</code>和<code>JSON.parse</code>处理后，得到的正则就不再是正则（变为空对象），得到的函数就不再是函数（变为<code>null</code>）了。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr1 = [<span class="number">1</span>, <span class="number">3</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; &#125;, &#123;</span><br><span class="line">  username: <span class="string">' kobe'</span></span><br><span class="line">&#125;];</span><br><span class="line"><span class="keyword">let</span> arr2 = <span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(arr1));</span><br><span class="line">arr2[<span class="number">3</span>].username = <span class="string">'duncan'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(arr1, arr2)</span><br></pre></td></tr></table></figure><h1 id="使用注意事项"><a href="#使用注意事项" class="headerlink" title="使用注意事项"></a>使用注意事项</h1><p><code>JSON.stringify()</code>虽然功能很强大，但是有些属性无法被stringify，所以在开发中需注意以下几种情况，以免产生一些始料未及的BUG。</p><h2 id="被转换值中有-NaN-和-Infinity"><a href="#被转换值中有-NaN-和-Infinity" class="headerlink" title="被转换值中有 NaN 和 Infinity"></a>被转换值中有 NaN 和 Infinity</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> myObj = &#123;</span><br><span class="line">  name: <span class="string">"浪里行舟"</span>,</span><br><span class="line">  age: <span class="literal">Infinity</span>,</span><br><span class="line">  money: <span class="literal">NaN</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">JSON</span>.stringify(myObj));</span><br><span class="line"><span class="comment">// &#123;"name":"浪里行舟","age":null,"money":null&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">JSON</span>.stringify([<span class="literal">NaN</span>, <span class="literal">Infinity</span>])</span><br><span class="line"><span class="comment">// [null,null]</span></span><br></pre></td></tr></table></figure><h2 id="被转换值中有-undefined、任意的函数以及-symbol-值"><a href="#被转换值中有-undefined、任意的函数以及-symbol-值" class="headerlink" title="被转换值中有 undefined、任意的函数以及 symbol 值"></a>被转换值中有 undefined、任意的函数以及 symbol 值</h2><p>分为两种情况：</p><h3 id="数组-undefined、任意的函数以及symbol值在序列化的过程中会被转换成-null"><a href="#数组-undefined、任意的函数以及symbol值在序列化的过程中会被转换成-null" class="headerlink" title="数组,undefined、任意的函数以及symbol值在序列化的过程中会被转换成 null"></a>数组,<code>undefined</code>、任意的函数以及<code>symbol</code>值在序列化的过程中会被转换成 <code>null</code></h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">JSON</span>.stringify([<span class="literal">undefined</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; &#125;, <span class="built_in">Symbol</span>(<span class="string">""</span>)]);</span><br><span class="line"><span class="comment">// '[null,null,null]'</span></span><br></pre></td></tr></table></figure><h3 id="非数组-undefined、任意的函数以及symbol值在序列化的过程中会被忽略"><a href="#非数组-undefined、任意的函数以及symbol值在序列化的过程中会被忽略" class="headerlink" title="非数组,undefined、任意的函数以及symbol值在序列化的过程中会被忽略"></a>非数组,undefined、任意的函数以及symbol值在序列化的过程中会被忽略</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">JSON</span>.stringify(&#123; <span class="attr">x</span>: <span class="literal">undefined</span>, <span class="attr">y</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; &#125;, <span class="attr">z</span>: <span class="built_in">Symbol</span>(<span class="string">""</span>) &#125;);</span><br><span class="line"><span class="comment">// '&#123;&#125;'</span></span><br></pre></td></tr></table></figure><h2 id="循环引用"><a href="#循环引用" class="headerlink" title="循环引用"></a>循环引用</h2><p>如果一个对象的属性值通过某种间接的方式指回该对象本身，那么就是一个循环引用。比如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> bar = &#123;</span><br><span class="line">  a: &#123;</span><br><span class="line">    c: foo</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> foo = &#123;</span><br><span class="line">  b: bar</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">JSON</span>.stringify(foo)</span><br></pre></td></tr></table></figure><p>这种情况下，序列化会报错的：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 错误信息</span></span><br><span class="line">Uncaught <span class="built_in">ReferenceError</span>: foo is not defined</span><br><span class="line">    at &lt;anonymous&gt;:<span class="number">3</span>:<span class="number">8</span></span><br></pre></td></tr></table></figure><h2 id="含有不可枚举的属性值时"><a href="#含有不可枚举的属性值时" class="headerlink" title="含有不可枚举的属性值时"></a>含有不可枚举的属性值时</h2><p>不可枚举的属性默认会被忽略：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> personObj = <span class="built_in">Object</span>.create(<span class="literal">null</span>, &#123;</span><br><span class="line">  name: &#123; <span class="attr">value</span>: <span class="string">"浪里行舟"</span>, <span class="attr">enumerable</span>: <span class="literal">false</span> &#125;,</span><br><span class="line">  year: &#123; <span class="attr">value</span>: <span class="string">"2021"</span>, <span class="attr">enumerable</span>: <span class="literal">true</span> &#125;,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">JSON</span>.stringify(personObj)) <span class="comment">// &#123;"year":"2021"&#125;</span></span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p><code>JSON.stringify()</code>用于将JavaScript对象序列化为JSON字符串，这方法有一些选项可以用来改变默认的行为，以实现过滤或修改流程。不过也应该注意有些属性是无法被 stringify，所以开发时候应该避开这些坑！</p><blockquote><p>文章来源：<strong>前端工匠</strong>:<a href="https://mp.weixin.qq.com/s/sxAyJO8wWxpkapwLB1i9Yw" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/sxAyJO8wWxpkapwLB1i9Yw</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;JSON是一种轻量级数据格式，可以方便地表示复杂数据结构。JSON对象有两个方法：stringify()和parse()。在简单的情况下，这两个方法分别可以将JavaScript序列化为JSON字符串，以及将JSON解析为原生JavaScript值。&lt;/p&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="http://hackycy.github.io/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="http://hackycy.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>Chrome DevTools查看页面是否开启gzip压缩</title>
    <link href="http://hackycy.github.io/2021/06/24/Chrome-DevTools%E6%9F%A5%E7%9C%8B%E9%A1%B5%E9%9D%A2%E6%98%AF%E5%90%A6%E5%BC%80%E5%90%AFgzip%E5%8E%8B%E7%BC%A9/"/>
    <id>http://hackycy.github.io/2021/06/24/Chrome-DevTools查看页面是否开启gzip压缩/</id>
    <published>2021-06-24T17:02:32.000Z</published>
    <updated>2021-10-09T02:19:56.857Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><strong>在自身不确定服务器是否开启了支持gzip时可以通过以下方法查看。</strong></p><p><strong>方法一</strong></p><p>打开<code>Chrome DevTools</code>，选中<code>Network</code>面板右键点击表头</p><a id="more"></a><p><img src="devtool.png" alt></p><p>如果<code>Content-Encoding</code>中有<code>gzip</code>值则代表已经开启支持gzip。</p><p><strong>方法二</strong></p><p>打开网址<a href="http://tool.chinaz.com/Gzips" target="_blank" rel="noopener">http://tool.chinaz.com/Gzips</a>进行查询，如：</p><p><img src="chinaz.png" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;在自身不确定服务器是否开启了支持gzip时可以通过以下方法查看。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;方法一&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;打开&lt;code&gt;Chrome DevTools&lt;/code&gt;，选中&lt;code&gt;Network&lt;/code&gt;面板右键点击表头&lt;/p&gt;
    
    </summary>
    
      <category term="程序人生" scheme="http://hackycy.github.io/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/"/>
    
    
      <category term="chrome" scheme="http://hackycy.github.io/tags/chrome/"/>
    
  </entry>
  
  <entry>
    <title>手写实现Promise</title>
    <link href="http://hackycy.github.io/2021/06/11/%E6%89%8B%E5%86%99%E5%AE%9E%E7%8E%B0Promise/"/>
    <id>http://hackycy.github.io/2021/06/11/手写实现Promise/</id>
    <published>2021-06-11T14:37:19.000Z</published>
    <updated>2021-10-09T02:19:57.405Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Promise的出现"><a href="#Promise的出现" class="headerlink" title="Promise的出现"></a>Promise的出现</h1><p>在 Promise 出现以前，在我们处理多个异步请求嵌套时，代码往往是个回掉地狱</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>)</span><br><span class="line"></span><br><span class="line">fs.readFile(<span class="string">'./name.txt'</span>,<span class="string">'utf8'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">err,data</span>)</span>&#123;</span><br><span class="line">  fs.readFile(data, <span class="string">'utf8'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">err,data</span>)</span>&#123;</span><br><span class="line">    fs.readFile(data,<span class="string">'utf8'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">err,data</span>)</span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(data);</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>为了拿到回调的结果，我们必须一层一层的嵌套，可以说是相当恶心了。而且基本上我们还要对每次请求的结果进行一系列的处理，使得代码变的更加难以阅读和难以维护，这就是传说中臭名昭著的<strong>回调地狱</strong>～产生<strong>回调地狱</strong>的原因归结起来有两点：</p><ol><li><strong>嵌套调用</strong>，第一个函数的输出往往是第二个函数的输入；</li><li><strong>处理多个异步请求并发</strong>，开发时往往需要同步请求最终的结果。</li></ol><a id="more"></a><p>原因分析出来后，那么问题的解决思路就很清晰了：</p><ol><li><strong>消灭嵌套调用</strong>：通过 Promise 的链式调用可以解决；</li><li><strong>合并多个任务的请求结果</strong>：使用 Promise.all 获取合并多个任务的错误处理。</li></ol><p>Promise 正是用一种更加友好的代码组织方式，解决了异步嵌套的问题。</p><p>我们来看看上面的例子用 Promise 实现是什么样的：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">read</span>(<span class="params">filename</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    fs.readFile(filename, <span class="string">'utf8'</span>, (err, data) =&gt; &#123;</span><br><span class="line">      <span class="keyword">if</span> (err) reject(err);</span><br><span class="line">      resolve(data);</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">read(<span class="string">'./name.txt'</span>).then(<span class="function">(<span class="params">data</span>)=&gt;</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> read(data) </span><br><span class="line">&#125;).then(<span class="function">(<span class="params">data</span>)=&gt;</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> read(data)  </span><br><span class="line">&#125;).then(<span class="function">(<span class="params">data</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(data);</span><br><span class="line">&#125;,err=&gt;&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>在传统的异步编程中，如果异步之间存在依赖关系，就需要通过层层嵌套回调的方式满足这种依赖，如果嵌套层数过多，可读性和可以维护性都会变得很差，产生所谓的“回调地狱”，而 Promise 将嵌套调用改为链式调用，增加了可阅读性和可维护性。也就是说，Promise 解决的是异步编码风格的问题。 <strong>那 Promise 的业界实现都有哪些呢？</strong> 业界比较著名的实现 Promise 的类库有 bluebird、Q、ES6-Promise。</p><h1 id="Promise-A-手写步骤分析"><a href="#Promise-A-手写步骤分析" class="headerlink" title="Promise/A+手写步骤分析"></a>Promise/A+手写步骤分析</h1><p>我们想要手写一个 Promise，就要遵循 <a href="https://promisesaplus.com/" target="_blank" rel="noopener">Promise/A+</a> 规范，业界所有 Promise 的类库都遵循这个规范。</p><p>其实 Promise/A+ 规范对如何实现一个符合标准的 Promise 类库已经阐述的很详细了。每一行代码在 Promise/A+ 规范中都有迹可循，所以在下面的实现的过程中，我会尽可能的将代码和 Promise/A+ 规范一一对应起来。</p><blockquote><p>中文译文：<a href="https://www.ituring.com.cn/article/66566" target="_blank" rel="noopener">https://www.ituring.com.cn/article/66566</a></p><p>本文讲解使用ES5方式实现，代码仓库中补充ES6 class方式实现</p></blockquote><p>结合Promise/A+的规范，边分析基础特征，边一步步实现代码：</p><h2 id="promise-有三个状态：pending，fulfilled，or-rejected"><a href="#promise-有三个状态：pending，fulfilled，or-rejected" class="headerlink" title="promise 有三个状态：pending，fulfilled，or rejected"></a>promise 有三个状态：<code>pending</code>，<code>fulfilled</code>，or <code>rejected</code></h2><p>根据三种状态，我们先定义成枚举，方便后续使用</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> State = &#123;</span><br><span class="line">  PENDING: <span class="built_in">Symbol</span>.for(<span class="string">'pending'</span>),</span><br><span class="line">  FULFILLED: <span class="built_in">Symbol</span>.for(<span class="string">'fulfilled'</span>),</span><br><span class="line">  REJECTED: <span class="built_in">Symbol</span>.for(<span class="string">'rejected'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当处于某一种状态时又需要满足以下的条件：</p><ul><li>等待态（Pending）<ul><li>可以迁移至执行态或拒绝态</li></ul></li><li>执行态（Fulfilled）<ul><li>不能迁移至其他任何状态</li><li>必须拥有一个<strong>不可变</strong>的终值</li></ul></li><li>拒绝态（Rejected）<ul><li>不能迁移至其他任何状态</li><li>必须拥有一个<strong>不可变</strong>的据因</li></ul></li></ul><p>根据以上条件当改变状态时，抽象成一个通用改变State的方法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * this需要绑定指向Promise实例</span></span><br><span class="line"><span class="comment"> * @param &#123;State&#125; state </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">changeState</span>(<span class="params">state</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.state === state) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'不能迁移至相同状态'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (state === State.PENDING) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'不允许迁移至Pending状态'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.state === State.FULFILLED || <span class="keyword">this</span>.state === State.REJECTED) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'当前State不为Pending状态时则不能再迁移至其他任何状态'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">this</span>.state = state</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Promise-是一个拥有-then-方法的对象或函数，且new-Promise-时，需要传递一个executor-函数执行器。"><a href="#Promise-是一个拥有-then-方法的对象或函数，且new-Promise-时，需要传递一个executor-函数执行器。" class="headerlink" title="Promise 是一个拥有 then 方法的对象或函数，且new Promise()时，需要传递一个executor()函数执行器。"></a>Promise 是一个拥有 <code>then</code> 方法的对象或函数，且<code>new Promise()</code>时，需要传递一个<code>executor()</code>函数执行器。</h2><p>那么我们先定义两个工具函数，后续也会用到</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 检测是否是一个函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isFunction</span>(<span class="params">check</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (<span class="keyword">typeof</span> check === <span class="string">'function'</span> || <span class="built_in">Object</span>.prototype.toString.call(check) === <span class="string">'[object Function]'</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检测是否是一个对象</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isObject</span>(<span class="params">check</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> check === <span class="built_in">Object</span>(check)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么根据定义可以实现一下代码</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Promise类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Promise</span>(<span class="params">executor</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (isFunction(executor)) &#123;</span><br><span class="line">    executor()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="executor并接受两个参数，分别是fulfill和reject，且该函数执行器立即执行。"><a href="#executor并接受两个参数，分别是fulfill和reject，且该函数执行器立即执行。" class="headerlink" title="executor并接受两个参数，分别是fulfill和reject，且该函数执行器立即执行。"></a><code>executor</code>并接受两个参数，分别是<code>fulfill</code>和<code>reject</code>，且该函数执行器立即执行。</h2><p>并且这里要结合第一点：</p><p><code>Promise</code>中有变量来代表当前的状态，且状态默认为Pending</p><p><code>Promise</code>有一个<code>value</code>保存成功状态的值，可以是<code>undefined/thenable/promise</code>；「规范 Promise/A+ 1.3」</p><p><code>Promise</code> 有一个<code>reason</code>保存失败状态的值；「规范 Promise/A+ 1.5」</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 调用方法时改变Promise状态且拥有一个终值</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fulfill</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">  changeState.call(<span class="keyword">this</span>, State.FULFILLED)</span><br><span class="line">  <span class="keyword">this</span>.value = value</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用方法时改变Promise状态且拥有一个据因</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reject</span>(<span class="params">reason</span>) </span>&#123;</span><br><span class="line">  changeState.call(<span class="keyword">this</span>, State.REJECTED)</span><br><span class="line">  <span class="keyword">this</span>.reason = reason</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Promise类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Promise</span>(<span class="params">executor</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.state = State.PENDING</span><br><span class="line">  <span class="keyword">this</span>.value = <span class="literal">undefined</span></span><br><span class="line">  <span class="keyword">this</span>.reason = <span class="literal">undefined</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (isFunction(executor)) &#123;</span><br><span class="line">    executor(fulfill.bind(<span class="keyword">this</span>), reject.bind(<span class="keyword">this</span>))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>通常fulfill的定义也可以表示为resolve，但是本文和后续方法名字有点冲突不方便查看所以定义为fulfill，平常所用的resolve意义一样。</p></blockquote><h2 id="一个-promise-必须提供一个-then-方法以访问其当前值、终值和据因。且接受两个参数onFulfilled-onRejected"><a href="#一个-promise-必须提供一个-then-方法以访问其当前值、终值和据因。且接受两个参数onFulfilled-onRejected" class="headerlink" title="一个 promise 必须提供一个 then 方法以访问其当前值、终值和据因。且接受两个参数onFulfilled, onRejected"></a>一个 promise 必须提供一个 <code>then</code> 方法以访问其当前值、终值和据因。且接受两个参数<code>onFulfilled</code>, <code>onRejected</code></h2><p><code>onFulfilled</code> 和 <code>onRejected</code> 都是可选参数，并且两者不为函数则都需要忽略（内部实现用默认函数替代）</p><p>如果 <code>onFulfilled</code> 是函数：</p><ul><li>当 <code>promise</code> 执行结束后其必须被调用，其第一个参数为 <code>promise</code> 的终值</li><li>在 <code>promise</code> 执行结束前其不可被调用</li><li>其调用次数不可超过一次</li></ul><p>如果 <code>onRejected</code> 是函数：</p><ul><li>当 <code>promise</code> 被拒绝执行后其必须被调用，其第一个参数为 <code>promise</code> 的据因</li><li>在 <code>promise</code> 被拒绝执行前其不可被调用</li><li>其调用次数不可超过一次</li></ul><p><code>onFulfilled</code> 和 <code>onRejected</code> 只有在<a href="http://es5.github.io/#x10.3" target="_blank" rel="noopener">执行环境</a>堆栈仅包含<strong>平台代码</strong>时才可被调用（后面再解释）</p><p>根据以上定义，完善现在的代码</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 增加try catch保证稳定执行，因为changeState在不正当切换State时会抛出错误</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fulfill</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    changeState.call(<span class="keyword">this</span>, State.FULFILLED)</span><br><span class="line">    <span class="keyword">this</span>.value = value</span><br><span class="line">    <span class="comment">// 当状态改变时，需要遍历执行队列中的任务</span></span><br><span class="line">    <span class="keyword">this</span>.fulfillQueue.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">fn</span>) </span>&#123; fn() &#125;)</span><br><span class="line">  &#125; <span class="keyword">catch</span> &#123; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reject</span>(<span class="params">reason</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    changeState.call(<span class="keyword">this</span>, State.REJECTED)</span><br><span class="line">    <span class="keyword">this</span>.reason = reason</span><br><span class="line">    <span class="comment">// 当状态改变时，需要遍历执行队列中的任务</span></span><br><span class="line">    <span class="keyword">this</span>.rejectQueue.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">fn</span>) </span>&#123; fn() &#125;)</span><br><span class="line">  &#125; <span class="keyword">catch</span> &#123; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Promise类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Promise</span>(<span class="params">executor</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.state = State.PENDING</span><br><span class="line">  <span class="keyword">this</span>.value = <span class="literal">undefined</span></span><br><span class="line">  <span class="keyword">this</span>.reason = <span class="literal">undefined</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 保存异步执行的队列 &#123; fulfill, reject &#125;</span></span><br><span class="line">  <span class="keyword">this</span>.fulfillQueue = []</span><br><span class="line">  <span class="keyword">this</span>.rejectQueue = []</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (isFunction(executor)) &#123;</span><br><span class="line">    executor(fulfill.bind(<span class="keyword">this</span>), reject.bind(<span class="keyword">this</span>))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.prototype.then = <span class="function"><span class="keyword">function</span>(<span class="params">onFulfilled, onRejected</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> _self = <span class="keyword">this</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.state === State.FULFILLED) &#123;</span><br><span class="line">    onFulfilled(<span class="keyword">this</span>.value)</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.state === State.REJECTED) &#123;</span><br><span class="line">    onRejected(<span class="keyword">this</span>.reason)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 当还没执行时不可以被调用，那么需要将此保存起来，在后续状态改变后调用</span></span><br><span class="line">    <span class="keyword">this</span>.fulfillQueue.push(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      onFulfilled(_self.value)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.rejectQueue.push(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      onRejected(_self.reason)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="then-方法必须返回一个-promise-对象"><a href="#then-方法必须返回一个-promise-对象" class="headerlink" title="then 方法必须返回一个 promise 对象"></a><code>then</code> 方法必须返回一个 <code>promise</code> 对象</h2><p>Promise的优势就在于链式调用，在我们使用Promise的时候，当then函数中返回了一个值，不管是什么值，我们都能在下一个then中获取到，这就是所谓的<strong>then的链式调用</strong>。而且，当我们不再<code>then</code>中放入参数，例如：<code>promise.then().then()</code>，那么其后面的<code>then</code>依然可以得到之前<code>then</code>返回的值，这就是<strong>值得穿透</strong>。这也是规范实现得思路。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> promise2 = promise1.then(onFulfilled, onRejected);</span><br></pre></td></tr></table></figure><ul><li>如果 <code>onFulfilled</code> 或者 <code>onRejected</code> 返回一个值 <code>x</code> ，则运行下面的 <strong>Promise 解决过程</strong>：<code>[[Resolve]](promise2, x)</code></li><li>如果 <code>onFulfilled</code> 或者 <code>onRejected</code> 抛出一个异常 <code>e</code> ，则 <code>promise2</code> 必须拒绝执行，并返回拒因 <code>e</code></li><li>如果 <code>onFulfilled</code> 不是函数且 <code>promise1</code> 成功执行， <code>promise2</code> 必须成功执行并返回相同的值</li><li>如果 <code>onRejected</code> 不是函数且 <code>promise1</code> 拒绝执行， <code>promise2</code> 必须拒绝执行并返回相同的据因</li></ul><blockquote><p> <strong>理解上面的“返回”部分非常重要，即：不论 <code>promise1</code> 被 <code>reject</code> 还是被 <code>resolve</code> 时 <code>promise2</code> 都会被 <code>resolve</code>，只有出现异常时才会被 <code>rejected</code></strong>。</p></blockquote><p>分析一下上述可以看到，then方法需要返回一个新的Promise对象（promise2）,且需要进行处理promise1中<code>then</code>两个参数的返回值</p><p>并且多了一个<code>resolve</code>方法定义<code>Promise解决过程</code>，方法的参数传入<code>（promise2，x）</code>。具体下面再实现，先进行调用。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Promise解决过程</span></span><br><span class="line"><span class="comment"> * @param &#123;Promise&#125; promise2 </span></span><br><span class="line"><span class="comment"> * @param &#123;value&#125; x </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="function"><span class="keyword">function</span> <span class="title">resolve</span>(<span class="params">promise2, x</span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * Promise类</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">function</span> <span class="title">Promise</span>(<span class="params">executor</span>) </span>&#123;</span><br><span class="line">   <span class="keyword">this</span>.state = State.PENDING</span><br><span class="line">   <span class="keyword">this</span>.value = <span class="literal">undefined</span></span><br><span class="line">   <span class="keyword">this</span>.reason = <span class="literal">undefined</span></span><br><span class="line"> </span><br><span class="line">   <span class="comment">// 保存异步执行的队列 &#123; fulfill, reject &#125;</span></span><br><span class="line">   <span class="keyword">this</span>.fulfillQueue = []</span><br><span class="line">   <span class="keyword">this</span>.rejectQueue = []</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">if</span> (isFunction(executor)) &#123;</span><br><span class="line">     executor(fulfill.bind(<span class="keyword">this</span>), reject.bind(<span class="keyword">this</span>))</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> <span class="built_in">Promise</span>.prototype.then = <span class="function"><span class="keyword">function</span>(<span class="params">onFulfilled, onRejected</span>) </span>&#123;</span><br><span class="line">   <span class="keyword">const</span> _self = <span class="keyword">this</span> <span class="comment">// 处理this指向</span></span><br><span class="line">   <span class="comment">// 如果 onFulfilled 不是函数且 promise1 成功执行， promise2 必须成功执行并返回相同的值</span></span><br><span class="line">   onFulfilled = isFunction(onFulfilled) ? onFulfilled : <span class="function"><span class="keyword">function</span>(<span class="params">v</span>) </span>&#123; <span class="keyword">return</span> v &#125;</span><br><span class="line">   <span class="comment">// 如果 onRejected 不是函数且 promise1 拒绝执行， promise2 必须拒绝执行并返回相同的据因</span></span><br><span class="line">   onRejected = isFunction(onRejected) ? onRejected : <span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123; <span class="keyword">throw</span> err &#125;</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">const</span> promise2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">     <span class="keyword">if</span> (_self.state === State.FULFILLED) &#123;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">         <span class="comment">// 如果 onFulfilled 或者 onRejected 返回一个值 x ，则运行下面的 Promise 解决过程</span></span><br><span class="line">         <span class="keyword">const</span> x = onFulfilled(_self.value)</span><br><span class="line">         resolve(promise2, x)</span><br><span class="line">       &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">         <span class="comment">// 如果 onFulfilled 或者 onRejected 抛出一个异常 e ，则 promise2 必须拒绝执行，并返回拒因 e</span></span><br><span class="line">         reject.call(promise2, e)</span><br><span class="line">       &#125;</span><br><span class="line">     &#125; <span class="keyword">else</span> <span class="keyword">if</span> (_self.state === State.REJECTED) &#123;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">         <span class="comment">// 如果 onFulfilled 或者 onRejected 返回一个值 x ，则运行下面的 Promise 解决过程</span></span><br><span class="line">         <span class="keyword">const</span> x = onRejected(_self.reason)</span><br><span class="line">         resolve(promise2, x)</span><br><span class="line">       &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">         <span class="comment">// 如果 onFulfilled 或者 onRejected 抛出一个异常 e ，则 promise2 必须拒绝执行，并返回拒因 e</span></span><br><span class="line">         reject.call(promise2, e)</span><br><span class="line">       &#125;</span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">       <span class="comment">// 当还没执行时不可以被调用，那么需要将此保存起来，在后续状态改变后调用</span></span><br><span class="line">       _self.fulfillQueue.push(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        onFulfilled(_self.value)</span><br><span class="line">      &#125;)</span><br><span class="line"></span><br><span class="line">      _self.rejectQueue.push(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        onRejected(_self.reason)</span><br><span class="line">      &#125;)</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;)</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">return</span> promise2</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h2 id="Promise解决过程-The-Promise-Resolution-Procedure"><a href="#Promise解决过程-The-Promise-Resolution-Procedure" class="headerlink" title="Promise解决过程 (The Promise Resolution Procedure)"></a>Promise解决过程 (The Promise Resolution Procedure)</h2><p>我们先看看规范是怎么定义的：</p><p>Promise 解决过程是一个抽象的操作，其需输入一个 promise 和一个值，我们表示为<code>[[Resolve]](promise, x)</code>，如果 x 有 then 方法且看上去像一个 Promise ，解决程序即尝试使 promise 接受 x 的状态；否则其用 x 的值来执行 promise 。</p><blockquote><p> 这种<code>thenable</code> 的特性使得 Promise 的实现更具有通用性：只要其暴露出一个遵循 Promise/A+ 协议的 then 方法即可；这同时也使遵循 Promise/A+ 规范的实现可以与那些不太规范但可用的实现能良好共存。</p></blockquote><p>运行 <code>[[Resolve]](promise, x)</code>需遵循以下步骤：</p><ul><li><p>x 与 promise 相等<br>如果 promise 和 x 指向同一对象，以 <code>TypeError</code> 为据因拒绝执行 promise</p></li><li><p>x 为 Promise时 ，则使 promise 接受 x 的状态 ：</p><ul><li><p>如果 x 处于等待态， promise 需保持为等待态直至 x 被执行或拒绝</p></li><li><p>如果 x 处于执行态，用相同的值执行 promise</p></li><li><p>如果 x 处于拒绝态，用相同的据因拒绝 promise</p></li></ul></li><li><p>x 为对象或函数时</p><ul><li><p>把 <code>x.then</code> 赋值给 then </p></li><li><p>如果取 <code>x.then</code> 的值时抛出错误 e ，则以 e 为据因拒绝 promise</p></li><li><p>如果 then 是函数，将 x 作为函数的作用域<code>this</code> 调用之。传递两个回调函数作为参数，第一个参数叫做 <code>resolvePromise</code> ，第二个参数叫做 <code>rejectPromise</code>:<br>(1) 如果 <code>resolvePromise</code> 以值 y 为参数被调用，则运行 <code>[[Resolve]](promise, y)</code><br>(2) 如果 <code>rejectPromise</code> 以据因 r 为参数被调用，则以据因 r 拒绝 promise<br>(3) 如果 <code>resolvePromise</code> 和 <code>rejectPromise</code> 均被调用，或者被同一参数调用了多次，则优先采用首次调用并忽略剩下的调用<br>(4) 如果调用 then 方法抛出了异常 e， 如果<code>resolvePromise</code> 或 <code>rejectPromise</code> 已经被调用，则忽略之。否则以 e 为据因拒绝 promise<br>(5) 如果 then 不是函数，以 x 为参数执行 promise</p></li><li><p>如果 x 不为对象或者函数，以 x 为参数执行 promise</p></li></ul></li></ul><blockquote><p> 注：如果一个 promise 被一个循环的 <code>thenable</code> 链中的对象解决，而 <code>[[Resolve]](promise, thenable)</code>的递归性质又使得其被再次调用，根据上述的算法将会陷入无限递归之中。算法虽不强制要求，但也鼓励施者检测这样的递归是否存在，若检测到存在则以一个可识别的<code>TypeError</code>为据因来拒绝 promise。</p></blockquote><p>那么根据定义我们来完善一下先前空实现的<code>resolve</code>方法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Promise解决过程</span></span><br><span class="line"><span class="comment"> * @param &#123;Promise&#125; promise2 </span></span><br><span class="line"><span class="comment"> * @param &#123;value&#125; x </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">resolve</span>(<span class="params">promise2, x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (promise2 === x) &#123;</span><br><span class="line">    <span class="comment">// 如果 promise 和 x 指向同一对象，以 TypeError 为据因拒绝执行 promise</span></span><br><span class="line">    reject.call(promise2, <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">'x 与 promise2 不能相等'</span>))</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (x &amp;&amp; x <span class="keyword">instanceof</span> <span class="built_in">Promise</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (x.state === State.PENDING) &#123;</span><br><span class="line">      <span class="comment">// 如果 x 处于等待态， promise 需保持为等待态直至 x 被执行或拒绝</span></span><br><span class="line">      x.then(<span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">        resolve(promise2, value)</span><br><span class="line">      &#125;, <span class="function"><span class="keyword">function</span> (<span class="params">reason</span>) </span>&#123;</span><br><span class="line">        reject.call(promise2, reason)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (x.state === State.FULFILLED) &#123;</span><br><span class="line">      <span class="comment">// 如果 x 处于执行态，用相同的值执行 promise</span></span><br><span class="line">      resolve(promise2, x.value)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 如果 x 处于拒绝态，用相同的据因拒绝 promise</span></span><br><span class="line">      reject.call(promise2, x.reason)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isObject(x) || isFunction(x)) &#123;</span><br><span class="line">    <span class="comment">// x 为对象或函数时</span></span><br><span class="line">    <span class="comment">// 由于不允许调用多次，采用一个变量记录是否已经被调用过</span></span><br><span class="line">    <span class="keyword">let</span> called = <span class="literal">false</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 把 `x.then` 赋值给 then </span></span><br><span class="line">      <span class="keyword">const</span> then = x.then</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 如果then是个函数</span></span><br><span class="line">      <span class="keyword">if</span> (isFunction(then)) &#123;</span><br><span class="line"></span><br><span class="line">        then.call(x, <span class="function"><span class="keyword">function</span> (<span class="params">y</span>) </span>&#123;</span><br><span class="line">          <span class="comment">// resolvePromise</span></span><br><span class="line">          <span class="keyword">if</span> (!called) &#123;</span><br><span class="line">            called = <span class="literal">true</span></span><br><span class="line">            resolve(promise2, y)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;, <span class="function"><span class="keyword">function</span> (<span class="params">r</span>) </span>&#123;</span><br><span class="line">          <span class="comment">// resolvePromise</span></span><br><span class="line">          <span class="keyword">if</span> (!called) &#123;</span><br><span class="line">            called = <span class="literal">true</span></span><br><span class="line">            reject.call(promise2, r)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;)</span><br><span class="line"></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 如果不是函数</span></span><br><span class="line">        fulfill.call(promise2, x)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!called) &#123;</span><br><span class="line">        <span class="comment">// 如果已经调用过则忽略</span></span><br><span class="line">        <span class="comment">// 如果取 `x.then` 的值时抛出错误 e ，则以 e 为据因拒绝 promise</span></span><br><span class="line">        reject.call(promise2, e)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 如果 x 不为对象或者函数</span></span><br><span class="line">    fulfill.call(promise2, x)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>看到这里问题来了，Promise的异步概念还没有体现到，这是因为规范后面有一个注释：</p><p>有英文能力的可以看一下原文：<a href="https://promisesaplus.com/#notes" target="_blank" rel="noopener">https://promisesaplus.com/#notes</a></p><p><strong>注释</strong></p><p>在本文第四点提到的<strong>平台代码</strong>指的是引擎、环境以及 promise 的实施代码。实践中要确保 <code>onFulfilled</code> 和 <code>onRejected</code> 方法异步执行，且应该在 <code>then</code> 方法被调用的那一轮事件循环之后的新执行栈中执行。这个事件队列可以采用“宏任务（macro-task）”机制或者“微任务（micro-task）”机制来实现。由于 promise 的实施代码本身就是平台代码（<strong>译者注：</strong>即都是 JavaScript），故代码自身在处理在处理程序时可能已经包含一个任务调度队列。</p><p><strong>译者注：</strong>这里提及了 macrotask 和 microtask 两个概念，这表示异步任务的两种分类。在挂起任务时，JS 引擎会将所有任务按照类别分到这两个队列中，首先在 macrotask 的队列（这个队列也被叫做 task queue）中取出第一个任务，执行完毕后取出 microtask 队列中的所有任务顺序执行；之后再取 macrotask 任务，周而复始，直至两个队列的任务都取完。</p><p>两个类别的具体分类如下：</p><ul><li><strong>macro-task:</strong> script（整体代码）, <code>setTimeout</code>, <code>setInterval</code>, <code>setImmediate</code>, <code>I/O</code>, <code>UI rendering</code></li><li><strong>micro-task:</strong> <code>process.nextTick</code>, <code>Promises</code>（这里指浏览器实现的原生 Promise）, <code>Object.observe</code>, <code>MutationObserver</code></li></ul><p>详见 <a href="http://stackoverflow.com/questions/25915634/difference-between-microtask-and-macrotask-within-an-event-loop-context" target="_blank" rel="noopener">stackoverflow 解答</a> 或 <a href="http://wengeezhang.com/?p=11" target="_blank" rel="noopener">这篇博客</a></p></blockquote><h2 id="使用setTimeout模拟异步处理"><a href="#使用setTimeout模拟异步处理" class="headerlink" title="使用setTimeout模拟异步处理"></a>使用setTimeout模拟异步处理</h2><p>最终完善一下<code>then</code>方法，直接贴所有代码</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 尝试手写实现Promise</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isFunction</span>(<span class="params">check</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (<span class="keyword">typeof</span> check === <span class="string">'function'</span> || <span class="built_in">Object</span>.prototype.toString.call(check) === <span class="string">'[object Function]'</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isObject</span>(<span class="params">check</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> check === <span class="built_in">Object</span>(check)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// promise 的三种状态</span></span><br><span class="line"><span class="keyword">const</span> State = &#123;</span><br><span class="line">  PENDING: <span class="built_in">Symbol</span>.for(<span class="string">'pending'</span>),</span><br><span class="line">  FULFILLED: <span class="built_in">Symbol</span>.for(<span class="string">'fulfilled'</span>),</span><br><span class="line">  REJECTED: <span class="built_in">Symbol</span>.for(<span class="string">'rejected'</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * this需要绑定指向Promise实例</span></span><br><span class="line"><span class="comment"> * @param &#123;State&#125; state </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">changeState</span>(<span class="params">state</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.state === state) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'不能迁移至相同状态'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (state === State.PENDING) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'不允许迁移至Pending状态'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.state === State.FULFILLED || <span class="keyword">this</span>.state === State.REJECTED) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'不能迁移至其他任何状态'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">this</span>.state = state</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fulfill</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    changeState.call(<span class="keyword">this</span>, State.FULFILLED)</span><br><span class="line">    <span class="keyword">this</span>.value = value</span><br><span class="line">    <span class="comment">// 当状态改变时，需要遍历执行队列中的任务</span></span><br><span class="line">    <span class="keyword">this</span>.fulfillQueue.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">fn</span>) </span>&#123; fn() &#125;)</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reject</span>(<span class="params">reason</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    changeState.call(<span class="keyword">this</span>, State.REJECTED)</span><br><span class="line">    <span class="keyword">this</span>.reason = reason</span><br><span class="line">    <span class="comment">// 当状态改变时，需要遍历执行队列中的任务</span></span><br><span class="line">    <span class="keyword">this</span>.rejectQueue.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">fn</span>) </span>&#123; fn() &#125;)</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Promise解决过程</span></span><br><span class="line"><span class="comment"> * @param &#123;Promise&#125; promise2 </span></span><br><span class="line"><span class="comment"> * @param &#123;value&#125; x </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">resolve</span>(<span class="params">promise2, x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (promise2 === x) &#123;</span><br><span class="line">    <span class="comment">// 如果 promise 和 x 指向同一对象，以 TypeError 为据因拒绝执行 promise</span></span><br><span class="line">    reject.call(promise2, <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">'x 与 promise2 不能相等'</span>))</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (x &amp;&amp; x <span class="keyword">instanceof</span> <span class="built_in">Promise</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (x.state === State.PENDING) &#123;</span><br><span class="line">      <span class="comment">// 如果 x 处于等待态， promise 需保持为等待态直至 x 被执行或拒绝</span></span><br><span class="line">      x.then(<span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">        resolve(promise2, value)</span><br><span class="line">      &#125;, <span class="function"><span class="keyword">function</span> (<span class="params">reason</span>) </span>&#123;</span><br><span class="line">        reject.call(promise2, reason)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (x.state === State.FULFILLED) &#123;</span><br><span class="line">      <span class="comment">// 如果 x 处于执行态，用相同的值执行 promise</span></span><br><span class="line">      resolve(promise2, x.value)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 如果 x 处于拒绝态，用相同的据因拒绝 promise</span></span><br><span class="line">      reject.call(promise2, x.reason)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isObject(x) || isFunction(x)) &#123;</span><br><span class="line">    <span class="comment">// x 为对象或函数时</span></span><br><span class="line">    <span class="comment">// 由于不允许调用多次，采用一个变量记录是否已经被调用过</span></span><br><span class="line">    <span class="keyword">let</span> called = <span class="literal">false</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 把 `x.then` 赋值给 then </span></span><br><span class="line">      <span class="keyword">const</span> then = x.then</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 如果then是个函数</span></span><br><span class="line">      <span class="keyword">if</span> (isFunction(then)) &#123;</span><br><span class="line"></span><br><span class="line">        then.call(x, <span class="function"><span class="keyword">function</span> (<span class="params">y</span>) </span>&#123;</span><br><span class="line">          <span class="comment">// resolvePromise</span></span><br><span class="line">          <span class="keyword">if</span> (!called) &#123;</span><br><span class="line">            called = <span class="literal">true</span></span><br><span class="line">            resolve(promise2, y)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;, <span class="function"><span class="keyword">function</span> (<span class="params">r</span>) </span>&#123;</span><br><span class="line">          <span class="comment">// resolvePromise</span></span><br><span class="line">          <span class="keyword">if</span> (!called) &#123;</span><br><span class="line">            called = <span class="literal">true</span></span><br><span class="line">            reject.call(promise2, r)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;)</span><br><span class="line"></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 如果不是函数</span></span><br><span class="line">        fulfill.call(promise2, x)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!called) &#123;</span><br><span class="line">        <span class="comment">// 如果已经调用过则忽略</span></span><br><span class="line">        <span class="comment">// 如果取 `x.then` 的值时抛出错误 e ，则以 e 为据因拒绝 promise</span></span><br><span class="line">        reject.call(promise2, e)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 如果 x 不为对象或者函数</span></span><br><span class="line">    fulfill.call(promise2, x)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Promise类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Promise</span>(<span class="params">executor</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.state = State.PENDING</span><br><span class="line">  <span class="keyword">this</span>.value = <span class="literal">undefined</span></span><br><span class="line">  <span class="keyword">this</span>.reason = <span class="literal">undefined</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 保存异步执行的队列 &#123; fulfill, reject &#125;</span></span><br><span class="line">  <span class="keyword">this</span>.fulfillQueue = []</span><br><span class="line">  <span class="keyword">this</span>.rejectQueue = []</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (isFunction(executor)) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      executor(fulfill.bind(<span class="keyword">this</span>), reject.bind(<span class="keyword">this</span>))</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">      reject.call(<span class="keyword">this</span>, e)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.prototype.then = <span class="function"><span class="keyword">function</span> (<span class="params">onFulfilled, onRejected</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> _self = <span class="keyword">this</span></span><br><span class="line">  <span class="comment">// promise2 必须成功执行并返回相同的值</span></span><br><span class="line">  onFulfilled = isFunction(onFulfilled) ? onFulfilled : <span class="function"><span class="keyword">function</span> (<span class="params">v</span>) </span>&#123; <span class="keyword">return</span> v &#125;</span><br><span class="line">  <span class="comment">// promise2 必须拒绝执行并返回相同的据因</span></span><br><span class="line">  onRejected = isFunction(onRejected) ? onRejected : <span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123; <span class="keyword">throw</span> err &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> promise2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (_self.state === State.FULFILLED) &#123;</span><br><span class="line">      <span class="comment">// 重点步骤</span></span><br><span class="line">      setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="comment">// 如果 onFulfilled 或者 onRejected 返回一个值 x ，则运行下面的 Promise 解决过程</span></span><br><span class="line">          <span class="keyword">const</span> x = onFulfilled(_self.value)</span><br><span class="line">          resolve(promise2, x)</span><br><span class="line">        &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">          <span class="comment">// 如果 onFulfilled 或者 onRejected 抛出一个异常 e ，则 promise2 必须拒绝执行，并返回拒因 e</span></span><br><span class="line">          reject.call(promise2, e)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;, <span class="number">0</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (_self.state === State.REJECTED) &#123;</span><br><span class="line">      <span class="comment">// 重点步骤</span></span><br><span class="line">      setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="comment">// 如果 onFulfilled 或者 onRejected 返回一个值 x ，则运行下面的 Promise 解决过程</span></span><br><span class="line">          <span class="keyword">const</span> x = onRejected(_self.reason)</span><br><span class="line">          resolve(promise2, x)</span><br><span class="line">        &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">          <span class="comment">// 如果 onFulfilled 或者 onRejected 抛出一个异常 e ，则 promise2 必须拒绝执行，并返回拒因 e</span></span><br><span class="line">          reject.call(promise2, e)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;, <span class="number">0</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 当还没执行时不可以被调用，那么需要将此保存起来，在后续状态改变后调用</span></span><br><span class="line">      _self.fulfillQueue.push(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">          <span class="comment">// 重点步骤</span></span><br><span class="line">          setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 如果 onFulfilled 或者 onRejected 返回一个值 x ，则运行下面的 Promise 解决过程</span></span><br><span class="line">            <span class="keyword">const</span> x = onFulfilled(_self.value)</span><br><span class="line">            resolve(promise2, x)</span><br><span class="line">          &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">            <span class="comment">// 如果 onFulfilled 或者 onRejected 抛出一个异常 e ，则 promise2 必须拒绝执行，并返回拒因 e</span></span><br><span class="line">            reject.call(promise2, e)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;, <span class="number">0</span>)</span><br><span class="line">      &#125;)</span><br><span class="line"></span><br><span class="line">      _self.rejectQueue.push(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 重点步骤</span></span><br><span class="line">        setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 如果 onFulfilled 或者 onRejected 返回一个值 x ，则运行下面的 Promise 解决过程</span></span><br><span class="line">            <span class="keyword">const</span> x = onRejected(_self.reason)</span><br><span class="line">            resolve(promise2, x)</span><br><span class="line">          &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">            <span class="comment">// 如果 onFulfilled 或者 onRejected 抛出一个异常 e ，则 promise2 必须拒绝执行，并返回拒因 e</span></span><br><span class="line">            reject.call(promise2, e)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;, <span class="number">0</span>)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> promise2</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="built_in">Promise</span></span><br></pre></td></tr></table></figure><h1 id="测试手写Promise-A-代码"><a href="#测试手写Promise-A-代码" class="headerlink" title="测试手写Promise/A+代码"></a>测试手写Promise/A+代码</h1><p>需要安装<code>mocha</code>以及<code>promises-aplus-tests</code>库</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm i -D mocha promises-aplus-tests</span><br></pre></td></tr></table></figure><p>新建<strong>test.js</strong>文件，并添加以下代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="built_in">Promise</span> = <span class="built_in">require</span>(<span class="string">'./promise-step'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> adapter = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> res, rej;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        deferred: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> &#123;</span><br><span class="line">                promise: <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>)</span>&#123;</span><br><span class="line">                    res = resolve;</span><br><span class="line">                    rej = reject;</span><br><span class="line">                &#125;),</span><br><span class="line">                resolve: res,</span><br><span class="line">                reject: rej,</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line">describe(<span class="string">"Promises/A+ Tests"</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">require</span>(<span class="string">"promises-aplus-tests"</span>).mocha(adapter);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>手动执行命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ./node_modules/mocha/bin/mocha</span><br></pre></td></tr></table></figure><p>或者在<code>package.json</code>中添加<code>scripts</code></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">"scripts": &#123;</span><br><span class="line">  "test": "mocha"</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>部分运行结果如下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">    The value is `1` with `Number.prototype` modified to have a `<span class="keyword">then</span>` method</span><br><span class="line">      ✓ already-fulfilled</span><br><span class="line">      ✓ immediately-fulfilled</span><br><span class="line">      ✓ eventually-fulfilled (56ms)</span><br><span class="line">      ✓ already-rejected</span><br><span class="line">      ✓ immediately-rejected</span><br><span class="line">      ✓ eventually-rejected (56ms)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">872 passing (16s)</span><br></pre></td></tr></table></figure><h1 id="Promise的API"><a href="#Promise的API" class="headerlink" title="Promise的API"></a>Promise的API</h1><h2 id="Promise-resolve"><a href="#Promise-resolve" class="headerlink" title="Promise.resolve"></a>Promise.resolve</h2><p>我们来看看MDN上的定义：<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise/resolve" target="_blank" rel="noopener">Promise.resolve()</a></p><p><code>**Promise.resolve(value)**</code>方法返回一个以给定值解析后的<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise" target="_blank" rel="noopener"><code>Promise</code></a> 对象。如果这个值是一个 promise ，那么将返回这个 promise如果这个值是thenable（即带有<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise/then" target="_blank" rel="noopener"><code>&quot;then&quot;</code></a>方法），返回的promise会“跟随”这个thenable的对象，采用它的最终状态；否则返回的promise将以此值完成。此函数将类promise对象的多层嵌套展平。</p><p>根据定义我们来手写实现一下</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.resolve = <span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 如果value是个Promise，那么直接返回</span></span><br><span class="line">  <span class="keyword">if</span> (value &amp;&amp; value <span class="keyword">instanceof</span> <span class="built_in">Promise</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> value</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (isFunction(value.then)) &#123;</span><br><span class="line">      x.then(<span class="function"><span class="keyword">function</span>(<span class="params">v</span>) </span>&#123;</span><br><span class="line">        resolve(v)</span><br><span class="line">      &#125;, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">        reject(e)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      resolve(value)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> promise</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试一下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Promise.resolve(new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">  setTimeout(() =&gt; &#123;</span><br><span class="line">    resolve('ok');</span><br><span class="line">  &#125;, 3000);</span><br><span class="line">&#125;)).then(data=&gt;&#123;</span><br><span class="line">  console.log(data,'success')</span><br><span class="line">&#125;).catch(err=&gt;&#123;</span><br><span class="line">  console.log(err,'error')</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>控制台等待 <code>3s</code> 后输出：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"ok success"</span></span><br></pre></td></tr></table></figure><h2 id="Promise-reject"><a href="#Promise-reject" class="headerlink" title="Promise.reject"></a>Promise.reject</h2><p><code>Promise.reject()</code>方法返回一个带有拒绝原因的<code>Promise</code>对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.reject = <span class="function"><span class="keyword">function</span> (<span class="params">reason</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">_, reject</span>) </span>&#123;</span><br><span class="line">    reject(reason)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Promise-prototype-catch"><a href="#Promise-prototype-catch" class="headerlink" title="Promise.prototype.catch"></a>Promise.prototype.catch</h2><p><strong>catch()</strong> 方法返回一个<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise" target="_blank" rel="noopener">Promise (en-US)</a>，并且处理拒绝的情况。它的行为与调用<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise/then" target="_blank" rel="noopener"><code>Promise.prototype.then(undefined, onRejected)</code></a> 相同。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.prototype.catch = <span class="function"><span class="keyword">function</span> (<span class="params">callback</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.then(<span class="literal">null</span>, callback)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Promise-prototype-finally"><a href="#Promise-prototype-finally" class="headerlink" title="Promise.prototype.finally"></a>Promise.prototype.finally</h2><p><code>finally()</code> 方法返回一个<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise" target="_blank" rel="noopener"><code>Promise</code></a>。在promise结束时，无论结果是fulfilled或者是rejected，都会执行指定的回调函数。这为在<code>Promise</code>是否成功完成后都需要执行的代码提供了一种方式。</p><p>这避免了同样的语句需要在<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise/then" target="_blank" rel="noopener"><code>then()</code></a>和<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise/catch" target="_blank" rel="noopener"><code>catch()</code></a>中各写一次的情况。</p><blockquote><p><strong>注意:</strong> 在<code>finally</code>回调中 <code>throw</code>（或返回被拒绝的promise）将以 <code>throw()</code> 指定的原因拒绝新的promise.</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.prototype.finally = <span class="function"><span class="keyword">function</span> (<span class="params">callback</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve(callback()).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="keyword">return</span> value &#125;)</span><br><span class="line">  &#125;, <span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve(callback()).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="keyword">throw</span> err &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Promise-all"><a href="#Promise-all" class="headerlink" title="Promise.all"></a>Promise.all</h2><p>Promise.all() 方法接收一个promise的iterable类型（注：Array，Map，Set都属于ES6的iterable类型）的输入，并且只返回一个<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise" target="_blank" rel="noopener"><code>Promise</code></a>实例， 那个输入的所有promise的resolve回调的结果是一个数组。这个<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise" target="_blank" rel="noopener"><code>Promise</code></a>的resolve回调执行是在所有输入的promise的resolve回调都结束，或者输入的iterable里没有promise了的时候。它的reject回调执行是，只要任何一个输入的promise的reject回调执行或者输入不合法的promise就会立即抛出错误，并且reject的是第一个抛出的错误信息。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.all = <span class="function"><span class="keyword">function</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!<span class="built_in">Array</span>.isArray(arr)) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">'param is not iterable'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> resultArr = []</span><br><span class="line">    <span class="comment">// 已处理计数</span></span><br><span class="line">    <span class="keyword">let</span> processCount = <span class="number">0</span></span><br><span class="line">    <span class="keyword">const</span> processResultByIndex = <span class="function"><span class="keyword">function</span>(<span class="params">result, i</span>) </span>&#123;</span><br><span class="line">      resultArr[i] = result</span><br><span class="line">      <span class="comment">// 已处理计数 + 1</span></span><br><span class="line">      processCount += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">// 如果计数等于arr长度则代表已处理完毕，则执行resolve</span></span><br><span class="line">      <span class="keyword">if</span> (processCount === arr.length) &#123;</span><br><span class="line">        resolve(resultArr)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">      <span class="keyword">const</span> item = arr[i]</span><br><span class="line">      <span class="keyword">if</span> (item &amp;&amp; <span class="keyword">typeof</span> item.then === <span class="string">'function'</span>) &#123;</span><br><span class="line">        <span class="comment">// is a promise or thenable</span></span><br><span class="line">        item.then(<span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">          processResultByIndex(value, i)</span><br><span class="line">        &#125;, reject)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// normal value</span></span><br><span class="line">        processResultByIndex(item, i)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试一下</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> promise1 = <span class="built_in">Promise</span>.resolve(<span class="number">3</span>);</span><br><span class="line"><span class="keyword">const</span> promise2 = <span class="number">42</span>;</span><br><span class="line"><span class="keyword">const</span> promise3 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  setTimeout(resolve, <span class="number">100</span>, <span class="string">'foo'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.all([promise1, promise2, promise3]).then(<span class="function">(<span class="params">values</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(values);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// expected output: Array [3, 42, "foo"]</span></span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>从 promise 的使用方法入手，构造出了 promise 的大致框架，然后根据 promise/A+ 规范填充代码，重点实现了 <strong>then 的链式调用和值的穿透</strong>；然后使用测试脚本对所写的代码是否符合规范进行了测试；最后完成了 Promise 的 API 的实现。弄懂 promise 其实并不复杂，归根结底还是孰能生巧。</p><p>且涉及到了JS 的循环机制EventLoop（主线程、微任务、渲染、宏任务）。</p><p>代码已放置Github：<a href="https://github.com/hackycy/practice-examples/blob/master/javascript/promise/promise-step.js" target="_blank" rel="noopener">es5实现</a>、<a href="https://github.com/hackycy/practice-examples/blob/master/javascript/promise/promise-step-es6.js" target="_blank" rel="noopener">es6实现</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Promise的出现&quot;&gt;&lt;a href=&quot;#Promise的出现&quot; class=&quot;headerlink&quot; title=&quot;Promise的出现&quot;&gt;&lt;/a&gt;Promise的出现&lt;/h1&gt;&lt;p&gt;在 Promise 出现以前，在我们处理多个异步请求嵌套时，代码往往是个回掉地狱&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; fs = &lt;span class=&quot;built_in&quot;&gt;require&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&#39;fs&#39;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;fs.readFile(&lt;span class=&quot;string&quot;&gt;&#39;./name.txt&#39;&lt;/span&gt;,&lt;span class=&quot;string&quot;&gt;&#39;utf8&#39;&lt;/span&gt;,&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;err,data&lt;/span&gt;)&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  fs.readFile(data, &lt;span class=&quot;string&quot;&gt;&#39;utf8&#39;&lt;/span&gt;,&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;err,data&lt;/span&gt;)&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    fs.readFile(data,&lt;span class=&quot;string&quot;&gt;&#39;utf8&#39;&lt;/span&gt;,&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;err,data&lt;/span&gt;)&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(data);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;为了拿到回调的结果，我们必须一层一层的嵌套，可以说是相当恶心了。而且基本上我们还要对每次请求的结果进行一系列的处理，使得代码变的更加难以阅读和难以维护，这就是传说中臭名昭著的&lt;strong&gt;回调地狱&lt;/strong&gt;～产生&lt;strong&gt;回调地狱&lt;/strong&gt;的原因归结起来有两点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;嵌套调用&lt;/strong&gt;，第一个函数的输出往往是第二个函数的输入；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;处理多个异步请求并发&lt;/strong&gt;，开发时往往需要同步请求最终的结果。&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="http://hackycy.github.io/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="http://hackycy.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>浅谈CSS设计模式/架构</title>
    <link href="http://hackycy.github.io/2021/06/09/%E6%B5%85%E8%B0%88CSS%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%9E%B6%E6%9E%84/"/>
    <id>http://hackycy.github.io/2021/06/09/浅谈CSS设计模式-架构/</id>
    <published>2021-06-09T11:53:02.000Z</published>
    <updated>2021-10-09T02:19:57.405Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>一套可维护的CSS库离不开一套好的CSS设计模式或者架构。那么这三个主流的CSS设计思想和一个最近通用的CSS设计思想：OOCSS、SMACSS、BEMCSS、METACSS都是必须要去了解的。</p><a id="more"></a><h1 id="OOCSS"><a href="#OOCSS" class="headerlink" title="OOCSS"></a>OOCSS</h1><p><code>OOCSS</code>,字面意思是面向对象的CSS，是由<code>Nicole Sullivan</code>提出的css理论，虽说是理论，实则更像一种程序员间约定的规范：</p><ul><li>Separate structure and skin（分离结构和主题）减少对 HTML 结构的依赖</li><li>Separate container and content（分离容器和内容）增加样式的复用性</li></ul><p>在 <code>OOCSS</code> 的观念中，强调重复使用 <code>class</code>，而应该避免使用 <code>id</code> 作为 CSS 的选择器。OOCSS追求元件的复用，其<code>class</code>命名更为抽象，一般不体现具体事物，而注重表现层的抽取。</p><h1 id="SMACSS"><a href="#SMACSS" class="headerlink" title="SMACSS"></a>SMACSS</h1><p><code>SMACSS</code>通过一个灵活的思维过程来检查你的设计过程和方式是否符合你的架构</p><p>设计的主要规范有三点：</p><ul><li>Categorizing CSS Rules（为css分类）</li><li>Naming Rules（命名规范）</li><li>Minimizing the Depth of Applicability（最小化适配深度）</li></ul><h2 id="Categorizing-CSS-Rules"><a href="#Categorizing-CSS-Rules" class="headerlink" title="Categorizing CSS Rules"></a>Categorizing CSS Rules</h2><p>这一点是<code>SMACSS</code>的核心。SMACSS认为css有5个类别，分别是：</p><ul><li>Base </li><li>Layout </li><li>Module </li><li>State </li><li>Theme or Skin</li></ul><h2 id="Base-Rules"><a href="#Base-Rules" class="headerlink" title="Base Rules"></a>Base Rules</h2><p>基础规范,描述的是任何场合下，页面元素的默认外观。它的定义不会用到class和ID。<code>css reset</code>也属于此类。常见的如<code>normalize.css</code>, <code>CSS Tools</code></p><h2 id="Layout-Rules"><a href="#Layout-Rules" class="headerlink" title="Layout Rules"></a>Layout Rules</h2><p>布局规范,元素是有层次级别之分的，Layout Rules属于较高的一层，它可以作为层级较低的Module Rules元素的容器。左右分栏、栅格系统等都属于布局规范。布局是一个网站的基本，无论是左右还是居中，甚至其他什么布局，要实现页面的基本浏览功能，布局必不可少。SMACSS还约定了一个前缀l-/layout-来标识布局的class。举个最普遍的例子。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.layout-header</span> &#123;&#125;</span><br><span class="line"><span class="selector-class">.layout-container</span> &#123;&#125;</span><br><span class="line"><span class="selector-class">.layout-sidebar</span> &#123;&#125;</span><br><span class="line"><span class="selector-class">.layout-content</span> &#123;&#125;</span><br><span class="line"><span class="selector-class">.layout-footer</span> &#123;&#125;</span><br></pre></td></tr></table></figure><h2 id="Module-Rules"><a href="#Module-Rules" class="headerlink" title="Module Rules"></a>Module Rules</h2><p>模块规范,模块是SMACSS最基本的思想，同时也是大部分CSS理论的基本，将样式模块化就能达到复用和可维护的目的，但是SMACSS提出了更具体的模块化方案。SMACSS中的模块具有自己的一个命名，隶属于模块下的类皆以该模块为前缀，例子如下：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.todolist</span>&#123;&#125;</span><br><span class="line"><span class="selector-class">.todolist-title</span>&#123;&#125;</span><br><span class="line"><span class="selector-class">.todolist-image</span>&#123;&#125;</span><br><span class="line"><span class="selector-class">.todolist-article</span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>可以看到<code>todolist</code>作为一个模块，包含了title，image，article等组件，同时还可以加上如<code>todolist-background-danger</code>等修饰类，在模块内可以使用其名称做前缀任意组织模块结构，但目的是让其变得更易用，提高可扩展性和灵活度，如果只是为了修饰而修饰，写出大量没有任何复用性的类，便是一种弄巧成拙的做法。</p><h2 id="State-Rules"><a href="#State-Rules" class="headerlink" title="State Rules"></a>State Rules</h2><p>状态规范,这个应该很多前端开发者都很好理解，描述的是任一元素在特定状态下的外观。例如，一个消息框可能有success和error等状态。与OOCSS抽取修饰类的方式的不同，SMACSS是抽取更高级别的样式类，得到更强的复用性，如隐藏某个元素的写法：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.is-hidden</span>&#123;</span><br><span class="line">    <span class="attribute">display</span>: none;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Theme-Rules"><a href="#Theme-Rules" class="headerlink" title="Theme Rules"></a>Theme Rules</h2><p>主题规范,描述了页面主题外观，一般是指颜色、背景图。Theme Rules可以修改前面4个类别的样式，且应和前面4个类别分离开来（便于切换，也就是“换肤”）。SMACSS的Theme Rules不要求使用单独的class命名，也就是说，你可以在Module Rules中定义.header{ }然后在Theme Rules中也用.header { }来定义需要修改的部分(后加载覆盖前加载样式内容)</p><h2 id="Naming-Rules"><a href="#Naming-Rules" class="headerlink" title="Naming Rules"></a>Naming Rules</h2><p>命名规范</p><p>按照前面5种的划分:</p><ul><li>Base Rules(Pass)</li><li>Layout Rules用l-或layout-这样的前缀，例如：<code>.l-header</code>、<code>.l-sidebar</code>。</li><li>Module Rules用模块本身的命名，例如图文排列的<code>.media</code>、<code>.media-image</code>。</li><li>State Rules用is-前缀，例如：<code>.is-active</code>、<code>.is-hidden</code>。</li><li>Theme Rules如果作为单独class，用theme-前缀，例如<code>.theme-a-background</code>、<code>.theme-a-shadow</code>。</li></ul><h3 id="Minimizing-the-Depth-of-Applicability"><a href="#Minimizing-the-Depth-of-Applicability" class="headerlink" title="Minimizing the Depth of Applicability"></a>Minimizing the Depth of Applicability</h3><p>最小适配深度原则，简单的例子：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* depth 1 */</span></span><br><span class="line"><span class="selector-class">.sidebar</span> <span class="selector-tag">ul</span> <span class="selector-tag">h3</span> &#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* depth 2 */</span></span><br><span class="line"><span class="selector-class">.sub-title</span> &#123; &#125;</span><br></pre></td></tr></table></figure><p>两段css的区别在于html和css的耦合度(这一点上和OOCSS的分离容器和内容的原则不谋而合)。可以想到，由于上面的样式规则使用了继承选择符，因此对于html的结构实际是有一定依赖的。如果html发生重构，就有可能不再具有这些样式。对应的，下面的样式规则只有一个选择符，因此不依赖于特定html结构，只要为元素添加class，就可以获得对应样式。</p><p>当然，继承选择符是有用的，它可以减少因相同命名引发的样式冲突（常发生于多人协作开发）。但是，我们不应过度使用，在不造成样式冲突的允许范围之内，尽可能使用短的、不限定html结构的选择符。这就是SMACSS的最小化适配深度的意义。</p><h1 id="BEMCSS"><a href="#BEMCSS" class="headerlink" title="BEMCSS"></a>BEMCSS</h1><p>BEM 分别代表着：Block（块）、Element（元素/子块/组成部分）、Modifier（修饰符），是一种组件化的 CSS 命名方法和规范，由俄罗斯 Yandex 团队所提出。其目的是将用户界面划分成独立的（模）块，使开发更为简单和快速，利于团队协作开发。</p><p><strong>特点</strong></p><p>组件化/模块化的开发思路。书写方式解耦化，不会造成命名空间的污染，如：<code>.xxx ul li</code> 写法带来的潜在嵌套风险。命名方式化扁平，避免样式层级过多而导致的解析效率降低，渲染开销变大。组件结构独立化，减少样式冲突，可以将已开完成的组件快速应用到新项目中。有着较好的维护性、易读性、灵活性。规则</p><p>BEM的命名模式在社区中有着不同方式，以下为 Yandex 团队所提出的命名规则为：</p><p><code>.[Block 块]__[Element 元素]_[Modifier 修饰符]</code>不同的命名模式，区别在于BEM之间的连接符号不同，依个人而定：</p><p><code>.[Block 块]__[Element 元素]--[Modifier 修饰符]</code>任何一种规范，都是基于实际需求而定，便于团队开发和维护扩展，每个规范都是经过合理评估后所得出的一种“思路”和“建议”。</p><h2 id="Block（块）"><a href="#Block（块）" class="headerlink" title="Block（块）"></a>Block（块）</h2><p>是一个独立的实体，即通常所说的模块或组件。</p><p>例：header、menu、search</p><p>规则：块名需能清晰的表达出，其用途、功能或意义，具有唯一性。块名称之间用-连接。每个块名前应增加一个前缀，<strong>这前缀在 CSS 中有命名空间（如：m-、u-、分别代表：mod 模块、ui 元件）。每个块在逻辑上和功能上都相互独立。由于块是独立的，可以在应用开发中进行复用，从而降低代码重复并提高开发效率。块可以放置在页面上的任何位置，也可以互相嵌套。同类型的块，在显示上可能会有一定的差异，所以不要定义过多的外观显示样式，主要负责结构的呈现。</strong></p><p>这样就能确保块在不同地方复用和嵌套时，增加其扩展性。综上所述，最终我们可以把BEM规则最终定义成：</p><p><code>.[命名空间]-[组件名/块]__[元素名/元素]--[修饰符]</code> 情景 需要构建一个 <code>search</code> 组件。</p><p>写法 <code>.m-search{}</code> 结构</p><p>如果打算开发一套框架，可以使用具有代表性的缩写，用来表示命名空间：<code>Element UI(el-)</code>、<code>Ant Design(ant-)</code>、<code>iView(ivu-)</code>。</p><h2 id="Element（元素）"><a href="#Element（元素）" class="headerlink" title="Element（元素）"></a>Element（元素）</h2><p>是块中的组成部分，对应块中的子元素/子节点。</p><p>例：header title、menu item、list item</p><p>规则：元素名需能简单的描述出，其结构、布局或意义，并且在语义上与块相关联。<strong>块与元素之间用<code>__</code>连接。</strong>不能与块分开单独使用。块的内部元素，都被认为是块的子元素。一个块中元素的类名必须用父级块的名称作为前缀，因此不能写成：<code>block__elem1__elem2</code>。情景 search 组件中包含 input 和 button，是列表中的一个子元素。</p><p>写法 <code>.m-search{}</code>、<code>.m-search__input{}</code>、<code>.m-search__button{}</code>结构</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- search 组件 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">class</span>=<span class="string">"m-search"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- input 是 search 组件的子元素 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">class</span>=<span class="string">"m-search__input"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- button 是 search 组件的子元素 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">class</span>=<span class="string">"m-search__button"</span>&gt;</span>Search<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><p>原则上书写时不会出现两层以上的嵌套，所有样式都为平级，嵌套只出现在<code>.m-block_active</code> ，状态激活时的情况。</p><h2 id="Modifier（修饰符）"><a href="#Modifier（修饰符）" class="headerlink" title="Modifier（修饰符）"></a>Modifier（修饰符）</h2><p>定义块和元素的外观、状态或类型。</p><p>例：<code>color</code>、<code>disabled</code>、<code>size</code></p><p>规则：修饰符需能直观易懂表达出，其外观、状态或行为。修饰符用_连接块与元素。修饰符不能单独使用。在必要时可进行扩展，书写成：<code>block__elem_modifier_modifier</code>，第一个modifier表示其命名空间。情景 假定 search 组件有多种外观，我们选择其中一种。并且在用户未输入内容时，button 显示为禁用样式。</p><p>写法<code>.m-search{}</code> 、 <code>.m-search_dark{}</code>  、<code>.m-search__input{}</code> 、 <code>.m-search__button{}</code> 、 <code>.m-search__button_disabled{}</code> 结构</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- dark 表明 search 组件的外观 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">class</span>=<span class="string">"m-search m-search-form_dark"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">class</span>=<span class="string">"m-search__input"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- disabled 表明 search__button 的状态 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">class</span>=<span class="string">"m-search__button m-search__button_disabled"</span>&gt;</span>Search<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>很多人觉得 BEM 写法难看，审美本是“智者见智，仁者见仁”的事。刚刚接触可能是会觉得有点奇怪，但所有东西都有一个适应过程。如果仅仅为了好看，规避其优点，我认为得不偿失。个人建议可以尝试使用 BEM 规范来书写代码。</p><p>BEM 命名会使得 Class 类名变长，但经过 GZIP 等压缩后，文件的体积其实并无太大影响。</p><p>就和早年提出 CSS语义化 一样，不要为了语义而去语义，语义化本身的作用就是帮助大家更好的识别代码，所有的规范都是基于项目的发展和团队的协作，团队可以根据成员的意愿选择最合适的方式。</p></blockquote><h1 id="METACSS"><a href="#METACSS" class="headerlink" title="METACSS"></a>METACSS</h1><p>一些写在全局的通用方法，是SMACSS中通用方法思想的分支，一般以css属性、Emmet css缩写或功能来命名，通常以一个css属性为一个单位</p><p>表示属性的：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.df</span> &#123; <span class="attribute">display</span>: flex; &#125;</span><br></pre></td></tr></table></figure><p>表示功能的：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.tcut</span> &#123;  </span><br><span class="line">  <span class="attribute">text-overflow</span>: ellipsis;</span><br><span class="line">  <span class="attribute">white-space</span>: nowrap;</span><br><span class="line">  <span class="attribute">overflow</span>: hidden;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以此类推，封装好放到全局来使用，快速添加属性来开发页面。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>smacss覆盖了所有的细节点；bemcss着重css的命名和语义化；oocss着重可复用，把每一个dom节点当成一个对象，是css返璞归真的思想；metacss着重快速开发快速添加属性，颗粒度更细，通过在html代码中添加类名来添加属性，不必再去找相对应的选择器中的css代码来修改样式。</p><blockquote><p>原文来自：<a href="https://juejin.cn/post/6958690548009926687" target="_blank" rel="noopener">https://juejin.cn/post/6958690548009926687</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一套可维护的CSS库离不开一套好的CSS设计模式或者架构。那么这三个主流的CSS设计思想和一个最近通用的CSS设计思想：OOCSS、SMACSS、BEMCSS、METACSS都是必须要去了解的。&lt;/p&gt;
    
    </summary>
    
      <category term="CSS" scheme="http://hackycy.github.io/categories/CSS/"/>
    
    
      <category term="CSS" scheme="http://hackycy.github.io/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>Git项目换行符LF与CRLF导致ESLint报错解决方法</title>
    <link href="http://hackycy.github.io/2021/03/19/Git%E9%A1%B9%E7%9B%AE%E6%8D%A2%E8%A1%8C%E7%AC%A6LF%E4%B8%8ECRLF%E5%AF%BC%E8%87%B4ESLint%E6%8A%A5%E9%94%99%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/"/>
    <id>http://hackycy.github.io/2021/03/19/Git项目换行符LF与CRLF导致ESLint报错解决方法/</id>
    <published>2021-03-19T10:13:13.000Z</published>
    <updated>2021-10-09T02:19:56.885Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="产生该问题的原因"><a href="#产生该问题的原因" class="headerlink" title="产生该问题的原因"></a>产生该问题的原因</h1><p>产生该问题的原因是由于Windows平台和linux平台的默认换行符是不一样的,linux使用的是<code>0x0A(LF)</code>而Windows使用的是<code>0x0D0A(CRLF)</code>,这就导致了当Windows下的代码放到linux下运行时,虽然代码没有错,但是linux下的git检测到项目的换行符为CRLF时会自动换成LF。</p><a id="more"></a><h1 id="该问题的症状"><a href="#该问题的症状" class="headerlink" title="该问题的症状"></a>该问题的症状</h1><p>出现这个问题的症状表现为git会提示项目的每一个文件的所有位置都发生了修改,但是查看diff的时候发现其实哪都没修改,这是因为换行符被换了但是我们是看不出来的。</p><h1 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h1><p>由于代码多是运行在linux,所以现在主流的换行符标准就是LF,所以我们的项目一开始就应该有将换行符设置为LF的意识.</p><p>项目一开始创建,还没有加入git仓库的时候就应该将换行符设置为LF,vscode等工具都提供了这个简单的功能,</p><p><img src="1.png" alt></p><p>如果项目已经加入了git仓库,那就让git帮我们解决问题,git有一个<code>autocrlf</code>配置,可以在我们提交时自动转换换行符,它有3个选项:</p><ul><li><strong>true:</strong> 提交时转换为 LF，检出时转换为 CRLF</li><li><strong>false:</strong> 提交检出均不转换</li><li><strong>input:</strong> 提交时转换为LF，检出时不转换</li></ul><p>另一个设置项<code>safecrlf</code>用于检查文件是否包含着混合换行符,也有3个选项:</p><ul><li><strong>true:</strong> 拒绝提交包含混合换行符的文件</li><li><strong>false:</strong> 允许提交包含混合换行符的文件</li><li><strong>warn:</strong> 提交包含混合换行符的文件时给出警告</li></ul><p>所以,如果我们要将已经加入git的大量CRLF结尾文件批量转换成LF结尾的文件,可以这样设置:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git config --global core.autocrlf input</span><br><span class="line">$ git config --global core.safecrlf warn</span><br></pre></td></tr></table></figure><p>这样设置之后,先将项目提交一次,这样所有的文件就都会被改成LF结尾.</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://jiayaoo3o.github.io/2019/06/26/git项目换行符LF与CRLF导致的大量更改解决办法" target="_blank" rel="noopener">link</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;产生该问题的原因&quot;&gt;&lt;a href=&quot;#产生该问题的原因&quot; class=&quot;headerlink&quot; title=&quot;产生该问题的原因&quot;&gt;&lt;/a&gt;产生该问题的原因&lt;/h1&gt;&lt;p&gt;产生该问题的原因是由于Windows平台和linux平台的默认换行符是不一样的,linux使用的是&lt;code&gt;0x0A(LF)&lt;/code&gt;而Windows使用的是&lt;code&gt;0x0D0A(CRLF)&lt;/code&gt;,这就导致了当Windows下的代码放到linux下运行时,虽然代码没有错,但是linux下的git检测到项目的换行符为CRLF时会自动换成LF。&lt;/p&gt;
    
    </summary>
    
      <category term="程序人生" scheme="http://hackycy.github.io/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/"/>
    
    
      <category term="Git" scheme="http://hackycy.github.io/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>密码学之MD5 + Salt</title>
    <link href="http://hackycy.github.io/2021/03/17/%E5%AF%86%E7%A0%81%E5%AD%A6%E4%B9%8BMD5-Salt/"/>
    <id>http://hackycy.github.io/2021/03/17/密码学之MD5-Salt/</id>
    <published>2021-03-17T11:02:05.000Z</published>
    <updated>2021-10-09T02:19:57.401Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="MD算法的基本概念"><a href="#MD算法的基本概念" class="headerlink" title="MD算法的基本概念"></a>MD算法的基本概念</h1><p>MD5算法是典型的消息摘要算法，其前身有MD2、MD3和MD4算法，它由MD4、MD3和MD2算法改进而来。不论是哪一种MD算法，它们都需 要获得一个随机长度的信息并产生一个128位的信息摘要。如果将这个128位的二进制摘要信息换算成十六进制，可以得到一个32位的字符串，故我们见到的 大部分MD5算法的数字指纹都是32为十六进制的字符串。</p><a id="more"></a><h1 id="MD算法的发展史"><a href="#MD算法的发展史" class="headerlink" title="MD算法的发展史"></a>MD算法的发展史</h1><h2 id="MD2算法"><a href="#MD2算法" class="headerlink" title="MD2算法"></a>MD2算法</h2><p>1989年，著名的非对称算法RSA发明人之一—-麻省理工学院教授罗纳德.李维斯特开发了MD2算法。这个算法首先对信息进行数据补位，使信 息的字节长度是16的倍数。再以一个16位的检验和做为补充信息追加到原信息的末尾。最后根据这个新产生的信息计算出一个128位的散列值，MD2算法由 此诞生。</p><h2 id="MD4算法"><a href="#MD4算法" class="headerlink" title="MD4算法"></a>MD4算法</h2><p>1990年，罗纳德.李维斯特教授开发出较之MD2算法有着更高安全性的MD4算法。在这个算法中，我们仍需对信息进行数据补位。不同的是，这种补 位使其信息的字节长度加上448个字节后成为512的倍数（信息字节长度mod 512 =448）。此外，关于MD4算的处理和MD2算法有很大的差别。但最终仍旧会获得一个128为的散列值。MD4算法对后续消息摘要算法起到了推动作用， 许多比较有名的消息摘要算法都是在MD4算法的基础上发展而来的，如MD5、SHA-1、RIPE-MD和HAVAL算法等。</p><h2 id="MD5算法"><a href="#MD5算法" class="headerlink" title="MD5算法"></a>MD5算法</h2><p>1991年，继MD4算法后，罗纳德.李维斯特教授开发了MD5算法，将MD算法推向成熟。MD5算法经MD2、MD3和MD4算法发展而来，算法复杂程度和安全强度打打提高，但浙西MD算法的最终结果都是产生一个128位的信息摘要。这也是MD系列算法的特点。MD5算法的算法特点如下： （1）压缩性：任意长度的数据，算出的MD5值长度都是固定的。 （2）容易计算：从原数据计算出MD5值很容易。 （3）抗修改性：对原数据进行任何改动，哪怕只修改1个字节，所得到的MD5值都有很大区别。 （4）弱抗碰撞：已知原数据和其MD5值，想找到一个具有相同MD5值的数据（即伪造数据）是非常困难的。 （5）强抗碰撞：想找到两个不同的数据，使它们具有相同的MD5值，是非常困难的。</p><h2 id="MD5破解方面"><a href="#MD5破解方面" class="headerlink" title="MD5破解方面"></a>MD5破解方面</h2><p>在破解md5方面，最常用的方法是“跑字典”，有两种方法得到字典，一种是日常搜集的用做密码的字符串表，另一种是用排列组合方法生成的，先用MD5程序计算出这些字典项的MD5值，然后再用目标的MD5值在这个字典中检索。我们假设密码的最大长度为8位字节（8 Bytes），同时密码只能是字母和数字，共26+26+10=62个字节，排列组合出的字典的项数则是P（62,1）+P（62,2）….+P（62,8），那也已经是一个很天文的数字了，存储这个字典就需要TB级的磁盘阵列，而且这种方法还有一个前提，就是能获得目标账户的密码MD5值的情况下才可以。</p><p>所以总体而言，md5加密是十分安全的，即使有一些瑕疵，但并不影响具体的使用，外加md5是免费的，所以它的应用还是十分广泛的。</p><h1 id="MD5算法应用"><a href="#MD5算法应用" class="headerlink" title="MD5算法应用"></a>MD5算法应用</h1><h2 id="Md5-密码存储加盐"><a href="#Md5-密码存储加盐" class="headerlink" title="Md5 密码存储加盐"></a>Md5 密码存储加盐</h2><p>MD5算法，可以用来保存用户的密码信息。为了更好的保存，可以在保存的过程中，加入盐。/在保存用户密码的时候，盐可以利用生成的随机数。可以将密码结合MD5加盐，生成的数据摘要和盐保存起来 。以便于下次用户验证使用。在用户表里面，也保存salt。</p><h2 id="Md5-文件完整性校验"><a href="#Md5-文件完整性校验" class="headerlink" title="Md5 文件完整性校验"></a>Md5 文件完整性校验</h2><p>每个文件都可以用MD5验证程序算出一个固定的MD5值，是独一无二的。一般来说，开发方会在软件发布时预先算出文件的MD5值，如果文件被盗用，加了木马或者被篡改版权，那么它的MD5值也随之改变，也就是说我们对比文件当前的MD5值和它标准的MD5值来检验它是否正确和完整。 （1）例如网盘中的秒传4G文件，可以使用用户需要上传的文件进行Md5运算，判断与服务器中是否存在该文件，如果存在只需添加文件索引，不存在再真正上传。 （2）例如自动升级的客户端，判断下载的程序安装包是否完整，可以计算文件的MD5值，与服务器端计算的Md5值进行比对。</p><h1 id="MD5加盐"><a href="#MD5加盐" class="headerlink" title="MD5加盐"></a>MD5加盐</h1><p>我们知道，如果直接对密码进行散列，那么黑客可以对通过获得这个密码散列值，然后通过查散列值字典（例如MD5密码破解网站），得到某用户的密码。</p><p>加Salt可以一定程度上解决这一问题。所谓加Salt方法，就是加点“佐料”。其基本想法是这样的：当用户首次提供密码时（通常是注册时），由系统自动往这个密码里撒一些“佐料”，然后再散列。而当用户登录时，系统为用户提供的代码撒上同样的“佐料”，然后散列，再比较散列值，已确定密码是否正确。</p><p><strong>这里的“佐料”被称作“Salt值”，这个值是由系统随机生成的，并且只有系统知道。这样，即便两个用户使用了同一个密码，由于系统为它们生成的salt值不同，他们的散列值也是不同的。即便黑客可以通过自己的密码和自己生成的散列值来找具有特定密码的用户，但这个几率太小了（密码和salt值都得和黑客使用的一样才行）。 </strong></p><p>下面详细介绍一下加Salt散列的过程。介绍之前先强调一点，前面说过，验证密码时要使用和最初散列密码时使用“相同的”佐料。所以Salt值是要存放在数据库里的。</p><p><strong>用户注册时，</strong></p><ol><li>用户输入【账号】和【密码】（以及其他用户信息）；</li><li>系统为用户生成【Salt值】；</li><li>系统将【Salt值】和【用户密码】连接到一起；</li><li>对连接后的值进行散列，得到【Hash值】；</li><li>将【Hash值1】和【Salt值】分别放到数据库中。</li></ol><p><strong>用户登录时，</strong></p><ol><li>用户输入【账号】和【密码】；</li><li>系统通过用户名找到与之对应的【Hash值】和【Salt值】；</li><li>系统将【Salt值】和【用户输入的密码】连接到一起；</li><li>对连接后的值进行散列，得到【Hash值2】（注意是即时运算出来的值）；</li><li>比较【Hash值1】和【Hash值2】是否相等，相等则表示密码正确，否则表示密码错误。</li></ol><p>有时候，为了减轻开发压力，程序员会统一使用一个salt值（储存在某个地方），而不是每个用户都生成私有的salt值。</p><p>例子详解：</p><h2 id="第一代密码"><a href="#第一代密码" class="headerlink" title="第一代密码"></a>第一代密码</h2><p>早期的软件系统或者互联网应用，数据库中设计用户表的时候，大致是这样的结构：</p><p><img src="d1.png" alt></p><p>数据存储形式如下：</p><p><img src="d1-s.png" alt></p><p>主要的关键字段就是这么两个，一个是登陆时的用户名，对应的一个密码，而且那个时候的用户名是明文存储的，如果你登陆时用户名是 123，那么数据库里存的就是 <code>123</code>。这种设计思路非常简单，但是缺陷也非常明显，数据库一旦泄露，那么所有用户名和密码都会泄露，后果非常严重。</p><h2 id="第二代密码"><a href="#第二代密码" class="headerlink" title="第二代密码"></a>第二代密码</h2><p>为了规避第一代密码设计的缺陷，聪明的人在数据库中不在存储明文密码，转而存储加密后的密码，典型的加密算法是 MD5 和 SHA1，其数据表大致是这样设计的：</p><p><img src="d2.png" alt></p><p>数据存储形式如下： </p><p><img src="d2-s.png" alt></p><p>假如你设置的密码是<code>123</code>，那么数据库中存储的就是<code>202cb962ac59075b964b07152d234b70</code>或 <code>40bd001563085fc35165329ea1ff5c5ecbdbbeef</code>。当用户登陆的时候，会把用户输入的密码执行 MD5（或者 SHA1）后再和数据库就行对比，判断用户身份是否合法，这种加密算法称为散列。</p><p>严格地说，这种算法不能算是加密，因为理论上来说，它不能被解密。所以即使数据库丢失了，但是由于数据库里的密码都是密文，根本无法判断用户的原始密码，所以后果也不算太严重。</p><h2 id="第三代密码"><a href="#第三代密码" class="headerlink" title="第三代密码"></a>第三代密码</h2><p>本来第二代密码设计方法已经很不错了，只要你密码设置得稍微复杂一点，就几乎没有被破解的可能性。但是如果你的密码设置得不够复杂，被破解出来的可能性还是比较大的。</p><p>好事者收集常用的密码，然后对他们执行 MD5 或者 SHA1，然后做成一个数据量非常庞大的数据字典，然后对泄露的数据库中的密码就行对比，如果你的原始密码很不幸的被包含在这个数据字典中，那么花不了多长时间就能把你的原始密码匹配出来。这个数据字典很容易收集，CSDN 泄露的那 600w 个密码，就是很好的原始素材。</p><p>于是，第三代密码设计方法诞生，用户表中多了一个字段：</p><p><img src="d3.png" alt></p><p> 数据存储形式如下：</p><p><img src="d3-s.png" alt></p><p>Salt 可以是任意字母、数字、或是字母或数字的组合，但必须是随机产生的，每个用户的 Salt 都不一样，用户注册的时候，数据库中存入的不是明文密码，也不是简单的对明文密码进行散列，而是 MD5( 明文密码 + Salt)，也就是说： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MD5(&apos;123&apos; + &apos;1ck12b13k1jmjxrg1h0129h2lj&apos;) = &apos;6c22ef52be70e11b6f3bcf0f672c96ce&apos;</span><br><span class="line">MD5(&apos;456&apos; + &apos;1h029kh2lj11jmjxrg13k1c12b&apos;) = &apos;7128f587d88d6686974d6ef57c193628&apos;</span><br></pre></td></tr></table></figure><p>由于加了 Salt，即便数据库泄露了，但是由于密码都是加了 Salt 之后的散列，坏人们的数据字典已经无法直接匹配，明文密码被破解出来的概率也大大降低。</p><p>是不是加了 Salt 之后就绝对安全了呢？淡然没有！坏人们还是可以他们数据字典中的密码，加上我们泄露数据库中的 Salt，然后散列，然后再匹配。但是由于我们的 Salt 是随机产生的，假如我们的用户数据表中有 30w 条数据，数据字典中有 600w 条数据，坏人们如果想要完全覆盖的坏，他们加上 Salt 后再散列的数据字典数据量就应该是 300000* 6000000 = 1800000000000，一万八千亿啊，干坏事的成本太高了吧。但是如果只是想破解某个用户的密码的话，只需为这 600w 条数据加上 Salt，然后散列匹配。可见 Salt 虽然大大提高了安全系数，但也并非绝对安全。</p><p>实际项目中，Salt 不一定要加在最前面或最后面，也可以插在中间嘛，也可以分开插入，也可以倒序，程序设计时可以灵活调整，都可以使破解的难度指数级增长。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://www.cnblogs.com/myseries/p/11581170.html" target="_blank" rel="noopener">https://www.cnblogs.com/myseries/p/11581170.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;MD算法的基本概念&quot;&gt;&lt;a href=&quot;#MD算法的基本概念&quot; class=&quot;headerlink&quot; title=&quot;MD算法的基本概念&quot;&gt;&lt;/a&gt;MD算法的基本概念&lt;/h1&gt;&lt;p&gt;MD5算法是典型的消息摘要算法，其前身有MD2、MD3和MD4算法，它由MD4、MD3和MD2算法改进而来。不论是哪一种MD算法，它们都需 要获得一个随机长度的信息并产生一个128位的信息摘要。如果将这个128位的二进制摘要信息换算成十六进制，可以得到一个32位的字符串，故我们见到的 大部分MD5算法的数字指纹都是32为十六进制的字符串。&lt;/p&gt;
    
    </summary>
    
      <category term="程序人生" scheme="http://hackycy.github.io/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/"/>
    
    
  </entry>
  
  <entry>
    <title>Windows Server 2012/2016搭建VPN教程</title>
    <link href="http://hackycy.github.io/2021/03/09/Windows-Server-2012-2016%E6%90%AD%E5%BB%BAVPN%E6%95%99%E7%A8%8B/"/>
    <id>http://hackycy.github.io/2021/03/09/Windows-Server-2012-2016搭建VPN教程/</id>
    <published>2021-03-09T10:17:53.000Z</published>
    <updated>2021-10-09T02:19:57.249Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前置准备"><a href="#前置准备" class="headerlink" title="前置准备"></a>前置准备</h1><ul><li>Windows Server 2012/2016版服务器</li></ul><blockquote><p>该文以腾讯云创建的Server 2016服务器为例</p></blockquote><a id="more"></a><p>需要先放通服务器安全组端口，以腾讯云服务器为例：</p><p><img src="server_port.png" alt></p><p>以及关闭服务器的防火墙。</p><h1 id="配置步骤"><a href="#配置步骤" class="headerlink" title="配置步骤"></a>配置步骤</h1><p>连接远程服务器，打开服务器管理器。</p><p><img src="open_manager.png" alt></p><p>点击<code>添加角色和功能</code>，进行下图所示配置。</p><p><img src="add_role.png" alt></p><p>开始之前直接点击下一步</p><p><img src="config_1.png" alt></p><p>安装类型直接点击下一步</p><p><img src="config_2.png" alt></p><p>服务器选择直接点击下一步</p><p><img src="config_3.png" alt></p><p>服务器角色增加<code>网络策略和访问服务</code>以及<code>远程访问</code></p><p><img src="config_4.png" alt></p><p>选择添加功能</p><p><img src="config_5.png" alt></p><p>勾选后点击下一步</p><p><img src="config_6.png" alt></p><p>功能默认即可，直接点击下一步</p><p><img src="config_7.png" alt></p><p>网络策略和访问服务直接点击下一步</p><p><img src="config_8.png" alt></p><p>远程访问直接点击下一步</p><p><img src="config_9.png" alt></p><p>角色服务增加<code>DirectAccess和VPN(RAS)</code>以及路由</p><p><img src="config_10.png" alt></p><p>选择添加功能即可</p><p><img src="config_11.png" alt></p><p>勾选后点击下一步</p><p><img src="config_12.png" alt></p><p>Web服务器角色直接点击下一步</p><p><img src="config_13.png" alt></p><p>角色服务默认即可直接点击下一步</p><p><img src="config_14.png" alt></p><p>确认安装</p><p><img src="config_15.png" alt></p><p>点击安装后等待安装完毕关闭即可。</p><p><img src="config_16.png" alt></p><p>打开服务器管理器，点击工具，选择路由和远程访问</p><p><img src="config_17.png" alt></p><p>右键本地服务器，选择“配置并启用路由和远程访问”，启动配置向导。</p><p><img src="config_18.png" alt></p><p>点击下一步</p><p><img src="config_19.png" alt></p><p>选择自定义配置</p><p><img src="config_20.png" alt></p><p>全部勾选，并点击下一步</p><p><img src="config_21.png" alt></p><p>点击完成</p><p><img src="config_22.png" alt></p><p>如出现该提示直接点击确定</p><p><img src="config_23.png" alt></p><p>点击启动服务</p><p><img src="config_24.png" alt></p><p>展开本地服务器，展开<code>IPv4</code>，右键<code>NAT</code>，选择<code>新建接口</code></p><p><img src="config_25.png" alt></p><p>选择<code>以太网</code>，点击确定</p><p><img src="config_26.png" alt></p><p>勾选公用以及启用NAT，如图所示，点击确定</p><p><img src="config_27.png" alt></p><p>再次展开本地服务器，展开<code>IPv4</code>，右键<code>NAT</code>，选择<code>新建接口</code></p><p>选择<code>内部</code>，点击确定</p><p><img src="config_28.png" alt></p><p>勾选专用，点击确定</p><p><img src="config_29.png" alt></p><p>配置本地服务器属性</p><p><img src="config_30.png" alt></p><p>点击<code>IPv4</code>标签页为远端连接分配IP地址池</p><p><img src="config_31.png" alt></p><p><img src="config_32.png" alt></p><p>再次配置本地服务器属性</p><p>选择<code>安全</code>标签页，配置允许L2TP策略选项，并填入<strong>预共享密钥</strong>，点击确定</p><blockquote><p>务必记住该密钥，后续需要填写</p></blockquote><p><img src="config_33.png" alt></p><p>点击确定</p><p><img src="config_34.png" alt></p><p>打开服务器管理器，点击工具选择计算机管理</p><p><img src="config_35.png" alt></p><p>展开本地用户和组，选择新建组</p><p><img src="config_36.png" alt></p><p>展开本地用户和组，选择新用户</p><p><img src="config_37.png" alt></p><p>点击新建的用户名右键选择属性</p><p><img src="config_38.png" alt></p><p>按图中依次点击<code>隶属于</code>–<code>添加</code>–<code>高级</code>—<code>立即查找</code>—<code>VPNGroup（刚刚创建的组）</code>—<code>确定</code></p><p><img src="config_39.png" alt></p><p>点击确定</p><p><img src="config_40.png" alt></p><p>配置 VPN 访问权限，回到服务器管理器，点击<code>NAPS</code>–<code>选择服务器</code>–启动<code>网络策略服务器</code>配置</p><p><img src="config_41.png" alt></p><p>展开策略，右键点击网络策略并新建</p><p><img src="config_42.png" alt></p><p>填写名称并在“网络访问服务器的类型”中选择<code>远程访问服务器(VPN 拨号)</code>，点击下一步</p><p><img src="config_43.png" alt></p><p>在指定条件中，根据实际需求，选择合适的匹配条件。比如，文中选择了域中的<code>VPNGroup</code>用户组。</p><p><img src="config_44.png" alt></p><p><img src="config_45.png" alt></p><p><img src="config_46.png" alt></p><p>点击下一步</p><p><img src="config_47.png" alt></p><p>点击下一步</p><p><img src="config_48.png" alt></p><p>点击下一步</p><p><img src="config_49.png" alt></p><p>点击下一步</p><p><img src="config_50.png" alt></p><p>点击完成</p><p><img src="config_51.png" alt></p><p>然后重启服务器（重启服务）但懒得找服务直接重启服务器了。</p><p>重启完成后打开服务器管理器，找到远程访问，并启动对应的服务。</p><p><img src="config_52.png" alt></p><p>右键启动即可</p><p><img src="config_53.png" alt></p><h1 id="连接测试"><a href="#连接测试" class="headerlink" title="连接测试"></a>连接测试</h1><h2 id="Mac环境"><a href="#Mac环境" class="headerlink" title="Mac环境"></a>Mac环境</h2><p>打开<code>设置</code>—<code>网络</code>，点击<code>+</code>号新建</p><p><img src="test_1.png" alt></p><p>选择图中对应类型</p><p><img src="test_2.png" alt></p><p><img src="test_3.png" alt></p><p><img src="test_4.png" alt></p><h2 id="Win10环境"><a href="#Win10环境" class="headerlink" title="Win10环境"></a>Win10环境</h2><p>打开<code>设置</code>—<code>网络和Internet</code>—<code>VPN</code></p><p><img src="wtest_1.png" alt></p><p>配置如图所示</p><p><img src="wtest_2.png" alt></p><p><img src="wtest_3.png" alt></p><h1 id="错误修复"><a href="#错误修复" class="headerlink" title="错误修复"></a>错误修复</h1><p>这边测试在Win7或Win10连接时会出现<code>无法建立计算机与VPN服务器之间的网络连接,因为远程服务器未响应</code>的问题。查找了文章修复了问题。</p><h2 id="错误1：因为没有修改过注册表，所以是报这样的错误"><a href="#错误1：因为没有修改过注册表，所以是报这样的错误" class="headerlink" title="错误1：因为没有修改过注册表，所以是报这样的错误"></a>错误1：因为没有修改过注册表，所以是报这样的错误</h2><p><img src="fix_1.jpg" alt></p><p><strong>解决办法</strong></p><p>按<code>windows图标键 + R键</code> &gt;在运行中输入<code>regedit</code>，单击<code>确定</code>，进入<code>注册表编辑器</code></p><p><img src="fix_2.png" alt></p><p>在注册表编辑器”页面的左侧导航树点开 <code>HKEY_LOCAL_MACHINE</code>&gt;<code>SYSTEM</code>&gt;<code>CurrentControlSet</code>&gt;<code>Services</code>&gt;<code>PolicyAgent</code></p><p><img src="fix_3.jpg" alt></p><p>在右边空白处新建 &gt; <code>DWORD值</code>，名称为<code>AssumeUDPEncapsulationContextOnSendRule</code></p><p><img src="fix_4.jpg" alt></p><p>右键单击<code>AssumeUDPEncapsulationContextOnSendRule</code>，选择“修改”，进入修改界面，修改值为<code>2</code>(表示可以与位于NAT设备后方的服务器建立安全关联)</p><p><img src="fix_5.jpg" alt></p><blockquote><p>重启电脑即可。一般Win7配置完该步骤后即可连接，但Win10还会出现问题。</p></blockquote><h2 id="错误2：修改完注册表，错误就变了，是因为认证的协议问题"><a href="#错误2：修改完注册表，错误就变了，是因为认证的协议问题" class="headerlink" title="错误2：修改完注册表，错误就变了，是因为认证的协议问题"></a>错误2：修改完注册表，错误就变了，是因为认证的协议问题</h2><p><img src="fix_6.jpg" alt></p><p><strong>解决办法</strong></p><p>打开更改适配器选项，找到对应的VPN名称的适配器，右键属性</p><p><img src="fix_7.jpg" alt></p><p>打开安全选项，选择使用这些协议勾上；注意此处还有高级设置里面的L2TP身份验证类型，这里也要填写的（秘钥方式还是证书方式）</p><p><img src="fix_8.jpg" alt></p><blockquote><p>再次连接，即可修复</p></blockquote><h2 id="Window自动修复注册表bat脚本"><a href="#Window自动修复注册表bat脚本" class="headerlink" title="Window自动修复注册表bat脚本"></a>Window自动修复注册表bat脚本</h2><p>新建一个<code>.bat</code>文件，如<code>修复注册表.bat</code>，右键编辑增加以下代码：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@echo off</span><br><span class="line"></span><br><span class="line">reg add "HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\PolicyAgent" /v "AssumeUDPEncapsulationContextOnSendRule" /t REG_DWORD /d 2 /f</span><br><span class="line"></span><br><span class="line">echo 注册表导入完成按任意键退出...</span><br><span class="line"></span><br><span class="line">pause&gt;nul</span><br><span class="line"></span><br><span class="line">exit</span><br></pre></td></tr></table></figure><p>保存后双击运行即可。</p><h1 id="参考教程"><a href="#参考教程" class="headerlink" title="参考教程"></a>参考教程</h1><p><a href="https://www.365jz.com/article/24912" target="_blank" rel="noopener">https://www.365jz.com/article/24912</a></p><p><a href="https://me.jinchuang.org/archives/381.html" target="_blank" rel="noopener">https://me.jinchuang.org/archives/381.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前置准备&quot;&gt;&lt;a href=&quot;#前置准备&quot; class=&quot;headerlink&quot; title=&quot;前置准备&quot;&gt;&lt;/a&gt;前置准备&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;Windows Server 2012/2016版服务器&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;该文以腾讯云创建的Server 2016服务器为例&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="程序人生" scheme="http://hackycy.github.io/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/"/>
    
    
  </entry>
  
  <entry>
    <title>利用Canvas进行前端图片压缩</title>
    <link href="http://hackycy.github.io/2021/02/25/%E5%88%A9%E7%94%A8Canvas%E8%BF%9B%E8%A1%8C%E5%89%8D%E7%AB%AF%E5%9B%BE%E7%89%87%E5%8E%8B%E7%BC%A9/"/>
    <id>http://hackycy.github.io/2021/02/25/利用Canvas进行前端图片压缩/</id>
    <published>2021-02-25T10:36:00.000Z</published>
    <updated>2021-10-09T02:19:57.397Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><strong>纯前端利用Canvas来进行图片压缩的方法</strong></p><a id="more"></a><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 压缩方法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">compress</span>(<span class="params">file, callback</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> reader = <span class="keyword">new</span> FileReader();</span><br><span class="line">  reader.readAsDataURL(file);</span><br><span class="line">  reader.onload = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> base64Image = e.target.result;</span><br><span class="line">    <span class="keyword">var</span> image = <span class="keyword">new</span> Image();</span><br><span class="line">    image.src = base64Image;</span><br><span class="line"></span><br><span class="line">    image.addEventListener(<span class="string">'load'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">var</span> needCompress = <span class="literal">false</span>; <span class="comment">// 是否需要压缩</span></span><br><span class="line">      <span class="keyword">var</span> ratio;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 支持最大的宽高</span></span><br><span class="line">      <span class="keyword">var</span> maxH = <span class="number">400</span>;</span><br><span class="line">      <span class="keyword">var</span> maxW = <span class="number">800</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">var</span> imageH = image.naturalHeight;</span><br><span class="line">      <span class="keyword">var</span> imageW = image.naturalWidth;</span><br><span class="line">      </span><br><span class="line">      <span class="comment">// 宽高压缩</span></span><br><span class="line">      <span class="keyword">if</span> (maxH &lt; imageH) &#123;</span><br><span class="line">        needCompress = <span class="literal">true</span>;</span><br><span class="line">        ratio = imageH / maxH;</span><br><span class="line">        maxW = imageW / ratio;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (maxW &lt; imageW) &#123;</span><br><span class="line">        needCompress = <span class="literal">true</span>;</span><br><span class="line">        ratio = imageW / maxW;</span><br><span class="line">        maxH = imageH / ratio;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (!needCompress) &#123;</span><br><span class="line">        maxW = imageW;</span><br><span class="line">        maxH = imageH;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 创建canvas并隐藏</span></span><br><span class="line">      <span class="keyword">var</span> canvas = <span class="built_in">document</span>.createElement(<span class="string">'canvas'</span>);</span><br><span class="line">      canvas.setAttribute(<span class="string">'id'</span>, <span class="string">'__compress__'</span>);</span><br><span class="line">      canvas.width = maxW;</span><br><span class="line">      canvas.height = maxH;</span><br><span class="line">      canvas.style.visibility = <span class="string">'hidden'</span>;</span><br><span class="line">      <span class="built_in">document</span>.body.appendChild(canvas);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">var</span> ctx = canvas.getContext(<span class="string">'2d'</span>);</span><br><span class="line">      ctx.clearRect(<span class="number">0</span>, <span class="number">0</span>, maxW, maxH);</span><br><span class="line">      ctx.drawImage(image, <span class="number">0</span>, <span class="number">0</span>, maxW, maxH);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// canvas 压缩比值，不宜过小</span></span><br><span class="line">      <span class="keyword">const</span> compressImage = canvas.toDataURL(file.type, <span class="number">0.9</span>);</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'原来大小：'</span> + base64Image.length);</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'压缩后大小：'</span> + compressImage.length)</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'压缩比：'</span> + base64Image.length / compressImage.length);</span><br><span class="line">      callback(compressImage);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>使用案例</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">"upload"</span> <span class="attr">type</span>=<span class="string">"file"</span> /&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 支持的类型</span></span><br><span class="line"><span class="keyword">var</span> ACCEPT_TYPE = [ <span class="string">'image/jpeg'</span>, <span class="string">'image/png'</span>, <span class="string">'image/jpg'</span> ];</span><br><span class="line"><span class="keyword">const</span> upload = <span class="built_in">document</span>.getElementById(<span class="string">'upload'</span>);</span><br><span class="line">upload.addEventListener(<span class="string">'change'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line"><span class="keyword">const</span> [ file ] = e.target.files;</span><br><span class="line"><span class="keyword">if</span> (!file) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> &#123; <span class="attr">type</span>: fileType, <span class="attr">size</span>: fileSize &#125; = file;</span><br><span class="line"><span class="keyword">if</span> (ACCEPT_TYPE.indexOf(fileType) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">upload.value = <span class="literal">null</span>;</span><br><span class="line">alert(<span class="string">'不支持的文件类型'</span> + fileType);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">compress(file, (compressImage) =&gt; <span class="built_in">console</span>.log(compressImage));</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><blockquote><p><a href="https://github.com/hackycy/practice-examples/blob/master/javascript/canvas/compress.html" target="_blank" rel="noopener">案例源码</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;纯前端利用Canvas来进行图片压缩的方法&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="http://hackycy.github.io/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="http://hackycy.github.io/tags/JavaScript/"/>
    
      <category term="Canvas" scheme="http://hackycy.github.io/tags/Canvas/"/>
    
  </entry>
  
  <entry>
    <title>解决Mac出现Kotlin could not find the required JDK tools in the Java installation</title>
    <link href="http://hackycy.github.io/2020/12/25/%E8%A7%A3%E5%86%B3Mac%E5%87%BA%E7%8E%B0Kotlin-could-not-find-the-required-JDK-tools-in-the-Java-installation/"/>
    <id>http://hackycy.github.io/2020/12/25/解决Mac出现Kotlin-could-not-find-the-required-JDK-tools-in-the-Java-installation/</id>
    <published>2020-12-25T18:17:38.000Z</published>
    <updated>2021-10-09T02:19:57.445Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt; Task :compileKotlin FAILED</span><br><span class="line"></span><br><span class="line">FAILURE: Build failed with an exception.</span><br><span class="line"></span><br><span class="line">* What went wrong:</span><br><span class="line">Execution failed <span class="keyword">for</span> task <span class="string">':compileKotlin'</span>.</span><br><span class="line">&gt; Kotlin could not find the require JDK tools <span class="keyword">in</span> the Java installtion <span class="string">'/Library/Internet Plug-Ins/JavaAppletPlugin.plugin/Contents/Home'</span> used by Gradle. Make sure is running on a JDK, not JRE.</span><br></pre></td></tr></table></figure><p>在混编开发过程中，打包的时候出现了该问题，排查很久，总算找到了原因：<strong>没有配置JAVA_HOME环境变量</strong>。</p><a id="more"></a><p><strong>解决方案</strong></p><p>安装好JDK后，获取JAVA的安装路径</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ /usr/libexec/java_home -V</span><br><span class="line">Matching Java Virtual Machines (2):</span><br><span class="line">    1.8.201.09 (x86_64) <span class="string">"Oracle Corporation"</span> - <span class="string">"Java"</span> /Library/Internet Plug-Ins/JavaAppletPlugin.plugin/Contents/Home</span><br><span class="line">    1.8.0_201 (x86_64) <span class="string">"Oracle Corporation"</span> - <span class="string">"Java SE 8"</span> /Library/Java/JavaVirtualMachines/jdk1.8.0_201.jdk/Contents/Home</span><br><span class="line">/Library/Java/JavaVirtualMachines/jdk1.8.0_201.jdk/Contents/Home</span><br></pre></td></tr></table></figure><p>mac下编辑profile：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ vi ~/.bash_profile</span><br><span class="line"></span><br><span class="line"><span class="comment"># android</span></span><br><span class="line"><span class="built_in">export</span> ANDROID_HOME=/Users/zjyzy/Library/Android/sdk</span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$&#123;PATH&#125;</span>:<span class="variable">$&#123;ANDROID_HOME&#125;</span>/tools</span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$&#123;PATH&#125;</span>:<span class="variable">$&#123;ANDROID_HOME&#125;</span>/platform-tools</span><br><span class="line"></span><br><span class="line"><span class="comment"># java</span></span><br><span class="line"><span class="built_in">export</span> JAVA_HOME=/Library/Java/JavaVirtualMachines/jdk1.8.0_201.jdk/Contents/Home</span><br><span class="line"><span class="built_in">export</span> CLASSPAHT=.:<span class="variable">$JAVA_HOME</span>/lib/dt.jar:<span class="variable">$JAVA_HOME</span>/lib/tools.jar</span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$JAVA_HOME</span>/bin:<span class="variable">$PATH</span>:</span><br></pre></td></tr></table></figure><p>编辑完成后，按<code>esc</code>退出插入模式，输入<code>:wq</code>退出保存即可。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">source</span> ~/.bash_profile</span><br></pre></td></tr></table></figure><p>生效后验证：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> <span class="variable">$JAVA_HOME</span></span><br><span class="line">/Library/Java/JavaVirtualMachines/jdk1.8.0_201.jdk/Contents/Home</span><br></pre></td></tr></table></figure><p>问题解决。</p>]]></content>
    
    <summary type="html">
    
      &lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&amp;gt; Task :compileKotlin FAILED&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;FAILURE: Build failed with an exception.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;* What went wrong:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Execution failed &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; task &lt;span class=&quot;string&quot;&gt;&#39;:compileKotlin&#39;&lt;/span&gt;.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;gt; Kotlin could not find the require JDK tools &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; the Java installtion &lt;span class=&quot;string&quot;&gt;&#39;/Library/Internet Plug-Ins/JavaAppletPlugin.plugin/Contents/Home&#39;&lt;/span&gt; used by Gradle. Make sure is running on a JDK, not JRE.&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;在混编开发过程中，打包的时候出现了该问题，排查很久，总算找到了原因：&lt;strong&gt;没有配置JAVA_HOME环境变量&lt;/strong&gt;。&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="http://hackycy.github.io/categories/Android/"/>
    
    
      <category term="Android" scheme="http://hackycy.github.io/tags/Android/"/>
    
      <category term="Android Studio" scheme="http://hackycy.github.io/tags/Android-Studio/"/>
    
  </entry>
  
  <entry>
    <title>Flutter屏幕适配攻略</title>
    <link href="http://hackycy.github.io/2020/12/25/Flutter%E5%B1%8F%E5%B9%95%E9%80%82%E9%85%8D%E6%94%BB%E7%95%A5/"/>
    <id>http://hackycy.github.io/2020/12/25/Flutter屏幕适配攻略/</id>
    <published>2020-12-25T10:08:58.000Z</published>
    <updated>2021-10-09T02:19:56.885Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><strong>目前移动端的设备已经非常多，并且不同的设备手机屏幕也不相同。</strong></p><p><strong>目前做移动端开发都要针对不同的设备进行一定的适配，无论是移动原生开发、小程序、H5页面。</strong></p><a id="more"></a><h1 id="Flutter中的单位"><a href="#Flutter中的单位" class="headerlink" title="Flutter中的单位"></a>Flutter中的单位</h1><p>在进行Flutter开发时，我们通常不需要传入尺寸的单位，那么Flutter使用的是什么单位呢？</p><ul><li>Flutter使用的是类似于iOS中的点pt，也就是point。</li><li>所以我们经常说iPhone6的尺寸是375x667，但是它的分辨率其实是750x1334。</li><li>因为iPhone6的dpr（devicePixelRatio）是2.0，iPhone6plus的dpr是3.0</li></ul><p><img src="1.png" alt></p><blockquote><p> 在Flutter开发中，我们使用的是对应的逻辑分辨率</p></blockquote><h1 id="Flutter设备信息"><a href="#Flutter设备信息" class="headerlink" title="Flutter设备信息"></a>Flutter设备信息</h1><p>获取屏幕上的一些信息，可以通过MediaQuery：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.媒体查询信息</span></span><br><span class="line"><span class="keyword">final</span> mediaQueryData = MediaQuery.of(context);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.获取宽度和高度</span></span><br><span class="line"><span class="keyword">final</span> screenWidth = mediaQueryData.size.width;</span><br><span class="line"><span class="keyword">final</span> screenHeight = mediaQueryData.size.height;</span><br><span class="line"><span class="keyword">final</span> physicalWidth = <span class="built_in">window</span>.physicalSize.width;</span><br><span class="line"><span class="keyword">final</span> physicalHeight = <span class="built_in">window</span>.physicalSize.height;</span><br><span class="line"><span class="keyword">final</span> dpr = <span class="built_in">window</span>.devicePixelRatio;</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"屏幕width:<span class="subst">$screenWidth</span> height:<span class="subst">$screenHeight</span>"</span>);</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"分辨率: <span class="subst">$physicalWidth</span> - <span class="subst">$physicalHeight</span>"</span>);</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"dpr: <span class="subst">$dpr</span>"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.状态栏的高度</span></span><br><span class="line"><span class="comment">// 有刘海的屏幕:44 没有刘海的屏幕为20</span></span><br><span class="line"><span class="keyword">final</span> statusBarHeight = mediaQueryData.padding.top;</span><br><span class="line"><span class="comment">// 有刘海的屏幕:34 没有刘海的屏幕0</span></span><br><span class="line"><span class="keyword">final</span> bottomHeight = mediaQueryData.padding.bottom;</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"状态栏height: <span class="subst">$statusBarHeight</span> 底部高度:<span class="subst">$bottomHeight</span>"</span>);</span><br></pre></td></tr></table></figure><p>获取一些设备相关的信息，可以使用官方提供的一个库：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dependencies:</span><br><span class="line">  device_info: ^<span class="number">0.4</span><span class="number">.2</span>+<span class="number">1</span></span><br></pre></td></tr></table></figure><h1 id="适配方案"><a href="#适配方案" class="headerlink" title="适配方案"></a>适配方案</h1><p>假如我们有下面这样一段代码：</p><ul><li>在屏幕中间显示一个200*200的Container</li><li>Container中有一段文字是30</li></ul><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HomePage</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> Scaffold(</span><br><span class="line">      appBar: AppBar(</span><br><span class="line">        title: Text(<span class="string">"首页"</span>),</span><br><span class="line">      ),</span><br><span class="line">      body: Center(</span><br><span class="line">        child: Container(</span><br><span class="line">          width: <span class="number">200</span>,</span><br><span class="line">          height: <span class="number">200</span>,</span><br><span class="line">          color: Colors.red,</span><br><span class="line">          alignment: Alignment.center,</span><br><span class="line">          child: Text(<span class="string">"Hello World"</span>, style: TextStyle(fontSize: <span class="number">30</span>, color: Colors.white),),</span><br><span class="line">        ),</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码在不同屏幕上会有不同的表现：</p><ul><li>很明显，如果按照上面的规则，在iPhone5上面，尺寸过大，在iPhone6plus上面尺寸过小</li><li>在开发中，我们应该可以根据不同的屏幕来完成尺寸的缩放</li></ul><p><img src="2.png" alt></p><p>在前端开发中，针对不同的屏幕常见的适配方案有下面几种：</p><ul><li>rem：<ul><li>rem是给根标签（HTML标签）设置一个字体大小；</li><li>但是不同的屏幕要动画设置不同的字体大小（可以通过媒体查询，也可以通过js动态计算）；</li><li>其它所有的单位都使用rem单位（相对于根标签）；</li></ul></li><li>vw、wh：<ul><li>vw和vh是将屏幕（视口）分成100等份，一个1vw相当于是1%的大小；</li><li>其它所有的单位都使用vw或wh单位；</li></ul></li><li>rpx：<ul><li>rpx是小程序中的适配方案，它将750px作为设计稿，1rpx=屏幕宽度/750；</li><li>其它所有的单位都使用rpx单位；</li></ul></li></ul><p><strong>该文采用类似小程序的rpx方案来完成Flutter的适配</strong></p><h1 id="rpx适配"><a href="#rpx适配" class="headerlink" title="rpx适配"></a>rpx适配</h1><p>小程序中rpx的原理是什么呢？</p><ul><li>不管是什么屏幕，统一分成750份</li><li>在iPhone5上：1rpx = 320/750 = 0.4266 ≈ 0.42px</li><li>在iPhone6上： 1rpx = 375/750 = 0.5px</li><li>在iPhone6plus上：1rpx = 414/750 = 0.552px</li></ul><p>那么我们就可以通过上面的计算方式，算出一个rpx，再将自己的size和rpx单位相乘即可：</p><ul><li>比如100px的宽度：100 <em> 2 </em> rpx</li><li>在iPhone5上计算出的结果是84px</li><li>在iPhone6上计算出的结果是100px</li><li>在iPhone6plus上计算出的结果是110.4px</li></ul><p>我们自己来封装一个工具类：</p><ul><li>工具类需要进行初始化，传入context</li><li>可以通过传入context，利用媒体查询获取屏幕的宽度和高度</li><li>也可以传入一个可选的参数，以什么尺寸作为设计稿</li></ul><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'package:flutter/material.dart'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// <span class="markdown">屏幕适配工具类</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ScreenAdapterUtils</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> ScreenAdapterUtils _instance;</span><br><span class="line">  <span class="keyword">static</span> MediaQueryData _mediaQueryData;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">double</span> screenWidth;</span><br><span class="line">  <span class="built_in">double</span> screenHeight;</span><br><span class="line">  <span class="built_in">double</span> density = <span class="number">2.0</span>;</span><br><span class="line">  <span class="built_in">double</span> standartWidth = <span class="number">750</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// <span class="markdown">比值</span></span></span><br><span class="line">  <span class="built_in">double</span> _rpxW;</span><br><span class="line">  <span class="built_in">double</span> _rpxH;</span><br><span class="line"></span><br><span class="line">  ScreenAdapterUtils._() &#123;</span><br><span class="line">    screenWidth = _mediaQueryData.size.width;</span><br><span class="line">    screenHeight = _mediaQueryData.size.height;</span><br><span class="line">    _rpxW = screenWidth / standartWidth;</span><br><span class="line">    _rpxH = screenHeight / standartWidth;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">factory</span> ScreenAdapterUtils.instance() &#123;</span><br><span class="line">    <span class="keyword">return</span> _instance;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// <span class="markdown">初始化</span></span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">void</span> init(BuildContext context) &#123;</span><br><span class="line">    _mediaQueryData = MediaQuery.of(context);</span><br><span class="line">    _instance = ScreenAdapterUtils._();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// <span class="markdown">是否为横屏</span></span></span><br><span class="line">  <span class="built_in">bool</span> isLand() &#123;</span><br><span class="line">    <span class="keyword">return</span> _mediaQueryData.orientation == Orientation.landscape;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// <span class="markdown">需要考虑横屏和竖屏</span></span></span><br><span class="line">  <span class="built_in">double</span> px(<span class="built_in">double</span> size) &#123;</span><br><span class="line">    <span class="keyword">return</span> (isLand() ? _rpxH : _rpxW) * size * density;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">double</span> rpx(<span class="built_in">double</span> size) &#123;</span><br><span class="line">    <span class="keyword">return</span> (isLand() ? _rpxH : _rpxW) * size;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>初始化<code>ScreenAdapterUtils</code>类的属性：</p><ul><li>注意：必须在已经有<code>MaterialApp</code>的Widget中使用context，否则是无效的</li></ul><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HomePage</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="comment">// 初始化ScreenAdapterUtils</span></span><br><span class="line">    ScreenAdapterUtils.init(context);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用rpx来完成屏幕适配：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HomePage</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    ScreenAdapterUtils.init(context);</span><br><span class="line">    <span class="keyword">return</span> Scaffold(</span><br><span class="line">      appBar: AppBar(</span><br><span class="line">        title: Text(<span class="string">"首页"</span>),</span><br><span class="line">      ),</span><br><span class="line">      body: Center(</span><br><span class="line">        child: Container(</span><br><span class="line">          width: ScreenAdapterUtils.instance().px(<span class="number">200</span>),</span><br><span class="line">          height: ScreenAdapterUtils.instance().rpx(<span class="number">400</span>),</span><br><span class="line">          color: Colors.red,</span><br><span class="line">          alignment: Alignment.center,</span><br><span class="line">          child: Text(<span class="string">"Hello World"</span>, style: TextStyle(fontSize: SizeFit.setPx(<span class="number">30</span>), color: Colors.white),),</span><br><span class="line">        ),</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现效果：</p><p><img src="4.png" alt></p><h1 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h1><p>如果每次我们需要将现在的宽度或者高度，去使用<code>ScreenAdapterUtils.instance().px(200)</code>或者<code>ScreenAdapterUtils.instance().rpx(400)</code>类似的方式去适配，显然看起来非常麻烦。</p><p><strong>有没有更好的方案可以实现了？比如 200.px或者400.rpx，非常的清晰简洁</strong></p><p><strong>当然可以，我们需要依赖Dart语言的一个特性：extension</strong></p><ul><li>Dart从<code>2.7.0</code>开始，可以通过extension来给现有的类进行扩展（事实上Swift里面也有）</li><li>对现有的类包括：自定义的类、第三方库的类、系统的类</li></ul><p>比如我们现在对String类型扩展：</p><ul><li>扩展一个parseInt的方法，当然内部调用的是<code>int.parse(this)</code>，只是调用者变成了<code>String</code>本身</li></ul><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 步骤一：扩展代码</span></span><br><span class="line"><span class="keyword">extension</span> NumberParsing <span class="keyword">on</span> <span class="built_in">String</span> &#123;</span><br><span class="line">  <span class="built_in">int</span> parseInt() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">int</span>.parse(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ···</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 步骤二：调用代码</span></span><br><span class="line"><span class="comment">// 导入扩展类对应的模块</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">'string_apis.dart'</span>;</span><br><span class="line"><span class="comment">// 使用里面的方法</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">'42'</span>.parseInt()); <span class="comment">// 使用String扩展的方法</span></span><br></pre></td></tr></table></figure><p>显然，数字（比如200、200.0）有对应的包装类int、double，我们可以对其进行扩展：</p><p><strong>对int类型扩展</strong></p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'../utils/screen_adapter.dart'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extension</span> IntScreenAdapter <span class="keyword">on</span> <span class="built_in">int</span> &#123;</span><br><span class="line">  <span class="built_in">double</span> <span class="keyword">get</span> rpx &#123;</span><br><span class="line">    <span class="keyword">return</span> ScreenAdapterUtils.instance().rpx(<span class="keyword">this</span>.toDouble());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">double</span> <span class="keyword">get</span> px &#123;</span><br><span class="line">    <span class="keyword">return</span> ScreenAdapterUtils.instance().px(<span class="keyword">this</span>.toDouble());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>对double类型扩展</strong></p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'../utils/screen_adapter.dart'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extension</span> DoubleScreenAdapter <span class="keyword">on</span> <span class="built_in">double</span> &#123;</span><br><span class="line">  <span class="built_in">double</span> <span class="keyword">get</span> rpx &#123;</span><br><span class="line">    <span class="keyword">return</span> ScreenAdapterUtils.instance().rpx(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">double</span> <span class="keyword">get</span> px &#123;</span><br><span class="line">    <span class="keyword">return</span> ScreenAdapterUtils.instance().px(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>使用</strong></p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'./extension/adapter.dart'</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="number">200.</span>px); <span class="comment">// 在不同屏幕下200px是不同的值</span></span><br><span class="line"><span class="built_in">print</span>(<span class="number">400.</span>rpx); <span class="comment">// 在不同屏幕下400rpx是不同的值</span></span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>如果美工提供的设计稿为iPhone6尺寸的设计稿（最好不过），那么直接使用对着稿子量多少代码填多少rpx单位即可。</p><h1 id="题外话"><a href="#题外话" class="headerlink" title="题外话"></a>题外话</h1><p>当使用extension时出现报错时，例如</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Undefined class <span class="string">'extension'</span>.</span><br><span class="line">Try changing the name to the name of an existing class, or creating a class with the name <span class="string">'extension'</span>. dartundefined_class</span><br><span class="line">This requires the <span class="string">'extension-methods'</span> language feature to be enabled.</span><br></pre></td></tr></table></figure><p><strong>解决办法：</strong></p><p>在项目根目录下创建<code>analysis_options.yaml</code>，并写入以下内容：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">include:</span></span><br><span class="line"></span><br><span class="line"><span class="attr">analyzer:</span></span><br><span class="line">  <span class="attr">enable-experiment:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">extension-methods</span></span><br><span class="line"></span><br><span class="line"><span class="attr">linter:</span></span><br></pre></td></tr></table></figure><p>以及设置<code>pubspec.yaml</code>的environment</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">environment:</span></span><br><span class="line">  <span class="attr">sdk:</span> <span class="string">'&gt;=2.6.0 &lt;3.0.0'</span></span><br></pre></td></tr></table></figure><p>重启VSCode即可。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li><a href="https://juejin.cn/post/6844904176489594893" target="_blank" rel="noopener">https://juejin.cn/post/6844904176489594893</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;目前移动端的设备已经非常多，并且不同的设备手机屏幕也不相同。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;目前做移动端开发都要针对不同的设备进行一定的适配，无论是移动原生开发、小程序、H5页面。&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Flutter" scheme="http://hackycy.github.io/categories/Flutter/"/>
    
    
      <category term="Flutter" scheme="http://hackycy.github.io/tags/Flutter/"/>
    
  </entry>
  
  <entry>
    <title>Android各版本迭代信息集合</title>
    <link href="http://hackycy.github.io/2020/12/22/Android%E5%90%84%E7%89%88%E6%9C%AC%E8%BF%AD%E4%BB%A3%E4%BF%A1%E6%81%AF%E9%9B%86%E5%90%88/"/>
    <id>http://hackycy.github.io/2020/12/22/Android各版本迭代信息集合/</id>
    <published>2020-12-22T14:29:43.000Z</published>
    <updated>2021-10-09T02:19:56.841Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>今天分享的面试题是：</p><p>Android在版本迭代中，总会进行很多改动，那么你熟知各版本都改动了什么内容？又要怎么适配呢？</p><a id="more"></a><h1 id="Android4-4"><a href="#Android4-4" class="headerlink" title="Android4.4"></a>Android4.4</h1><ul><li>发布<code>ART</code>虚拟机，提供选项可以开启。</li><li><code>HttpURLConnection</code>的底层实现改为了OkHttp。</li></ul><h1 id="Android5-0"><a href="#Android5-0" class="headerlink" title="Android5.0"></a>Android5.0</h1><ul><li><code>ART</code>成为默认虚拟机，完全代替Dalvik虚拟机。</li><li><code>Context.bindService()</code> 方法需要显式 Intent，如果提供隐式 intent，将引发异常。</li></ul><h1 id="Android6-0"><a href="#Android6-0" class="headerlink" title="Android6.0"></a>Android6.0</h1><ul><li>增加运行时权限限制</li></ul><p>如果你的应用使用到了危险权限，比如在运行时进行检查和请求权限。<code>checkSelfPermission()</code>方法用于检查权限，<code>requestPermissions()</code> 方法用于请求权限。</p><ul><li>取消支持Apache HTTP</li></ul><p>Android 6.0 版移除了对 <code>Apache HTTP</code>相关类库的支持。要继续使用 Apache HTTP API，您必须先在 build.gradle 文件中声明以下编译时依赖项：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">android &#123;useLibrary &apos;org.apache.http.legacy&apos;&#125;</span><br></pre></td></tr></table></figure><p>有的小伙伴可能不熟悉这是啥，简单说下：</p><blockquote><p>Apache HttpClient 是Apache开源组织提供的一个开源的项目,它是一个简单的HTTP客户端（并不是浏览器），可以发送HTTP请求，接受HTTP响应。</p></blockquote><p>所以说白了，其实就是一个请求网络的项目框架。</p><h1 id="Android-7-0"><a href="#Android-7-0" class="headerlink" title="Android 7.0"></a>Android 7.0</h1><ul><li>Android 7.0 引入一项新的应用签名方案 APK Signature Scheme v2</li><li>Toast导致的BadTokenException</li><li>在Android7.0系统上，Android 框架强制执行了 StrictMode API 政策禁止向你的应用外公开 file:// URI。如果一项包含文件 file:// URI类型 的 Intent 离开你的应用，应用失败，并出现 <code>FileUriExposedException</code> 异常，如调用系统相机拍照录制视频，或裁切照片。</li></ul><p>这一点其实就是限制了在应用间共享文件，如果需要在应用间共享，需要授予要访问的URI临时访问权限，我们要做的就是注册<code>FileProvider</code>：</p><p>1）声明FileProvider。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">provider</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:name</span>=<span class="string">"android.support.v4.content.FileProvider"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:authorities</span>=<span class="string">"app的包名.fileProvider"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:grantUriPermissions</span>=<span class="string">"true"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:exported</span>=<span class="string">"false"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta-data</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:name</span>=<span class="string">"android.support.FILE_PROVIDER_PATHS"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:resource</span>=<span class="string">"@xml/file_paths"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">provider</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--androidx版本类路径为：androidx.core.content.FileProvider--&gt;</span></span><br></pre></td></tr></table></figure><p>2）编写xml文件，确定可访问的目录</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">paths</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span>&gt;</span></span><br><span class="line"> //代表设备的根目录new File("/");</span><br><span class="line">    <span class="tag">&lt;<span class="name">root-path</span> <span class="attr">name</span>=<span class="string">"root"</span> <span class="attr">path</span>=<span class="string">"."</span> /&gt;</span> </span><br><span class="line">    //context.getFilesDir()</span><br><span class="line">    <span class="tag">&lt;<span class="name">files-path</span> <span class="attr">name</span>=<span class="string">"files"</span> <span class="attr">path</span>=<span class="string">"."</span> /&gt;</span> </span><br><span class="line">    //context.getCacheDir()</span><br><span class="line">    <span class="tag">&lt;<span class="name">cache-path</span> <span class="attr">name</span>=<span class="string">"cache"</span> <span class="attr">path</span>=<span class="string">"."</span> /&gt;</span> </span><br><span class="line">    //Environment.getExternalStorageDirectory()</span><br><span class="line">    <span class="tag">&lt;<span class="name">external-path</span> <span class="attr">name</span>=<span class="string">"external"</span> <span class="attr">path</span>=<span class="string">"."</span> /&gt;</span></span><br><span class="line">    //context.getExternalFilesDirs()</span><br><span class="line">    <span class="tag">&lt;<span class="name">external-files-path</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">path</span>=<span class="string">"path"</span> /&gt;</span></span><br><span class="line">    //getExternalCacheDirs()</span><br><span class="line">     <span class="tag">&lt;<span class="name">external-cache-path</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">path</span>=<span class="string">"path"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">paths</span>&gt;</span></span><br></pre></td></tr></table></figure><p>3）使用FileProvider</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.N) &#123;</span><br><span class="line">    Uri uri = FileProvider.getUriForFile(CameraActivity.<span class="keyword">this</span>, <span class="string">"app的包名.fileProvider"</span>, photoFile);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    Uri uri = Uri.fromFile(photoFile);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Android8-0"><a href="#Android8-0" class="headerlink" title="Android8.0"></a>Android8.0</h1><ul><li>修改运行时权限错误</li></ul><p>在 <code>Android 8.0</code> 之前，如果应用在运行时请求权限并且被授予该权限，系统会错误地将属于同一权限组并且在清单中注册的其他权限也一起授予应用。对于针对 Android 8.0 的应用，系统只会授予应用明确请求的权限。然而，一旦用户为应用授予某个权限，则所有后续对该权限组中权限的请求都将被自动批准。</p><p>也就是说，以前你申请了<code>READ_EXTERNAL_STORAGE</code>权限，应用会同时给你授予同权限组的<code>WRITE_EXTERNAL_STORAGE</code>权限。如果Android8.0以上，只会给你授予你请求的<code>READ_EXTERNAL_STORAGE</code>权限。如果需要<code>WRITE_EXTERNAL_STORAGE</code>权限，还要单独申请，不过系统会立即授予，不会提示。</p><ul><li>修改通知</li></ul><p>Android 8.0 对于通知修改了很多，比如通知渠道、通知标志、通知超时、背景颜色。其中比较重要的就是通知渠道，其允许您为要显示的每种通知类型创建用户可自定义的渠道。</p><p>这样的好处就是对于某个应用可以把权限分成很多类，用户来控制是否显示哪些类别的通知。而开发者要做的就是必须设置这个渠道id，否则通知可能会失效。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">createNotificationChannel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.O) &#123;</span><br><span class="line"></span><br><span class="line">            NotificationManager notificationManager = (NotificationManager)</span><br><span class="line">                    getSystemService(Context.NOTIFICATION_SERVICE);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//分组（可选）</span></span><br><span class="line">            <span class="comment">//groupId要唯一</span></span><br><span class="line">            String groupId = <span class="string">"group_001"</span>;</span><br><span class="line">            NotificationChannelGroup group = <span class="keyword">new</span> NotificationChannelGroup(groupId, <span class="string">"广告"</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//创建group</span></span><br><span class="line">            notificationManager.createNotificationChannelGroup(group);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//channelId要唯一</span></span><br><span class="line">            String channelId = <span class="string">"channel_001"</span>;</span><br><span class="line"></span><br><span class="line">            NotificationChannel adChannel = <span class="keyword">new</span> NotificationChannel(channelId,</span><br><span class="line">                    <span class="string">"推广信息"</span>, NotificationManager.IMPORTANCE_DEFAULT);</span><br><span class="line">            <span class="comment">//补充channel的含义（可选）</span></span><br><span class="line">            adChannel.setDescription(<span class="string">"推广信息"</span>);</span><br><span class="line">            <span class="comment">//将渠道添加进组（先创建组才能添加）</span></span><br><span class="line">            adChannel.setGroup(groupId);</span><br><span class="line">            <span class="comment">//创建channel</span></span><br><span class="line">            notificationManager.createNotificationChannel(adChannel);</span><br><span class="line"></span><br><span class="line">   <span class="comment">//创建通知时，标记你的渠道id</span></span><br><span class="line">            Notification notification = <span class="keyword">new</span> Notification.Builder(MainActivity.<span class="keyword">this</span>, channelId)</span><br><span class="line">                    .setSmallIcon(R.mipmap.ic_launcher)</span><br><span class="line">                    .setLargeIcon(BitmapFactory.decodeResource(getResources(), R.mipmap.ic_launcher))</span><br><span class="line">                    .setContentTitle(<span class="string">"一条新通知"</span>)</span><br><span class="line">                    .setContentText(<span class="string">"这是一条测试消息"</span>)</span><br><span class="line">                    .setAutoCancel(<span class="keyword">true</span>)</span><br><span class="line">                    .build();</span><br><span class="line">            notificationManager.notify(<span class="number">1</span>, notification);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ul><li>悬浮窗</li></ul><p>Android8.0以上必须使用新的窗口类型(<code>TYPE_APPLICATION_OVERLAY</code>)才能显示提醒悬浮窗：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.O) &#123;</span><br><span class="line">    mWindowParams.type = WindowManager.LayoutParams.TYPE_APPLICATION_OVERLAY</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">    mWindowParams.type = WindowManager.LayoutParams.TYPE_SYSTEM_ALERT</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>不允许安装未知来源的应用</li></ul><p>Android 8.0去除了“允许未知来源”选项，所以如果我们的App有安装App的功能（检查更新之类的），那么会无法正常安装。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// &lt;uses-permission android:name="android.permission.REQUEST_INSTALL_PACKAGES"/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">installAPK</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.O) &#123;</span><br><span class="line">            <span class="keyword">boolean</span> hasInstallPermission = getPackageManager().canRequestPackageInstalls();</span><br><span class="line">            <span class="keyword">if</span> (hasInstallPermission) &#123;</span><br><span class="line">                <span class="comment">//安装应用</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//跳转至“安装未知应用”权限界面，引导用户开启权限</span></span><br><span class="line">                Uri selfPackageUri = Uri.parse(<span class="string">"package:"</span> + <span class="keyword">this</span>.getPackageName());</span><br><span class="line">                Intent intent = <span class="keyword">new</span> Intent(Settings.ACTION_MANAGE_UNKNOWN_APP_SOURCES, selfPackageUri);</span><br><span class="line">                startActivityForResult(intent, <span class="number">100</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//安装应用</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//接收“安装未知应用”权限的开启结果</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onActivityResult</span><span class="params">(<span class="keyword">int</span> requestCode, <span class="keyword">int</span> resultCode, Intent data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onActivityResult(requestCode, resultCode, data);</span><br><span class="line">        <span class="keyword">if</span> (requestCode == <span class="number">100</span>) &#123;</span><br><span class="line">            installAPK();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ul><li>Only fullscreen opaque activities can request orientation</li></ul><p>只有全屏不透明的<code>activity</code>才可以设置方向。这应该是个bug，在Android8.0中出现，8.1中被修复。</p><p>我们的处理办法就是要么去掉设置方向的代码，要么舍弃透明效果。</p><h1 id="Android9-0"><a href="#Android9-0" class="headerlink" title="Android9.0"></a>Android9.0</h1><ul><li>在9.0中默认情况下启用网络传输层安全协议 (TLS)，默认情况下已停用明文支持。也就是不允许使用http请求，要求使用<code>https</code>。解决办法就是添加网络安全配置：</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">application</span> <span class="attr">android:networkSecurityConfig</span>=<span class="string">"@xml/network_security_config"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">network-security-config</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">base-config</span> <span class="attr">cleartextTrafficPermitted</span>=<span class="string">"true"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">network-security-config</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--或者在AndroidManifest.xml中配置：</span></span><br><span class="line"><span class="comment">android:usesCleartextTraffic="true"</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br></pre></td></tr></table></figure><ul><li>移除Apache HTTP 客户端</li></ul><p>在6.0中取消了对<code>Apache HTTP</code> 客户端的支持，Android9.0中直接移除了该库，要使用的话需要添加配置：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">uses-library</span> <span class="attr">android:name</span>=<span class="string">"org.apache.http.legacy"</span> <span class="attr">android:required</span>=<span class="string">"false"</span>/&gt;</span></span><br></pre></td></tr></table></figure><ul><li>前台服务调用</li></ul><p>Android 9.0 要求创建一个前台服务需要请求 FOREGROUND_SERVICE 权限，否则系统会引发 SecurityException。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// &lt;uses-permission android:name="android.permission.FOREGROUND_SERVICE" /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (android.os.Build.VERSION.SDK_INT &gt;= android.os.Build.VERSION_CODES.O) &#123;</span><br><span class="line">    startForegroundService(intentService);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    startService(intentService);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>不能在非Acitivity环境中启动Activity</li></ul><p>在9.0 中，不能直接非 Activity 环境中（比如Service，Application）启动 Activity，否则会崩溃报错，解决办法就是加上<code>FLAG_ACTIVITY_NEW_TASK</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Intent intent = <span class="keyword">new</span> Intent(<span class="keyword">this</span>, TestActivity<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);</span><br><span class="line">startActivity(intent);</span><br></pre></td></tr></table></figure><h1 id="Android10"><a href="#Android10" class="headerlink" title="Android10"></a>Android10</h1><ul><li>分区存储</li></ul><p>Android10中默认开启了分区存储，也就是沙盒模式。应用只能看到本应用专有的目录（通过 <code>Context.getExternalFilesDir()</code> 访问）以及特定类型的媒体。</p><p>如果需要关闭这个功能可以配置：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">android:requestLegacyExternalStorage="true"</span><br></pre></td></tr></table></figure><p>分区存储下，访问文件的方法：</p><p>1）应用专属目录</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//分区存储空间</span></span><br><span class="line"><span class="keyword">val</span> file = File(context.filesDir, filename)</span><br><span class="line"></span><br><span class="line"><span class="comment">//应用专属外部存储空间</span></span><br><span class="line"><span class="keyword">val</span> appSpecificExternalDir = File(context.getExternalFilesDir(), filename)</span><br></pre></td></tr></table></figure><p>2）访问公共媒体目录文件</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> cursor = contentResolver.query(MediaStore.Images.Media.EXTERNAL_CONTENT_URI, <span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">null</span>, <span class="string">"<span class="subst">$&#123;MediaStore.MediaColumns.DATE_ADDED&#125;</span> desc"</span>)</span><br><span class="line"><span class="keyword">if</span> (cursor != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">while</span> (cursor.moveToNext()) &#123;</span><br><span class="line">        <span class="keyword">val</span> id = cursor.getLong(cursor.getColumnIndexOrThrow(MediaStore.MediaColumns._ID))</span><br><span class="line">        <span class="keyword">val</span> uri = ContentUris.withAppendedId(MediaStore.Images.Media.EXTERNAL_CONTENT_URI, id)</span><br><span class="line">        println(<span class="string">"image uri is <span class="variable">$uri</span>"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    cursor.close()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3）SAF(存储访问框架–Storage Access Framework)</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> intent = Intent(Intent.ACTION_OPEN_DOCUMENT)</span><br><span class="line">intent.addCategory(Intent.CATEGORY_OPENABLE)</span><br><span class="line">intent.type = <span class="string">"image/*"</span></span><br><span class="line">startActivityForResult(intent, <span class="number">100</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">@RequiresApi(Build.VERSION_CODES.KITKAT)</span></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onActivityResult</span><span class="params">(requestCode: <span class="type">Int</span>, resultCode: <span class="type">Int</span>, <span class="keyword">data</span>: <span class="type">Intent</span>?)</span></span> &#123;</span><br><span class="line">    <span class="keyword">super</span>.onActivityResult(requestCode, resultCode, <span class="keyword">data</span>)</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">data</span> == <span class="literal">null</span> || resultCode != Activity.RESULT_OK) <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">if</span> (requestCode == <span class="number">100</span>) &#123;</span><br><span class="line">        <span class="keyword">val</span> uri = <span class="keyword">data</span>.<span class="keyword">data</span></span><br><span class="line">        println(<span class="string">"image uri is <span class="variable">$uri</span>"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>权限再次升级</li></ul><p>从Android10开始普通应用不再允许请求权限android.permission.READ_PHONE_STATE。而且，无论你的App是否适配过Android Q（既targetSdkVersion是否大于等于29），均无法再获取到设备IMEI等设备信息。</p><p>如果Android10以下设备获取设备IMEI等信息，可以配置最大sdk版本：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">"android.permission.READ_PHONE_STATE"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:maxSdkVersion</span>=<span class="string">"28"</span>/&gt;</span></span><br></pre></td></tr></table></figure><h1 id="Android-11"><a href="#Android-11" class="headerlink" title="Android 11"></a>Android 11</h1><ul><li>分区存储强制执行</li></ul><p>没错，Android11强制执行分区存储，也就是沙盒模式。这次真的没有关闭功能了，离Android11出来也有一段时间了，还是抓紧适配把。</p><ul><li>修改电话权限</li></ul><p>改动了两个API：getLine1Number()和 getMsisdn() ，需要加上READ_PHONE_NUMBERS权限</p><ul><li>不允许自定义toast从后台显示了</li><li>必须加上v2签名</li><li>增加5g相关API</li><li>后台位置访问权限再次限制</li></ul><p>你一定很奇怪，为什么<code>Android11</code>的适配就这么草草收尾了？这可是我们最需要的啊？</p><p>哈哈，因为改动还是挺多的，所以给你推荐文章—<code>Android11最全适配指南</code>，应该有很多朋友都看过了：<a href="https://juejin.cn/post/6860370635664261128，或者点击文末的“阅读原文”即可。" target="_blank" rel="noopener">https://juejin.cn/post/6860370635664261128，或者点击文末的“阅读原文”即可。</a></p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://juejin.cn/post/6898176468661059597" target="_blank" rel="noopener">https://juejin.cn/post/6898176468661059597</a> <a href="https://blog.csdn.net/qq_17766199/article/details/80965631" target="_blank" rel="noopener">https://blog.csdn.net/qq_17766199/article/details/80965631</a> <a href="https://weilu.blog.csdn.net/article/details/98336225" target="_blank" rel="noopener">https://weilu.blog.csdn.net/article/details/98336225</a></p><h1 id="相关阅读"><a href="#相关阅读" class="headerlink" title="相关阅读"></a>相关阅读</h1><p><a href="http://mp.weixin.qq.com/s?__biz=MzIxNzU1Nzk3OQ==&amp;mid=2247488324&amp;idx=1&amp;sn=617d63108f012d02d426817ee62978cd&amp;chksm=97f6adf0a08124e652c7c03bfb956c6a3823a1aab4d1ace50042a2db2c76cce2c903379355b4&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">Android 适配之版本适配</a></p><p><a href="http://mp.weixin.qq.com/s?__biz=MzIxNzU1Nzk3OQ==&amp;mid=2247491967&amp;idx=1&amp;sn=631436731bd07a3f6b8dbb90ec513ce0&amp;chksm=97f55fcba082d6dd0e1180ab7d505ce4d5786d8acb4f81d44afc47360739f2e4d7d0705d1e7b&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">谷歌：未来 Android 手机将获得 4 年软件更新</a></p><p><a href="http://mp.weixin.qq.com/s?__biz=MzIxNzU1Nzk3OQ==&amp;mid=2247487853&amp;idx=1&amp;sn=1ab4a680b0d9e76f2226311f1e2ae53f&amp;chksm=97f6afd9a08126cfef73a185fd984bf8cfda36c24573134fde196fb9ade4278f5a61f4a6a14e&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">Android-图片的选择，裁剪，压缩，适配高版本</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;今天分享的面试题是：&lt;/p&gt;
&lt;p&gt;Android在版本迭代中，总会进行很多改动，那么你熟知各版本都改动了什么内容？又要怎么适配呢？&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="http://hackycy.github.io/categories/Android/"/>
    
    
      <category term="Android" scheme="http://hackycy.github.io/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>多线程NSThread基础小记</title>
    <link href="http://hackycy.github.io/2020/12/15/%E5%A4%9A%E7%BA%BF%E7%A8%8BNSThread%E5%9F%BA%E7%A1%80%E5%B0%8F%E8%AE%B0/"/>
    <id>http://hackycy.github.io/2020/12/15/多线程NSThread基础小记/</id>
    <published>2020-12-15T14:17:52.000Z</published>
    <updated>2021-10-09T02:19:57.401Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>NSThread 基于OC的API,使用其简单，面向对象操作。但线程周期由程序员管理。</p><p><strong>优点：</strong>轻量级<br><strong>缺点：</strong>需要自己管理线程的生命周期，线程同步。线程同步对数据的加锁会有一定的系统开销</p><p><strong>苹果推荐是用GCD 和 NSOperation</strong></p><a id="more"></a><blockquote><p>注意：<br> [NSThread currentThread]跟踪任务所在线程，适用于NSThread、NSOperation、GCD<br> 使用NSThread的线程，不会自动添加autoreleasepool<br> 线程中的自动释放池：<br> @autoreleasepool{}自动释放池。主线程中是有自动释放池，使用NSThread 和 NSObject 不会有。如果在后台线程中创建了autoreleasepool的对象，需要使用自动释放池，否则会出现内存泄漏。当自动释放池销毁时，对池中的所有对象发送release消息，清空自动释放池。当所有的autorelease对象，在出了作用域后，会自动添加到最近一次创建的自动释放池中。</p></blockquote><h1 id="NSThread-常用属性"><a href="#NSThread-常用属性" class="headerlink" title="NSThread 常用属性"></a>NSThread 常用属性</h1><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@property</span> (<span class="keyword">nullable</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> *name  <span class="comment">//线程名字</span></span><br><span class="line"><span class="keyword">@property</span> <span class="built_in">NSUInteger</span> stackSize  <span class="comment">//线程栈大小,默认主线程1m ,子线程512k,次属性可读写,但是写入大小必须为4k的倍数,最小为16k</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">readonly</span>) <span class="built_in">BOOL</span> isMainThread <span class="comment">// 是否是主线程</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">readonly</span>, <span class="keyword">getter</span>=isExecuting) <span class="built_in">BOOL</span> executing  <span class="comment">//是否正在执行</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">readonly</span>, <span class="keyword">getter</span>=isFinished) <span class="built_in">BOOL</span> finished  <span class="comment">//是否已经完成</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">readonly</span>, <span class="keyword">getter</span>=isCancelled) <span class="built_in">BOOL</span> cancelled  <span class="comment">//是否已经取消</span></span><br></pre></td></tr></table></figure><h1 id="NSThread类方法-作用于当前线程"><a href="#NSThread类方法-作用于当前线程" class="headerlink" title="NSThread类方法 作用于当前线程"></a>NSThread类方法 作用于当前线程</h1><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="keyword">void</span>)detachNewThreadSelector:(SEL)selector toTarget:(<span class="keyword">id</span>)target withObject:(<span class="keyword">nullable</span> <span class="keyword">id</span>)argument; <span class="comment">//开辟一个新的线程</span></span><br><span class="line">+ (<span class="keyword">void</span>)sleepUntilDate:(<span class="built_in">NSDate</span> *)date;<span class="comment">//休眠到什么时候（具体日期）</span></span><br><span class="line">+ (<span class="keyword">void</span>)sleepForTimeInterval:(<span class="built_in">NSTimeInterval</span>)ti; <span class="comment">//休眠一段时间单位秒</span></span><br><span class="line">+ (<span class="keyword">void</span>)exit; <span class="comment">//结束当前线程</span></span><br><span class="line">+ (<span class="keyword">double</span>)threadPriority; <span class="comment">//返回当前线程优先级</span></span><br><span class="line">+ (<span class="built_in">BOOL</span>)setThreadPriority:(<span class="keyword">double</span>)p; <span class="comment">//设置当前线程优先级 0.0~1.0</span></span><br><span class="line">+ (<span class="built_in">NSArray</span>&lt;<span class="built_in">NSNumber</span> *&gt; *)callStackReturnAddresses <span class="comment">//返回当前线程访问的堆栈信息</span></span><br><span class="line">+ (<span class="built_in">NSArray</span>&lt;<span class="built_in">NSString</span> *&gt; *)callStackSymbols <span class="comment">//返回一堆十六进制的地址</span></span><br><span class="line">+ (<span class="built_in">BOOL</span>)isMainThread <span class="comment">//返回当前线程是否是主线程</span></span><br><span class="line">+ (<span class="built_in">NSThread</span> *)mainThread <span class="comment">//返回主线程</span></span><br></pre></td></tr></table></figure><h1 id="NSThread实例方法"><a href="#NSThread实例方法" class="headerlink" title="NSThread实例方法"></a>NSThread实例方法</h1><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">instancetype</span>)init</span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithTarget:(<span class="keyword">id</span>)target selector:(SEL)selector object:(<span class="keyword">nullable</span> <span class="keyword">id</span>)argument </span><br><span class="line">- (<span class="keyword">void</span>)main    <span class="comment">//主方法，用于子类继承重写</span></span><br><span class="line">- (<span class="keyword">void</span>)start   <span class="comment">//开始线程</span></span><br><span class="line">- (<span class="keyword">void</span>)cancel  <span class="comment">//取消线程</span></span><br></pre></td></tr></table></figure><h1 id="NSThread-详解"><a href="#NSThread-详解" class="headerlink" title="NSThread 详解"></a>NSThread 详解</h1><h2 id="线程的生命周期"><a href="#线程的生命周期" class="headerlink" title="线程的生命周期"></a>线程的生命周期</h2><ul><li>创建线程的方法</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">instancetype</span>)initWithTarget:(<span class="keyword">id</span>)target selector:(SEL)selector object:(<span class="keyword">id</span>)argument <span class="comment">//此方法创建的线程需要手动启动</span></span><br><span class="line">+ (<span class="keyword">void</span>)detachNewThreadSelector:(SEL)selector toTarget:(<span class="keyword">id</span>)target withObject:(<span class="keyword">id</span>)argument<span class="comment">//创建线程后自动启动</span></span><br><span class="line">- (<span class="keyword">void</span>)performSelectorInBackground:(SEL)aSelector withObject:(<span class="keyword">id</span>)arg<span class="comment">//隐式创建线程并启动</span></span><br></pre></td></tr></table></figure><ul><li>配置线程</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//通过name属性设置线程名字</span></span><br><span class="line">+ (<span class="built_in">BOOL</span>)setThreadPriority:(<span class="keyword">double</span>)p设置线程的优先级</span><br></pre></td></tr></table></figure><ul><li>启动线程</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)start</span><br></pre></td></tr></table></figure><ul><li>阻塞线程</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="keyword">void</span>)sleepUntilDate:(<span class="built_in">NSDate</span> *)date</span><br><span class="line">+ (<span class="keyword">void</span>)sleepForTimeInterval:(<span class="built_in">NSTimeInterval</span>)time</span><br></pre></td></tr></table></figure><ul><li>取消线程</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)cancel <span class="comment">//当前正在执行的线程不会立刻停止</span></span><br></pre></td></tr></table></figure><ul><li>强制退出线程</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="keyword">void</span>)exit</span><br></pre></td></tr></table></figure><h2 id="NSThread的其他操作"><a href="#NSThread的其他操作" class="headerlink" title="NSThread的其他操作"></a>NSThread的其他操作</h2><ul><li>与主线程相关</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="built_in">NSThread</span> *)mainThread <span class="comment">//获取主线程</span></span><br><span class="line">+ (<span class="built_in">BOOL</span>)isMainThread<span class="comment">//判断当前线程是不是主线程</span></span><br></pre></td></tr></table></figure><ul><li>与当前线程相关</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="built_in">NSThread</span> *)currentThread <span class="comment">//获取当前线程</span></span><br></pre></td></tr></table></figure><ul><li>判断线程的状态</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">* 通过executing属性判断线程是否正在执行</span><br><span class="line">* 通过finished属性判断线程是否执行完毕</span><br><span class="line">* 通过cancelled属性判断线程是否被取消</span><br></pre></td></tr></table></figure><ul><li>线程同步</li><li>原因：多个线程访问同一资源，很可能会引起数据错乱和数据安全问题</li><li>解决方案：使用互斥锁来解决互斥资源访问问题，iOS中通常使用@synchronized(锁){}对临界资源进行锁定，通常使用self作为锁</li><li>注意：由于线程同步会消耗大量的资源，应尽量避免多个线程访问同一资源，且通常将线程同步的逻辑交由服务器端实现</li></ul><h2 id="线程之间的通信"><a href="#线程之间的通信" class="headerlink" title="线程之间的通信"></a>线程之间的通信</h2><ul><li>从子线程回到主线程</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)performSelectorOnMainThread:(SEL)aSelector withObject:(<span class="keyword">id</span>)arg waitUntilDone:(<span class="built_in">BOOL</span>)wait modes:(<span class="built_in">NSArray</span> *)array</span><br><span class="line"><span class="comment">//array指定runLoop的模式，若为空，则不执行aselector方法的调用者即为aselector的调用者</span></span><br><span class="line">- (<span class="keyword">void</span>)performSelectorOnMainThread:(SEL)aSelector withObject:(<span class="keyword">id</span>)arg waitUntilDone:(<span class="built_in">BOOL</span>)wait</span><br></pre></td></tr></table></figure><ul><li>从一个线程到另一个线程(包括主线程)</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)performSelector:(SEL)aSelector onThread:(<span class="built_in">NSThread</span> )thr withObject:(<span class="keyword">id</span>)arg waitUntilDone:(<span class="built_in">BOOL</span>)wait modes:(<span class="built_in">NSArray</span> )array</span><br><span class="line">- (<span class="keyword">void</span>)performSelector:(SEL)aSelector onThread:(<span class="built_in">NSThread</span> *)thr withObject:(<span class="keyword">id</span>)arg waitUntilDone:(<span class="built_in">BOOL</span>)wait</span><br></pre></td></tr></table></figure><p><strong>也可以通过NSPort对象实现通信</strong></p><h1 id="反思"><a href="#反思" class="headerlink" title="反思"></a>反思</h1><h2 id="资源共享"><a href="#资源共享" class="headerlink" title="资源共享"></a>资源共享</h2><ul><li>1块资源可能会被多个线程共享，也就是多个线程可能会访问同一块资源</li><li>当多个线程访问同一块资源时，很容易引发数据错乱和数据安全问题</li></ul><h2 id="解决办法互斥锁"><a href="#解决办法互斥锁" class="headerlink" title="解决办法互斥锁"></a>解决办法互斥锁</h2><ul><li>互斥锁使用格式</li></ul><blockquote><p>1.@synchronized(锁对象) { // 需要锁定的代码 }<br>2.只用一把锁,多锁是无效的</p></blockquote><ul><li>互斥锁的优缺点</li></ul><blockquote><p>优点：能有效防止因多线程抢夺资源造成的数据安全问题<br>缺点：需要消耗大量的CPU资源</p></blockquote><ul><li>互斥锁的使用前提：多条线程抢夺同一块资源</li></ul><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>摘抄自 <a href="https://www.jianshu.com/p/8c7635428599" target="_blank" rel="noopener">https://www.jianshu.com/p/8c7635428599</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;NSThread 基于OC的API,使用其简单，面向对象操作。但线程周期由程序员管理。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;优点：&lt;/strong&gt;轻量级&lt;br&gt;&lt;strong&gt;缺点：&lt;/strong&gt;需要自己管理线程的生命周期，线程同步。线程同步对数据的加锁会有一定的系统开销&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;苹果推荐是用GCD 和 NSOperation&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Ios" scheme="http://hackycy.github.io/categories/Ios/"/>
    
    
      <category term="Ios" scheme="http://hackycy.github.io/tags/Ios/"/>
    
  </entry>
  
  <entry>
    <title>Flutter解决 警告 Waiting for another flutter command to release the startup lock</title>
    <link href="http://hackycy.github.io/2020/12/14/Flutter%E8%A7%A3%E5%86%B3-%E8%AD%A6%E5%91%8A-Waiting-for-another-flutter-command-to-release-the-startup-lock/"/>
    <id>http://hackycy.github.io/2020/12/14/Flutter解决-警告-Waiting-for-another-flutter-command-to-release-the-startup-lock/</id>
    <published>2020-12-14T09:49:26.000Z</published>
    <updated>2021-10-09T02:19:56.885Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><strong>运行flutter命令的时候显示出如下警告时</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Waiting <span class="keyword">for</span> another flutter <span class="built_in">command</span> to release the startup lock</span><br></pre></td></tr></table></figure><p>当项目异常关闭，或者<code>android studio</code>用任务管理器强制关闭，下次启动就会出现上面的一行话。</p><p>此时需要打开<code>${flutter的安装目录}/bin/cache/lockfile</code>，删除就行了。</p><p>或者直接用下面的命令：<code>rm -rf ${flutter的安装目录}/bin/cache/lockfile</code></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="Flutter" scheme="http://hackycy.github.io/categories/Flutter/"/>
    
    
      <category term="Flutter" scheme="http://hackycy.github.io/tags/Flutter/"/>
    
  </entry>
  
  <entry>
    <title>package.json中的browser字段</title>
    <link href="http://hackycy.github.io/2020/12/07/package-json%E4%B8%AD%E7%9A%84browser%E5%AD%97%E6%AE%B5/"/>
    <id>http://hackycy.github.io/2020/12/07/package-json中的browser字段/</id>
    <published>2020-12-07T09:34:37.000Z</published>
    <updated>2021-10-09T02:19:57.397Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>有时候，我们想要写一个能够跑在浏览器上和node上的包，但是由于二者在执行环境上有微弱的区别，比如浏览器上请求数据是用XMLHttpRequest对象，但是node上用的确是http或者https，诸如此类的差异还有很多。这就导致了我们要为浏览器端和node端准备不同的源文件，那我们要怎么区分不同的环境呢？</p><a id="more"></a><h1 id="依赖打包器的process-browser"><a href="#依赖打包器的process-browser" class="headerlink" title="依赖打包器的process.browser"></a>依赖打包器的process.browser</h1><p>在此，以实现base64编码为例，在同一个入口文件，可以根据打包器提供的process.browser字段（在浏览器环境下为true，在node环境下为false）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (process.browser) &#123;</span><br><span class="line">    <span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span> (<span class="params">string</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> btoa(string)</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span> (<span class="params">string</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Buffer.from(string, <span class="string">'binary'</span>).toString(<span class="string">'base64'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是这种方式有一个很大的问题，打包器会在执行上诉代码中会为包引入polyfill，在这个例子中就是在浏览器中的Buffer实现<a href="https://github.com/feross/buffer" target="_blank" rel="noopener">buffer</a>。这样打包出来的体积就会很大。</p><h1 id="使用package-json的browser字段"><a href="#使用package-json的browser字段" class="headerlink" title="使用package.json的browser字段"></a>使用package.json的browser字段</h1><p><a href="https://docs.npmjs.com/files/package.json" target="_blank" rel="noopener">npm doc</a>上的解释如下</p><blockquote><p>If your module is meant to be used client-side the browser field should be used instead of the main field. This is helpful to hint users that it might rely on primitives that aren’t available in Node.js modules. (e.g. window)</p></blockquote><p>总而言之就是在浏览器环境下用来替换main字段，包的作者可以通过browser字段提示包中要替换掉哪些模块或者要替换掉哪些源文件的实现。</p><p>browser的用法有以下几种</p><h2 id="browser为某一个单个的字符串"><a href="#browser为某一个单个的字符串" class="headerlink" title="browser为某一个单个的字符串"></a>browser为某一个单个的字符串</h2><p>替换main成为浏览器环境的入口文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;browser&quot;: &quot;./lib/browser/main.js&quot;</span><br></pre></td></tr></table></figure><h2 id="browser为一个对象，声明要替换或者忽略的文件"><a href="#browser为一个对象，声明要替换或者忽略的文件" class="headerlink" title="browser为一个对象，声明要替换或者忽略的文件"></a>browser为一个对象，声明要替换或者忽略的文件</h2><p>这种形式比较适合替换部分文件，不需要创建新的入口。key是要替换的module或者文件名，右侧是替换的</p>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;browser&quot;: &#123;&quot;module-a&quot;: &quot;./browser/module-a.js&quot;,&quot;./server/module-b.js&quot;: &quot;./browser/module-b.js&quot;&#125;</span><br></pre></td></tr></table></figure><p>打包器在打包到浏览器环境时，会将来自<code>module-a</code>的替换为<code>./browser/module-a.js</code>。将文件’./server/module-b.js’的引入替换为<code>./browser/module-b.js</code>。</p><p>还可以使用布尔值防止将module加载到包中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;browser&quot;: &#123;&quot;module-a&quot;:false,&quot;./server/only.js&quot;:&quot;./shims/server-only.js&quot;&#125;</span><br></pre></td></tr></table></figure><p>这种写法<code>module-a</code>在浏览器环境中将不会被打包。</p><p>上面的所有写法的路径都是基于<code>package.json</code>文件地址。</p><p><strong>需要注意的是如果你的包能在浏览器和node上无差异化地实现，就不需要browser字段了。</strong></p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://zhuanlan.zhihu.com/p/25215447" target="_blank" rel="noopener">[译] 怎样写一个能同时用于 Node 和浏览器的 JavaScript 包？</a></p><p><a href="https://juejin.im/post/5cfe6d3be51d454d544abf30" target="_blank" rel="noopener">package.json 中 你还不清楚的 browser，module，main 字段优先级</a></p><p><a href="https://www.helplib.com/GitHub/article_134305" target="_blank" rel="noopener">package-browser-field-spec, 在 package.json 中，’browser’字段的规范文档</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;有时候，我们想要写一个能够跑在浏览器上和node上的包，但是由于二者在执行环境上有微弱的区别，比如浏览器上请求数据是用XMLHttpRequest对象，但是node上用的确是http或者https，诸如此类的差异还有很多。这就导致了我们要为浏览器端和node端准备不同的源文件，那我们要怎么区分不同的环境呢？&lt;/p&gt;
    
    </summary>
    
      <category term="NodeJS" scheme="http://hackycy.github.io/categories/NodeJS/"/>
    
    
      <category term="NodeJS" scheme="http://hackycy.github.io/tags/NodeJS/"/>
    
      <category term="Package.json" scheme="http://hackycy.github.io/tags/Package-json/"/>
    
  </entry>
  
  <entry>
    <title>发布npm包填坑小记</title>
    <link href="http://hackycy.github.io/2020/09/21/%E5%8F%91%E5%B8%83npm%E5%8C%85%E5%A1%AB%E5%9D%91%E5%B0%8F%E8%AE%B0/"/>
    <id>http://hackycy.github.io/2020/09/21/发布npm包填坑小记/</id>
    <published>2020-09-21T11:09:24.000Z</published>
    <updated>2021-10-09T02:19:57.397Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><strong>发布NPM包时遇到的一些问题记录</strong></p><h1 id="问题1"><a href="#问题1" class="headerlink" title="问题1"></a>问题1</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm ERR! publish Failed PUT 403</span><br><span class="line">npm ERR! code E403</span><br><span class="line">npm ERR! you must verify your email before publishing a new package: https://www.npmjs.com/email-edit : your-package</span><br></pre></td></tr></table></figure><p>这是注册的npm账号邮箱未进行验证，先去验证。一开始出现这个原因我是邮箱填错一直没收到邮件。</p><a id="more"></a><h1 id="问题2"><a href="#问题2" class="headerlink" title="问题2"></a>问题2</h1><p>在发布<code>npm</code>包的时候可能会出现报错信息：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm ERR! 403 403 Forbidden - PUT https://registry.npm.taobao.org/@hackycy%2fegg-typeorm - [no_perms] Private mode <span class="built_in">enable</span>, only admin can publish this module</span><br><span class="line">npm ERR! 403 In most cases, you or one of your dependencies are requesting</span><br><span class="line">npm ERR! 403 a package version that is forbidden by your security policy.</span><br></pre></td></tr></table></figure><p>出现这个问题是因为当前设置的是<code>cnpm</code>登录到的是<code>cnpm</code>，所以需要切换回来。<br>之前登录的时候就提出登录的是<code>taobao</code>只不过那个时候没注意。</p><p>可以输入一下命令查看当前的登录源：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ npm config get registry</span><br><span class="line">https://registry.npm.taobao.org/</span><br></pre></td></tr></table></figure><p>可以看到返回的地址是淘宝源，需要切回到npmjs源，输入以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm config <span class="built_in">set</span> registry=http://registry.npmjs.org</span><br></pre></td></tr></table></figure><p>设置完之后在查看当前登录的源地址：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ npm config get registry</span><br><span class="line">http://registry.npmjs.org/</span><br></pre></td></tr></table></figure><p>然后重新<code>npm login</code>再发布即可。</p><h1 id="问题3"><a href="#问题3" class="headerlink" title="问题3"></a>问题3</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm ERR! publish Failed PUT 403</span><br><span class="line">npm ERR! code E403</span><br><span class="line">npm ERR! You <span class="keyword">do</span> not have permission to publish <span class="string">"your-package"</span>. Are you logged <span class="keyword">in</span> as the correct user? : your-package</span><br></pre></td></tr></table></figure><p>你的包和别人的包重名了，npm 里的包不允许重名，所以去 <a href="https://links.jianshu.com/go?to=https%3A%2F%2Fwww.npmjs.com%2F" target="_blank" rel="noopener">npm</a> 搜一下，改个没人用的名字就可以了。或者用<code>@your-name/your-package</code>来命名。</p><h1 id="问题4"><a href="#问题4" class="headerlink" title="问题4"></a>问题4</h1><p>无法发布私有包：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm ERR! publish Failed PUT 402</span><br><span class="line">npm ERR! code E402</span><br><span class="line">npm ERR! You must sign up <span class="keyword">for</span> private packages :</span><br></pre></td></tr></table></figure><p>大多数是因为当你的包名为<code>@your-name/your-package</code>时才会出现，原因是当包名以<code>@your-name</code>开头时，<code>npm publish</code>会默认发布为私有包，但是 npm 的私有包需要付费，所以需要添加如下参数进行发布：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm publish --access public</span><br></pre></td></tr></table></figure><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://blog.csdn.net/weixin_38080573/article/details/88080556" target="_blank" rel="noopener">https://blog.csdn.net/weixin_38080573/article/details/88080556</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;发布NPM包时遇到的一些问题记录&lt;/strong&gt;&lt;/p&gt;
&lt;h1 id=&quot;问题1&quot;&gt;&lt;a href=&quot;#问题1&quot; class=&quot;headerlink&quot; title=&quot;问题1&quot;&gt;&lt;/a&gt;问题1&lt;/h1&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;npm ERR! publish Failed PUT 403&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;npm ERR! code E403&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;npm ERR! you must verify your email before publishing a new package: https://www.npmjs.com/email-edit : your-package&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这是注册的npm账号邮箱未进行验证，先去验证。一开始出现这个原因我是邮箱填错一直没收到邮件。&lt;/p&gt;
    
    </summary>
    
      <category term="NodeJS" scheme="http://hackycy.github.io/categories/NodeJS/"/>
    
    
      <category term="NPM" scheme="http://hackycy.github.io/tags/NPM/"/>
    
  </entry>
  
  <entry>
    <title>解决Element-UI el-tree有关子、父节点选中问题</title>
    <link href="http://hackycy.github.io/2020/09/15/%E8%A7%A3%E5%86%B3Element-UI-el-tree%E6%9C%89%E5%85%B3%E5%AD%90%E3%80%81%E7%88%B6%E8%8A%82%E7%82%B9%E9%80%89%E4%B8%AD%E9%97%AE%E9%A2%98/"/>
    <id>http://hackycy.github.io/2020/09/15/解决Element-UI-el-tree有关子、父节点选中问题/</id>
    <published>2020-09-15T17:23:07.000Z</published>
    <updated>2021-10-09T02:19:57.445Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="问题1"><a href="#问题1" class="headerlink" title="问题1"></a>问题1</h1><p>在使用el-tree组件在获取完数据进行页面回显数据时，因为后端返回的数据中包含父节点的关系，但是子节点并没有全部选中，就把不该选中的子节点也全部勾上了。</p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><ul><li><p>isLeaf（判断节点是否为叶子节点）</p></li><li><p>getNode（获取tree中对应的节点）</p></li><li><p>setChecked （设置tree中对应的节点为选中状态）</p></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> res = [<span class="number">1</span>,<span class="number">11</span>,<span class="number">23</span>,<span class="number">25</span>,<span class="number">28</span>,<span class="number">37</span>];</span><br><span class="line">res.map(<span class="function">(<span class="params">i, n</span>) =&gt;</span> &#123;     </span><br><span class="line">     <span class="comment">//根据i获取tree中的节点     </span></span><br><span class="line">     <span class="keyword">const</span> node = that.$refs.menuListTree.getNode(i);     </span><br><span class="line">     <span class="keyword">if</span> (node &amp;&amp; node.isLeaf) &#123;          </span><br><span class="line">         <span class="comment">//设置某个节点的勾选状态          </span></span><br><span class="line">         that.$refs.menuListTree.setChecked(node, <span class="literal">true</span>);      </span><br><span class="line">     &#125;</span><br><span class="line"> &#125;);</span><br></pre></td></tr></table></figure><a id="more"></a><blockquote><p>注意，手动更新节点后无需在用回显数据赋值给data中绑定的值，否则会无效</p></blockquote><h1 id="问题2"><a href="#问题2" class="headerlink" title="问题2"></a>问题2</h1><p>在获取选择的节点数据时，子节点未全部选中时，<code>getCheckedKeys</code>中没有包含父节点id。</p><h2 id="解决方案-1"><a href="#解决方案-1" class="headerlink" title="解决方案"></a><strong>解决方案</strong></h2><ul><li>halfCheckedKeys中为半选中的节点（具体可查看官方API）</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">getCheckedKeys() &#123;  </span><br><span class="line"><span class="keyword">const</span> childKeys = <span class="keyword">this</span>.$refs.menuListTree.getCheckedKeys()</span><br><span class="line">  <span class="keyword">const</span> halfKeys = <span class="keyword">this</span>.$refs.menuListTree.getHalfCheckedKeys()</span><br><span class="line">  <span class="keyword">return</span> [...childKeys, ...halfKeys]</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><h1 id="文档"><a href="#文档" class="headerlink" title="文档"></a>文档</h1><p><a href="https://element.eleme.cn/#/zh-CN/component/tree" target="_blank" rel="noopener">https://element.eleme.cn/#/zh-CN/component/tree</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;问题1&quot;&gt;&lt;a href=&quot;#问题1&quot; class=&quot;headerlink&quot; title=&quot;问题1&quot;&gt;&lt;/a&gt;问题1&lt;/h1&gt;&lt;p&gt;在使用el-tree组件在获取完数据进行页面回显数据时，因为后端返回的数据中包含父节点的关系，但是子节点并没有全部选中，就把不该选中的子节点也全部勾上了。&lt;/p&gt;
&lt;h2 id=&quot;解决方案&quot;&gt;&lt;a href=&quot;#解决方案&quot; class=&quot;headerlink&quot; title=&quot;解决方案&quot;&gt;&lt;/a&gt;解决方案&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;isLeaf（判断节点是否为叶子节点）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;getNode（获取tree中对应的节点）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;setChecked （设置tree中对应的节点为选中状态）&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; res = [&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;11&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;23&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;25&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;28&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;37&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;res.map(&lt;span class=&quot;function&quot;&gt;(&lt;span class=&quot;params&quot;&gt;i, n&lt;/span&gt;) =&amp;gt;&lt;/span&gt; &amp;#123;     &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     &lt;span class=&quot;comment&quot;&gt;//根据i获取tree中的节点     &lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     &lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; node = that.$refs.menuListTree.getNode(i);     &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (node &amp;amp;&amp;amp; node.isLeaf) &amp;#123;          &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;         &lt;span class=&quot;comment&quot;&gt;//设置某个节点的勾选状态          &lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;         that.$refs.menuListTree.setChecked(node, &lt;span class=&quot;literal&quot;&gt;true&lt;/span&gt;);      &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="Vue" scheme="http://hackycy.github.io/categories/Vue/"/>
    
    
      <category term="Element-UI" scheme="http://hackycy.github.io/tags/Element-UI/"/>
    
  </entry>
  
  <entry>
    <title>egg-core源码分析</title>
    <link href="http://hackycy.github.io/2020/08/26/egg-core%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    <id>http://hackycy.github.io/2020/08/26/egg-core源码分析/</id>
    <published>2020-08-26T11:17:20.000Z</published>
    <updated>2021-10-09T02:19:57.389Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>最近在翻查<a href="https://www.npmjs.com/package/egg-cool-router" target="_blank" rel="noopener">egg-cool-router</a>源码查看如何使用装饰器来注册egg路由，看到了一些很牛逼的操作，想知道为什么就查了一下关于源码讲解的文章，解惑了所以摘抄了下来。</p><a id="more"></a><h1 id="egg-core是什么"><a href="#egg-core是什么" class="headerlink" title="egg-core是什么"></a>egg-core是什么</h1><h2 id="应用、框架、插件之间的关系"><a href="#应用、框架、插件之间的关系" class="headerlink" title="应用、框架、插件之间的关系"></a>应用、框架、插件之间的关系</h2><p>在学习egg-core是什么之前，我们先了解一下关于Egg框架中应用，框架，插件这三个概念及其之间的关系：</p><ul><li>一个应用必须指定一个框架才能运行起来，根据需要我们可以给一个应用配置多个不同的插件</li><li>插件只完成特定独立的功能，实现即插即拔的效果</li><li>框架是一个启动器，必须有它才能运行起来。框架还是一个封装器，它可以在已有框架的基础上进行封装，框架也可以配置插件，其中Egg，EggCore都是框架</li><li>在框架的基础上还可以扩展出新的框架，也就是说框架是可以无限级继承的，有点像类的继承</li><li>框架/应用/插件的关于service/controler/config/middleware的目录结构配置基本相同，称之为加载单元（loadUnit），包括后面源码分析中的getLoadUnits都是为了获取这个结构</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"># 加载单元的目录结构如下图，其中插件和框架没有controller和router.js</span><br><span class="line"># 这个目录结构很重要，后面所有的load方法都是针对这个目录结构进行的</span><br><span class="line">        loadUnit</span><br><span class="line">        ├── package.json</span><br><span class="line">        ├── app</span><br><span class="line">        │   ├── extend</span><br><span class="line">        │   |   ├── helper.js</span><br><span class="line">        │   |   ├── request.js</span><br><span class="line">        │   |   ├── response.js</span><br><span class="line">        │   |   ├── context.js</span><br><span class="line">        │   |   ├── application.js</span><br><span class="line">        │   |   └── agent.js</span><br><span class="line">        │   ├── service</span><br><span class="line">        |   ├── controller</span><br><span class="line">        │   ├── middleware</span><br><span class="line">        │   └── router.js</span><br><span class="line">        └── config</span><br><span class="line">            ├── config.default.js</span><br><span class="line">            ├── config.prod.js</span><br><span class="line">            ├── config.test.js</span><br><span class="line">            ├── config.local.js</span><br><span class="line">            └── config.unittest.js</span><br></pre></td></tr></table></figure><h2 id="eggCore的主要工作"><a href="#eggCore的主要工作" class="headerlink" title="eggCore的主要工作"></a>eggCore的主要工作</h2><p>egg.js的大部分核心代码实现都在<a href="https://github.com/eggjs/egg-core" target="_blank" rel="noopener">egg-core库</a>中，egg-core主要export四个对象:</p><ul><li>EggCore类：继承于Koa，做一些初始化工作，EggCore中最主要的一个属性是loader，也就是egg-core的导出的第二个类EggLoader的实例</li><li>EggLoader类：整个框架目录结构（controller，service，middleware，extend，route.js）的加载和初始化工作都在该类中实现的，主要提供了几个load函数(loadPlugin,loadConfig,loadMiddleware,loadService,loadController,loadRouter等)，这些函数会根据指定目录结构下文件输出形式不同进行适配，最终挂载输出内容。</li><li>BaseContextClass类：这个类主要是为了我们在使用框架开发时，在controller和service作为基类使用，只有继承了该类，我们才可以通过this.ctx获取到当前请求的上下文对象</li><li>utils对象：几个主要的函数，包括转换成中间件函数middleware，根据不同类型文件获取文件导出内容函数loadFile等</li></ul><p>所以egg-core做的主要事情就是根据loadUnit的目录结构规范，将目录结构中的config，controller，service，middleware，plugin，router等文件load到app或者context上，开发人员只要按照这套约定规范，就可以很方便进行开发，以下是EggCore的exports对象源码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//egg-core源码 -&gt; index文件导出的数据结构</span></span><br><span class="line"><span class="keyword">const</span> EggCore = <span class="built_in">require</span>(<span class="string">'./lib/egg'</span>);</span><br><span class="line"><span class="keyword">const</span> EggLoader = <span class="built_in">require</span>(<span class="string">'./lib/loader/egg_loader'</span>);</span><br><span class="line"><span class="keyword">const</span> BaseContextClass = <span class="built_in">require</span>(<span class="string">'./lib/utils/base_context_class'</span>);</span><br><span class="line"><span class="keyword">const</span> utils = <span class="built_in">require</span>(<span class="string">'./lib/utils'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  EggCore,</span><br><span class="line">  EggLoader,</span><br><span class="line">  BaseContextClass,</span><br><span class="line">  utils,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="EggLoader的具体实现源码学习"><a href="#EggLoader的具体实现源码学习" class="headerlink" title="EggLoader的具体实现源码学习"></a>EggLoader的具体实现源码学习</h3><h4 id="EggCore类源码学习"><a href="#EggCore类源码学习" class="headerlink" title="EggCore类源码学习"></a>EggCore类源码学习</h4><p>EggCore类是算是上文提到的框架范畴，它从Koa类继承而来，并做了一些初始化工作，其中有三个主要属性是：</p><ul><li>loader：这个对象是EggLoader的实例，定义了多个load函数，用于对loadUnit目录下的文件进行加载，后面后专门讲这个类的是实现</li><li>router：是EggRouter类的实例，从<a href="https://github.com/alexmingoia/koa-router" target="_blank" rel="noopener">koa-router</a>继承而来，用于egg框架的路由管理和分发，这个类的实现在后面的loadRouter函数会有说明</li><li>lifecycle：这个属性用于app的生命周期管理，由于和整个文件加载逻辑关系不大，所以这里不作说明</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//egg-core源码 -&gt; EggCore类的部分实现</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> KoaApplication = <span class="built_in">require</span>(<span class="string">'koa'</span>);</span><br><span class="line"><span class="keyword">const</span> EGG_LOADER = <span class="built_in">Symbol</span>.for(<span class="string">'egg#loader'</span>);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EggCore</span> <span class="keyword">extends</span> <span class="title">KoaApplication</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(options = &#123;&#125;) &#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        <span class="keyword">const</span> Loader = <span class="keyword">this</span>[EGG_LOADER];</span><br><span class="line">        <span class="comment">//初始化loader对象</span></span><br><span class="line">        <span class="keyword">this</span>.loader = <span class="keyword">new</span> Loader(&#123;</span><br><span class="line">            baseDir: options.baseDir,          <span class="comment">//项目启动的根目录</span></span><br><span class="line">            app: <span class="keyword">this</span>,                         <span class="comment">//EggCore实例本身</span></span><br><span class="line">            plugins: options.plugins,          <span class="comment">//自定义插件配置信息，设置插件配置信息有多种方式，后面我们会讲</span></span><br><span class="line">            logger: <span class="keyword">this</span>.console,             </span><br><span class="line">            serverScope: options.serverScope, </span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">get</span> [EGG_LOADER]() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">require</span>(<span class="string">'./loader/egg_loader'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//router对象</span></span><br><span class="line">    <span class="keyword">get</span> router() &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>[ROUTER]) &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">this</span>[ROUTER];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">const</span> router = <span class="keyword">this</span>[ROUTER] = <span class="keyword">new</span> Router(&#123; <span class="attr">sensitive</span>: <span class="literal">true</span> &#125;, <span class="keyword">this</span>);</span><br><span class="line">        <span class="comment">// register router middleware</span></span><br><span class="line">        <span class="keyword">this</span>.beforeStart(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">this</span>.use(router.middleware());</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> router;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//生命周期对象初始化</span></span><br><span class="line">    <span class="keyword">this</span>.lifecycle = <span class="keyword">new</span> Lifecycle(&#123;</span><br><span class="line">        baseDir: options.baseDir,</span><br><span class="line">        app: <span class="keyword">this</span>,</span><br><span class="line">        logger: <span class="keyword">this</span>.console,</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="EggLoader类源码学习"><a href="#EggLoader类源码学习" class="headerlink" title="EggLoader类源码学习"></a>EggLoader类源码学习</h4><p>如果说eggCore是egg框架的精华所在，那么eggLoader可以说是eggCore的精华所在，下面我们主要从EggLoader的实现细节开始学习eggCore这个库：</p><p>EggLoader首先对app中的一些基本信息（pkg/eggPaths/serverEnv/appInfo/serverScope/baseDir等）进行整理，并且定义一些基础共用函数(getEggPaths/getTypeFiles/getLoadUnits/loadFile)，所有的这些基础准备都是为了后面介绍的几个load函数作准备，我们下面看一下其基础部分的实现：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//egg-core源码 -&gt; EggLoader中基本属性和基本函数的实现</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EggLoader</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(options) &#123;</span><br><span class="line">        <span class="keyword">this</span>.options = options;</span><br><span class="line">        <span class="keyword">this</span>.app = <span class="keyword">this</span>.options.app;</span><br><span class="line">        <span class="comment">//pkg是根目录的package.json输出对象</span></span><br><span class="line">        <span class="keyword">this</span>.pkg = utility.readJSONSync(path.join(<span class="keyword">this</span>.options.baseDir, <span class="string">'package.json'</span>));</span><br><span class="line">        <span class="comment">//eggPaths是所有框架目录的集合体，虽然我们上面提到一个应用只有一个框架，但是框架可以在框架的基础上实现多级继承，所以是多个eggPath</span></span><br><span class="line">        <span class="comment">//在实现框架类的时候，必须指定属性Symbol.for('egg#eggPath')，这样才能找到框架的目录结构</span></span><br><span class="line">        <span class="comment">//下面有关于getEggPaths函数的实现分析</span></span><br><span class="line">        <span class="keyword">this</span>.eggPaths = <span class="keyword">this</span>.getEggPaths();</span><br><span class="line">        <span class="keyword">this</span>.serverEnv = <span class="keyword">this</span>.getServerEnv();</span><br><span class="line">        <span class="comment">//获取app的一些基本配置信息(name,baseDir,env,scope,pkg等)</span></span><br><span class="line">        <span class="keyword">this</span>.appInfo = <span class="keyword">this</span>.getAppInfo();</span><br><span class="line">        <span class="keyword">this</span>.serverScope = options.serverScope !== <span class="literal">undefined</span></span><br><span class="line">            ? options.serverScope</span><br><span class="line">            : <span class="keyword">this</span>.getServerScope();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//递归获取继承链上所有eggPath</span></span><br><span class="line">    getEggPaths() &#123;</span><br><span class="line">        <span class="keyword">const</span> EggCore = <span class="built_in">require</span>(<span class="string">'../egg'</span>);</span><br><span class="line">        <span class="keyword">const</span> eggPaths = [];</span><br><span class="line">        <span class="keyword">let</span> proto = <span class="keyword">this</span>.app;</span><br><span class="line">        <span class="comment">//循环递归的获取原型链上的框架Symbol.for('egg#eggPath')属性</span></span><br><span class="line">        <span class="keyword">while</span> (proto) &#123;</span><br><span class="line">            proto = <span class="built_in">Object</span>.getPrototypeOf(proto);</span><br><span class="line">            <span class="comment">//直到proto属性等于EggCore本身，说明到了最上层的框架类，停止循环</span></span><br><span class="line">            <span class="keyword">if</span> (proto === <span class="built_in">Object</span>.prototype || proto === EggCore.prototype) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">const</span> eggPath = proto[<span class="built_in">Symbol</span>.for(<span class="string">'egg#eggPath'</span>)];</span><br><span class="line">            <span class="keyword">const</span> realpath = fs.realpathSync(eggPath);</span><br><span class="line">            <span class="keyword">if</span> (!eggPaths.includes(realpath)) &#123;</span><br><span class="line">                eggPaths.unshift(realpath);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> eggPaths;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//函数输入：config或者plugin；函数输出：当前环境下的所有配置文件</span></span><br><span class="line">    <span class="comment">//该函数会根据serverScope，serverEnv的配置信息，返回当前环境对应filename的所有配置文件</span></span><br><span class="line">    <span class="comment">//比如我们的serverEnv=prod，serverScope=online，那么返回的config配置文件是['config.default', 'config.prod', 'config.online_prod']</span></span><br><span class="line">    <span class="comment">//这几个文件加载顺序非常重要，因为最终获取到的config信息会进行深度的覆盖，后面的文件信息会覆盖前面的文件信息</span></span><br><span class="line">    getTypeFiles(filename) &#123;</span><br><span class="line">        <span class="keyword">const</span> files = [ <span class="string">`<span class="subst">$&#123;filename&#125;</span>.default`</span> ];</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.serverScope) files.push(<span class="string">`<span class="subst">$&#123;filename&#125;</span>.<span class="subst">$&#123;<span class="keyword">this</span>.serverScope&#125;</span>`</span>);</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.serverEnv === <span class="string">'default'</span>) <span class="keyword">return</span> files;</span><br><span class="line"></span><br><span class="line">        files.push(<span class="string">`<span class="subst">$&#123;filename&#125;</span>.<span class="subst">$&#123;<span class="keyword">this</span>.serverEnv&#125;</span>`</span>);</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.serverScope) files.push(<span class="string">`<span class="subst">$&#123;filename&#125;</span>.<span class="subst">$&#123;<span class="keyword">this</span>.serverScope&#125;</span>_<span class="subst">$&#123;<span class="keyword">this</span>.serverEnv&#125;</span>`</span>);</span><br><span class="line">        <span class="keyword">return</span> files;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//获取框架、应用、插件的loadUnits目录集合，上文有关于loadUnits的说明</span></span><br><span class="line">    <span class="comment">//这个函数在下文中介绍的loadSerivce,loadMiddleware,loadConfig,loadExtend中都会用到，因为plugin，framework，app中都会有关系这些信息的配置</span></span><br><span class="line">    getLoadUnits() &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.dirs) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.dirs;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">const</span> dirs = <span class="keyword">this</span>.dirs = [];</span><br><span class="line">        <span class="comment">//插件目录，关于orderPlugins会在后面的loadPlugin函数中讲到</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.orderPlugins) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">const</span> plugin <span class="keyword">of</span> <span class="keyword">this</span>.orderPlugins) &#123;</span><br><span class="line">                dirs.push(&#123;</span><br><span class="line">                    path: plugin.path,</span><br><span class="line">                    type: <span class="string">'plugin'</span>,</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//框架目录</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> eggPath <span class="keyword">of</span> <span class="keyword">this</span>.eggPaths) &#123;</span><br><span class="line">            dirs.push(&#123;</span><br><span class="line">                path: eggPath,</span><br><span class="line">                type: <span class="string">'framework'</span>,</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//应用目录</span></span><br><span class="line">        dirs.push(&#123;</span><br><span class="line">            path: <span class="keyword">this</span>.options.baseDir,</span><br><span class="line">            type: <span class="string">'app'</span>,</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> dirs;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这个函数用于读取某个LoadUnit下的文件具体内容，包括js文件，json文件及其它普通文件</span></span><br><span class="line">    loadFile(filepath, ...inject) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!filepath || !fs.existsSync(filepath)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (inject.length === <span class="number">0</span>) inject = [ <span class="keyword">this</span>.app ];</span><br><span class="line">        <span class="keyword">let</span> ret = <span class="keyword">this</span>.requireFile(filepath);</span><br><span class="line">        <span class="comment">//这里要注意，如果某个js文件导出的是一个函数，且不是一个Class，那么Egg认为这个函数的格式是：app =&gt; &#123;&#125;,输入是EggCore实例，输出是真正需要的信息</span></span><br><span class="line">        <span class="keyword">if</span> (is<span class="function">.<span class="keyword">function</span>(<span class="params">ret</span>) &amp;&amp; !<span class="title">is</span>.<span class="title">class</span>(<span class="params">ret</span>)) </span>&#123;</span><br><span class="line">            ret = ret(...inject);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="各种loader函数的实现源码分析"><a href="#各种loader函数的实现源码分析" class="headerlink" title="各种loader函数的实现源码分析"></a>各种loader函数的实现源码分析</h3><p>上文中只是介绍了EggLoader中的一些基本属性和函数，那么如何将LoadUnits中的不同类型的文件分别加载进来呢，egg-core中每一种类型（service/controller等）的文件加载都在一个独立的文件里实现。比如我们加载controller文件可以通过’./mixin/controller’目录下的loadController完成，加载service文件可以通过’./mixin/service’下的loadService函数完成，然后将这些方法挂载EggLoader的原型上，这样就可以直接在EggLoader的实例上使用</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//egg-core源码 -&gt; 混入不同目录文件的加载方法到EggLoader的原型上</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> loaders = [</span><br><span class="line">  <span class="built_in">require</span>(<span class="string">'./mixin/plugin'</span>),            <span class="comment">//loadPlugin方法</span></span><br><span class="line">  <span class="built_in">require</span>(<span class="string">'./mixin/config'</span>),            <span class="comment">//loadConfig方法</span></span><br><span class="line">  <span class="built_in">require</span>(<span class="string">'./mixin/extend'</span>),            <span class="comment">//loadExtend方法</span></span><br><span class="line">  <span class="built_in">require</span>(<span class="string">'./mixin/custom'</span>),            <span class="comment">//loadCustomApp和loadCustomAgent方法</span></span><br><span class="line">  <span class="built_in">require</span>(<span class="string">'./mixin/service'</span>),           <span class="comment">//loadService方法</span></span><br><span class="line">  <span class="built_in">require</span>(<span class="string">'./mixin/middleware'</span>),        <span class="comment">//loadMiddleware方法</span></span><br><span class="line">  <span class="built_in">require</span>(<span class="string">'./mixin/controller'</span>),        <span class="comment">//loadController方法</span></span><br><span class="line">  <span class="built_in">require</span>(<span class="string">'./mixin/router'</span>),            <span class="comment">//loadRouter方法</span></span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> loader <span class="keyword">of</span> loaders) &#123;</span><br><span class="line">  <span class="built_in">Object</span>.assign(EggLoader.prototype, loader);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们按照上述loaders中定义的元素顺序，对各个load函数的源码实现进行一一分析：</p><h4 id="loadPlugin函数"><a href="#loadPlugin函数" class="headerlink" title="loadPlugin函数"></a>loadPlugin函数</h4><p>插件是一个迷你的应用，没有包含router.js和controller文件夹，我们上文也提到，应用和框架里都可以包含插件，而且还可以通过环境变量和初始化参数传入，关于插件初始化的几个参数：</p><ul><li>enable： 是否开启插件</li><li>env： 选择插件在哪些环境运行</li><li>path： 插件的所在路径</li><li>package： 和path只能设置其中一个，根据package名称去node_modules里查询plugin，后面源码里有详细说明</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//egg-core源码 -&gt; loadPlugin函数部分源码</span></span><br><span class="line"></span><br><span class="line">loadPlugin() &#123;</span><br><span class="line">    <span class="comment">//加载应用目录下的plugins</span></span><br><span class="line">    <span class="comment">//readPluginConfigs这个函数会先调用我们上文提到的getTypeFiles获取到app目录下所有的plugin文件名，然后按照文件顺序进行加载并合并，并规范plugin的数据结构</span></span><br><span class="line">    <span class="keyword">const</span> appPlugins = <span class="keyword">this</span>.readPluginConfigs(path.join(<span class="keyword">this</span>.options.baseDir, <span class="string">'config/plugin.default'</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//加载框架目录下的plugins</span></span><br><span class="line">    <span class="keyword">const</span> eggPluginConfigPaths = <span class="keyword">this</span>.eggPaths.map(<span class="function"><span class="params">eggPath</span> =&gt;</span> path.join(eggPath, <span class="string">'config/plugin.default'</span>));</span><br><span class="line">    <span class="keyword">const</span> eggPlugins = <span class="keyword">this</span>.readPluginConfigs(eggPluginConfigPaths);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//可以通过环境变量EGG_PLUGINS对配置plugins，从环境变量加载plugins</span></span><br><span class="line">    <span class="keyword">let</span> customPlugins;</span><br><span class="line">    <span class="keyword">if</span> (process.env.EGG_PLUGINS) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        customPlugins = <span class="built_in">JSON</span>.parse(process.env.EGG_PLUGINS);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">        debug(<span class="string">'parse EGG_PLUGINS failed, %s'</span>, e);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//从启动参数options里加载plugins</span></span><br><span class="line">    <span class="comment">//启动参数的plugins和环境变量的plugins都是自定义的plugins，可以对默认的应用和框架plugin进行覆盖</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.options.plugins) &#123;</span><br><span class="line">      customPlugins = <span class="built_in">Object</span>.assign(&#123;&#125;, customPlugins, <span class="keyword">this</span>.options.plugins);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.allPlugins = &#123;&#125;;</span><br><span class="line">    <span class="keyword">this</span>.appPlugins = appPlugins;</span><br><span class="line">    <span class="keyword">this</span>.customPlugins = customPlugins;</span><br><span class="line">    <span class="keyword">this</span>.eggPlugins = eggPlugins;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//按照顺序对plugin进行合并及覆盖</span></span><br><span class="line">    <span class="comment">//_extendPlugins在合并的过程中，对相同name的plugin中的属性进行覆盖，有一个特殊处理的地方，如果某个属性的值是空数组，那么不会覆盖前者</span></span><br><span class="line">    <span class="keyword">this</span>._extendPlugins(<span class="keyword">this</span>.allPlugins, eggPlugins);</span><br><span class="line">    <span class="keyword">this</span>._extendPlugins(<span class="keyword">this</span>.allPlugins, appPlugins);</span><br><span class="line">    <span class="keyword">this</span>._extendPlugins(<span class="keyword">this</span>.allPlugins, customPlugins);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> enabledPluginNames = []; <span class="comment">// enabled plugins that configured explicitly</span></span><br><span class="line">    <span class="keyword">const</span> plugins = &#123;&#125;;</span><br><span class="line">    <span class="keyword">const</span> env = <span class="keyword">this</span>.serverEnv;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> name <span class="keyword">in</span> <span class="keyword">this</span>.allPlugins) &#123;</span><br><span class="line">      <span class="keyword">const</span> plugin = <span class="keyword">this</span>.allPlugins[name];</span><br><span class="line">      <span class="comment">//plugin的path可能是直接指定的，也有可能指定了一个package的name，然后从node_modules中查找</span></span><br><span class="line">      <span class="comment">//从node_modules中查找的顺序是：&#123;APP_PATH&#125;/node_modules -&gt; &#123;EGG_PATH&#125;/node_modules -&gt; $CWD/node_modules</span></span><br><span class="line">      plugin.path = <span class="keyword">this</span>.getPluginPath(plugin, <span class="keyword">this</span>.options.baseDir);</span><br><span class="line">      <span class="comment">//这个函数会读取每个plugin.path路径下的package.json,获取plugin的version，并会使用package.json中的dependencies，optionalDependencies, env变量作覆盖</span></span><br><span class="line">      <span class="keyword">this</span>.mergePluginConfig(plugin);</span><br><span class="line">      <span class="comment">// 有些plugin只有在某些环境（serverEnv）下才能使用，否则改成enable=false</span></span><br><span class="line">      <span class="keyword">if</span> (env &amp;&amp; plugin.env.length &amp;&amp; !plugin.env.includes(env)) &#123;</span><br><span class="line">        plugin.enable = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//获取enable=true的所有pluginnName</span></span><br><span class="line">      plugins[name] = plugin;</span><br><span class="line">      <span class="keyword">if</span> (plugin.enable) &#123;</span><br><span class="line">        enabledPluginNames.push(name);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这个函数会检查插件的依赖关系，插件的依赖关系在dependencies中定义，最后返回所有需要的插件</span></span><br><span class="line">    <span class="comment">//如果enable=true的插件依赖的插件不在已有的插件中，或者插件的依赖关系存在循环引用，则会抛出异常</span></span><br><span class="line">    <span class="comment">//如果enable=true的依赖插件为enable=false，那么该被依赖的插件会被改为enable=true</span></span><br><span class="line">    <span class="keyword">this</span>.orderPlugins = <span class="keyword">this</span>.getOrderPlugins(plugins, enabledPluginNames, appPlugins);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//最后我们以对象的方式将enable=true的插件挂载在this对象上</span></span><br><span class="line">    <span class="keyword">const</span> enablePlugins = &#123;&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> plugin <span class="keyword">of</span> <span class="keyword">this</span>.orderPlugins) &#123;</span><br><span class="line">      enablePlugins[plugin.name] = plugin;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.plugins = enablePlugins;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="loadConfig函数"><a href="#loadConfig函数" class="headerlink" title="loadConfig函数"></a>loadConfig函数</h4><p>配置信息的管理对于一个应用来说非常重要，我们需要对不同的部署环境的配置进行管理，Egg就是针对环境加载不同的配置文件，然后将配置挂载在app上，</p><p>加载config的逻辑相对简单，就是按照顺序加载所有loadUnit目录下的config文件内容，进行合并，最后将config信息挂载在this对象上，整个加载函数请看下面源码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//egg-core源码 -&gt; loadConfig函数分析</span></span><br><span class="line"></span><br><span class="line">loadConfig() &#123;</span><br><span class="line">    <span class="keyword">this</span>.configMeta = &#123;&#125;;</span><br><span class="line">    <span class="keyword">const</span> target = &#123;&#125;;</span><br><span class="line">    <span class="comment">//这里之所以先加载app相关的config，是因为在加载plugin和framework的config时会使用到app的config</span></span><br><span class="line">    <span class="keyword">const</span> appConfig = <span class="keyword">this</span>._preloadAppConfig();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//config的加载顺序为：plugin config.default -&gt; framework config.default -&gt; app config.default -&gt; plugin config.&#123;env&#125; -&gt; framework config.&#123;env&#125; -&gt; app config.&#123;env&#125;</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> filename <span class="keyword">of</span> <span class="keyword">this</span>.getTypeFiles(<span class="string">'config'</span>)) &#123;</span><br><span class="line">    <span class="comment">// getLoadUnits函数前面有介绍，获取loadUnit目录集合</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">const</span> unit <span class="keyword">of</span> <span class="keyword">this</span>.getLoadUnits()) &#123;</span><br><span class="line">        <span class="keyword">const</span> isApp = unit.type === <span class="string">'app'</span>;</span><br><span class="line">        <span class="comment">//如果是加载插件和框架下面的config，那么会将appConfig当作参数传入</span></span><br><span class="line">        <span class="comment">//这里appConfig已经加载了一遍了，又重复加载了，不知道处于什么原因，下面会有_loadConfig函数源码分析</span></span><br><span class="line">        <span class="keyword">const</span> config = <span class="keyword">this</span>._loadConfig(unit.path, filename, isApp ? <span class="literal">undefined</span> : appConfig, unit.type);</span><br><span class="line">        <span class="keyword">if</span> (!config) &#123;</span><br><span class="line">          <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//config进行覆盖</span></span><br><span class="line">        extend(<span class="literal">true</span>, target, config);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.config = target;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">_loadConfig(dirpath, filename, extraInject, type) &#123;</span><br><span class="line">    <span class="keyword">const</span> isPlugin = type === <span class="string">'plugin'</span>;</span><br><span class="line">    <span class="keyword">const</span> isApp = type === <span class="string">'app'</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> filepath = <span class="keyword">this</span>.resolveModule(path.join(dirpath, <span class="string">'config'</span>, filename));</span><br><span class="line">    <span class="comment">//如果没有config.default文件，则用config.js文件替代，隐藏逻辑</span></span><br><span class="line">    <span class="keyword">if</span> (filename === <span class="string">'config.default'</span> &amp;&amp; !filepath) &#123;</span><br><span class="line">      filepath = <span class="keyword">this</span>.resolveModule(path.join(dirpath, <span class="string">'config/config'</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//loadFile函数我们在EggLoader中讲到过，如果config导出的是一个函数会先执行这个函数，将函数的返回结果导出，函数的参数也就是[this.appInfo extraInject]</span></span><br><span class="line">    <span class="keyword">const</span> config = <span class="keyword">this</span>.loadFile(filepath, <span class="keyword">this</span>.appInfo, extraInject);</span><br><span class="line">    <span class="keyword">if</span> (!config) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//框架使用哪些中间件也是在config里作配置的，后面关于loadMiddleware函数实现中有说明</span></span><br><span class="line">    <span class="comment">//coreMiddleware只能在框架里使用</span></span><br><span class="line">    <span class="keyword">if</span> (isPlugin || isApp) &#123;</span><br><span class="line">      assert(!config.coreMiddleware, <span class="string">'Can not define coreMiddleware in app or plugin'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//middleware只能在应用里定义</span></span><br><span class="line">    <span class="keyword">if</span> (!isApp) &#123;</span><br><span class="line">      assert(!config.middleware, <span class="string">'Can not define middleware in '</span> + filepath);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//这里是为了设置configMeta，表示每个配置项是从哪里来的</span></span><br><span class="line">    <span class="keyword">this</span>[SET_CONFIG_META](config, filepath);</span><br><span class="line">    <span class="keyword">return</span> config;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h4 id="loadExtend相关函数"><a href="#loadExtend相关函数" class="headerlink" title="loadExtend相关函数"></a>loadExtend相关函数</h4><p>这里的loadExtend是一个笼统的概念，其实是针对koa中的app.response，app.respond，app.context以及app本身进行扩展，同样是根据所有loadUnits下的配置顺序进行加载</p><p>下面看一下loadExtend这个函数的实现，一个通用的加载函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//egg-core -&gt; loadExtend函数实现</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//name输入是"response"/"respond"/"context"/"app"中的一个，proto是被扩展的对象</span></span><br><span class="line">loadExtend(name, proto) &#123;</span><br><span class="line">    <span class="comment">//获取指定name所有loadUnits下的配置文件路径</span></span><br><span class="line">    <span class="keyword">const</span> filepaths = <span class="keyword">this</span>.getExtendFilePaths(name);</span><br><span class="line">    <span class="keyword">const</span> isAddUnittest = <span class="string">'EGG_MOCK_SERVER_ENV'</span> <span class="keyword">in</span> process.env &amp;&amp; <span class="keyword">this</span>.serverEnv !== <span class="string">'unittest'</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, l = filepaths.length; i &lt; l; i++) &#123;</span><br><span class="line">      <span class="keyword">const</span> filepath = filepaths[i];</span><br><span class="line">      filepaths.push(filepath + <span class="string">`.<span class="subst">$&#123;<span class="keyword">this</span>.serverEnv&#125;</span>`</span>);</span><br><span class="line">      <span class="keyword">if</span> (isAddUnittest) filepaths.push(filepath + <span class="string">'.unittest'</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这里并没有对属性的直接覆盖，而是对原先的PropertyDescriptor的get和set进行合并</span></span><br><span class="line">    <span class="keyword">const</span> mergeRecord = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> filepath <span class="keyword">of</span> filepaths) &#123;</span><br><span class="line">      filepath = <span class="keyword">this</span>.resolveModule(filepath);</span><br><span class="line">      <span class="keyword">const</span> ext = <span class="keyword">this</span>.requireFile(filepath);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">const</span> properties = <span class="built_in">Object</span>.getOwnPropertyNames(ext)</span><br><span class="line">        .concat(<span class="built_in">Object</span>.getOwnPropertySymbols(ext));</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">const</span> property <span class="keyword">of</span> properties) &#123;</span><br><span class="line">        <span class="keyword">let</span> descriptor = <span class="built_in">Object</span>.getOwnPropertyDescriptor(ext, property);</span><br><span class="line">        <span class="keyword">let</span> originalDescriptor = <span class="built_in">Object</span>.getOwnPropertyDescriptor(proto, property);</span><br><span class="line">        <span class="keyword">if</span> (!originalDescriptor) &#123;</span><br><span class="line">          <span class="keyword">const</span> originalProto = originalPrototypes[name];</span><br><span class="line">          <span class="keyword">if</span> (originalProto) &#123;</span><br><span class="line">            originalDescriptor = <span class="built_in">Object</span>.getOwnPropertyDescriptor(originalProto, property);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果原始对象上已经存在相关属性的Descriptor，那么对其set和get方法进行合并</span></span><br><span class="line">        <span class="keyword">if</span> (originalDescriptor) &#123;</span><br><span class="line">          <span class="comment">// don't override descriptor</span></span><br><span class="line">          descriptor = <span class="built_in">Object</span>.assign(&#123;&#125;, descriptor);</span><br><span class="line">          <span class="keyword">if</span> (!descriptor.set &amp;&amp; originalDescriptor.set) &#123;</span><br><span class="line">            descriptor.set = originalDescriptor.set;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">if</span> (!descriptor.get &amp;&amp; originalDescriptor.get) &#123;</span><br><span class="line">            descriptor.get = originalDescriptor.get;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//否则直接覆盖</span></span><br><span class="line">        <span class="built_in">Object</span>.defineProperty(proto, property, descriptor);</span><br><span class="line">        mergeRecord.set(property, filepath);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h4 id="loadService函数"><a href="#loadService函数" class="headerlink" title="loadService函数"></a>loadService函数</h4><h5 id="如何在egg框架中使用service"><a href="#如何在egg框架中使用service" class="headerlink" title="如何在egg框架中使用service"></a>如何在egg框架中使用service</h5><p>loadService函数的实现是所有load函数中最复杂的一个，我们不着急看源码，先看一下service在egg框架中如何使用</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//egg-core源码 -&gt; 如何在egg框架中使用service</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//方式1：app/service/user1.js</span></span><br><span class="line"><span class="comment">//这个是最标准的做法，导出一个class，这个class继承了require('egg').Service，其实也就是我们上文提到的eggCore导出的BaseContextClass</span></span><br><span class="line"><span class="comment">//最终我们在业务逻辑中获取到的是这个class的一个实例，在load的时候是将app.context当作新建实例的参数</span></span><br><span class="line"><span class="comment">//在controller中调用方式：this.ctx.service.user1.find(1)</span></span><br><span class="line"><span class="keyword">const</span> Service = <span class="built_in">require</span>(<span class="string">'egg'</span>).Service;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserService</span> <span class="keyword">extends</span> <span class="title">Service</span> </span>&#123;</span><br><span class="line">  <span class="keyword">async</span> find(uid) &#123;</span><br><span class="line">    <span class="comment">//此时我们可以通过this.ctx,this.app,this.config,this.service获取到有用的信息，尤其是this.ctx非常重要，每个请求对应一个ctx，我们可以查询到当前请求的所有信息</span></span><br><span class="line">    <span class="keyword">const</span> user = <span class="keyword">await</span> <span class="keyword">this</span>.ctx.db.query(<span class="string">'select * from user where uid = ?'</span>, uid);</span><br><span class="line">    <span class="keyword">return</span> user;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">module</span>.exports = UserService;</span><br><span class="line"></span><br><span class="line"><span class="comment">//方式2：app/service/user2.js</span></span><br><span class="line"><span class="comment">//这个做法是我模拟了一个BaseContextClass，当然也就可以实现方法1的目的，但是不推荐</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(ctx) &#123;</span><br><span class="line">    <span class="keyword">this</span>.ctx = ctx;</span><br><span class="line">    <span class="keyword">this</span>.app = ctx.app;</span><br><span class="line">    <span class="keyword">this</span>.config = ctx.app.config;</span><br><span class="line">    <span class="keyword">this</span>.service = ctx.service;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">async</span> find(uid) &#123;</span><br><span class="line">    <span class="keyword">const</span> user = <span class="keyword">await</span> <span class="keyword">this</span>.ctx.db.query(<span class="string">'select * from user where uid = ?'</span>, uid);</span><br><span class="line">    <span class="keyword">return</span> user;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">module</span>.exports = UserService;</span><br><span class="line"></span><br><span class="line"><span class="comment">//方式3：app/service/user3.js</span></span><br><span class="line"><span class="comment">//service中也可以export函数，在load的时候会主动调用这个函数，把appInfo参数传入，最终获取到的是函数返回结果</span></span><br><span class="line"><span class="comment">//在controller中调用方式：this.ctx.service.user3.getAppName(1)，这个时候在service中获取不到当前请求的上下文ctx</span></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function">(<span class="params">appInfo</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="keyword">async</span> getAppName(uid)&#123;</span><br><span class="line">            <span class="keyword">return</span> appInfo.name;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//方式4：app/service/user4.js</span></span><br><span class="line"><span class="comment">//service也可以直接export普通的原生对象，load的时候会将该普通对象返回，同样获取不到当前请求的上下文ctx</span></span><br><span class="line"><span class="comment">//在controller中调用方式：this.ctx.service.user4.getAppName(1)</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    <span class="keyword">async</span> getAppName(uid)&#123;</span><br><span class="line">        <span class="keyword">return</span> appInfo.name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>我们上面列举了service下的js文件的四种写法，都是从每次请求的上下文this.ctx获取到service对象，然后就可以使用到每个service文件导出的对象了，这里主要有两个地方需要注意：</p><ol><li><p>为什么我们可以从每个请求的this.ctx上获取到service对象呢：</p><p>看过koa源码的同学知道，this.ctx其实是从app.context继承而来，所以我们只要把service绑定到app.context上，那么当前请求的上下文ctx自然可以拿到service对象，eggLoader也是这样做的</p></li><li><p>针对上述四种使用场景，具体导出实例是怎么处理的呢？</p><ul><li>如果导出的是一个类，EggLoader会主动以ctx对象去初始化这个实例并导出，所以我们就可以直接在该类中使用this.ctx获取当前请求的上下文了</li><li>如果导出的是一个函数，那么EggLoader会以app作为参数运行这个函数并将结果导出</li><li>如果是一个普通的对象，直接导出</li></ul></li></ol><h5 id="FileLoader类的实现分析"><a href="#FileLoader类的实现分析" class="headerlink" title="FileLoader类的实现分析"></a>FileLoader类的实现分析</h5><p>在实现loadService函数时，有一个基础类就是FileLoader，它同时也是loadMiddleware，loadController实现的基础，这个类提供一个load函数根据目录结构和文件内容进行解析，返回一个target对象，我们可以根据文件名以及子文件名以及函数名称获取到service里导出的内容，target结构类似这样：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"file1"</span>: &#123;</span><br><span class="line">        <span class="attr">"file11"</span>: &#123;</span><br><span class="line">            <span class="attr">"function1"</span>: a =&gt; a</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"file2"</span>: &#123;</span><br><span class="line">        <span class="attr">"function2"</span>: a =&gt; a</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面我们先看一下fileLoader这个类的实现</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//egg-core源码 -&gt; FileLoader实现</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FileLoader</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(options) &#123;</span><br><span class="line">    <span class="comment">/*options里几个重要参数的含义:</span></span><br><span class="line"><span class="comment">    1.directory: 需要加载文件的所有目录</span></span><br><span class="line"><span class="comment">    2.target: 最终加载成功后的目标对象</span></span><br><span class="line"><span class="comment">    3.initializer：一个初始化函数，对文件导出内容进行初始化，这个在loadController实现时会用到</span></span><br><span class="line"><span class="comment">    4.inject：如果某个文件的导出对象是一个函数，那么将该值传入函数并执行导出，一般都是this.app</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">this</span>.options = <span class="built_in">Object</span>.assign(&#123;&#125;, defaults, options);</span><br><span class="line">  &#125;</span><br><span class="line">  load() &#123;</span><br><span class="line">    <span class="comment">//解析directory下的文件，下面有parse函数的部分实现</span></span><br><span class="line">    <span class="keyword">const</span> items = <span class="keyword">this</span>.parse();</span><br><span class="line">    <span class="keyword">const</span> target = <span class="keyword">this</span>.options.target;</span><br><span class="line">    <span class="comment">//item1 = &#123; properties: [ 'a', 'b', 'c'], exports1 &#125;,item2 = &#123; properties: [ 'a', 'b', 'd'], exports2 &#125;</span></span><br><span class="line">    <span class="comment">// =&gt; target = &#123;a: &#123;b: &#123;c: exports1, d: exports2&#125;&#125;&#125;</span></span><br><span class="line">    <span class="comment">//根据文件路径名称递归生成一个大的对象target，我们通过target.file1.file2就可以获取到对应的导出内容</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> item <span class="keyword">of</span> items) &#123;</span><br><span class="line">      item.properties.reduce(<span class="function">(<span class="params">target, property, index</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> obj;</span><br><span class="line">        <span class="keyword">const</span> properties = item.properties.slice(<span class="number">0</span>, index + <span class="number">1</span>).join(<span class="string">'.'</span>);</span><br><span class="line">        <span class="keyword">if</span> (index === item.properties.length - <span class="number">1</span>) &#123;</span><br><span class="line">          obj = item.exports;</span><br><span class="line">          <span class="keyword">if</span> (obj &amp;&amp; !is.primitive(obj)) &#123;</span><br><span class="line">            <span class="comment">//这步骤很重要，确定这个target是不是一个exports，有可能只是一个路径而已</span></span><br><span class="line">            obj[FULLPATH] = item.fullpath;</span><br><span class="line">            obj[EXPORTS] = <span class="literal">true</span>;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          obj = target[property] || &#123;&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        target[property] = obj;</span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">      &#125;, target);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> target;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//最终生成[&#123; properties: [ 'a', 'b', 'c'], exports，fullpath&#125;]形式，properties文件路径名称的数组，exports是导出对象，fullpath是文件的绝对路径</span></span><br><span class="line">  parse() &#123;</span><br><span class="line">    <span class="comment">//文件目录转换为数组</span></span><br><span class="line">    <span class="keyword">let</span> directories = <span class="keyword">this</span>.options.directory;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">Array</span>.isArray(directories)) &#123;</span><br><span class="line">      directories = [ directories ];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//遍历所有文件路径</span></span><br><span class="line">    <span class="keyword">const</span> items = [];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> directory <span class="keyword">of</span> directories) &#123;</span><br><span class="line">      <span class="comment">//每个文件目录下面可能还会有子文件夹，所以globby.sync函数是获取所有文件包括子文件下的文件的路径</span></span><br><span class="line">      <span class="keyword">const</span> filepaths = globby.sync(files, &#123; <span class="attr">cwd</span>: directory &#125;);</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">const</span> filepath <span class="keyword">of</span> filepaths) &#123;</span><br><span class="line">        <span class="keyword">const</span> fullpath = path.join(directory, filepath);</span><br><span class="line">        <span class="keyword">if</span> (!fs.statSync(fullpath).isFile()) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="comment">//获取文件路径上的以"/"分割的所有文件名，foo/bar.js =&gt; [ 'foo', 'bar' ]，这个函数会对propertie同一格式，默认为驼峰</span></span><br><span class="line">        <span class="keyword">const</span> properties = getProperties(filepath, <span class="keyword">this</span>.options);</span><br><span class="line">        <span class="comment">//app/service/foo/bar.js =&gt; service.foo.bar</span></span><br><span class="line">        <span class="keyword">const</span> pathName = directory.split(<span class="regexp">/[/\\]/</span>).slice(<span class="number">-1</span>) + <span class="string">'.'</span> + properties.join(<span class="string">'.'</span>);</span><br><span class="line">        <span class="comment">//getExports函数获取文件内容，并将结果做一些处理，看下面实现</span></span><br><span class="line">        <span class="keyword">const</span> exports = getExports(fullpath, <span class="keyword">this</span>.options, pathName);</span><br><span class="line">        <span class="comment">//如果导出的是class，会设置一些属性，这个属性下文中对于class的特殊处理地方会用到</span></span><br><span class="line">        <span class="keyword">if</span> (is.class(exports)) &#123;</span><br><span class="line">          exports.prototype.pathName = pathName;</span><br><span class="line">          exports.prototype.fullPath = fullpath;</span><br><span class="line">        &#125;</span><br><span class="line">        items.push(&#123; fullpath, properties, exports &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> items;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//根据指定路径获取导出对象并作预处理</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getExports</span>(<span class="params">fullpath, &#123; initializer, call, inject &#125;, pathName</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> exports = utils.loadFile(fullpath);</span><br><span class="line">  <span class="comment">//用initializer函数对exports结果做预处理</span></span><br><span class="line">  <span class="keyword">if</span> (initializer) &#123;</span><br><span class="line">    exports = initializer(exports, &#123; <span class="attr">path</span>: fullpath, pathName &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//如果exports是class，generatorFunction，asyncFunction则直接返回    </span></span><br><span class="line">  <span class="keyword">if</span> (is.class(exports) || is.generatorFunction(exports) || is.asyncFunction(exports)) &#123;</span><br><span class="line">    <span class="keyword">return</span> exports;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//如果导出的是一个普通函数，并且设置了call=true，默认是true，会将inject传入并调用该函数，上文中提到过好几次，就是在这里实现的</span></span><br><span class="line">  <span class="keyword">if</span> (call &amp;&amp; is<span class="function">.<span class="keyword">function</span>(<span class="params">exports</span>)) </span>&#123;</span><br><span class="line">    exports = exports(inject);</span><br><span class="line">    <span class="keyword">if</span> (exports != <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> exports;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//其它情况直接返回</span></span><br><span class="line">  <span class="keyword">return</span> exports;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="ContextLoader类的实现分析"><a href="#ContextLoader类的实现分析" class="headerlink" title="ContextLoader类的实现分析"></a>ContextLoader类的实现分析</h5><p>上文中说道loadService函数其实最终把service对象挂载在了app.context上，所以为此提供了ContextLoader这个类，继承了FileLoader类，用于将FileLoader解析出来的target挂载在app.context上，下面是其实现：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//egg-core -&gt; ContextLoader类的源码实现</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ContextLoader</span> <span class="keyword">extends</span> <span class="title">FileLoader</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(options) &#123;</span><br><span class="line">    <span class="keyword">const</span> target = options.target = &#123;&#125;;</span><br><span class="line">    <span class="keyword">super</span>(options);</span><br><span class="line">    <span class="comment">//FileLoader已经讲过inject就是app</span></span><br><span class="line">    <span class="keyword">const</span> app = <span class="keyword">this</span>.options.inject;</span><br><span class="line">    <span class="comment">//property就是要挂载的属性，比如"service"</span></span><br><span class="line">    <span class="keyword">const</span> property = options.property;</span><br><span class="line">    <span class="comment">//将service属性挂载在app.context上</span></span><br><span class="line">    <span class="built_in">Object</span>.defineProperty(app.context, property, &#123;</span><br><span class="line">      <span class="keyword">get</span>() &#123;</span><br><span class="line">        <span class="comment">//做缓存，由于不同的请求ctx不一样，这里是针对同一个请求的内容进行缓存</span></span><br><span class="line">        <span class="keyword">if</span> (!<span class="keyword">this</span>[CLASSLOADER]) &#123;</span><br><span class="line">          <span class="keyword">this</span>[CLASSLOADER] = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">const</span> classLoader = <span class="keyword">this</span>[CLASSLOADER];</span><br><span class="line">        <span class="comment">//获取导出实例，这里就是上文用例中获取this.ctx.service.file1.fun1的实现，这里的实例就是this.ctx.service,实现逻辑请看下面的getInstance的实现</span></span><br><span class="line">        <span class="keyword">let</span> instance = classLoader.get(property);</span><br><span class="line">        <span class="keyword">if</span> (!instance) &#123;</span><br><span class="line">          <span class="comment">//这里传入的this就是为了初始化require('egg').Service实例时当作参数传入</span></span><br><span class="line">          <span class="comment">//this会根据调用者的不同而改变，比如是app.context的实例调用那么就是app.context，如果是app.context子类的实例调用，那么就是其子类的实例</span></span><br><span class="line">          <span class="comment">//就是因为这个this，我们service里继承require('egg').Service，才可以通过this.ctx获取到当前请求的上下文</span></span><br><span class="line">          instance = getInstance(target, <span class="keyword">this</span>);</span><br><span class="line">          classLoader.set(property, instance);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//values是FileLoader/load函数生成target对象</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getInstance</span>(<span class="params">values, ctx</span>) </span>&#123;</span><br><span class="line">  <span class="comment">//上文FileLoader里实现中我们讲过，target对象是一个由路径和exports组装成的一个大对象，这里Class是为了确定其是不是一个exports，有可能是一个路径名</span></span><br><span class="line">  <span class="keyword">const</span> Class = values[EXPORTS] ? values : <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">let</span> instance;</span><br><span class="line">  <span class="keyword">if</span> (Class) &#123;</span><br><span class="line">    <span class="keyword">if</span> (is.class(Class)) &#123;</span><br><span class="line">        <span class="comment">//这一步很重要，如果是类，就用ctx进行初始化获取实例</span></span><br><span class="line">      instance = <span class="keyword">new</span> Class(ctx);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">//普通对象直接导出，这里要注意的是如果是exports函数，在FileLoader实现中已经将其执行并转换为了对象</span></span><br><span class="line">      <span class="comment">//function和class分别在子类和父类的处理的原因是，function的处理逻辑loadMiddleware,loadService,loadController公用，而class的处理逻辑loadService使用</span></span><br><span class="line">      instance = Class;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (is.primitive(values)) &#123;</span><br><span class="line">    <span class="comment">//原生类型直接导出</span></span><br><span class="line">    instance = values;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//如果目前的target部分是一个路径，那么会新建一个ClassLoader实例，这个ClassLoader中又会递归的调用getInstance</span></span><br><span class="line">    <span class="comment">//这里之所以新建一个类，一是为了做缓存，二是为了在每个节点获取到的都是一个类的实例</span></span><br><span class="line">    instance = <span class="keyword">new</span> ClassLoader(&#123; ctx, <span class="attr">properties</span>: values &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="loadService的实现"><a href="#loadService的实现" class="headerlink" title="loadService的实现"></a>loadService的实现</h5><p>有了ContextLoader类，那实现loadService函数就非常容易了，如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//egg-core -&gt; loadService函数实现源码</span></span><br><span class="line"><span class="comment">//loadService函数调用loadToContext函数</span></span><br><span class="line">loadService(opt) &#123;</span><br><span class="line">    opt = <span class="built_in">Object</span>.assign(&#123;</span><br><span class="line">      call: <span class="literal">true</span>,</span><br><span class="line">      caseStyle: <span class="string">'lower'</span>,</span><br><span class="line">      fieldClass: <span class="string">'serviceClasses'</span>,</span><br><span class="line">      directory: <span class="keyword">this</span>.getLoadUnits().map(<span class="function"><span class="params">unit</span> =&gt;</span> path.join(unit.path, <span class="string">'app/service'</span>)), <span class="comment">//所有加载单元目录下的service</span></span><br><span class="line">    &#125;, opt);</span><br><span class="line">    <span class="keyword">const</span> servicePaths = opt.directory;</span><br><span class="line">    <span class="keyword">this</span>.loadToContext(servicePaths, <span class="string">'service'</span>, opt);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//loadToContext函数直接新建ContextLoader实例，调用load函数实现加载</span></span><br><span class="line">loadToContext(directory, property, opt) &#123;</span><br><span class="line">    opt = <span class="built_in">Object</span>.assign(&#123;&#125;, &#123;</span><br><span class="line">      directory,</span><br><span class="line">      property,</span><br><span class="line">      inject: <span class="keyword">this</span>.app,</span><br><span class="line">    &#125;, opt);</span><br><span class="line">    <span class="keyword">new</span> ContextLoader(opt).load();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="loadMiddleware函数"><a href="#loadMiddleware函数" class="headerlink" title="loadMiddleware函数"></a>loadMiddleware函数</h4><p>中间件是koa框架中很重要的一个环节，通过app.use引入中间件，使用洋葱圈模型，所以中间件加载的顺序很重要。</p><ul><li>如果在上文中的config中配置的中间件，系统会自动用app.use函数使用该中间件</li><li>所有的中间件我们都可以在app.middleware中通过中间件name获取到，便于在业务中动态使用</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//egg-core -&gt; loadMiddleware函数实现源码</span></span><br><span class="line"></span><br><span class="line">loadMiddleware(opt) &#123;</span><br><span class="line">    <span class="keyword">const</span> app = <span class="keyword">this</span>.app;</span><br><span class="line">    <span class="comment">// load middleware to app.middleware</span></span><br><span class="line">    opt = <span class="built_in">Object</span>.assign(&#123;</span><br><span class="line">      call: <span class="literal">false</span>,   <span class="comment">//call=false表示如果中间件导出是函数，不会主动调用函数做转换</span></span><br><span class="line">      override: <span class="literal">true</span>,</span><br><span class="line">      caseStyle: <span class="string">'lower'</span>,</span><br><span class="line">      directory: <span class="keyword">this</span>.getLoadUnits().map(<span class="function"><span class="params">unit</span> =&gt;</span> join(unit.path, <span class="string">'app/middleware'</span>)) <span class="comment">//所有加载单元目录下的middleware</span></span><br><span class="line">    &#125;, opt);</span><br><span class="line">    <span class="keyword">const</span> middlewarePaths = opt.directory;</span><br><span class="line">    <span class="comment">//将所有中间件middlewares挂载在app上，这个函数在loadController实现中也用到了，看下文的实现</span></span><br><span class="line">    <span class="keyword">this</span>.loadToApp(middlewarePaths, <span class="string">'middlewares'</span>, opt);</span><br><span class="line">    <span class="comment">//将app.middlewares中的每个中间件重新绑定在app.middleware上，每个中间件的属性不可配置，不可枚举</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> name <span class="keyword">in</span> app.middlewares) &#123;</span><br><span class="line">      <span class="built_in">Object</span>.defineProperty(app.middleware, name, &#123;</span><br><span class="line">        <span class="keyword">get</span>() &#123;</span><br><span class="line">          <span class="keyword">return</span> app.middlewares[name];</span><br><span class="line">        &#125;,</span><br><span class="line">        enumerable: <span class="literal">false</span>,</span><br><span class="line">        configurable: <span class="literal">false</span>,</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//只有在config中配置了appMiddleware和coreMiddleware才会直接在app.use中使用，其它中间件只是挂载在app上，开发人员可以动态使用</span></span><br><span class="line">    <span class="keyword">const</span> middlewareNames = <span class="keyword">this</span>.config.coreMiddleware.concat(<span class="keyword">this</span>.config.appMiddleware);</span><br><span class="line">    <span class="keyword">const</span> middlewaresMap = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> name <span class="keyword">of</span> middlewareNames) &#123;</span><br><span class="line">      <span class="comment">//如果config中定义middleware在app.middlewares中找不到或者重复定义，都会报错</span></span><br><span class="line">      <span class="keyword">if</span> (!app.middlewares[name]) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">`Middleware <span class="subst">$&#123;name&#125;</span> not found`</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (middlewaresMap.has(name)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">`Middleware <span class="subst">$&#123;name&#125;</span> redefined`</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      middlewaresMap.set(name, <span class="literal">true</span>);</span><br><span class="line">      <span class="keyword">const</span> options = <span class="keyword">this</span>.config[name] || &#123;&#125;;</span><br><span class="line">      <span class="keyword">let</span> mw = app.middlewares[name];</span><br><span class="line">      <span class="comment">//中间件的文件定义必须exports一个普通function，并且接受两个参数：</span></span><br><span class="line">      <span class="comment">//options: 中间件的配置项，框架会将 app.config[$&#123;middlewareName&#125;] 传递进来, app: 当前应用 Application 的实例</span></span><br><span class="line">      <span class="comment">//执行exports的函数，生成最终要的中间件</span></span><br><span class="line">      mw = mw(options, app);</span><br><span class="line">      mw._name = name;</span><br><span class="line">      <span class="comment">//包装中间件，最终转换成async function(ctx, next)形式</span></span><br><span class="line">      mw = wrapMiddleware(mw, options);</span><br><span class="line">      <span class="keyword">if</span> (mw) &#123;</span><br><span class="line">        app.use(mw);</span><br><span class="line">        <span class="keyword">this</span>.options.logger.info(<span class="string">'[egg:loader] Use middleware: %s'</span>, name);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.options.logger.info(<span class="string">'[egg:loader] Disable middleware: %s'</span>, name);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过FileLoader实例加载指定属性的所有文件并导出，然后将该属性挂载在app上</span></span><br><span class="line">loadToApp(directory, property, opt) &#123;</span><br><span class="line">    <span class="keyword">const</span> target = <span class="keyword">this</span>.app[property] = &#123;&#125;;</span><br><span class="line">    opt = <span class="built_in">Object</span>.assign(&#123;&#125;, &#123;</span><br><span class="line">      directory,</span><br><span class="line">      target,</span><br><span class="line">      inject: <span class="keyword">this</span>.app,</span><br><span class="line">    &#125;, opt);</span><br><span class="line">    <span class="keyword">new</span> FileLoader(opt).load();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="loadController函数"><a href="#loadController函数" class="headerlink" title="loadController函数"></a>loadController函数</h4><p>controller中生成的函数最终还是在router.js中当作一个中间件使用，所以我们需要将controller中内容转换为中间件形式async function(ctx, next)，其中initializer这个函数就是用来针对不同的情况将controller中的内容转换为中间件的，下面是loadController的实现逻辑：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//egg-core源码 -&gt; loadController函数实现源码</span></span><br><span class="line"></span><br><span class="line">loadController(opt) &#123;</span><br><span class="line">    opt = <span class="built_in">Object</span>.assign(&#123;</span><br><span class="line">      caseStyle: <span class="string">'lower'</span>,</span><br><span class="line">      directory: path.join(<span class="keyword">this</span>.options.baseDir, <span class="string">'app/controller'</span>),</span><br><span class="line">      <span class="comment">//这个配置，上文有提到，是为了对导出对象做预处理的函数</span></span><br><span class="line">      initializer: <span class="function">(<span class="params">obj, opt</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">//如果是普通函数，依然直接调用它生成新的对象</span></span><br><span class="line">        <span class="keyword">if</span> (is<span class="function">.<span class="keyword">function</span>(<span class="params">obj</span>) &amp;&amp; !<span class="title">is</span>.<span class="title">generatorFunction</span>(<span class="params">obj</span>) &amp;&amp; !<span class="title">is</span>.<span class="title">class</span>(<span class="params">obj</span>) &amp;&amp; !<span class="title">is</span>.<span class="title">asyncFunction</span>(<span class="params">obj</span>)) </span>&#123;</span><br><span class="line">          obj = obj(<span class="keyword">this</span>.app);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (is.class(obj)) &#123;</span><br><span class="line">          obj.prototype.pathName = opt.pathName;</span><br><span class="line">          obj.prototype.fullPath = opt.path;</span><br><span class="line">          <span class="comment">//如果是一个class，class中的函数转换成async function(ctx, next)中间件形式，并用ctx去初始化该class，所以在controller里我们也可以使用this.ctx.xxx形式</span></span><br><span class="line">          <span class="keyword">return</span> wrapClass(obj);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (is.object(obj)) &#123;</span><br><span class="line">          <span class="comment">//如果是一个Object，会递归的将该Object中每个属性对应的函数转换成async function(ctx, next)中间件形式形式</span></span><br><span class="line">          <span class="keyword">return</span> wrapObject(obj, opt.path);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// support generatorFunction for forward compatbility</span></span><br><span class="line">        <span class="keyword">if</span> (is.generatorFunction(obj) || is.asyncFunction(obj)) &#123;</span><br><span class="line">          <span class="keyword">return</span> wrapObject(&#123; <span class="string">'module.exports'</span>: obj &#125;, opt.path)[<span class="string">'module.exports'</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;, opt);</span><br><span class="line">    <span class="comment">//loadController函数同样是通过loadToApp函数将其导出对象挂载在app下，controller里的内容在loadRouter时会将其载入</span></span><br><span class="line">    <span class="keyword">const</span> controllerBase = opt.directory;</span><br><span class="line">    <span class="keyword">this</span>.loadToApp(controllerBase, <span class="string">'controller'</span>, opt);</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure><h4 id="loadRouter函数"><a href="#loadRouter函数" class="headerlink" title="loadRouter函数"></a>loadRouter函数</h4><p>loadRouter函数特别简单，只是require加载一下app/router目录下的文件而已，而所有的事情都交给了EggCore类上的router属性去实现</p><p>而router又是Router类的实例，Router类是基于koa-router实现的</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//egg-core源码 -&gt; loadRouter函数源码实现</span></span><br><span class="line"></span><br><span class="line">loadRouter() &#123;</span><br><span class="line">    <span class="keyword">this</span>.loadFile(<span class="keyword">this</span>.resolveModule(path.join(<span class="keyword">this</span>.options.baseDir, <span class="string">'app/router'</span>)));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置router属性的get方法</span></span><br><span class="line"><span class="keyword">get</span> router() &#123;</span><br><span class="line">    <span class="comment">//缓存设置</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>[ROUTER]) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>[ROUTER];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//新建Router实例，其中Router类是继承koa-router实现的</span></span><br><span class="line">    <span class="keyword">const</span> router = <span class="keyword">this</span>[ROUTER] = <span class="keyword">new</span> Router(&#123; <span class="attr">sensitive</span>: <span class="literal">true</span> &#125;, <span class="keyword">this</span>);</span><br><span class="line">    <span class="comment">//在启动前将router中间件载入引用</span></span><br><span class="line">    <span class="keyword">this</span>.beforeStart(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.use(router.middleware());</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> router;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="comment">//将router上所有的method函数代理到EggCore上，这样我们就可以通过app.get('/async', ...asyncMiddlewares, 'subController.subHome.async1')的方式配置路由</span></span><br><span class="line">utils.methods.concat([ <span class="string">'all'</span>, <span class="string">'resources'</span>, <span class="string">'register'</span>, <span class="string">'redirect'</span> ]).forEach(<span class="function"><span class="params">method</span> =&gt;</span> &#123;</span><br><span class="line">  EggCore.prototype[method] = <span class="function"><span class="keyword">function</span>(<span class="params">...args</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.router[method](...args);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>Router类继承了KoaRouter类，并对其的method相关函数做了扩展，解析controller的写法，同时提供了resources方法，为了兼容restAPI的方式</p><p>关于restAPI的使用方式和实现源码我们这里就不介绍了，可以看官方文档，有具体的格式要求，下面看一下Router类的部分实现逻辑：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//egg-core源码 -&gt; Router类实现源码</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Router</span> <span class="keyword">extends</span> <span class="title">KoaRouter</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(opts, app) &#123;</span><br><span class="line">    <span class="keyword">super</span>(opts);</span><br><span class="line">    <span class="keyword">this</span>.app = app;</span><br><span class="line">    <span class="comment">//对method方法进行扩展</span></span><br><span class="line">    <span class="keyword">this</span>.patchRouterMethod();</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  patchRouterMethod() &#123;</span><br><span class="line">    <span class="comment">//为了支持generator函数类型，以及获取controller类中导出的中间件</span></span><br><span class="line">    methods.concat([ <span class="string">'all'</span> ]).forEach(<span class="function"><span class="params">method</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>[method] = <span class="function">(<span class="params">...args</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">//spliteAndResolveRouterParams主要是为了拆分router.js中的路由规则，将其拆分成普通中间件和controller生成的中间件部分，请看下文源码</span></span><br><span class="line">        <span class="keyword">const</span> splited = spliteAndResolveRouterParams(&#123; args, <span class="attr">app</span>: <span class="keyword">this</span>.app &#125;);</span><br><span class="line">        args = splited.prefix.concat(splited.middlewares);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>[method](...args);</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//返回router里每个路由规则的前缀和中间件部分</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">spliteAndResolveRouterParams</span>(<span class="params">&#123; args, app &#125;</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> prefix;</span><br><span class="line">    <span class="keyword">let</span> middlewares;</span><br><span class="line">    <span class="keyword">if</span> (args.length &gt;= <span class="number">3</span> &amp;&amp; (is.string(args[<span class="number">1</span>]) || is.regExp(args[<span class="number">1</span>]))) &#123;</span><br><span class="line">        <span class="comment">// app.get(name, url, [...middleware], controller)的形式</span></span><br><span class="line">        prefix = args.slice(<span class="number">0</span>, <span class="number">2</span>);</span><br><span class="line">        middlewares = args.slice(<span class="number">2</span>);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// app.get(url, [...middleware], controller)的形式</span></span><br><span class="line">        prefix = args.slice(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">        middlewares = args.slice(<span class="number">1</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//controller部分肯定是最后一个</span></span><br><span class="line">      <span class="keyword">const</span> controller = middlewares.pop();</span><br><span class="line">      <span class="comment">//resolveController函数主要是为了处理router.js中关于controller的两种写法：</span></span><br><span class="line">      <span class="comment">//写法1：app.get('/async', ...asyncMiddlewares, 'subController.subHome.async1')</span></span><br><span class="line">      <span class="comment">//写法2：app.get('/async', ...asyncMiddlewares, subController.subHome.async1)</span></span><br><span class="line">      <span class="comment">//最终从app.controller上获取到真正的controller中间件，resolveController具体函数实现就不介绍了</span></span><br><span class="line">      middlewares.push(resolveController(controller, app));</span><br><span class="line">      <span class="keyword">return</span> &#123; prefix, middlewares &#125;;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>以上便是对EggCore的大部分源码的实现的学习总结，其中关于源码中一些debug代码以及timing运行时间记录的代码都删掉了，关于app的生命周期管理的那部分代码和loadUnits加载逻辑关系不大，所以没有讲到。EggCore的核心在于EggLoader，也就是plugin，config, extend, service, middleware, controller, router的加载函数，而这几个内容加载必须按照顺序进行加载，存在依赖关系，比如：</p><ul><li>加载middleware时会用到config关于应用中间件的配置</li><li>加载router时会用到关于controller的配置</li><li>而config，extend，service，middleware，controller的加载都必须依赖于plugin，通过plugin配置获取插件目录</li><li>service，middleware，controller，router的加载又必须依赖于extend（对app进行扩展），因为如果exports是函数的情况下，会将app作为参数执行函数</li></ul><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li><a href="https://www.npmjs.com/package/egg-cool-router" target="_blank" rel="noopener">https://www.npmjs.com/package/egg-cool-router</a></li><li>摘抄自：<a href="https://cnodejs.org/topic/5bc933129545eaf107b9cc84" target="_blank" rel="noopener">https://cnodejs.org/topic/5bc933129545eaf107b9cc84</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;最近在翻查&lt;a href=&quot;https://www.npmjs.com/package/egg-cool-router&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;egg-cool-router&lt;/a&gt;源码查看如何使用装饰器来注册egg路由，看到了一些很牛逼的操作，想知道为什么就查了一下关于源码讲解的文章，解惑了所以摘抄了下来。&lt;/p&gt;
    
    </summary>
    
      <category term="NodeJS" scheme="http://hackycy.github.io/categories/NodeJS/"/>
    
    
      <category term="NodeJS" scheme="http://hackycy.github.io/tags/NodeJS/"/>
    
      <category term="Egg" scheme="http://hackycy.github.io/tags/Egg/"/>
    
  </entry>
  
  <entry>
    <title>Typescript装饰器讲解</title>
    <link href="http://hackycy.github.io/2020/08/25/Typescript%E8%A3%85%E9%A5%B0%E5%99%A8%E8%AE%B2%E8%A7%A3/"/>
    <id>http://hackycy.github.io/2020/08/25/Typescript装饰器讲解/</id>
    <published>2020-08-25T12:22:26.000Z</published>
    <updated>2021-10-09T02:19:57.249Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>装饰器（Decorators）为我们在类的声明及成员上通过元编程语法添加标注提供了一种方式。 Javascript里的装饰器目前处在 <a href="https://github.com/tc39/proposal-decorators" target="_blank" rel="noopener">建议征集的第二阶段</a>，但在TypeScript里已做为一项实验性特性予以支持。</p><blockquote><p>注意  装饰器是一项实验性特性，在未来的版本中可能会发生改变。</p></blockquote><a id="more"></a><p>若要启用实验性的装饰器特性，你必须在命令行或<code>tsconfig.json</code>里启用<code>experimentalDecorators</code>编译器选项：</p><p><strong>命令行</strong>:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tsc --target ES5 --experimentalDecorators</span><br></pre></td></tr></table></figure><p><strong>tsconfig.json</strong>:</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"compilerOptions"</span>: &#123;</span><br><span class="line">        <span class="attr">"target"</span>: <span class="string">"ES5"</span>,</span><br><span class="line">    <span class="attr">"experimentalDecorators"</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">"emitDecoratorMetadata"</span>: <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><p>装饰器是一种特殊类型的声明，它能够被附加到类声明，方法， 访问符，属性或参数上，可以修改类的行为。 装饰器使用 <code>@expression</code>这种形式，<code>expression</code>求值后必须为一个函数，它会在运行时被调用，被装饰的声明信息做为参数传入。</p><p>例：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Path</span>(<span class="string">'/hello'</span>)</span><br><span class="line"><span class="keyword">class</span> HelloService &#123;&#125;</span><br></pre></td></tr></table></figure><h2 id="如何定义装饰器"><a href="#如何定义装饰器" class="headerlink" title="如何定义装饰器"></a>如何定义装饰器</h2><p>装饰器本身其实就是一个函数，理论上忽略参数的话，任何函数都可以当做装饰器使用。例：</p><p>demo.ts</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Path</span>(<span class="params">target:<span class="built_in">any</span></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"I am decorator."</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Path</span></span><br><span class="line"><span class="keyword">class</span> HelloService &#123;&#125;</span><br></pre></td></tr></table></figure><p>使用<code>tsc</code>编译后,执行命令<code>node demo.js</code>，输出结果如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">I am decorator.</span><br></pre></td></tr></table></figure><h2 id="装饰器执行时机"><a href="#装饰器执行时机" class="headerlink" title="装饰器执行时机"></a>装饰器执行时机</h2><p>修饰器对类的行为的改变，是代码编译时发生的（不是TypeScript编译，而是js在执行机中编译阶段），而不是在运行时。这意味着，修饰器能在编译阶段运行代码。也就是说，修饰器本质就是编译时执行的函数。<br>在Node.js环境中模块一加载时就会执行</p><h2 id="函数柯里化解决参数问题"><a href="#函数柯里化解决参数问题" class="headerlink" title="函数柯里化解决参数问题"></a>函数柯里化解决参数问题</h2><p>但是实际场景中，有时希望向装饰器传入一些参数, 如下：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Path</span>(<span class="string">"/hello"</span>, <span class="string">"world"</span>)</span><br><span class="line"><span class="keyword">class</span> HelloService &#123;&#125;</span><br></pre></td></tr></table></figure><p>此时上面装饰器方法就不满足了（VSCode编译报错），这是我们可以借助JavaScript中函数柯里化特性</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Path</span>(<span class="params">p1: <span class="built_in">string</span>, p2: <span class="built_in">string</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">target</span>) </span>&#123; <span class="comment">//  这才是真正装饰器</span></span><br><span class="line">        <span class="comment">// do something </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="五种装饰器"><a href="#五种装饰器" class="headerlink" title="五种装饰器"></a>五种装饰器</h2><p>在TypeScript中装饰器可以修饰四种语句：类，属性，访问器，方法以及方法参数。</p><h3 id="1-类装饰器"><a href="#1-类装饰器" class="headerlink" title="1 类装饰器"></a>1 类装饰器</h3><p>应用于类构造函数，其参数是类的构造函数。<br>注意<code>class</code>并不是像Java那种强类型语言中的类，而是JavaScript构造函数的语法糖。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Path</span>(<span class="params">path: <span class="built_in">string</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">target: <span class="built_in">Function</span></span>) </span>&#123;</span><br><span class="line">        !target.prototype.$Meta &amp;&amp; (target.prototype.$Meta = &#123;&#125;)</span><br><span class="line">        target.prototype.$Meta.baseUrl = path;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Path</span>(<span class="string">'/hello'</span>)</span><br><span class="line"><span class="keyword">class</span> HelloService &#123;</span><br><span class="line">    <span class="keyword">constructor</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(HelloService.prototype.$Meta);<span class="comment">// 输出：&#123; baseUrl: '/hello' &#125;</span></span><br><span class="line"><span class="keyword">let</span> hello = <span class="keyword">new</span> HelloService();</span><br><span class="line"><span class="built_in">console</span>.log(hello.$Meta) <span class="comment">// 输出：&#123; baseUrl: '/hello' &#125;</span></span><br></pre></td></tr></table></figure><h3 id="2-方法装饰器"><a href="#2-方法装饰器" class="headerlink" title="2 方法装饰器"></a>2 方法装饰器</h3><p>它会被应用到方法的 属性描述符上，可以用来监视，修改或者替换方法定义。<br>方法装饰会在运行时传入下列3个参数：</p><ul><li>1、对于静态成员来说是类的构造函数，对于实例成员是类的原型对象。</li><li>2、成员的名字。</li><li>3、成员的属性描述符。</li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">GET</span>(<span class="params">url: <span class="built_in">string</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">target, methodName: <span class="built_in">string</span>, descriptor: PropertyDescriptor</span>) </span>&#123;</span><br><span class="line">        !target.$Meta &amp;&amp; (target.$Meta = &#123;&#125;);</span><br><span class="line">        target.$Meta[methodName] = url;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> HelloService &#123;</span><br><span class="line">    <span class="keyword">constructor</span>(<span class="params"></span>) &#123; &#125;</span><br><span class="line">    <span class="meta">@GET</span>(<span class="string">"xx"</span>)</span><br><span class="line">    getUser() &#123; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log((&lt;<span class="built_in">any</span>&gt;HelloService).$Meta);</span><br></pre></td></tr></table></figure><p>注意：在vscode编辑时有时会报<code>作为表达式调用时，无法解析方法修饰器的签名。</code>错误，此时需要在tsconfig.json中增加target配置项：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">"compilerOptions"</span>: &#123;</span><br><span class="line">        <span class="string">"target"</span>: <span class="string">"es6"</span>,</span><br><span class="line">        <span class="string">"experimentalDecorators"</span>: <span class="literal">true</span>,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-方法参数装饰器"><a href="#3-方法参数装饰器" class="headerlink" title="3 方法参数装饰器"></a>3 方法参数装饰器</h3><p>参数装饰器表达式会在运行时当作函数被调用，传入下列3个参数：</p><ul><li>1、对于静态成员来说是类的构造函数，对于实例成员是类的原型对象。</li><li>2、参数的名字。</li><li>3、参数在函数参数列表中的索引。</li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">PathParam</span>(<span class="params">paramName: <span class="built_in">string</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">target, methodName: <span class="built_in">string</span>, paramIndex: <span class="built_in">number</span></span>) </span>&#123;</span><br><span class="line">        !target.$Meta &amp;&amp; (target.$Meta = &#123;&#125;);</span><br><span class="line">        target.$Meta[paramIndex] = paramName;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> HelloService &#123;</span><br><span class="line">    <span class="keyword">constructor</span>(<span class="params"></span>) &#123; &#125;</span><br><span class="line">    getUser( <span class="meta">@PathParam</span>(<span class="string">"userId"</span>) userId: <span class="built_in">string</span>) &#123; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log((&lt;<span class="built_in">any</span>&gt;HelloService).prototype.$Meta); <span class="comment">// &#123;'0':'userId'&#125;</span></span><br></pre></td></tr></table></figure><h3 id="4-属性装饰器"><a href="#4-属性装饰器" class="headerlink" title="4 属性装饰器"></a>4 属性装饰器</h3><p>属性装饰器表达式会在运行时当作函数被调用，传入下列2个参数：</p><ul><li>1、对于静态成员来说是类的构造函数，对于实例成员是类的原型对象。</li><li>2、成员的名字。</li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">DefaultValue</span>(<span class="params">value: <span class="built_in">string</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">target: <span class="built_in">any</span>, propertyName: <span class="built_in">string</span></span>) </span>&#123;</span><br><span class="line">        target[propertyName] = value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Hello &#123;</span><br><span class="line">    <span class="meta">@DefaultValue</span>(<span class="string">"world"</span>) greeting: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">new</span> Hello().greeting);<span class="comment">// 输出: world</span></span><br></pre></td></tr></table></figure><h3 id="装饰器加载顺序"><a href="#装饰器加载顺序" class="headerlink" title="装饰器加载顺序"></a>装饰器加载顺序</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ClassDecorator</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">target</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"I am class decorator"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MethodDecorator</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">target, methodName: <span class="built_in">string</span>, descriptor: PropertyDescriptor</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"I am method decorator"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Param1Decorator</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">target, methodName: <span class="built_in">string</span>, paramIndex: <span class="built_in">number</span></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"I am parameter1 decorator"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Param2Decorator</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">target, methodName: <span class="built_in">string</span>, paramIndex: <span class="built_in">number</span></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"I am parameter2 decorator"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">PropertyDecorator</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">target, propertyName: <span class="built_in">string</span></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"I am property decorator"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@ClassDecorator</span>()</span><br><span class="line"><span class="keyword">class</span> Hello &#123;</span><br><span class="line">    <span class="meta">@PropertyDecorator</span>()</span><br><span class="line">    greeting: <span class="built_in">string</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@MethodDecorator</span>()</span><br><span class="line">    greet( <span class="meta">@Param1Decorator</span>() p1: <span class="built_in">string</span>, <span class="meta">@Param2Decorator</span>() p2: <span class="built_in">string</span>) &#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">I am property decorator</span><br><span class="line">I am parameter2 decorator</span><br><span class="line">I am parameter1 decorator</span><br><span class="line">I am method decorator</span><br><span class="line">I am class decorator</span><br></pre></td></tr></table></figure><p>从上述例子得出如下结论：</p><p>1、有多个参数装饰器时：从最后一个参数依次向前执行</p><p>2、方法和方法参数中参数装饰器先执行。</p><p>3、类装饰器总是最后执行。</p><p>4、方法和属性装饰器，谁在前面谁先执行。因为参数属于方法一部分，所以参数会一直紧紧挨着方法执行。上述例子中属性和方法调换位置，输出如下结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">I am parameter2 decorator</span><br><span class="line">I am parameter1 decorator</span><br><span class="line">I am method decorator</span><br><span class="line">I am property decorator</span><br><span class="line">I am class decorator</span><br></pre></td></tr></table></figure><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li><p>摘抄自 - <a href="https://www.cnblogs.com/winfred/p/8216650.html" target="_blank" rel="noopener">https://www.cnblogs.com/winfred/p/8216650.html</a></p></li><li><p><a href="https://github.com/hackycy/practice-examples/tree/master/typescript/DecoratorDemo" target="_blank" rel="noopener">Github Sample</a></p></li><li><p><a href="https://www.tslang.cn/docs/handbook/decorators.html" target="_blank" rel="noopener">https://www.tslang.cn/docs/handbook/decorators.html</a></p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h1&gt;&lt;p&gt;装饰器（Decorators）为我们在类的声明及成员上通过元编程语法添加标注提供了一种方式。 Javascript里的装饰器目前处在 &lt;a href=&quot;https://github.com/tc39/proposal-decorators&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;建议征集的第二阶段&lt;/a&gt;，但在TypeScript里已做为一项实验性特性予以支持。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;注意  装饰器是一项实验性特性，在未来的版本中可能会发生改变。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="TypeScript" scheme="http://hackycy.github.io/categories/TypeScript/"/>
    
    
      <category term="TypeScript" scheme="http://hackycy.github.io/tags/TypeScript/"/>
    
  </entry>
  
  <entry>
    <title>重学Android之FileProvider</title>
    <link href="http://hackycy.github.io/2020/08/19/%E9%87%8D%E5%AD%A6Android%E4%B9%8BFileProvider/"/>
    <id>http://hackycy.github.io/2020/08/19/重学Android之FileProvider/</id>
    <published>2020-08-19T10:55:20.000Z</published>
    <updated>2021-10-09T02:19:57.449Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>项目之前使用了第三方库的时候，对于<code>FileProvider</code>的适配还不是很了解，因为使用时第三方库已经进行了适配。但是自己去覆写别人的第三方库的时候了解到了<code>FileProvider</code>的适配。</p><p>对于Android 7.0，提供了非常多的变化，详细的可以阅读官方文档<a href="https://developer.android.com/about/versions/nougat/android-7.0-changes.html" target="_blank" rel="noopener">Android 7.0 行为变更</a>，但是该文章主要叙述关于<code>FileProvider</code>的适配。</p><blockquote><p> 在官方7.0的以上的系统中，尝试传递 <code>file://URI</code>可能会触发<code>FileUriExposedException</code>。</p></blockquote><a id="more"></a><h1 id="出错案例"><a href="#出错案例" class="headerlink" title="出错案例"></a>出错案例</h1><p>先来一个常用的例子，大家应该对于手机拍照一定都不陌生，在希望得到一张高清拍照图的时候，我们通过Intent会传递一个File的Uri给相机应用。</p><p>大致代码如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> REQUEST_CODE_TAKE_PHOTO = <span class="number">0x110</span>;</span><br><span class="line">    <span class="keyword">private</span> String mCurrentPhotoPath;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">takePhotoNoCompress</span><span class="params">(View view)</span> </span>&#123;</span><br><span class="line">        Intent takePictureIntent = <span class="keyword">new</span> Intent(MediaStore.ACTION_IMAGE_CAPTURE);</span><br><span class="line">        <span class="keyword">if</span> (takePictureIntent.resolveActivity(getPackageManager()) != <span class="keyword">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">            String filename = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyyMMdd-HHmmss"</span>, Locale.CHINA)</span><br><span class="line">                    .format(<span class="keyword">new</span> Date()) + <span class="string">".png"</span>;</span><br><span class="line">            File file = <span class="keyword">new</span> File(Environment.getExternalStorageDirectory(), filename);</span><br><span class="line">            mCurrentPhotoPath = file.getAbsolutePath();</span><br><span class="line"><span class="comment">// File -&gt; Uri </span></span><br><span class="line">            takePictureIntent.putExtra(MediaStore.EXTRA_OUTPUT, Uri.fromFile(file));</span><br><span class="line">            startActivityForResult(takePictureIntent, REQUEST_CODE_TAKE_PHOTO);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onActivityResult</span><span class="params">(<span class="keyword">int</span> requestCode, <span class="keyword">int</span> resultCode, Intent data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onActivityResult(requestCode, resultCode, data);</span><br><span class="line">        <span class="keyword">if</span> (resultCode == RESULT_OK &amp;&amp; requestCode == REQUEST_CODE_TAKE_PHOTO) &#123;</span><br><span class="line">            mIvPhoto.setImageBitmap(BitmapFactory.decodeFile(mCurrentPhotoPath));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// else tip?</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>未处理6.0权限，有需要的自行处理下，nexus系列如果未处理，需要手动在设置页开启存储权限。</p></blockquote><p>此时如果我们使用Android 7.0或者以上的原生系统，再次运行一下，你会发现应用直接停止运行，抛出了<code>android.os.FileUriExposedException</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Caused by: android.os.FileUriExposedException: </span><br><span class="line">    file:///storage/emulated/0/20170601-030254.png </span><br><span class="line">        exposed beyond app through ClipData.Item.getUri()</span><br><span class="line">    at android.os.StrictMode.onFileUriExposed(StrictMode.java:1932)</span><br><span class="line">    at android.net.Uri.checkFileUriExposed(Uri.java:2348)</span><br></pre></td></tr></table></figure><p>原因在官网已经给了解释：</p><blockquote><p>对于面向 Android 7.0 的应用，Android 框架执行的 StrictMode API 政策禁止在您的应用外部公开 file:// URI。如果一项包含文件 URI 的 intent 离开您的应用，则应用出现故障，并出现 FileUriExposedException 异常。</p></blockquote><p>同样的，官网也给出了解决方案：</p><blockquote><p>要在应用间共享文件，您应发送一项 content:// URI，并授予 URI 临时访问权限。进行此授权的最简单方式是使用 FileProvider 类。如需了解有关权限和共享文件的详细信息，请参阅共享文件。<br><a href="https://developer.android.com/about/versions/nougat/android-7.0-changes.html#accessibility" target="_blank" rel="noopener">https://developer.android.com/about/versions/nougat/android-7.0-changes.html#accessibility</a></p></blockquote><h1 id="使用FileProvider"><a href="#使用FileProvider" class="headerlink" title="使用FileProvider"></a>使用FileProvider</h1><p><code>FileProvider</code>属于Android 7.0新增的一个类，该类位于v4或者androidx包下，详情可见<code>android.support.v4.content.FileProvider</code>或者<code>androidx.core.content.FileProvider</code>，使用方法类似与<code>ContentProvider</code>，简单概括为三个步骤，这里先以调用系统相机拍照并保存<strong>sdcard</strong>公共目录为例，演示使用过程：</p><ul><li>在资源文件夹<code>res/xml</code>下新建<code>file_paths.xml</code>文件，文件声明权限请求的路径，代码如下：</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">paths</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--3、对应外部内存卡根目录：Environment.getExternalStorageDirectory()--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">external-path</span> <span class="attr">name</span>=<span class="string">"external"</span> <span class="attr">path</span>=<span class="string">"/"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">paths</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>要使用<code>content://uri</code>替代<code>file://uri</code>，需要一个虚拟的路径对文件路径进行映射，所以需要编写个xml文件，通过path以及xml节点确定可访问的目录，通过name属性来映射真实的文件路径。</p></blockquote><ul><li>在<code>AndroidManifest.xml</code>添加组件<code>provider</code>相关信息，类似组件<code>activity</code>，指定<code>resource</code>属性引用上一步创建的xml文件（后面会详细介绍各个属性的用法），代码如下：</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 定义FileProvider --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">provider</span></span></span><br><span class="line"><span class="tag"><span class="attr">android:name</span>=<span class="string">"androidx.core.content.FileProvider"</span></span></span><br><span class="line"><span class="tag"><span class="attr">android:authorities</span>=<span class="string">"com.siyee.android7.fileprovider"</span></span></span><br><span class="line"><span class="tag"><span class="attr">android:exported</span>=<span class="string">"false"</span></span></span><br><span class="line"><span class="tag"><span class="attr">android:grantUriPermissions</span>=<span class="string">"true"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta-data</span></span></span><br><span class="line"><span class="tag"><span class="attr">android:name</span>=<span class="string">"android.support.FILE_PROVIDER_PATHS"</span></span></span><br><span class="line"><span class="tag"><span class="attr">android:resource</span>=<span class="string">"@xml/file_paths"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">provider</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>最后一步，Java代码申请权限，使用新增的方法<code>getUriForFile()</code>和<code>grantUriPermission()</code>，代码如下（后面会详细介绍方法对应参数的使用）：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">takePhotoNoCompress</span><span class="params">(View view)</span> </span>&#123;</span><br><span class="line">        Intent takePictureIntent = <span class="keyword">new</span> Intent(MediaStore.ACTION_IMAGE_CAPTURE);</span><br><span class="line">        <span class="keyword">if</span> (takePictureIntent.resolveActivity(getPackageManager()) != <span class="keyword">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">            String filename = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyyMMdd-HHmmss"</span>, Locale.CHINA)</span><br><span class="line">                    .format(<span class="keyword">new</span> Date()) + <span class="string">".png"</span>;</span><br><span class="line">            File file = <span class="keyword">new</span> File(Environment.getExternalStorageDirectory(), filename);</span><br><span class="line">            mCurrentPhotoPath = file.getAbsolutePath();</span><br><span class="line">          </span><br><span class="line"><span class="comment">// 核心就是这一行代码</span></span><br><span class="line">            Uri fileUri = FileProvider.getUriForFile(<span class="keyword">this</span>, <span class="string">"com.siyee.android7.fileprovider"</span>, file);</span><br><span class="line">            takePictureIntent.putExtra(MediaStore.EXTRA_OUTPUT, fileUri);</span><br><span class="line">            startActivityForResult(takePictureIntent, REQUEST_CODE_TAKE_PHOTO);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><blockquote><p>通过FileProvider把<code>file</code>转化为<code>content://uri</code>了</p></blockquote><p>核心代码就这一行了~</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FileProvider.getUriForFile(this, &quot;com.siyee.android7.fileprovider&quot;, file);</span><br></pre></td></tr></table></figure><p>第二个参数就是我们配置的<code>authorities</code>，这个很正常了，总得映射到确定的ContentProvider吧~所以需要这个参数。</p><p>然后再看一眼我们生成的uri：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">content:<span class="comment">//com.siyee.android7.fileprovider/external/20200819-041411.png</span></span><br></pre></td></tr></table></figure><p>可以看到格式为：<code>content://authorities/定义的name属性/文件的相对路径</code>，即<code>name</code>隐藏了可存储的文件夹路径。</p><h1 id="兼容"><a href="#兼容" class="headerlink" title="兼容"></a>兼容</h1><p>如果使用以上代码跑在7.0以上系统的手机没有问题，但是拿回到低版本的手机又会出现崩溃：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Caused by: java.lang.SecurityException: Permission Denial: opening provider androidx.core.content.FileProvider from ProcessRecord&#123;52b029b8 1670:com.android.camera/u0a36&#125; (pid=1670, uid=10036) that is not exported from uid 10052</span><br><span class="line">at android.os.Parcel.readException(Parcel.java:1465)</span><br><span class="line">at android.os.Parcel.readException(Parcel.java:1419)</span><br><span class="line">at android.app.ActivityManagerProxy.getContentProvider(ActivityManagerNative.java:2848)</span><br><span class="line">at android.app.ActivityThread.acquireProvider(ActivityThread.java:4399)</span><br></pre></td></tr></table></figure><p>因为低版本的系统，仅仅是把这个当成一个普通的Provider在使用，而我们没有授权，<code>contentprovider</code>的export设置的也是false；导致<code>Permission Denial</code>。</p><p>而解决的办法就是授权了。通过<code>grantUriPermission(String toPackage, Uri uri,int modeFlags)</code>和<code>revokeUriPermission(Uri uri, int modeFlags)</code>方法。</p><p>可以看到<code>grantUriPermission</code>需要传递一个包名，就是你给哪个应用授权，但是很多时候，比如分享，我们并不知道最终用户会选择哪个app，所以我们可以这样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">List&lt;ResolveInfo&gt; resInfoList = context.getPackageManager()</span><br><span class="line">            .queryIntentActivities(intent, PackageManager.MATCH_DEFAULT_ONLY);</span><br><span class="line"><span class="keyword">for</span> (ResolveInfo resolveInfo : resInfoList) &#123;</span><br><span class="line">    String packageName = resolveInfo.activityInfo.packageName;</span><br><span class="line">    context.grantUriPermission(packageName, uri, flag);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据Intent查询出的所以符合的应用，都给他们授权~~</p><p>恩，你可以在不需要的时候通过<code>revokeUriPermission</code>移除权限~</p><p>那么增加了授权后的代码是这样的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">takePhotoNoCompress</span><span class="params">(View view)</span> </span>&#123;</span><br><span class="line">    Intent takePictureIntent = <span class="keyword">new</span> Intent(MediaStore.ACTION_IMAGE_CAPTURE);</span><br><span class="line">    <span class="keyword">if</span> (takePictureIntent.resolveActivity(getPackageManager()) != <span class="keyword">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">        String filename = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyyMMdd-HHmmss"</span>, Locale.CHINA)</span><br><span class="line">                .format(<span class="keyword">new</span> Date()) + <span class="string">".png"</span>;</span><br><span class="line">        File file = <span class="keyword">new</span> File(Environment.getExternalStorageDirectory(), filename);</span><br><span class="line">        mCurrentPhotoPath = file.getAbsolutePath();</span><br><span class="line"></span><br><span class="line">        Uri fileUri = FileProvider.getUriForFile(<span class="keyword">this</span>, <span class="string">"com.siyee.android7.fileprovider"</span>, file);</span><br><span class="line"></span><br><span class="line">        List&lt;ResolveInfo&gt; resInfoList = getPackageManager()</span><br><span class="line">                .queryIntentActivities(takePictureIntent, PackageManager.MATCH_DEFAULT_ONLY);</span><br><span class="line">        <span class="keyword">for</span> (ResolveInfo resolveInfo : resInfoList) &#123;</span><br><span class="line">            String packageName = resolveInfo.activityInfo.packageName;</span><br><span class="line">            grantUriPermission(packageName, fileUri, Intent.FLAG_GRANT_READ_URI_PERMISSION</span><br><span class="line">                    | Intent.FLAG_GRANT_WRITE_URI_PERMISSION);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        takePictureIntent.putExtra(MediaStore.EXTRA_OUTPUT, fileUri);</span><br><span class="line">        startActivityForResult(takePictureIntent, REQUEST_CODE_TAKE_PHOTO);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是这样的做法相对麻烦，我们可以对系统版本进行判断高版本用<code>FileProvider.getUriForFile</code>，低版本继续使用<code>Uri.fromFile</code>即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Uri fileUri = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= <span class="number">24</span>) &#123;</span><br><span class="line">    fileUri = FileProvider.getUriForFile(<span class="keyword">this</span>, <span class="string">"com.siyee.android7.fileprovider"</span>, file);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    fileUri = Uri.fromFile(file);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="理解FileProvider"><a href="#理解FileProvider" class="headerlink" title="理解FileProvider"></a>理解FileProvider</h1><h2 id="定义FileProvider"><a href="#定义FileProvider" class="headerlink" title="定义FileProvider"></a>定义FileProvider</h2><p>直接使用<code>FileProvider</code>本身或者它的子类，需要在<code>AndroidManifest.xml</code>文件中声明组件的相关属性，包括：</p><ul><li><code>android:name</code>，对应属性值：<code>android.support.v4.content.FileProvider</code>或者子类完整路径</li><li><code>android:authorities</code>，对应属性值是一个常量，通常定义的方式<code>packagename.fileprovider</code>，例如：<code>cn.teachcourse.fileprovider</code></li><li><code>android:exported</code>，对应属性值是一个boolean变量，设置为<code>false</code></li><li><code>android:grantUriPermissions</code>，对应属性值也是一个boolean变量，设置为<code>true</code>，允许获得文件临时的访问权限</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">manifest</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="tag">&lt;<span class="name">application</span>&gt;</span></span><br><span class="line">        ...</span><br><span class="line">        <span class="tag">&lt;<span class="name">provider</span></span></span><br><span class="line"><span class="tag"><span class="attr">android:name</span>=<span class="string">"androidx.core.content.FileProvider"</span></span></span><br><span class="line"><span class="tag"><span class="attr">android:authorities</span>=<span class="string">"com.siyee.android7.fileprovider"</span></span></span><br><span class="line"><span class="tag"><span class="attr">android:exported</span>=<span class="string">"false"</span></span></span><br><span class="line"><span class="tag"><span class="attr">android:grantUriPermissions</span>=<span class="string">"true"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta-data</span></span></span><br><span class="line"><span class="tag"><span class="attr">android:name</span>=<span class="string">"android.support.FILE_PROVIDER_PATHS"</span></span></span><br><span class="line"><span class="tag"><span class="attr">android:resource</span>=<span class="string">"@xml/file_paths"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">provider</span>&gt;</span></span><br><span class="line">        ...</span><br><span class="line">    <span class="tag">&lt;/<span class="name">application</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">manifest</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="指定授予临时访问权限的文件目录"><a href="#指定授予临时访问权限的文件目录" class="headerlink" title="指定授予临时访问权限的文件目录"></a>指定授予临时访问权限的文件目录</h2><p>想要关联<code>res/xml</code>文件夹下创建的<code>file_paths.xml</code>文件，需要在<code>&lt;provider&gt;</code>标签内，添加<code>&lt;meta-data&gt;</code>子标签，设置<code>&lt;meta-data&gt;</code>标签的属性值，包括：</p><ul><li><code>android:name</code>，对应属性值是一个固定的系统常量<code>android.support.FILE_PROVIDER_PATHS</code></li><li><code>android:resource</code>，对应属性值指向我们的xml文件<code>@xml/file_paths</code></li></ul><p>在xml文件中指定文件存储的区块和区块的相对路径，在<code>&lt;paths&gt;</code>根标签中添加<code>&lt;files-path&gt;</code>子标签（稍后详细列出所有子标签），设置子标签的属性值，包括：</p><ul><li><code>name</code>，是一个虚设的文件名（可以自由命名），对外可见路径的一部分，隐藏真实文件目录</li><li><code>path</code>，是一个相对目录，相对于当前的子标签<code>&lt;files-path&gt;</code>根目录</li><li><code>&lt;files-path&gt;</code>，表示内部内存卡根目录，对应根目录等价于<code>Context.getFilesDir()</code>，查看完整路径：<br><code>/data/user/0/com.siyee.demos/files</code></li><li>代码如下：</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">paths</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">files-path</span> <span class="attr">name</span>=<span class="string">"my_images"</span> <span class="attr">path</span>=<span class="string">"images/"</span>/&gt;</span></span><br><span class="line">    ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">paths</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>&lt;paths&gt;</code>根标签下可以添加的子标签也是有限的，参考官网的开发文档，除了上述的提到的<code>&lt;files-path&gt;</code>这个子标签外，还包括下面几个：</p><ol><li><code>&lt;cache-path&gt;</code>，表示应用默认缓存根目录，对应根目录等价于<code>getCacheDir()</code>，查看完整路径：<code>/data/user/0/com.siyee.demos/cache</code></li><li><code>&lt;external-path&gt;</code>，表示外部内存卡根目录，对应根目录等价于<br><code>Environment.getExternalStorageDirectory()</code>，<br>查看完整路径：<code>/storage/emulated/0</code></li><li><code>&lt;external-files-path&gt;</code>，表示外部内存卡根目录下的APP公共目录，对应根目录等价于<br><code>Context#getExternalFilesDir(String) Context.getExternalFilesDir(null)</code>，<br>查看完整路径：<br><code>/storage/emulated/0/Android/data/com.siyee.demos/files/Download</code></li><li><code>&lt;external-cache-path&gt;</code>，表示外部内存卡根目录下的APP缓存目录，对应根目录等价于<code>Context.getExternalCacheDir()</code>，查看完整路径：<br><code>/storage/emulated/0/Android/data/com.siyee.demos/cache</code></li></ol><p>最终，在<code>file_provider.xml</code>文件中，添加上述5种类型的临时访问权限的文件目录，代码如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">paths</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">    1、name对应的属性值，开发者可以自由定义；</span></span><br><span class="line"><span class="comment">    2、path对应的属性值，当前external-path标签下的相对路径</span></span><br><span class="line"><span class="comment">    比如：/storage/emulated/0/92Recycle-release.apk</span></span><br><span class="line"><span class="comment">    sdcard路径：/storage/emulated/0(WriteToReadActivity.java:176)</span></span><br><span class="line"><span class="comment">                      at cn.teachcourse.nougat.WriteToReadActivity.onClick(WriteToReadActivity.java:97)</span></span><br><span class="line"><span class="comment">                      at android.view.View.performClick(View.java:5610)</span></span><br><span class="line"><span class="comment">                      at android.view.View$PerformClick.run(View.java:22265)</span></span><br><span class="line"><span class="comment">    相对路径：/</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--1、对应内部内存卡根目录：Context.getFileDir()--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">files-path</span></span></span><br><span class="line"><span class="tag">        <span class="attr">name</span>=<span class="string">"int_root"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">path</span>=<span class="string">"/"</span> /&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--2、对应应用默认缓存根目录：Context.getCacheDir()--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">cache-path</span></span></span><br><span class="line"><span class="tag">        <span class="attr">name</span>=<span class="string">"app_cache"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">path</span>=<span class="string">"/"</span> /&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--3、对应外部内存卡根目录：Environment.getExternalStorageDirectory()--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">external-path</span></span></span><br><span class="line"><span class="tag">        <span class="attr">name</span>=<span class="string">"ext_root"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">path</span>=<span class="string">"pictures/"</span> /&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--4、对应外部内存卡根目录下的APP公共目录：Context.getExternalFileDir(String)--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">external-files-path</span></span></span><br><span class="line"><span class="tag">        <span class="attr">name</span>=<span class="string">"ext_pub"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">path</span>=<span class="string">"/"</span> /&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--5、对应外部内存卡根目录下的APP缓存目录：Context.getExternalCacheDir()--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">external-cache-path</span></span></span><br><span class="line"><span class="tag">        <span class="attr">name</span>=<span class="string">"ext_cache"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">path</span>=<span class="string">"/"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">paths</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="生成指定文件的Content-URI"><a href="#生成指定文件的Content-URI" class="headerlink" title="生成指定文件的Content URI"></a>生成指定文件的Content URI</h2><p>Content URI方便与另一个APP应用程序共享同一个文件，共享的方式通过<code>ContentResolver.openFileDescriptor</code>获得一个<code>ParcelFileDescriptor</code>对象，读取文件内容。那么，如何生成一条完整的Content URI呢？TeachCourse总结后，概括为三个步骤，<strong>第一步：</strong>明确上述5种类型中的哪一种，<strong>第二步：</strong>明确指定文件的完整路径（包括目录、文件名），<strong>第三步：</strong>调用<code>getUriForFile()</code>方法生成URI</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">File imagePath = <span class="keyword">new</span> File(Environment.getExternalStorageDirectory(), <span class="string">"download"</span>);</span><br><span class="line">File newFile = <span class="keyword">new</span> File(imagePath, <span class="string">"default_image.jpg"</span>);</span><br><span class="line">Uri contentUri = getUriForFile(getContext(), <span class="string">"com.siyee.android7.fileprovider"</span>, newFile);</span><br></pre></td></tr></table></figure><h2 id="授予Content-URI临时访问权限"><a href="#授予Content-URI临时访问权限" class="headerlink" title="授予Content URI临时访问权限"></a>授予Content URI临时访问权限</h2><p>上一步获得的Content URI，并没有获得指定文件的读写权限，想要获得文件的读写权限需要调用<code>Context.grantUriPermission(package, Uri, mode_flags)</code>方法，该方法向指定包名的应用程序申请获得读取或者写入文件的权限，参数说明如下：</p><ul><li><code>package</code>，指定应用程序的包名，Android Studio真正的包名指<code>build.gradle</code>声明的<em>applicationId</em>属性值；<code>getPackageName()</code>指<code>AndroidManifest.xml</code>文件声明的<em>package</em>属性值，如果两者不一致，就不能提供<code>getPackageName()</code>获取包名，否则报错！</li><li><code>Uri</code>，指定请求授予临时权限的URI，例如：<code>contentUri</code></li><li><code>mode_flags</code>，指定授予临时权限的类型，选择其中一个常量或两个：<code>Intent.FLAG_GRANT_READ_URI_PERMISSION</code>，<code>Intent.FLAG_GRANT_WRITE_URI_PERMISSION</code></li></ul><p>授予文件的临时读取或写入权限，如果不再需要了，TeachCourse该如何撤销授予呢？撤销权限有两种方式：<strong>第一种：</strong>通过调用<code>revokeUriPermission()</code>撤销，<strong>第二种：</strong>重启系统后自动撤销</p><h1 id="使用FileProvider兼容安装apk"><a href="#使用FileProvider兼容安装apk" class="headerlink" title="使用FileProvider兼容安装apk"></a><a href="https://blog.csdn.net/lmj623565791/article/details/72859156" target="_blank" rel="noopener">使用FileProvider兼容安装apk</a></h1><p>正常我们在编写安装apk的时候，是这样的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">installApk</span><span class="params">(View view)</span> </span>&#123;</span><br><span class="line">    File file = <span class="keyword">new</span> File(Environment.getExternalStorageDirectory(), <span class="string">"testandroid7-debug.apk"</span>);</span><br><span class="line"></span><br><span class="line">    Intent intent = <span class="keyword">new</span> Intent(Intent.ACTION_VIEW);</span><br><span class="line">    intent.setDataAndType(Uri.fromFile(file),</span><br><span class="line">            <span class="string">"application/vnd.android.package-archive"</span>);</span><br><span class="line">    startActivity(intent);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>拿个7.0的原生手机跑一下，<code>android.os.FileUriExposedException</code>又来了~~</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">android.os.FileUriExposedException: file:///storage/emulated/0/testandroid7-debug.apk exposed beyond app through Intent.getData()</span><br></pre></td></tr></table></figure><p>好在有经验了，简单修改下uri的获取方式。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= <span class="number">24</span>) &#123;</span><br><span class="line">    fileUri = FileProvider.getUriForFile(<span class="keyword">this</span>, <span class="string">"com.zhy.android7.fileprovider"</span>, file);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    fileUri = Uri.fromFile(file);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再跑一次，没想到还是抛出了异常（警告，没有Crash）:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">java.lang.SecurityException: Permission Denial: </span><br><span class="line">opening provider android.support.v4.content.FileProvider </span><br><span class="line">        from ProcessRecord&#123;18570a 27107:com.google.android.packageinstaller/u0a26&#125; (pid=27107, uid=10026) that is not exported from UID 10004123</span><br></pre></td></tr></table></figure><p>可以看到是权限问题，对于权限我们刚说了一种方式为<code>grantUriPermission</code>，这种方式当然是没问题的啦~</p><p>加上后运行即可。</p><p>其实对于权限，还提供了一种方式，即：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">intent.addFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION | Intent.FLAG_GRANT_WRITE_URI_PERMISSION);</span><br></pre></td></tr></table></figure><p>我们可以在安装包之前加上上述代码，再次运行正常啦~</p><p>现在我有两个非常疑惑的问题：</p><ul><li>问题1：为什么刚才拍照的时候，Android 7的设备并没有遇到<code>Permission Denial</code>的问题？</li></ul><p>恩，之所以不需要权限，主要是因为Intent的action为<code>ACTION_IMAGE_CAPTURE</code>，当我们<code>startActivity</code>后，会辗转调用<code>Instrumentation的execStartActivity</code>方法，在该方法内部，会调用<code>intent.migrateExtraStreamToClipData();</code>方法。</p><p>该方法中包含：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (MediaStore.ACTION_IMAGE_CAPTURE.equals(action)</span><br><span class="line">        || MediaStore.ACTION_IMAGE_CAPTURE_SECURE.equals(action)</span><br><span class="line">        || MediaStore.ACTION_VIDEO_CAPTURE.equals(action)) &#123;</span><br><span class="line">    <span class="keyword">final</span> Uri output;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        output = getParcelableExtra(MediaStore.EXTRA_OUTPUT);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ClassCastException e) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (output != <span class="keyword">null</span>) &#123;</span><br><span class="line">        setClipData(ClipData.newRawUri(<span class="string">""</span>, output));</span><br><span class="line">        addFlags(FLAG_GRANT_WRITE_URI_PERMISSION|FLAG_GRANT_READ_URI_PERMISSION);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到将我们的<code>EXTRA_OUTPUT</code>，转为了<code>setClipData</code>，并直接给我们添加了<code>WRITE</code>和<code>READ</code>权限。</p><blockquote><p>注：该部分逻辑应该是21之后添加的。</p></blockquote><ul><li>问题2：为什么刚才拍照案例的时候，Android 4.4设备遇到权限问题，不通过addFlags这种方式解决？</li></ul><p>因为addFlags主要用于<code>setData</code>，<code>setDataAndType</code>以及<code>setClipData</code>（注意：4.4时，并没有将<code>ACTION_IMAGE_CAPTURE</code>转为<code>setClipData</code>实现）这种方式。</p><p>所以<code>addFlags</code>方式对于<code>ACTION_IMAGE_CAPTURE</code>在5.0以下是无效的，所以需要使用<code>grantUriPermission</code>，如果是正常的通过setData分享的uri，使用<code>addFlags</code>是没有问题的（可以写个简单的例子测试下，两个app交互，通过<code>content://</code>）。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>使用<code>content://</code>替代<code>file://</code>，主要需要<code>FileProvider</code>的支持，而因为<code>FileProvider</code>是<code>ContentProvider</code>的子类，所以需要在<code>AndroidManifest.xml</code>中注册；而又因为需要对真实的<code>filepath</code>进行映射，所以需要编写一个<code>xml</code>文档，用于描述可使用的文件夹目录，以及通过<code>name</code>去映射该文件夹目录。</p><p>对于权限，有两种方式：</p><ul><li>方式一为<code>Intent.addFlags</code>，该方式主要用于针对<code>intent.setData</code>，<code>setDataAndType</code>以及<code>setClipData</code>相关方式传递<code>uri</code>的。</li><li>方式二为<code>grantUriPermission</code>来进行授权</li></ul><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://blog.csdn.net/lmj623565791/article/details/72859156" target="_blank" rel="noopener">https://blog.csdn.net/lmj623565791/article/details/72859156</a></p><p><a href="https://www.cnblogs.com/dazhao/p/6547811.html" target="_blank" rel="noopener">https://www.cnblogs.com/dazhao/p/6547811.html</a></p><p><a href="https://www.jianshu.com/p/bce6a4c779dd" target="_blank" rel="noopener">https://www.jianshu.com/p/bce6a4c779dd</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;项目之前使用了第三方库的时候，对于&lt;code&gt;FileProvider&lt;/code&gt;的适配还不是很了解，因为使用时第三方库已经进行了适配。但是自己去覆写别人的第三方库的时候了解到了&lt;code&gt;FileProvider&lt;/code&gt;的适配。&lt;/p&gt;
&lt;p&gt;对于Android 7.0，提供了非常多的变化，详细的可以阅读官方文档&lt;a href=&quot;https://developer.android.com/about/versions/nougat/android-7.0-changes.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Android 7.0 行为变更&lt;/a&gt;，但是该文章主要叙述关于&lt;code&gt;FileProvider&lt;/code&gt;的适配。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt; 在官方7.0的以上的系统中，尝试传递 &lt;code&gt;file://URI&lt;/code&gt;可能会触发&lt;code&gt;FileUriExposedException&lt;/code&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Android" scheme="http://hackycy.github.io/categories/Android/"/>
    
    
      <category term="Android" scheme="http://hackycy.github.io/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Shadowsocks科学上网搭建</title>
    <link href="http://hackycy.github.io/2020/07/28/Shadowsocks%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91%E6%90%AD%E5%BB%BA/"/>
    <id>http://hackycy.github.io/2020/07/28/Shadowsocks科学上网搭建/</id>
    <published>2020-07-28T14:50:48.000Z</published>
    <updated>2021-10-09T02:19:57.249Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>最近某灯挂的厉害，导致访问Github等网站实在是太慢了。同事给了一些SSR的搭建方法。以此记录了下来。</p><a id="more"></a><h1 id="教程"><a href="#教程" class="headerlink" title="教程"></a>教程</h1><p><strong>选服务器</strong></p><p>我是使用<a href="https://www.vultr.com/" target="_blank" rel="noopener">vultr</a>，新建主机这里就不多详细叙述了。选择CentOS 7的即可。</p><p>新建主机后拿到IP地址查看下是否能够Ping通，Ping不同也无法使用SSH连接的。</p><p><strong>SSH连接后敲命令搭建好SSR的服务器环境：</strong></p><p><strong>CentOS:</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ yum install python-setuptools &amp;&amp; easy_install pip</span><br><span class="line">$ pip install shadowsocks</span><br></pre></td></tr></table></figure><p><strong>Debian / Ubuntu:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">apt-get install python-pip</span><br><span class="line">pip install shadowsocks</span><br></pre></td></tr></table></figure><p><strong>Windows:</strong></p><p>See <a href="https://github.com/shadowsocks/shadowsocks/wiki/Install-Shadowsocks-Server-on-Windows" target="_blank" rel="noopener">Install Server on Windows</a></p><p><strong>简单用法</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ssserver -p 443 -k password -m aes-256-cfb</span><br></pre></td></tr></table></figure><p><strong>后台运行</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo ssserver -p 443 -k password -m aes-256-cfb --user nobody -d start</span><br></pre></td></tr></table></figure><blockquote><p><code>-p</code>指定端口，<code>-k</code>指定密码，<code>-m</code>指定加密方式，客户端连接时都需要对应上</p></blockquote><p><strong>停止</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo ssserver -d stop</span><br></pre></td></tr></table></figure><p><strong>检查日志</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo less /var/<span class="built_in">log</span>/shadowsocks.log</span><br></pre></td></tr></table></figure><blockquote><p>通过检查所有选项-h。您也可以使用配置文件。</p></blockquote><p><strong>docker</strong></p><p>使用<a href="https://hub.docker.com/r/shadowsocks/shadowsocks-libev" target="_blank" rel="noopener">shadowsocks-libev</a>方式部署：</p><p>安装<code>yum-utils</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install -y yum-utils</span><br></pre></td></tr></table></figure><p>添加<code>docker yum</code>包</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">yum-config-manager \</span><br><span class="line">    --add-repo \</span><br><span class="line">    https://download.docker.com/linux/centos/docker-ce.repo</span><br></pre></td></tr></table></figure><p>安装最新版本的 <code>Docker Engine</code> 和<code>containerd</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install docker-ce docker-ce-cli containerd.io</span><br></pre></td></tr></table></figure><p>启动 Docker。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl start docker</span><br></pre></td></tr></table></figure><p>开机自启动</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl <span class="built_in">enable</span> docker</span><br></pre></td></tr></table></figure><p>通过运行<code>hello-world</code> 映像验证 Docker Engine 是否已正确安装。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run hello-world</span><br></pre></td></tr></table></figure><p>启动<code>ss-server</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker pull shadowsocks/shadowsocks-libev</span><br><span class="line">docker run -e PASSWORD=password -p 8388:8388 -p 8388:8388/udp -d shadowsocks/shadowsocks-libev</span><br></pre></td></tr></table></figure><blockquote><p>环境指定：</p><p>PASSWORD指定密码，METHOD指定加密方式，默认为<strong>aes-256-gcm</strong>，SERVER_PORT内置服务端口，默认为8388，请将主机端口映射至该端口即可。</p></blockquote><h1 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h1><p><a href="https://github.com/shadowsocks/shadowsocks-windows" target="_blank" rel="noopener">Windows</a> | <a href="https://github.com/shadowsocks/ShadowsocksX-NG" target="_blank" rel="noopener">OS X</a></p><p>打开小飞机，点击服务器，增加配置，根据服务器配置的填写即可。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://github.com/shadowsocksr-backup/shadowsocksr" target="_blank" rel="noopener">https://github.com/shadowsocksr-backup/shadowsocksr</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;最近某灯挂的厉害，导致访问Github等网站实在是太慢了。同事给了一些SSR的搭建方法。以此记录了下来。&lt;/p&gt;
    
    </summary>
    
      <category term="程序人生" scheme="http://hackycy.github.io/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/"/>
    
    
  </entry>
  
</feed>
