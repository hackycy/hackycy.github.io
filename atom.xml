<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>小小源Bの博客</title>
  
  <subtitle>zj&amp;ycy</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://hackycy.github.io/"/>
  <updated>2019-08-20T10:36:20.195Z</updated>
  <id>http://hackycy.github.io/</id>
  
  <author>
    <name>hackycy</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>IOS之App Store完整上架流程</title>
    <link href="http://hackycy.github.io/2019/08/20/IOS%E4%B9%8BApp-Store%E5%AE%8C%E6%95%B4%E4%B8%8A%E6%9E%B6%E6%B5%81%E7%A8%8B/"/>
    <id>http://hackycy.github.io/2019/08/20/IOS之App-Store完整上架流程/</id>
    <published>2019-08-20T08:59:20.000Z</published>
    <updated>2019-08-20T10:36:20.195Z</updated>
    
    <content type="html"><![CDATA[<p>最近在处理App Store上架的问题，和Android的打包流程比起来的确比较棘手些，因为涉及到很多的一些概念，现在也完整的梳理并记录一下。</p><a id="more"></a><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>发布上架都需要一个苹果开发者账号，免费的账号是有诸多限制的。</p><p><strong>苹果开发者帐号体系</strong></p><p><strong>Apple Developer：</strong>直接在<a href="https://link.juejin.im/?target=https%3A%2F%2Fdeveloper.apple.com%2F" target="_blank" rel="noopener">Apple Developer</a>登录，同意Apple Developer协议后的账号，免费，只可以使用Xcode进行真机调试，Xcode 7之后苹果推出的功能</p><p><strong>Apple Developer Program：</strong>分个人和组织类型，费用都是每年 99 美元，可以使用Xcode进行真机调试，打包Ad-Hoc测试，在App Store发布App</p><p><strong>Apple Developer Enterprise Program：</strong>企业账号，费用是每年 299 美元，可以使用Xcode进行真机调试，打包Ad-Hoc测试，打包In-House App，但不能在App Store发布App</p><p>不同安装方式对应的证书类型</p><ul><li>非App Store<ul><li>Development（真机调试）：iOS App Development</li><li>Ad Hoc：iOS Distribution (App Store and Ad Hoc)</li><li>Enterprise：iOS Distribution (In-House and Ad Hoc)</li></ul></li><li>App Store：iOS Distribution (App Store and Ad Hoc)</li></ul><p>在iOS的项目中，只要不是运行在模拟器上，都会涉及到开发者帐号、证书、<code>Provisioning Profile</code>这些概念。</p><p><strong>免费账号的限制：</strong></p><ul><li>创建的<code>Provisioning Profile</code>有效期只有7天</li><li>在7天内最多注册10个Bundle Id</li><li>只能同时注册3台iOS设备</li><li>在同一台iOS设备上，只能同时安装3个使用免费账号签名的App。当该设备上已经存在3个App，则无法安装任何免费账号签名的任何App，就算是那3个App其中一个也不行，只能先把其中一个删除</li></ul><blockquote><p>以下介绍是以我的Apple Developer Program个人账号来进行演示</p></blockquote><h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><p>证书、加密等原理这里不作介绍，主要讲解一些IOS所必要的概念。</p><h2 id="certSigningRequest"><a href="#certSigningRequest" class="headerlink" title=".certSigningRequest"></a>.certSigningRequest</h2><p>在<code>Mac</code>中的<code>钥匙串访问</code>里的 <code>证书助理 -&gt; 从证书颁发机构请求证书</code>：</p><p><img src="certSigningRequest.png" alt=""></p><p>最后会创建出一个<code>.certSigningRequest</code>文件，其实这个过程就是创建了一对公私钥</p><p><img src="certSigningRequest2.png" alt=""></p><ul><li>其中<code>.certSigningRequest</code>文件保存着<ul><li>申请者信息申请者的公钥</li><li>摘要算法</li><li>公钥加密算法</li></ul></li><li>私钥保存在 <code>keychain</code>中</li></ul><h2 id="AppleWWDRCA证书"><a href="#AppleWWDRCA证书" class="headerlink" title="AppleWWDRCA证书"></a>AppleWWDRCA证书</h2><p><code>iOS</code>以及 <code>mac OS</code>（在安装 Xcode 时）将自动安装 <code>AppleWWDRCA.cer</code>这个中间证书（Intermediate Certificates），它实际上就是 iOS（开发）证书的证书，即根证书（Apple Root Certificate）。</p><h2 id="iOS-App-Development证书"><a href="#iOS-App-Development证书" class="headerlink" title="iOS App Development证书"></a>iOS App Development证书</h2><p>iOS的开发证书，在开发阶段进行真机测试时需要用到的证书。可以在苹果开发网站上手动创建，需要上传<code>.certSigningRequest</code>文件；或者使用Xcode自动创建。</p><h2 id="iOS-Distribution证书"><a href="#iOS-Distribution证书" class="headerlink" title="iOS Distribution证书"></a>iOS Distribution证书</h2><p>iOS的发布证书，可以用于进行 <code>Ad Hoc</code> 测试、打包上传到 <code>App Store</code> 或者打包成 <code>Enterprisee（In-House）</code> 类型供企业内部使用。可以在苹果开发网站上手动创建，需要上传<code>.certSigningRequest</code>文件；或者使用Xcode自动创建。</p><h2 id="p12"><a href="#p12" class="headerlink" title=".p12"></a>.p12</h2><p>在<code>Mac</code>的<code>钥匙串访问</code>里选择一张证书，右击该证书，选择<code>导出&quot;xxxxx&quot;</code>，然后设置密码，可以导出该证书对应的<code>.p12</code>文件。<code>.p12</code>文件包含个人信息、公钥和私钥，也就是<code>证书 + 私钥</code>。iOS类型的每种证书同时存在数量有限制，而证书是依靠<code>mac OS</code>上的<code>.certSigningRequest</code>文件创建的，所以正常情况下，每种类型的证书只能在有限的Mac电脑上使用，如果需要在更多不同的Mac电脑上进行App开发、测试、签名，可以导出对应<code>.p12</code>文件代替证书来使用。</p><p><img src="p12.png" alt=""></p><h2 id="Provisioning-Profile"><a href="#Provisioning-Profile" class="headerlink" title="Provisioning Profile"></a>Provisioning Profile</h2><p><code>Provisioning Profile</code>的文件格式为<code>.mobileprovision</code>，里面包含着</p><ul><li>可以使用的证书</li><li>App ID，由 TeamID 和 BundleID 组合而成，类似于 <code>A1B2C3D4.com.domain.appName</code>形式</li><li>可安装该App的设备列表的UDID</li><li>Entitlements，授权文件，列出了App可以进行哪些行为</li><li>以上信息的签名</li></ul><p>在苹果开发网站上手动创建，或者使用Xcode自动创建。</p><h2 id="ipa"><a href="#ipa" class="headerlink" title=".ipa"></a>.ipa</h2><p><code>.ipa</code>文件是iOS上的App安装文件，其实它只是一个压缩包，等同于<code>.zip</code>格式，用<code>mac OS</code>自带的<code>归档实用工具</code>可以直接对它解压，可以看到里面的内容</p><p><img src="ipa.png" alt=""></p><h2 id="app"><a href="#app" class="headerlink" title=".app"></a>.app</h2><p>右击<code>.app</code>文件，选择<code>显示包内容</code>，可以看到里面的内容</p><p><img src="app.png" alt=""></p><p><code>.app</code>文件主要包含三部分：</p><ul><li><code>Mach-O</code>格式的二进制可执行文件，这个是一个App最重要的文件，我们编写的<code>Objective-C</code>、<code>Swift</code>代码都被编译在里面</li><li>资源文件，包括：<code>.bundle</code>文件，<code>.framework</code>文件，<code>.dylib</code>文件，<code>.nib</code>文件，图片文件，音视频文件，字体文件等所有项目用到的文件</li><li><code>CodeResources</code>，签名信息</li><li><code>embedded.mobileprovision</code>文件，或者<code>entitlements</code>文件<ul><li>对于没有上传App Store的<code>.app</code>文件，里面会包含<code>embedded.mobileprovision</code>文件，没有<code>entitlements</code>文件</li><li>App Store下载的<code>.app</code>文件，里面会包含<code>.entitlements</code>文件，没有<code>embedded.mobileprovision</code>文件</li></ul></li></ul><h1 id="Automatic-signing"><a href="#Automatic-signing" class="headerlink" title="Automatic signing"></a>Automatic signing</h1><p>在Xcode 7之前，只有加入到Apple Developer Program（即付费）才能进行真机调试，Xcode 7之后苹果推出了<code>Automatic signing</code>功能，只要在Xcode上登陆Apple ID，就会自动管理证书和Provisioning Profile，同时没有加入Apple Developer Program的账号也能进行真机调试。</p><p><img src="automanagesigning.png" alt=""></p><p>勾选Xcode中的<code>AutoMatically manager signing</code>，选择对应的<code>Team</code>后，无论是加入Apple Developer Program的账号（即付费账号）还是Apple Developer的账号（即免费账号）：</p><ul><li>如果Xcode没有帮该账号自动生成过<code>iOS App Development</code>类型的证书， 无论在苹果后台是否已经存在其他<code>iOS App Development</code>类型的证书，都会生成一张新的<code>iOS App Development</code>类型证书，证书名称的格式是：开发者账号名称(当前Mac电脑名称)， 如：Brian Hui (Daniels的MacBook Pro)，同时会保存在当前Mac电脑的<code>keychain</code>中</li><li>免费账号无法进入苹果的管理证书后台，但可以猜测出在苹果后台也会存在该证书</li><li>如果Xcode没有帮该App的Bundle ID自动生成过对应的<code>Provisioning Profile</code>，就会使用上面那张证书生成一个<code>Provisioning Profile</code>，保存在<code>~/Library/MobileDevice/Provisioning Profiles</code>，但在苹果后台则不会存在这个<code>Provisioning Profile</code></li><li>如果在<code>钥匙串访问</code>中删除了那张证书，Xcode会提示你的账号有<code>iOS App Development</code>类型的证书，但这台电脑没有安装，需要先把那张证书<code>Revoke</code>，<code>Revoke</code>后会再次重复前面的步骤，生成新的证书和<code>Provisioning Profile</code></li><li>如果在<code>~/Library/MobileDevice/Provisioning Profiles</code>里面，删除了该<code>Provisioning Profile</code>文件，Xcode会马上重新生成<code>Provisioning Profile</code></li></ul><p>在使用Xcode的<code>Automatic signing</code>功能的前提下，进行<code>Archive</code>，然后<code>Distribute App</code>的时候，选择非<code>Development</code>的选项，再选择AutoMatically manager signing</p><ul><li>如果本地存在<code>iOS Distribution</code>类型的证书，则会直接进行重签名</li><li>如果没有存在<code>iOS Distribution</code>类型的证书，而苹果的后台有，则会告诉你，该账号存在<code>iOS Distribution</code>类型的证书，但这台电脑没有安装，请联系创建人拿到备份（.p12文件）进行安装，当你安装了该证书（或者.p12文件），则会直接进行重签名</li><li>如果没有存在<code>iOS Distribution</code>类型的证书，而苹果的后台也没有，则Xcode会询问你是否需要生成<code>iOS Distribution</code>类型的证书，如果选择需要，则会自动生成<code>iOS Distribution</code>类型的证书，并且建议你保存在本地，证书名称的格式是：Team Name， 如：Hutchison Telephone (Macau) Company Limited，同时使用这张证书生成一个<code>Provisioning Profile</code>，保存在<code>~/Library/MobileDevice/Provisioning Profiles</code>，但在苹果后台则不会存在这个`Provisioning Profile。</li></ul><h1 id="App-Store上架打包流程"><a href="#App-Store上架打包流程" class="headerlink" title="App Store上架打包流程"></a>App Store上架打包流程</h1>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近在处理App Store上架的问题，和Android的打包流程比起来的确比较棘手些，因为涉及到很多的一些概念，现在也完整的梳理并记录一下。&lt;/p&gt;
    
    </summary>
    
      <category term="Ios" scheme="http://hackycy.github.io/categories/Ios/"/>
    
    
      <category term="Ios" scheme="http://hackycy.github.io/tags/Ios/"/>
    
  </entry>
  
  <entry>
    <title>QPS、TPS、PV、UV、GMV、IP、RPS概念解释</title>
    <link href="http://hackycy.github.io/2019/08/20/QPS%E3%80%81TPS%E3%80%81PV%E3%80%81UV%E3%80%81GMV%E3%80%81IP%E3%80%81RPS%E6%A6%82%E5%BF%B5%E8%A7%A3%E9%87%8A/"/>
    <id>http://hackycy.github.io/2019/08/20/QPS、TPS、PV、UV、GMV、IP、RPS概念解释/</id>
    <published>2019-08-20T02:36:54.000Z</published>
    <updated>2019-08-20T02:42:10.205Z</updated>
    
    <content type="html"><![CDATA[<p>之前看到一些QPS、TPS、PV等的一些名词，也还没清楚它们的意思，查了一下资料并记录一下。</p><a id="more"></a><h1 id="QPS"><a href="#QPS" class="headerlink" title="QPS"></a><strong>QPS</strong></h1><p>Queries Per Second，每秒查询数。每秒能够响应的查询次数。</p><p>QPS是对一个特定的查询服务器在规定时间内所处理流量多少的衡量标准，在因特网上，作为域名系统服务器的机器的性能经常用每秒查询率来衡量。每秒的响应请求数，也即是最大吞吐能力。</p><h1 id="TPS"><a href="#TPS" class="headerlink" title="TPS"></a><strong>TPS</strong></h1><p>Transactions Per Second 的缩写，每秒处理的事务数目。一个事务是指一个客户机向服务器发送请求然后服务器做出反应的过程。客户机在发送请求时开始计时，收到服务器响应后结束计时，以此来计算使用的时间和完成的事务个数，最终利用这些信息作出的评估分。</p><p>TPS 的过程包括：客户端请求服务端、服务端内部处理、服务端返回客户端。</p><p>例如，访问一个 Index 页面会请求服务器 3 次，包括一次 html，一次 css，一次 js，那么访问这一个页面就会产生一个“T”，产生三个“Q”。</p><h1 id="PV"><a href="#PV" class="headerlink" title="PV"></a><strong>PV</strong></h1><p>（page view）即页面浏览量，通常是衡量一个网络新闻频道或网站甚至一条网络新闻的主要指标。户每一次对网站中的每个页面访问均被记录 1 次。用户对同一页面的多次刷新，访问量累计。</p><p>根据这个特性，刷网站的 PV 就很好刷了。</p><p>与 PV 相关的还有 <strong>RV</strong>，即重复访问者数量（repeat visitors）。</p><h1 id="UV"><a href="#UV" class="headerlink" title="UV"></a><strong>UV</strong></h1><p>访问数（Unique Visitor）指独立访客访问数，统计1天内访问某站点的用户数(以 cookie 为依据)，一台电脑终端为一个访客。</p><h1 id="IP"><a href="#IP" class="headerlink" title="IP"></a><strong>IP</strong></h1><p>（Internet Protocol）独立 IP 数，是指 1 天内多少个独立的 IP 浏览了页面，即统计不同的 IP 浏览用户数量。同一 IP 不管访问了几个页面，独立 IP 数均为 1；不同的 IP 浏览页面，计数会加 1。IP 是基于用户广域网 IP 地址来区分不同的访问者的，所以，多个用户（多个局域网 IP）在同一个路由器（同一个广域网 IP）内上网，可能被记录为一个独立 IP 访问者。如果用户不断更换 IP，则有可能被多次统计。</p><h1 id="GMV"><a href="#GMV" class="headerlink" title="GMV"></a><strong>GMV</strong></h1><p>是 Gross Merchandise Volume 的简称。只要是订单，不管消费者是否付款、卖家是否发货、是否退货，都可放进 GMV 。</p><h1 id="RPS"><a href="#RPS" class="headerlink" title="RPS"></a><strong>RPS</strong></h1><p>代表吞吐率，即 Requests Per Second 的缩写。吞吐率是服务器并发处理能力的量化描述，单位是 reqs/s，指的是某个并发用户数下单位时间内处理的请求数。<br>某个并发用户数下单位时间内能处理的最大的请求数，称之为最大吞吐率。</p><blockquote><p>有人把 RPS 说等效于 QPS。其实可以看作同一个统计方式，只是叫法不同而已。RPS/QPS，可以使用 apche ab 工具进行测量。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;之前看到一些QPS、TPS、PV等的一些名词，也还没清楚它们的意思，查了一下资料并记录一下。&lt;/p&gt;
    
    </summary>
    
      <category term="程序人生" scheme="http://hackycy.github.io/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/"/>
    
    
      <category term="QPS、TPS、PV、UV、GMV、IP、RPS" scheme="http://hackycy.github.io/tags/QPS%E3%80%81TPS%E3%80%81PV%E3%80%81UV%E3%80%81GMV%E3%80%81IP%E3%80%81RPS/"/>
    
  </entry>
  
  <entry>
    <title>Android SharedPreferences使用</title>
    <link href="http://hackycy.github.io/2019/08/13/Android-SharedPreferences%E4%BD%BF%E7%94%A8/"/>
    <id>http://hackycy.github.io/2019/08/13/Android-SharedPreferences使用/</id>
    <published>2019-08-13T05:57:52.000Z</published>
    <updated>2019-08-13T08:46:52.767Z</updated>
    
    <content type="html"><![CDATA[<p>Sharedpreferences是Android平台上一个轻量级的存储类，用来保存应用程序的各种配置信息，其本质是一个以“键-值”对的方式保存数据的xml文件，其文件保存在<code>/data/data/${pkg}/shared_prefs</code>目录下。在全局变量上看，其优点是不会产生Application 、 静态变量的OOM（out of memory）和空指针问题，其缺点是效率没有上面的两种方法高。<strong>SharedPreferences实现是线程安全的，但不是进程安全的。</strong></p><a id="more"></a><h1 id="获取SharedPreferences"><a href="#获取SharedPreferences" class="headerlink" title="获取SharedPreferences"></a>获取SharedPreferences</h1><p>使用 SharedPreferences 来存储数据，首先需要获取到 SharedPreferences 对象。Android中主要提供了两种方法用于得到 SharedPreferences 对象。</p><h2 id="Context-类中的-getSharedPreferences-方法："><a href="#Context-类中的-getSharedPreferences-方法：" class="headerlink" title="Context 类中的 getSharedPreferences()方法："></a>Context 类中的 getSharedPreferences()方法：</h2><p>此方法接收两个参数，第一个参数用于指定 SharedPreferences 文件的名称，如果指定的文件不存在则会创建一个，第二个参数用于指定操作模式，主要有以下几种模式可以选择。<code>MODE_PRIVATE</code> 是默认的操作模式，和直接传入 0 效果是相同的。<br><code>MODE_WORLD_READABLE</code> 和 <code>MODE_WORLD_WRITEABLE</code> 这两种模式已在 Android 4.2 版本中被废弃。</p><ul><li><strong>Context.MODE_PRIVATE：</strong>为默认操作模式,代表该文件是私有数据,只能被应用本身访问,在该模式下,写入的内容会覆盖原文件的内容；</li><li><strong>Context.MODE_APPEND：</strong>模式会检查文件是否存在,存在就往文件追加内容,否则就创建新文件；</li><li><strong>Context.MODE_WORLD_READABLE：</strong>表示当前文件可以被其他应用读取；</li><li><strong>Context.MODE_WORLD_WRITEABLE：</strong>表示当前文件可以被其他应用写入；</li></ul><h2 id="PreferenceManager-类中的-getDefaultSharedPreferences-方法："><a href="#PreferenceManager-类中的-getDefaultSharedPreferences-方法：" class="headerlink" title="PreferenceManager 类中的 getDefaultSharedPreferences()方法："></a>PreferenceManager 类中的 getDefaultSharedPreferences()方法：</h2><p>这是一个静态方法，它接收一个 Context 参数，并自动使用当前应用程序的包名作为前缀来命名 SharedPreferences 文件。<del>[已废弃]</del></p><h1 id="SharedPreferences的使用"><a href="#SharedPreferences的使用" class="headerlink" title="SharedPreferences的使用"></a>SharedPreferences的使用</h1><p>SharedPreferences对象本身只能获取数据而不支持存储和修改,存储修改是通过SharedPreferences.edit()获取的内部接口Editor对象实现。</p><h2 id="存储数据"><a href="#存储数据" class="headerlink" title="存储数据"></a>存储数据</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SharedPreferences sp = getSharedPreferences(<span class="string">"user"</span>, Context.MODE_PRIVATE);</span><br><span class="line">SharedPreferences.Editor editor = sp.edit();</span><br><span class="line">editor.putBoolean(<span class="string">"isBoy"</span>, <span class="keyword">true</span>);</span><br><span class="line">editor.putString(<span class="string">"username"</span>, <span class="string">"xiaohong"</span>);</span><br><span class="line">editor.putInt(<span class="string">"wage"</span>, <span class="number">6000</span>);</span><br><span class="line">editor.commit();</span><br></pre></td></tr></table></figure><h2 id="读取数据"><a href="#读取数据" class="headerlink" title="读取数据"></a>读取数据</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SharedPreferences sp = getSharedPreferences(<span class="string">"user"</span>, Context.MODE_PRIVATE);</span><br><span class="line">String username = sp.getString(<span class="string">"username"</span>, <span class="string">""</span>);</span><br><span class="line"><span class="keyword">boolean</span> isBoy = sp.getBoolean(<span class="string">"isBoy"</span>, <span class="keyword">false</span>);</span><br><span class="line"><span class="keyword">int</span> wage = sp.getInt(<span class="string">"wage"</span>, <span class="number">0</span>);</span><br></pre></td></tr></table></figure><h2 id="删除指定数据"><a href="#删除指定数据" class="headerlink" title="删除指定数据"></a>删除指定数据</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SharedPreferences sp = getSharedPreferences(<span class="string">"user"</span>, Context.MODE_PRIVATE);</span><br><span class="line">SharedPreferences.Editor editor = sp.edit();</span><br><span class="line">editor.remove(<span class="string">"wage"</span>);</span><br><span class="line">editor.commit();</span><br></pre></td></tr></table></figure><h2 id="清空数据"><a href="#清空数据" class="headerlink" title="清空数据"></a>清空数据</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SharedPreferences sp = getSharedPreferences(<span class="string">"user"</span>, Context.MODE_PRIVATE);</span><br><span class="line">SharedPreferences.Editor editor = sp.edit();</span><br><span class="line">editor.clear();</span><br><span class="line">editor.commit();</span><br></pre></td></tr></table></figure><p><strong>注意</strong>：如果在 Fragment 中使用SharedPreferences 时，需要放在onAttach(Activity activity)里面进行SharedPreferences的初始化，否则会报空指针 即 getActivity()会可能返回null ！</p><h2 id="读写其他应用的SharedPreferences"><a href="#读写其他应用的SharedPreferences" class="headerlink" title="读写其他应用的SharedPreferences"></a>读写其他应用的SharedPreferences</h2><p> 1. 在创建SharedPreferences时，指定MODE_WORLD_READABLE模式，表明该SharedPreferences数据可以被其他程序读取；<br> 2. 创建其他应用程序对应的Context；<br> 3. 使用其他程序的Context获取对应的SharedPreferences；<br> 4. 如果是写入数据，使用Editor接口即可，所有其他操作均和前面一致；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">//这里的com.example.mpreferences 就是应用的包名</span></span><br><span class="line">  Context mcontext = createPackageContext(<span class="string">"com.example.mpreferences"</span>, CONTEXT_IGNORE_SECURITY);</span><br><span class="line">  SharedPreferences msharedpreferences = mcontext.getSharedPreferences(<span class="string">"name_preference"</span>, MODE_PRIVATE);</span><br><span class="line">  <span class="keyword">int</span> count = msharedpreferences.getInt(<span class="string">"count"</span>, <span class="number">0</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (PackageManager.NameNotFoundException e) &#123;</span><br><span class="line">  e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="SharedPreferences-Editor对象中commit和apply的区别"><a href="#SharedPreferences-Editor对象中commit和apply的区别" class="headerlink" title="SharedPreferences.Editor对象中commit和apply的区别"></a>SharedPreferences.Editor对象中commit和apply的区别</h1><ul><li>apply没有返回值而commit返回boolean表明修改是否提交成功 ；</li><li>commit是把内容同步提交到硬盘的，而apply先立即把修改提交到内存，然后开启一个异步的线程提交到硬盘，并且如果提交失败，你不会收到任何通知。</li><li>所有commit提交是同步过程，效率会比apply异步提交的速度慢，在不关心提交结果是否成功的情况下，优先考虑apply方法。</li><li>apply是使用异步线程写入磁盘，commit是同步写入磁盘。所以我们在主线程使用的commit的时候，需要考虑是否会出现ANR问题。（不适合大量数据存储）</li></ul><h1 id="查看Sharedpreferencesd-保存数据的xml文件"><a href="#查看Sharedpreferencesd-保存数据的xml文件" class="headerlink" title="查看Sharedpreferencesd 保存数据的xml文件"></a>查看Sharedpreferencesd 保存数据的xml文件</h1><p>模拟器下直接打开打开AS，找到窗口右下角的<code>Device File Explorer</code>进行查看：</p><p><img src="file.png" alt=""></p><blockquote><p>真机环境下需要root。</p></blockquote><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://juejin.im/post/5adc444df265da0b886d00bc" target="_blank" rel="noopener">https://juejin.im/post/5adc444df265da0b886d00bc</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Sharedpreferences是Android平台上一个轻量级的存储类，用来保存应用程序的各种配置信息，其本质是一个以“键-值”对的方式保存数据的xml文件，其文件保存在&lt;code&gt;/data/data/${pkg}/shared_prefs&lt;/code&gt;目录下。在全局变量上看，其优点是不会产生Application 、 静态变量的OOM（out of memory）和空指针问题，其缺点是效率没有上面的两种方法高。&lt;strong&gt;SharedPreferences实现是线程安全的，但不是进程安全的。&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="http://hackycy.github.io/categories/Android/"/>
    
    
      <category term="Android" scheme="http://hackycy.github.io/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>IOS之NSUserDefaults</title>
    <link href="http://hackycy.github.io/2019/08/12/IOS%E4%B9%8BNSUserDefaults/"/>
    <id>http://hackycy.github.io/2019/08/12/IOS之NSUserDefaults/</id>
    <published>2019-08-12T07:27:44.000Z</published>
    <updated>2019-08-13T04:38:11.928Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h1><p><code>NSUserDefaults</code>类提供了一个与默认系统交互的编程接口。默认系统允许应用程序自定义其行为以匹配用户的首选项。例如，您可以允许用户指定其首选的测量单位或媒体播放速度。应用程序通过为用户默认数据库中的一组参数指定值来存储这些首选项。这些参数被称为默认值，因为它们通常用于确定应用程序启动时的默认状态或默认情况下的行为方式。在运行时，使用<code>NSUserDefaults</code>对象从用户的默认数据库中读取应用程序使用的默认值。nsUserDefaults缓存信息，以避免每次需要默认值时都必须打开用户的默认数据库。当您设置默认值时，它会在您的进程内同步更改，并异步更改为持久存储和其他进程。</p><a id="more"></a><p><img src="overview.png" alt=""></p><p>如果是一些大型数据，毫无疑问是用一些SQLite或者FMDB等来存储大量数据。但是又一些轻量级别的数据，例如用户的信息、用户的偏好设置，使用该类是最为简单方便的。它通过键值对的方式来来存储一系列的偏好设置来把对象存储/读取相应的<code>plist</code>文件中。那么既然是一个<code>plist</code>，则NSUserDefaults能够存储的数据类型有<a href="https://developer.apple.com/documentation/foundation/nsdata?language=objc" target="_blank" rel="noopener"><code>NSData</code></a>, <a href="https://developer.apple.com/documentation/foundation/nsstring?language=objc" target="_blank" rel="noopener"><code>NSString</code></a>, <a href="https://developer.apple.com/documentation/foundation/nsnumber?language=objc" target="_blank" rel="noopener"><code>NSNumber</code></a>, <a href="https://developer.apple.com/documentation/foundation/nsdate?language=objc" target="_blank" rel="noopener"><code>NSDate</code></a>, <a href="https://developer.apple.com/documentation/foundation/nsarray?language=objc" target="_blank" rel="noopener"><code>NSArray</code></a>, 和<a href="https://developer.apple.com/documentation/foundation/nsdictionary?language=objc" target="_blank" rel="noopener"><code>NSDictionary</code></a>。如果需要存储某些不支持的类型，可以先将其归档为NSData类型再进行存储。</p><p><strong>NSUserDefaults</strong>是一个单例类，在整个程序运行过程中只有一个实例对象，同时也是线程安全的。获取方式：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSUserDefaults</span> *defaults = [<span class="built_in">NSUserDefaults</span> standardUserDefaults];</span><br></pre></td></tr></table></figure><h1 id="存储数据"><a href="#存储数据" class="headerlink" title="存储数据"></a>存储数据</h1><p>存储一些默认支持的数据类型：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//存储数据</span></span><br><span class="line">[defaults setObject:<span class="string">@"hackycy"</span> forKey:<span class="string">@"username"</span>];</span><br><span class="line">[defaults setInteger:<span class="number">22</span> forKey:<span class="string">@"age"</span>];</span><br><span class="line">[defaults setBool:<span class="literal">YES</span> forKey:<span class="string">@"isBoy"</span>];</span><br><span class="line">[defaults setFloat:<span class="number">1.73</span> forKey:<span class="string">@"mmForHeight"</span>];</span><br><span class="line">[defaults setURL:[<span class="built_in">NSURL</span> URLWithString:<span class="string">@"https://hackycy.github.io"</span>] forKey:<span class="string">@"blog"</span>];</span><br><span class="line">[defaults setDouble:<span class="number">7500</span> forKey:<span class="string">@"wage"</span>];</span><br></pre></td></tr></table></figure><p><strong>更多方法</strong></p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Setting Default Values</span></span><br><span class="line">- setObject:forKey:</span><br><span class="line"><span class="comment">//Sets the value of the specified default key.</span></span><br><span class="line"></span><br><span class="line">- setFloat:forKey:</span><br><span class="line"><span class="comment">//Sets the value of the specified default key to the specified float value.</span></span><br><span class="line"></span><br><span class="line">- setDouble:forKey:</span><br><span class="line"><span class="comment">//Sets the value of the specified default key to the double value.</span></span><br><span class="line"></span><br><span class="line">- setInteger:forKey:</span><br><span class="line"><span class="comment">//Sets the value of the specified default key to the specified integer value.</span></span><br><span class="line"></span><br><span class="line">- setBool:forKey:</span><br><span class="line"><span class="comment">//Sets the value of the specified default key to the specified Boolean value.</span></span><br><span class="line"></span><br><span class="line">- setURL:forKey:</span><br><span class="line"><span class="comment">//Sets the value of the specified default key to the specified URL.</span></span><br></pre></td></tr></table></figure><h1 id="读取数据"><a href="#读取数据" class="headerlink" title="读取数据"></a>读取数据</h1><p>从上面存储的数据中读取并打印：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取数据   </span></span><br><span class="line"><span class="built_in">NSString</span> *username = [defaults stringForKey:<span class="string">@"username"</span>];</span><br><span class="line"><span class="built_in">NSInteger</span> age = [defaults integerForKey:<span class="string">@"age"</span>];</span><br><span class="line"><span class="built_in">BOOL</span> isBoy = [defaults boolForKey:<span class="string">@"isBoy"</span>];</span><br><span class="line"><span class="keyword">float</span> mmForHeight = [defaults floatForKey:<span class="string">@"mmForHeight"</span>];</span><br><span class="line"><span class="built_in">NSURL</span> *blog = [defaults URLForKey:<span class="string">@"blog"</span>];</span><br><span class="line"><span class="keyword">double</span> wage = [defaults doubleForKey:<span class="string">@"wage"</span>];</span><br><span class="line"><span class="built_in">NSData</span> *imageData = [defaults objectForKey:<span class="string">@"avatar"</span>];</span><br><span class="line"><span class="keyword">self</span>.imageView.image = [<span class="built_in">UIImage</span> imageWithData:imageData];</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"username : %@, age : %lu, isBoy : %@, mmForHeight : %f, blog : %@, wage : %f"</span>, username, (<span class="keyword">unsigned</span> <span class="keyword">long</span>)age, isBoy ? <span class="string">@"boy"</span> : <span class="string">@"girl"</span>, mmForHeight, blog, wage);</span><br></pre></td></tr></table></figure><p><strong>更多方法</strong></p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Getting Default Values</span></span><br><span class="line">- objectForKey:</span><br><span class="line"><span class="comment">//Returns the object associated with the specified key.</span></span><br><span class="line"></span><br><span class="line">- URLForKey:</span><br><span class="line"><span class="comment">//Returns the URL associated with the specified key.</span></span><br><span class="line"></span><br><span class="line">- arrayForKey:</span><br><span class="line"><span class="comment">//Returns the array associated with the specified key.</span></span><br><span class="line"></span><br><span class="line">- dictionaryForKey:</span><br><span class="line"><span class="comment">//Returns the dictionary object associated with the specified key.</span></span><br><span class="line"></span><br><span class="line">- stringForKey:</span><br><span class="line"><span class="comment">//Returns the string associated with the specified key.</span></span><br><span class="line"></span><br><span class="line">- stringArrayForKey:</span><br><span class="line"><span class="comment">//Returns the array of strings associated with the specified key.</span></span><br><span class="line"></span><br><span class="line">- dataForKey:</span><br><span class="line"><span class="comment">//Returns the data object associated with the specified key.</span></span><br><span class="line"></span><br><span class="line">- boolForKey:</span><br><span class="line"><span class="comment">//Returns the Boolean value associated with the specified key.</span></span><br><span class="line"></span><br><span class="line">- integerForKey:</span><br><span class="line"><span class="comment">//Returns the integer value associated with the specified key.</span></span><br><span class="line"></span><br><span class="line">- floatForKey:</span><br><span class="line"><span class="comment">//Returns the float value associated with the specified key.</span></span><br><span class="line"></span><br><span class="line">- doubleForKey:</span><br><span class="line"><span class="comment">//Returns the double value associated with the specified key.</span></span><br><span class="line"></span><br><span class="line">- dictionaryRepresentation</span><br><span class="line"><span class="comment">//Returns a dictionary that contains a union of all key-value pairs in the domains in the search list.</span></span><br></pre></td></tr></table></figure><h1 id="registerDefaults"><a href="#registerDefaults" class="headerlink" title="registerDefaults"></a>registerDefaults</h1><p>先让我们来看一种情况：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">BOOL</span> isNeedShowGuide = [defaults boolForKey:<span class="string">@"isNeedShowGuide"</span>];</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, isNeedShowGuide ? <span class="string">@"YES"</span> : <span class="string">@"NO"</span>);</span><br></pre></td></tr></table></figure><p>LOG：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2019</span><span class="number">-08</span><span class="number">-13</span> <span class="number">11</span>:<span class="number">54</span>:<span class="number">29.402946</span>+<span class="number">0800</span> nsuserdefaultdemo[<span class="number">4616</span>:<span class="number">174076</span>] <span class="literal">NO</span></span><br></pre></td></tr></table></figure><p>当我们APP首次启动时需要进入一个引导页，通过该<code>isNeedShowGuide</code>来判断是否进入引导页，而首次进入是需要YES的情况下进入引导页，后续将值设置为NO。但是通过打印该值时获取到的不是我们想要的值，因为该值如果设置过才会运行正确。但是没有设置过该值也没有该默认值则默认返回的是NO。</p><p>那么这里就需要用到<code>registerDefaults</code>方法了：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[[<span class="built_in">NSUserDefaults</span> standardUserDefaults] registerDefaults:@&#123;</span><br><span class="line">    <span class="string">@"isNeedShowGuide"</span> : @YES</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><p>我们在获取<code>isNeedShowGuide</code>之前先调用了<code>registerDefaults</code>方法设置了它的默认值，后面获取的时候即使没有再设置值也会获取到默认设置的值，就不会出现上述获取默认值尴尬的情况了。</p><p>当然我们也可以先默认保存一个plist文件在项目目录中来设置默认值来方便读取，来减少代码量：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSURL</span> *plistUrl = [[<span class="built_in">NSBundle</span> mainBundle] URLForResource:<span class="string">@"DefaultPreferences"</span> withExtension:<span class="string">@"plist"</span>];</span><br><span class="line"><span class="built_in">NSDictionary</span> *defaultPreferences = [<span class="built_in">NSDictionary</span> dictionaryWithContentsOfURL:plistUrl];</span><br><span class="line">[[<span class="built_in">NSUserDefaults</span> standardUserDefaults] registerDefaults:defaultPreferences];</span><br></pre></td></tr></table></figure><p><strong>注意：</strong><code>registerDefaults</code> 设置的默认值是不会持久化存储的，也就是说我们每次启动 APP 的时候，都需要这样设置一遍。所以<code>application:didFinishLaunchingWithOptions</code>是最合适的地方。</p><h1 id="NSUserDefaults域"><a href="#NSUserDefaults域" class="headerlink" title="NSUserDefaults域"></a>NSUserDefaults域</h1><p>NSUserDefaults 还有一个 Domain 的概念，当我们调用 <code>[NSUserDefaults standardUserDefaults]</code>方法时，就会初始化 <code>NSUserDefaults</code>， 并且它默认会包含 5 个 Domain， 分别是：</p><ul><li><strong>NSArgumentDomain</strong>：最高优先权</li><li><strong>Application</strong>：它存储着你app通过<code>NSUserDefaults set...forKey</code>添加的设置</li><li><strong>NSGlobalDomain</strong>：存储着系统的设置</li><li><strong>Languages</strong>：包括地区、日期等</li><li><strong>NSRegistrationDomain</strong>：仅有较低的优先权，只有在应用域没有找到值时才从注册域去寻找。</li></ul><p>来解释一下，比如调用了下面的一个方法：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[[<span class="built_in">NSUserDefaults</span> standardUserDefaults] setBool:<span class="literal">NO</span> forKey:<span class="string">@"isNeedShowGuide"</span>];</span><br></pre></td></tr></table></figure><p>这句话会将设置的key和值存储在了<code>Application</code>域中，但 <code>NSUserDefaults</code> 还包括了其他 4 个域，如果我们每次调用读取数据的方法的时候，例如：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[[<span class="built_in">NSUserDefaults</span> standardUserDefaults] boolForKey:<span class="string">@"isNeedShowGuide"</span>]</span><br></pre></td></tr></table></figure><p>那么其实底层的就会进行一次搜索，搜索顺序为：</p><p><code>NSArgumentDomain</code> -&gt; <code>Application</code> -&gt; <code>NSGlobalDomain</code> -&gt; <code>Languages</code> -&gt; <code>NSRegistrationDomain</code></p><p>而之前举的例子来说，我们并没有通过<code>setBool:forkey:</code>方法来设置该值，所以<code>Application</code>域中并没有该值，但是我们使用了<code>registerDefaults</code>将它设置到了<code>NSRegistrationDomain</code>域中。</p><p>所以按照<code>NSUserDefaults</code> 的默认搜索顺序，就会找到最后 <code>NSRegistrationDomain</code> 域中的那个 <code>isNeedShowGuide</code>， 也就是我们所谓的默认值 YES 了。</p><h1 id="存储路径"><a href="#存储路径" class="headerlink" title="存储路径"></a>存储路径</h1><p>NSUserDefaults 数据存放在沙盒 <code>Library/Preferences/</code> 目录下，一个以你包名命名的<code>.plist</code>文件。</p><p>通过代码获取路径后：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSString</span> *path = <span class="built_in">NSHomeDirectory</span>();</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"path : %@"</span>, path);</span><br></pre></td></tr></table></figure><p>将路径复制到Finder中，前往：</p><p><img src="cunchu.png" alt=""></p><h1 id="关于synchronize方法"><a href="#关于synchronize方法" class="headerlink" title="关于synchronize方法"></a>关于synchronize方法</h1><p>该方法是为了强制存储，但其实是没有必要的，该方法系统会默认调用。</p><blockquote><p>Waits for any pending asynchronous updates to the defaults database and returns; this method is unnecessary and shouldn’t be used.</p><p>等待默认数据库的任何挂起的异步更新并返回; 此方法是不必要的，不应使用。</p></blockquote><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="https://developer.apple.com/documentation/foundation/nsuserdefaults?language=objc" target="_blank" rel="noopener">https://developer.apple.com/documentation/foundation/nsuserdefaults?language=objc</a></p><p><a href="http://swiftcafe.io/post/nsuserdefaults" target="_blank" rel="noopener">http://swiftcafe.io/post/nsuserdefaults</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;概览&quot;&gt;&lt;a href=&quot;#概览&quot; class=&quot;headerlink&quot; title=&quot;概览&quot;&gt;&lt;/a&gt;概览&lt;/h1&gt;&lt;p&gt;&lt;code&gt;NSUserDefaults&lt;/code&gt;类提供了一个与默认系统交互的编程接口。默认系统允许应用程序自定义其行为以匹配用户的首选项。例如，您可以允许用户指定其首选的测量单位或媒体播放速度。应用程序通过为用户默认数据库中的一组参数指定值来存储这些首选项。这些参数被称为默认值，因为它们通常用于确定应用程序启动时的默认状态或默认情况下的行为方式。在运行时，使用&lt;code&gt;NSUserDefaults&lt;/code&gt;对象从用户的默认数据库中读取应用程序使用的默认值。nsUserDefaults缓存信息，以避免每次需要默认值时都必须打开用户的默认数据库。当您设置默认值时，它会在您的进程内同步更改，并异步更改为持久存储和其他进程。&lt;/p&gt;
    
    </summary>
    
      <category term="Ios" scheme="http://hackycy.github.io/categories/Ios/"/>
    
    
      <category term="Ios" scheme="http://hackycy.github.io/tags/Ios/"/>
    
  </entry>
  
  <entry>
    <title>Android TextView更换字体</title>
    <link href="http://hackycy.github.io/2019/08/07/Android-TextView%E6%9B%B4%E6%8D%A2%E5%AD%97%E4%BD%93/"/>
    <id>http://hackycy.github.io/2019/08/07/Android-TextView更换字体/</id>
    <published>2019-08-07T06:52:47.000Z</published>
    <updated>2019-08-07T08:04:45.021Z</updated>
    
    <content type="html"><![CDATA[<p>在开发UI时有时会涉及到TextView设置字体样式，TextView中在xml下仅可以设置自带的字体样式：</p><a id="more"></a><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">android:typeface="monospace"</span><br></pre></td></tr></table></figure><p>自带有四种文字类型，分别是：</p><ul><li>monospace</li><li>normal</li><li>sans</li><li>serif</li></ul><p>看看运行效果后的样式：</p><p><img src="systtf.png" alt=""></p><p>有时候UI需要设定特定字体的时候，我们可以给在代码中TextView设置特定的字体。</p><p>比如我们随便下载一些字体：<a href="https://www.sentyfont.com/download.htm" target="_blank" rel="noopener">https://www.sentyfont.com/download.htm</a></p><p>放在Assets目录下：</p><p><img src="demo1.png" alt=""></p><blockquote><p>注意留意目录结构，demo将字体文件放在了fonts目录下</p></blockquote><p>然后在代码中设置：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">TextView tv = findViewById(R.id.tv);</span><br><span class="line">Typeface tf = Typeface.createFromAsset(<span class="keyword">this</span>.getAssets(), <span class="string">"fonts/HanyiSentyVimalkirti.ttf"</span>);</span><br><span class="line">tv.setTypeface(tf);</span><br></pre></td></tr></table></figure><p>运行效果：</p><p><img src="demo2.png" alt=""></p><blockquote><p>字体文件otf等都支持。</p><p>字体包过大可以将使用到的字提取出来，不用将所有字体都打包成一个ttf。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在开发UI时有时会涉及到TextView设置字体样式，TextView中在xml下仅可以设置自带的字体样式：&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="http://hackycy.github.io/categories/Android/"/>
    
    
      <category term="Android" scheme="http://hackycy.github.io/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Android 软键盘imeOptions事件响应</title>
    <link href="http://hackycy.github.io/2019/07/31/Android-%E8%BD%AF%E9%94%AE%E7%9B%98imeOptions%E4%BA%8B%E4%BB%B6%E5%93%8D%E5%BA%94/"/>
    <id>http://hackycy.github.io/2019/07/31/Android-软键盘imeOptions事件响应/</id>
    <published>2019-07-31T04:17:22.000Z</published>
    <updated>2019-07-31T07:41:26.883Z</updated>
    
    <content type="html"><![CDATA[<p>在一些登陆，搜索的过程中，输入框在用户输入完后点击软键盘的回车、搜索等的按钮即可完成登陆或者搜索的功能，不必要再让用户再次点击页面上的登陆或者搜索按钮才能够进行操作。</p><a id="more"></a><h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>用图来说话吧，下图是一个高德地图的一个搜索框：</p><p><img src="demo.png" alt=""></p><p>你们会发现并没有搜索按钮，而是在键盘的右下角有一个小图标(放大镜图标或者搜索字样)，这代表的是搜索的动作，点击后就可以进行搜索。</p><p>而在一个浏览器下的一个输入框时，软键盘也会有相对应的变化，如下图：</p><p><img src="demo2.png" alt=""></p><p>填写网址后点击软键盘的转到即可到达输入的网页。</p><h1 id="imeOptions"><a href="#imeOptions" class="headerlink" title="imeOptions"></a>imeOptions</h1><p>上面概述上的两个功能使得EditText拥有图标变化的能力就是<code>android:imeOptions</code>属性。</p><p>而EditorInfo类源码中一共提供了以下属性供我们选择</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> IME_ACTION_DONE = <span class="number">6</span>; <span class="comment">//对应actionDone</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> IME_ACTION_GO = <span class="number">2</span>;  <span class="comment">//对应actionGo</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> IME_ACTION_NEXT = <span class="number">5</span>;  <span class="comment">//对应actionNext</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> IME_ACTION_NONE = <span class="number">1</span>;  <span class="comment">//对应actionNone</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> IME_ACTION_PREVIOUS = <span class="number">7</span>;  <span class="comment">//对应actionPrevious</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> IME_ACTION_SEARCH = <span class="number">3</span>;  <span class="comment">//对应actionSearch</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> IME_ACTION_SEND = <span class="number">4</span>;  <span class="comment">//对应actionSearch</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> IME_ACTION_UNSPECIFIED = <span class="number">0</span>;  <span class="comment">//对应actionUnspecified</span></span><br></pre></td></tr></table></figure><p>我们在xml中编写对应的EditText，来直接演示下理解它们的实用意义：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ScrollView</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:app</span>=<span class="string">"http://schemas.android.com/apk/res-auto"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:tools</span>=<span class="string">"http://schemas.android.com/tools"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">tools:context</span>=<span class="string">".MainActivity"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">LinearLayout</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:orientation</span>=<span class="string">"vertical"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">EditText</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:id</span>=<span class="string">"@+id/actionGo"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:imeOptions</span>=<span class="string">"actionGo"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:hint</span>=<span class="string">"actionGo"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:singleLine</span>=<span class="string">"true"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_height</span>=<span class="string">"45dp"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">EditText</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:id</span>=<span class="string">"@+id/actionSearch"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:imeOptions</span>=<span class="string">"actionSearch"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:hint</span>=<span class="string">"actionSearch"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:singleLine</span>=<span class="string">"true"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_height</span>=<span class="string">"45dp"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">EditText</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:id</span>=<span class="string">"@+id/actionNext"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:imeOptions</span>=<span class="string">"actionNext"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:hint</span>=<span class="string">"actionNext"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:singleLine</span>=<span class="string">"true"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_height</span>=<span class="string">"45dp"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">EditText</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:id</span>=<span class="string">"@+id/actionNone"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:imeOptions</span>=<span class="string">"actionNone"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:hint</span>=<span class="string">"actionNone"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:singleLine</span>=<span class="string">"true"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_height</span>=<span class="string">"45dp"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">EditText</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:id</span>=<span class="string">"@+id/actionDone"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:imeOptions</span>=<span class="string">"actionDone"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:hint</span>=<span class="string">"actionDone"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:singleLine</span>=<span class="string">"true"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_height</span>=<span class="string">"45dp"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">EditText</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:id</span>=<span class="string">"@+id/actionSend"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:imeOptions</span>=<span class="string">"actionSend"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:hint</span>=<span class="string">"actionSend"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:singleLine</span>=<span class="string">"true"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_height</span>=<span class="string">"45dp"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">EditText</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:id</span>=<span class="string">"@+id/actionPrevious"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:imeOptions</span>=<span class="string">"actionPrevious"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:hint</span>=<span class="string">"actionPrevious"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:singleLine</span>=<span class="string">"true"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_height</span>=<span class="string">"45dp"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">EditText</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:id</span>=<span class="string">"@+id/actionUnspecified"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:imeOptions</span>=<span class="string">"actionUnspecified"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:hint</span>=<span class="string">"actionUnspecified"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:singleLine</span>=<span class="string">"true"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_height</span>=<span class="string">"45dp"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ScrollView</span>&gt;</span></span><br></pre></td></tr></table></figure><p>运行效果：</p><p><img src="demo3.png" alt=""></p><blockquote><p><strong>注意：该属性必须配置<code>android:singleLine=&quot;true&quot;</code>属性或者配合<code>android:maxLines=&quot;1&quot;</code>与<code>android:inputType=&quot;number&quot;</code>结合使用。缺一不可。即便singleLine已经被废弃，又或者单纯使用maxLines是无效的。</strong></p></blockquote><p>对EditText指定不同的imeOptions之后，就需要实现OnEditorActionListener 中的onEditorAction()方法，然后根据不同的动作执行进行响应。 </p><p>对于actionDone、actionNext和actionPrevious，系统都自己进行了部分处理。 </p><ul><li>actionDone：隐藏输入法 </li><li>actionNext：跳到下一个EditText </li><li>actionPrevious：跳到上一个EditText</li></ul><p>我们使用案例中实现以一个搜索的例子实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> EditText actionSearch;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">        actionSearch = findViewById(R.id.actionSearch);</span><br><span class="line"></span><br><span class="line">        actionSearch.setOnEditorActionListener(<span class="keyword">new</span> TextView.OnEditorActionListener() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onEditorAction</span><span class="params">(TextView textView, <span class="keyword">int</span> actionId, KeyEvent keyEvent)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(actionId == EditorInfo.IME_ACTION_SEARCH) &#123;</span><br><span class="line">                    <span class="keyword">if</span>(actionSearch.getText().toString().isEmpty()) &#123;</span><br><span class="line">                        Toast.makeText(MainActivity.<span class="keyword">this</span>, <span class="string">"内容不能为空"</span>, Toast.LENGTH_SHORT).show();</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        Toast.makeText(MainActivity.<span class="keyword">this</span>, <span class="string">"您搜索的内容是："</span> + actionSearch.getText().toString(), Toast.LENGTH_SHORT).show();</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//只负责搜索事件处理，其他处理交回到系统的默认处理</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行效果：</p><p><img src="demo4.png" alt=""></p><blockquote><p>部分第三方的输入法，对EditorInfo支持的不一样，有的功能实现了，但是对应的图标没有修改过来，有的干脆功能就没有实现。</p></blockquote><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p><code>actionDone</code>  - 完成 - 对应 <code>EditorInfo.IME_ACTION_DONE</code><br><code>actionGo</code> - 前进 - 对应 <code>EditorInfo.IME_ACTION_GO</code><br><code>actionNext</code> - 下一项 - 对应 <code>EditorInfo.IME_ACTION_NEXT</code><br><code>actionNone</code> - 无动作 - 对应 <code>EditorInfo.IME_ACTION_NONE</code><br><code>actionPrevious</code> - 上一项 - 对应 <code>EditorInfo.IME_ACTION_PREVIOUS</code><br><code>actionSearch</code> - 搜索 - 对应 <code>EditorInfo.IME_ACTION_SEARCH</code><br><code>actionUnspecified</code> - 未指定 - <code>对应 EditorInfo.IME_ACTION_UNSPECIFIED</code><br><code>actionSend</code> - 发送 - 对应 <code>EditorInfo.IME_ACTION_SEND</code></p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://blog.csdn.net/liuweiballack/article/details/46708697" target="_blank" rel="noopener">https://blog.csdn.net/liuweiballack/article/details/46708697</a></p><p><a href="https://www.jianshu.com/p/d5c419bb4e19" target="_blank" rel="noopener">https://www.jianshu.com/p/d5c419bb4e19</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在一些登陆，搜索的过程中，输入框在用户输入完后点击软键盘的回车、搜索等的按钮即可完成登陆或者搜索的功能，不必要再让用户再次点击页面上的登陆或者搜索按钮才能够进行操作。&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="http://hackycy.github.io/categories/Android/"/>
    
    
      <category term="Android" scheme="http://hackycy.github.io/tags/Android/"/>
    
      <category term="EditText" scheme="http://hackycy.github.io/tags/EditText/"/>
    
  </entry>
  
  <entry>
    <title>IOS之UITableView使用</title>
    <link href="http://hackycy.github.io/2019/07/18/IOS%E4%B9%8BUITableView%E4%BD%BF%E7%94%A8/"/>
    <id>http://hackycy.github.io/2019/07/18/IOS之UITableView使用/</id>
    <published>2019-07-18T08:05:35.000Z</published>
    <updated>2019-08-06T03:06:44.744Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h1><p>iOS的<code>UITableView</code>显示单列垂直滚动内容。表格中的每一行都包含一段应用内容。例如，“联系人”应用程序在单独的行中显示每个联系人的姓名，“设置”应用程序的主页面显示可用的设置组。您可以将表配置为显示单个长行列表，也可以将相关行分组为多个部分，以便更轻松地导航内容。</p><a id="more"></a><p><img src="tableviewpreview.png" alt=""></p><h1 id="UITableView"><a href="#UITableView" class="headerlink" title="UITableView"></a><a href="https://developer.apple.com/documentation/uikit/uitableview" target="_blank" rel="noopener">UITableView</a></h1><p><code>UITableView</code>管理表的基本外观，但应用程序提供显示实际内容的单元格（对象）。标准单元格配置显示文本和图像的简单组合，但您可以定义显示所需内容的自定义单元格。您还可以提供页眉和页脚视图，以便为单元格组提供其他信息。</p><p><code>UITableView</code>有两种风格：<code>UITableViewStylePlain</code>和<code>UITableViewStyleGrouped</code>。这两者操作起来其实并没有本质区别，只是后者按分组样式显示前者按照普通样式显示而已。大家先看一下两者的应用：</p><p><img src="groupandnonggroup.png" alt=""></p><p><strong>UITableView的层次结构</strong></p><p><img src="tableviewintro.png" alt=""></p><h2 id="类方法"><a href="#类方法" class="headerlink" title="类方法"></a>类方法</h2><h3 id="创建表视图"><a href="#创建表视图" class="headerlink" title="创建表视图"></a>创建表视图</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">init</span>(frame: <span class="type">CGRect</span>, style: <span class="type">UITableView</span>.<span class="type">Style</span>)</span><br><span class="line"><span class="comment">//初始化并返回具有给定框架和样式的表视图对象。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">init</span>?(coder: <span class="type">NSCoder</span>)</span><br></pre></td></tr></table></figure><h3 id="提供表格的数据和单元格"><a href="#提供表格的数据和单元格" class="headerlink" title="提供表格的数据和单元格"></a>提供表格的数据和单元格</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> dataSource: <span class="type">UITableViewDataSource</span>?</span><br><span class="line"><span class="comment">//充当表视图数据源的对象。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> prefetchDataSource: <span class="type">UITableViewDataSourcePrefetching</span>?</span><br><span class="line"><span class="comment">//充当表视图的预取数据源的对象，接收即将到来的单元数据要求的通知。</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">UITableViewDataSource</span></span></span><br><span class="line"><span class="class">//您用于管理数据并为表视图提供单元格的对象采用的方法。</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">protocol</span> <span class="title">UITableViewDataSourcePrefetching</span></span></span><br><span class="line"><span class="class">//一种协议，提供表视图数据要求的预先警告，允许您尽早启动可能长时间运行的数据操作。</span></span><br></pre></td></tr></table></figure><h3 id="重用表视图单元格"><a href="#重用表视图单元格" class="headerlink" title="重用表视图单元格"></a>重用表视图单元格</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">register</span><span class="params">(UINib?, forCellReuseIdentifier: String)</span></span></span><br><span class="line"><span class="comment">//注册包含具有指定标识符下的表视图的单元格的nib对象。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">register</span><span class="params">(AnyClass?, forCellReuseIdentifier: String)</span></span></span><br><span class="line"><span class="comment">//注册用于创建新表格单元格的类。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">dequeueReusableCell</span><span class="params">(withIdentifier: String, <span class="keyword">for</span>: IndexPath)</span></span> -&gt; <span class="type">UITableViewCell</span></span><br><span class="line"><span class="comment">//返回指定重用标识符的可重用表视图单元对象，并将其添加到表中。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">dequeueReusableCell</span><span class="params">(withIdentifier: String)</span></span> -&gt; <span class="type">UITableViewCell</span>?</span><br><span class="line"><span class="comment">//返回按其标识符定位的可重用表视图单元对象。</span></span><br></pre></td></tr></table></figure><h3 id="重用部分页眉和页脚"><a href="#重用部分页眉和页脚" class="headerlink" title="重用部分页眉和页脚"></a>重用部分页眉和页脚</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">register</span><span class="params">(UINib?, forHeaderFooterViewReuseIdentifier: String)</span></span></span><br><span class="line"><span class="comment">//使用指定标识符下的表视图注册包含页眉或页脚的nib对象。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">register</span><span class="params">(AnyClass?, forHeaderFooterViewReuseIdentifier: String)</span></span></span><br><span class="line"><span class="comment">//注册一个类，用于创建新的表头或页脚视图。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">dequeueReusableHeaderFooterView</span><span class="params">(withIdentifier: String)</span></span> -&gt; <span class="type">UITableViewHeaderFooterView</span>?</span><br><span class="line"><span class="comment">//返回由其标识符定位的可重用页眉或页脚视图。</span></span><br></pre></td></tr></table></figure><h3 id="管理与表的交互"><a href="#管理与表的交互" class="headerlink" title="管理与表的交互"></a>管理与表的交互</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> delegate: <span class="type">UITableViewDelegate</span>?</span><br><span class="line"><span class="comment">//充当表视图委托的对象。</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">UITableViewDelegate</span></span></span><br><span class="line"><span class="class">//管理选择，配置节页眉和页脚，删除和重新排序单元格以及在表格视图中执行其他操作的方法。</span></span><br></pre></td></tr></table></figure><h3 id="配置表的外观"><a href="#配置表的外观" class="headerlink" title="配置表的外观"></a>配置表的外观</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> style: <span class="type">UITableView</span>.<span class="type">Style</span></span><br><span class="line"><span class="comment">//表格视图的样式。</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">UITableView</span>.<span class="title">Style</span></span></span><br><span class="line"><span class="class">//表视图样式的常量。</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">var</span> <span class="title">tableHeaderView</span>: <span class="title">UIView</span>?</span></span><br><span class="line"><span class="class">//显示在表格内容上方的视图。</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">var</span> <span class="title">tableFooterView</span>: <span class="title">UIView</span>?</span></span><br><span class="line"><span class="class">//显示在表格内容下方的视图。</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">var</span> <span class="title">backgroundView</span>: <span class="title">UIView</span>?</span></span><br><span class="line"><span class="class">//表视图的背景视图。</span></span><br></pre></td></tr></table></figure><h3 id="配置单元格高度和布局"><a href="#配置单元格高度和布局" class="headerlink" title="配置单元格高度和布局"></a>配置单元格高度和布局</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> rowHeight: <span class="type">CGFloat</span></span><br><span class="line"><span class="comment">//表视图中每行的默认高度（以磅为单位）。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> estimatedRowHeight: <span class="type">CGFloat</span></span><br><span class="line"><span class="comment">//表视图中行的估计高度。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> cellLayoutMarginsFollowReadableWidth: <span class="type">Bool</span></span><br><span class="line"><span class="comment">//一个布尔值，指示单元格边距是否从可读内容指南的宽度派生。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> insetsContentViewsToSafeArea: <span class="type">Bool</span></span><br><span class="line"><span class="comment">//一个布尔值，指示表视图是否将其内容视图重新定位在当前安全区域内。</span></span><br></pre></td></tr></table></figure><h3 id="配置页眉和页脚高度"><a href="#配置页眉和页脚高度" class="headerlink" title="配置页眉和页脚高度"></a>配置页眉和页脚高度</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> sectionHeaderHeight: <span class="type">CGFloat</span></span><br><span class="line"><span class="comment">//表视图中节标题的高度。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> sectionFooterHeight: <span class="type">CGFloat</span></span><br><span class="line"><span class="comment">//表格视图中部分页脚的高度。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> estimatedSectionHeaderHeight: <span class="type">CGFloat</span></span><br><span class="line"><span class="comment">//表视图中节标题的估计高度。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> estimatedSectionFooterHeight: <span class="type">CGFloat</span></span><br><span class="line"><span class="comment">//表格视图中部分页脚的估计高度。</span></span><br></pre></td></tr></table></figure><h3 id="自定义分隔符外观"><a href="#自定义分隔符外观" class="headerlink" title="自定义分隔符外观"></a>自定义分隔符外观</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> separatorStyle: <span class="type">UITableViewCell</span>.<span class="type">SeparatorStyle</span></span><br><span class="line"><span class="comment">//用作分隔符的表格单元格的样式。</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">UITableViewCell</span>.<span class="title">SeparatorStyle</span></span></span><br><span class="line"><span class="class">//用作分隔符的单元格样式。</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">var</span> <span class="title">separatorColor</span>: <span class="title">UIColor</span>?</span></span><br><span class="line"><span class="class">//表视图中分隔符行的颜色。</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">var</span> <span class="title">separatorEffect</span>: <span class="title">UIVisualEffect</span>?</span></span><br><span class="line"><span class="class">//应用于表分隔符的效果。</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">var</span> <span class="title">separatorInset</span>: <span class="title">UIEdgeInsets</span></span></span><br><span class="line"><span class="class">//单元格分隔符的默认插入。</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">var</span> <span class="title">separatorInsetReference</span>: <span class="title">UITableView</span>.<span class="title">SeparatorInsetReference</span></span></span><br><span class="line"><span class="class">//应该如何解释分隔符插入值的指示符。</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">enum</span> <span class="title">UITableView</span>.<span class="title">SeparatorInsetReference</span></span></span><br><span class="line"><span class="class">//指示如何解释表视图的分隔符插入值的常量。</span></span><br></pre></td></tr></table></figure><h3 id="获取行数和节数"><a href="#获取行数和节数" class="headerlink" title="获取行数和节数"></a>获取行数和节数</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">numberOfRows</span><span class="params">(inSection: Int)</span></span> -&gt; <span class="type">Int</span></span><br><span class="line"><span class="comment">//返回指定节中的行数（表格单元格）。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> numberOfSections: <span class="type">Int</span></span><br><span class="line"><span class="comment">//表视图中的节数。</span></span><br></pre></td></tr></table></figure><h3 id="获取单元格和基于节的视图"><a href="#获取单元格和基于节的视图" class="headerlink" title="获取单元格和基于节的视图"></a>获取单元格和基于节的视图</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">cellForRow</span><span class="params">(at: IndexPath)</span></span> -&gt; <span class="type">UITableViewCell</span>?</span><br><span class="line"><span class="comment">//返回指定索引路径的表格单元格。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">headerView</span><span class="params">(forSection: Int)</span></span> -&gt; <span class="type">UITableViewHeaderFooterView</span>?</span><br><span class="line"><span class="comment">//返回与指定节相关联的标题视图。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">footerView</span><span class="params">(forSection: Int)</span></span> -&gt; <span class="type">UITableViewHeaderFooterView</span>?</span><br><span class="line"><span class="comment">//返回与指定节相关联的页脚视图。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">indexPath</span><span class="params">(<span class="keyword">for</span>: UITableViewCell)</span></span> -&gt; <span class="type">IndexPath</span>?</span><br><span class="line"><span class="comment">//返回表示给定表视图单元格的行和部分的索引路径。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">indexPathForRow</span><span class="params">(at: CGPoint)</span></span> -&gt; <span class="type">IndexPath</span>?</span><br><span class="line"><span class="comment">//返回标识给定点处的行和节的索引路径。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">indexPathsForRows</span><span class="params">(<span class="keyword">in</span>: CGRect)</span></span> -&gt; [<span class="type">IndexPath</span>]?</span><br><span class="line"><span class="comment">//索引路径数组，每个索引路径表示由给定矩形包围的行。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> visibleCells: [<span class="type">UITableViewCell</span>]</span><br><span class="line"><span class="comment">//表视图中可见的表格单元格。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> indexPathsForVisibleRows: [<span class="type">IndexPath</span>]?</span><br><span class="line"><span class="comment">//索引路径数组，每个索引路径标识表视图中的可见行。</span></span><br></pre></td></tr></table></figure><h3 id="选择行"><a href="#选择行" class="headerlink" title="选择行"></a>选择行</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> indexPathForSelectedRow: <span class="type">IndexPath</span>?</span><br><span class="line"><span class="comment">//标识所选行的行和部分的索引路径。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> indexPathsForSelectedRows: [<span class="type">IndexPath</span>]?</span><br><span class="line"><span class="comment">//表示所选行的索引路径。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">selectRow</span><span class="params">(at: IndexPath?, animated: Bool, scrollPosition: UITableView.ScrollPosition)</span></span></span><br><span class="line"><span class="comment">//选择由索引路径标识的表视图中的行，可选择将行滚动到表视图中的某个位置。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">deselectRow</span><span class="params">(at: IndexPath, animated: Bool)</span></span></span><br><span class="line"><span class="comment">//取消选择由索引路径标识的给定行，并选择为取消选择设置动画。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> allowsSelection: <span class="type">Bool</span></span><br><span class="line"><span class="comment">//一个布尔值，用于确定用户是否可以选择行。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> allowsMultipleSelection: <span class="type">Bool</span></span><br><span class="line"><span class="comment">//一个布尔值，用于确定用户是否可以在编辑模式之外选择多个行。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> allowsSelectionDuringEditing: <span class="type">Bool</span></span><br><span class="line"><span class="comment">//一个布尔值，用于确定用户在表视图处于编辑模式时是否可以选择单元格。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> allowsMultipleSelectionDuringEditing: <span class="type">Bool</span></span><br><span class="line"><span class="comment">//一个布尔值，控制用户是否可以在编辑模式下同时选择多个单元格。</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">let</span> <span class="title">selectionDidChangeNotification</span>: <span class="title">NSNotification</span>.<span class="title">Name</span></span></span><br><span class="line"><span class="class">//发布表视图中的选定行发生更改时发布。</span></span><br></pre></td></tr></table></figure><h3 id="插入，删除和移动行和节"><a href="#插入，删除和移动行和节" class="headerlink" title="插入，删除和移动行和节"></a>插入，删除和移动行和节</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">insertRows</span><span class="params">(at: [IndexPath], with: UITableView.RowAnimation)</span></span></span><br><span class="line"><span class="comment">//在表视图中插入由索引路径数组标识的位置的行，并提供动画插入的选项。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">deleteRows</span><span class="params">(at: [IndexPath], with: UITableView.RowAnimation)</span></span></span><br><span class="line"><span class="comment">//删除索引路径数组指定的行，并带有为删除设置动画的选项。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">insertSections</span><span class="params">(IndexSet, with: UITableView.RowAnimation)</span></span></span><br><span class="line"><span class="comment">//在表视图中插入一个或多个部分，并提供动画插入的选项。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">deleteSections</span><span class="params">(IndexSet, with: UITableView.RowAnimation)</span></span></span><br><span class="line"><span class="comment">//删除表视图中的一个或多个部分，并带有为删除设置动画的选项。</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">UITableView</span>.<span class="title">RowAnimation</span></span></span><br><span class="line"><span class="class">//插入或删除行时使用的动画类型。</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">func</span> <span class="title">moveRow</span>(<span class="title">at</span>: <span class="title">IndexPath</span>, <span class="title">to</span>: <span class="title">IndexPath</span>)</span></span><br><span class="line"><span class="class">//将指定位置的行移动到目标位置。</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">func</span> <span class="title">moveSection</span>(<span class="title">Int</span>, <span class="title">toSection</span>: <span class="title">Int</span>)</span></span><br><span class="line"><span class="class">//将节移动到表视图中的新位置。</span></span><br></pre></td></tr></table></figure><h3 id="对行和节执行批量更新"><a href="#对行和节执行批量更新" class="headerlink" title="对行和节执行批量更新"></a>对行和节执行批量更新</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">performBatchUpdates</span><span class="params">(<span class="params">(<span class="params">()</span></span></span></span> -&gt; <span class="type">Void</span>)?, completion: ((<span class="type">Bool</span>) -&gt; <span class="type">Void</span>)?)</span><br><span class="line"><span class="comment">//动画多个插入，删除，重新加载和移动操作作为一组。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">beginUpdates</span><span class="params">()</span></span></span><br><span class="line"><span class="comment">//开始一系列方法调用，插入，删除或选择表视图的行和部分。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">endUpdates</span><span class="params">()</span></span></span><br><span class="line"><span class="comment">//结束一系列方法调用，插入，删除，选择或重新加载表视图的行和部分。</span></span><br></pre></td></tr></table></figure><h3 id="配置表索引"><a href="#配置表索引" class="headerlink" title="配置表索引"></a>配置表索引</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> sectionIndexMinimumDisplayRowCount: <span class="type">Int</span></span><br><span class="line"><span class="comment">//用于在表的右边缘显示索引列表的表行数。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> sectionIndexColor: <span class="type">UIColor</span>?</span><br><span class="line"><span class="comment">//用于表视图索引文本的颜色。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> sectionIndexBackgroundColor: <span class="type">UIColor</span>?</span><br><span class="line"><span class="comment">//用于表视图的节索引背景的颜色。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> sectionIndexTrackingBackgroundColor: <span class="type">UIColor</span>?</span><br><span class="line"><span class="comment">//用于表视图的索引背景区域的颜色。</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">let</span> <span class="title">indexSearch</span>: <span class="title">String</span></span></span><br><span class="line"><span class="class">//用于将放大镜图标添加到表视图的节索引的常量。</span></span><br></pre></td></tr></table></figure><h3 id="重新加载表视图"><a href="#重新加载表视图" class="headerlink" title="重新加载表视图"></a>重新加载表视图</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> hasUncommittedUpdates: <span class="type">Bool</span></span><br><span class="line"><span class="comment">//一个布尔值，指示表视图的外观是否包含未在其数据源中反映的更改。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reloadData</span><span class="params">()</span></span></span><br><span class="line"><span class="comment">//重新加载表视图的行和部分。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reloadRows</span><span class="params">(at: [IndexPath], with: UITableView.RowAnimation)</span></span></span><br><span class="line"><span class="comment">//使用给定的动画效果重新加载指定的行。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reloadSections</span><span class="params">(IndexSet, with: UITableView.RowAnimation)</span></span></span><br><span class="line"><span class="comment">//使用给定的动画效果重新加载指定的部分。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reloadSectionIndexTitles</span><span class="params">()</span></span></span><br><span class="line"><span class="comment">//重新加载表视图右侧索引栏中的项目。</span></span><br></pre></td></tr></table></figure><h3 id="管理拖动交互"><a href="#管理拖动交互" class="headerlink" title="管理拖动交互"></a>管理拖动交互</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> dragDelegate: <span class="type">UITableViewDragDelegate</span>?</span><br><span class="line"><span class="comment">//委托对象管理从表视图中拖动项目。</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">UITableViewDragDelegate</span></span></span><br><span class="line"><span class="class">//用于从表视图启动拖动的界面。</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">var</span> <span class="title">hasActiveDrag</span>: <span class="title">Bool</span></span></span><br><span class="line"><span class="class">//一个布尔值，指示是否从表视图中提升行并且尚未删除。</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">var</span> <span class="title">dragInteractionEnabled</span>: <span class="title">Bool</span></span></span><br><span class="line"><span class="class">//一个布尔值，指示表视图是否支持应用之间的拖放。</span></span><br></pre></td></tr></table></figure><h3 id="管理丢弃交互"><a href="#管理丢弃交互" class="headerlink" title="管理丢弃交互"></a>管理丢弃交互</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> dropDelegate: <span class="type">UITableViewDropDelegate</span>?</span><br><span class="line"><span class="comment">//管理将内容删除到表视图中的委托对象。</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">UITableViewDropDelegate</span></span></span><br><span class="line"><span class="class">//用于处理的接口在表视图中丢弃。</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">var</span> <span class="title">hasActiveDrop</span>: <span class="title">Bool</span></span></span><br><span class="line"><span class="class">//一个布尔值，指示表视图当前是否正在跟踪放置会话。</span></span><br></pre></td></tr></table></figure><h3 id="滚动表视图"><a href="#滚动表视图" class="headerlink" title="滚动表视图"></a>滚动表视图</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">scrollToRow</span><span class="params">(at: IndexPath, at: UITableView.ScrollPosition, animated: Bool)</span></span></span><br><span class="line"><span class="comment">//滚动表视图，直到索引路径标识的行位于屏幕上的特定位置。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">scrollToNearestSelectedRow</span><span class="params">(at: UITableView.ScrollPosition, animated: Bool)</span></span></span><br><span class="line"><span class="comment">//滚动表格视图，以便最接近表格视图中指定位置的选定行位于该位置。</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">UITableView</span>.<span class="title">ScrollPosition</span></span></span><br><span class="line"><span class="class">//表格视图中的位置（顶部，中间，底部），滚动给定行。</span></span><br></pre></td></tr></table></figure><h3 id="将表置于编辑模式"><a href="#将表置于编辑模式" class="headerlink" title="将表置于编辑模式"></a>将表置于编辑模式</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">setEditing</span><span class="params">(Bool, animated: Bool)</span></span></span><br><span class="line"><span class="comment">//切换表格视图进出编辑模式。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> isEditing: <span class="type">Bool</span></span><br><span class="line"><span class="comment">//一个布尔值，用于确定表视图是否处于编辑模式。</span></span><br></pre></td></tr></table></figure><h3 id="获取表格的绘图区域"><a href="#获取表格的绘图区域" class="headerlink" title="获取表格的绘图区域"></a>获取表格的绘图区域</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">rect</span><span class="params">(forSection: Int)</span></span> -&gt; <span class="type">CGRect</span></span><br><span class="line"><span class="comment">//返回表视图的指定部分的绘图区域。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">rectForRow</span><span class="params">(at: IndexPath)</span></span> -&gt; <span class="type">CGRect</span></span><br><span class="line"><span class="comment">//返回由索引路径标识的行的绘图区域。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">rectForFooter</span><span class="params">(inSection: Int)</span></span> -&gt; <span class="type">CGRect</span></span><br><span class="line"><span class="comment">//返回指定节的页脚的绘图区域。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">rectForHeader</span><span class="params">(inSection: Int)</span></span> -&gt; <span class="type">CGRect</span></span><br><span class="line"><span class="comment">//返回指定节的标题的绘图区域。</span></span><br></pre></td></tr></table></figure><h3 id="记住最后一个聚焦的单元格"><a href="#记住最后一个聚焦的单元格" class="headerlink" title="记住最后一个聚焦的单元格"></a>记住最后一个聚焦的单元格</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> remembersLastFocusedIndexPath: <span class="type">Bool</span></span><br><span class="line"><span class="comment">//一个布尔值，指示表视图是否应自动将焦点返回到上一个焦点索引路径处的单元格。</span></span><br></pre></td></tr></table></figure><h1 id="UITableViewCell"><a href="#UITableViewCell" class="headerlink" title="UITableViewCell"></a><a href="https://developer.apple.com/documentation/uikit/uitableviewcell" target="_blank" rel="noopener">UITableViewCell</a></h1><p>UITableViewCell对象是管理单个表行内容的专用视图类型。您主要使用单元格来组织和显示应用程序的自定义内容，但UITableViewCell提供了一些特定的自定义以支持与表相关的行为：</p><ul><li><p>将选定内容或突出显示颜色应用于单元格。</p></li><li><p>添加标准附件视图，如详细信息或披露控制。</p></li><li><p>将单元格置于可编辑状态。</p></li><li><p>缩进单元格内容以在表中创建可视层次结构。</p></li></ul><blockquote><p>A <code>UITableViewCell</code> object is a specialized type of view that manages the content of a single table row. You use cells primarily to organize and present your app’s custom content, but <code>UITableViewCell</code> provides some specific customizations to support table-related behaviors, including:</p><ul><li>Applying a selection or highlight color to the cell.</li><li>Adding standard accessory views, such as a detail or disclosure control.</li><li>Putting the cell into an editable state.</li><li>Indenting the cell’s content to create a visual hierarchy in your table.</li></ul><p>Your app’s content occupies most of the cell’s bounds, but the cell may adjust that space to make room for other content. Cells display accessory views on the trailing edge of their content area. When you put your table into edit mode, the cell adds a delete control to the leading edge of its content area, and optionally swaps out an accessory view for a reorder control.</p></blockquote><p><strong>UITableViewCellStyle/UITableViewCell.CellStyle</strong></p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">UITableViewCell</span> </span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">CellStyle</span> : <span class="title">Int</span> </span>&#123;</span><br><span class="line">        <span class="keyword">case</span> `<span class="keyword">default</span>`  <span class="comment">//具有文本标签（黑色和左对齐）和可选图像视图的单元格的简单样式。</span></span><br><span class="line">        <span class="keyword">case</span> value1<span class="comment">//单元格样式，单元格左侧带有标签，左对齐和黑色文本; 在右侧是一个标签，蓝色文字较小，右对齐。“设置”应用程序使用此样式的单元格。</span></span><br><span class="line">        <span class="keyword">case</span> value2<span class="comment">//单元格样式，单元格左侧带有标签，文本右对齐，蓝色; 在单元格的右侧是另一个标签，其中较小的文本是左对齐和黑色。电话/联系人应用程序使用此样式的单元格。</span></span><br><span class="line">        <span class="keyword">case</span> subtitle <span class="comment">//单元格的样式，顶部带有左对齐标签，下面带有左对齐标签，带有较小的灰色文本。</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="built_in">NS_ENUM</span>(<span class="built_in">NSInteger</span>, <span class="built_in">UITableViewCellStyle</span>) &#123;</span><br><span class="line">    <span class="built_in">UITableViewCellStyleDefault</span>,    </span><br><span class="line">    <span class="built_in">UITableViewCellStyleValue1</span>,        </span><br><span class="line">    <span class="built_in">UITableViewCellStyleValue2</span>,        </span><br><span class="line">    <span class="built_in">UITableViewCellStyleSubtitle</span>    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src="cellstyle.png" alt=""></p><p><strong>Cell的层次结构</strong></p><p><img src="cellintro.png" alt=""></p><h2 id="类方法-1"><a href="#类方法-1" class="headerlink" title="类方法"></a>类方法</h2><h3 id="创建表视图单元格"><a href="#创建表视图单元格" class="headerlink" title="创建表视图单元格"></a>创建表视图单元格</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">init</span>(style: <span class="type">UITableViewCell</span>.<span class="type">CellStyle</span>, reuseIdentifier: <span class="type">String</span>?)</span><br><span class="line"><span class="comment">//使用样式和重用标识符初始化表格单元格并将其返回给调用者。</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">UITableViewCell</span>.<span class="title">CellStyle</span></span></span><br><span class="line"><span class="class">//各种样式细胞的枚举。</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">init</span>?(<span class="title">coder</span>: <span class="title">NSCoder</span>)</span></span><br></pre></td></tr></table></figure><h3 id="重用"><a href="#重用" class="headerlink" title="重用"></a>重用</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> reuseIdentifier: <span class="type">String</span>?</span><br><span class="line"><span class="comment">//用于标识可重用单元的字符串。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">prepareForReuse</span><span class="params">()</span></span></span><br><span class="line"><span class="comment">//准备一个可重用的单元格以供表视图委托重用。</span></span><br></pre></td></tr></table></figure><h3 id="指定标准单元格样式的内容"><a href="#指定标准单元格样式的内容" class="headerlink" title="指定标准单元格样式的内容"></a>指定标准单元格样式的内容</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> textLabel: <span class="type">UILabel</span>?</span><br><span class="line"><span class="comment">//用于表格单元格主要文本内容的标签。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> detailTextLabel: <span class="type">UILabel</span>?</span><br><span class="line"><span class="comment">//表格单元格的辅助标签（如果存在）。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> imageView: <span class="type">UIImageView</span>?</span><br><span class="line"><span class="comment">//表格单元格的图像视图。</span></span><br></pre></td></tr></table></figure><h3 id="访问单元格对象的视图"><a href="#访问单元格对象的视图" class="headerlink" title="访问单元格对象的视图"></a>访问单元格对象的视图</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> contentView: <span class="type">UIView</span></span><br><span class="line"><span class="comment">//单元格对象的内容视图。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> backgroundView: <span class="type">UIView</span>?</span><br><span class="line"><span class="comment">//该视图用作单元格的背景。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> selectedBackgroundView: <span class="type">UIView</span>?</span><br><span class="line"><span class="comment">//视图在选中时用作单元格的背景。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> multipleSelectionBackgroundView: <span class="type">UIView</span>?</span><br><span class="line"><span class="comment">//当表视图允许多行选择时，用于选定单元格的背景视图。</span></span><br></pre></td></tr></table></figure><h3 id="管理附件视图"><a href="#管理附件视图" class="headerlink" title="管理附件视图"></a>管理附件视图</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> accessoryType: <span class="type">UITableViewCell</span>.<span class="type">AccessoryType</span></span><br><span class="line"><span class="comment">//单元应使用的标准附件视图的类型（正常状态）。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> accessoryView: <span class="type">UIView</span>?</span><br><span class="line"><span class="comment">//在单元格的右侧（正常状态）使用的视图，通常用作控件。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> editingAccessoryType: <span class="type">UITableViewCell</span>.<span class="type">AccessoryType</span></span><br><span class="line"><span class="comment">//单元格应在表格视图的编辑状态中使用的标准附件视图的类型。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> editingAccessoryView: <span class="type">UIView</span>?</span><br><span class="line"><span class="comment">//在编辑模式下，通常用作单元格右侧控件的视图。</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">UITableViewCell</span>.<span class="title">AccessoryType</span></span></span><br><span class="line"><span class="class">//单元使用的标准附件控件的类型。</span></span><br></pre></td></tr></table></figure><h3 id="管理单元格选择和突出显示"><a href="#管理单元格选择和突出显示" class="headerlink" title="管理单元格选择和突出显示"></a>管理单元格选择和突出显示</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> selectionStyle: <span class="type">UITableViewCell</span>.<span class="type">SelectionStyle</span></span><br><span class="line"><span class="comment">//细胞的选择方式。</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">UITableViewCell</span>.<span class="title">SelectionStyle</span></span></span><br><span class="line"><span class="class">//选定单元格的样式。</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">var</span> <span class="title">isSelected</span>: <span class="title">Bool</span></span></span><br><span class="line"><span class="class">//一个布尔值，指示是否选择了单元格。</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">func</span> <span class="title">setSelected</span>(<span class="title">Bool</span>, <span class="title">animated</span>: <span class="title">Bool</span>)</span></span><br><span class="line"><span class="class">//设置单元格的选定状态，可选地为状态之间的过渡设置动画。</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">var</span> <span class="title">isHighlighted</span>: <span class="title">Bool</span></span></span><br><span class="line"><span class="class">//一个布尔值，指示单元格是否突出显示。</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">func</span> <span class="title">setHighlighted</span>(<span class="title">Bool</span>, <span class="title">animated</span>: <span class="title">Bool</span>)</span></span><br><span class="line"><span class="class">//设置单元格的突出显示状态，可选地为状态之间的过渡设置动画。</span></span><br></pre></td></tr></table></figure><h3 id="编辑单元格"><a href="#编辑单元格" class="headerlink" title="编辑单元格"></a>编辑单元格</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> isEditing: <span class="type">Bool</span></span><br><span class="line"><span class="comment">//一个布尔值，指示单元格是否处于可编辑状态。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">setEditing</span><span class="params">(Bool, animated: Bool)</span></span></span><br><span class="line"><span class="comment">//切换接收器进入和退出编辑模式。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> editingStyle: <span class="type">UITableViewCell</span>.<span class="type">EditingStyle</span></span><br><span class="line"><span class="comment">//单元格的编辑样式。</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">UITableViewCell</span>.<span class="title">EditingStyle</span></span></span><br><span class="line"><span class="class">//单元格使用的编辑控件。</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">var</span> <span class="title">showingDeleteConfirmation</span>: <span class="title">Bool</span></span></span><br><span class="line"><span class="class">//一个布尔值，指示单元格当前是否显示删除确认按钮。</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">var</span> <span class="title">showsReorderControl</span>: <span class="title">Bool</span></span></span><br><span class="line"><span class="class">//一个布尔值，用于确定单元格是否显示重新排序控件。</span></span><br></pre></td></tr></table></figure><h3 id="拖动行"><a href="#拖动行" class="headerlink" title="拖动行"></a>拖动行</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> userInteractionEnabledWhileDragging: <span class="type">Bool</span></span><br><span class="line"><span class="comment">//一个布尔值，指示用户在拖动单元格时是否可以与单元格进行交互。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">dragStateDidChange</span><span class="params">(UITableViewCell.DragState)</span></span></span><br><span class="line"><span class="comment">//通知单元格其拖动状态已更改。</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">UITableViewCell</span>.<span class="title">DragState</span></span></span><br><span class="line"><span class="class">//指示拖动操作中涉及的行的当前状态的常量。</span></span><br></pre></td></tr></table></figure><h3 id="适应状态转变"><a href="#适应状态转变" class="headerlink" title="适应状态转变"></a>适应状态转变</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">willTransition</span><span class="params">(to: UITableViewCell.StateMask)</span></span></span><br><span class="line"><span class="comment">//被调用以通知单元格它将要转换到新的单元状态。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">didTransition</span><span class="params">(to: UITableViewCell.StateMask)</span></span></span><br><span class="line"><span class="comment">//被调用以通知单元格它已转换到新的单元状态。</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">UITableViewCell</span>.<span class="title">StateMask</span></span></span><br><span class="line"><span class="class">//常量用于在状态之间转换时确定单元格的新状态。</span></span><br></pre></td></tr></table></figure><h3 id="管理内容缩进"><a href="#管理内容缩进" class="headerlink" title="管理内容缩进"></a>管理内容缩进</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> indentationLevel: <span class="type">Int</span></span><br><span class="line"><span class="comment">//单元格内容的缩进级别。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> indentationWidth: <span class="type">CGFloat</span></span><br><span class="line"><span class="comment">//单元格内容的每个缩进级别的宽度。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> shouldIndentWhileEditing: <span class="type">Bool</span></span><br><span class="line"><span class="comment">//一个布尔值，用于控制表视图处于编辑模式时是否缩进单元格背景。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> separatorInset: <span class="type">UIEdgeInsets</span></span><br><span class="line"><span class="comment">//在单元格下方绘制的分隔线的插入值。</span></span><br></pre></td></tr></table></figure><h3 id="管理焦点"><a href="#管理焦点" class="headerlink" title="管理焦点"></a>管理焦点</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> focusStyle: <span class="type">UITableViewCell</span>.<span class="type">FocusStyle</span></span><br><span class="line"><span class="comment">//聚焦时的外观。</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">UITableViewCell</span>.<span class="title">FocusStyle</span></span></span><br><span class="line"><span class="class">//聚焦的风格。</span></span><br></pre></td></tr></table></figure><h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">UITableViewCell</span>.<span class="title">SeparatorStyle</span></span></span><br><span class="line"><span class="class">用作分隔符的单元格样式。</span></span><br></pre></td></tr></table></figure><h1 id="UITableViewDelegate"><a href="#UITableViewDelegate" class="headerlink" title="UITableViewDelegate"></a><a href="https://developer.apple.com/documentation/uikit/uitableviewdelegate" target="_blank" rel="noopener">UITableViewDelegate</a></h1><p><code>UITableViewDelegate</code>用来管理选择，配置节页眉和页脚，删除和重新排序单元格以及在表格视图中执行其他操作的方法。例如：</p><ul><li>创建和管理自定义页眉和页脚视图。</li><li>指定行，页眉和页脚的自定义高度。</li><li>提供高度估计以获得更好的滚动支持。</li><li>缩进行内容。</li><li>响应行选择。</li><li>响应表行中的滑动和其他操作。</li><li>支持编辑表格的内容。</li></ul><h2 id="协议方法："><a href="#协议方法：" class="headerlink" title="协议方法："></a><strong>协议方法：</strong></h2><h3 id="配置表视图行"><a href="#配置表视图行" class="headerlink" title="配置表视图行"></a>配置表视图行</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">tableView</span><span class="params">(UITableView, willDisplay: UITableViewCell, forRowAt: IndexPath)</span></span></span><br><span class="line"><span class="comment">//告诉委托表视图是否要为特定行绘制单元格。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">tableView</span><span class="params">(UITableView, indentationLevelForRowAt: IndexPath)</span></span> -&gt; <span class="type">Int</span></span><br><span class="line"><span class="comment">//要求委托者返回给定部分中某行的缩进级别。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">tableView</span><span class="params">(UITableView, shouldSpringLoadRowAt: IndexPath, with: UISpringLoadedInteractionContext)</span></span> -&gt; <span class="type">Bool</span></span><br><span class="line"><span class="comment">//被调用以允许您微调表中行的弹簧加载行为。</span></span><br></pre></td></tr></table></figure><h3 id="响应行选择"><a href="#响应行选择" class="headerlink" title="响应行选择"></a>响应行选择</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">tableView</span><span class="params">(UITableView, willSelectRowAt: IndexPath)</span></span> -&gt; <span class="type">IndexPath</span>?</span><br><span class="line"><span class="comment">//告诉委托者即将选择指定的行。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">tableView</span><span class="params">(UITableView, didSelectRowAt: IndexPath)</span></span></span><br><span class="line"><span class="comment">//告诉委托者现在选择了指定的行。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">tableView</span><span class="params">(UITableView, willDeselectRowAt: IndexPath)</span></span> -&gt; <span class="type">IndexPath</span>?</span><br><span class="line"><span class="comment">//告诉委托者即将取消选择指定的行。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">tableView</span><span class="params">(UITableView, didDeselectRowAt: IndexPath)</span></span></span><br><span class="line"><span class="comment">//告诉代理现在取消选择指定的行。</span></span><br></pre></td></tr></table></figure><h3 id="提供自定义页眉和页脚视图"><a href="#提供自定义页眉和页脚视图" class="headerlink" title="提供自定义页眉和页脚视图"></a>提供自定义页眉和页脚视图</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">tableView</span><span class="params">(UITableView, viewForHeaderInSection: Int)</span></span> -&gt; <span class="type">UIView</span>?</span><br><span class="line"><span class="comment">//要求委托使视图对象显示在表视图的指定部分的标题中。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">tableView</span><span class="params">(UITableView, viewForFooterInSection: Int)</span></span> -&gt; <span class="type">UIView</span>?</span><br><span class="line"><span class="comment">//要求委托使视图对象显示在表视图的指定部分的页脚中。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">tableView</span><span class="params">(UITableView, willDisplayHeaderView: UIView, forSection: Int)</span></span></span><br><span class="line"><span class="comment">//告诉委托表该表即将显示指定节的标题视图。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">tableView</span><span class="params">(UITableView, willDisplayFooterView: UIView, forSection: Int)</span></span></span><br><span class="line"><span class="comment">//告诉代理该表即将显示指定部分的页脚视图。</span></span><br></pre></td></tr></table></figure><h3 id="提供页眉，页脚和行高"><a href="#提供页眉，页脚和行高" class="headerlink" title="提供页眉，页脚和行高"></a>提供页眉，页脚和行高</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">tableView</span><span class="params">(UITableView, heightForRowAt: IndexPath)</span></span> -&gt; <span class="type">CGFloat</span></span><br><span class="line"><span class="comment">//询问代理用于指定位置的行的高度。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">tableView</span><span class="params">(UITableView, heightForHeaderInSection: Int)</span></span> -&gt; <span class="type">CGFloat</span></span><br><span class="line"><span class="comment">//询问代理用于特定部分标题的高度。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">tableView</span><span class="params">(UITableView, heightForFooterInSection: Int)</span></span> -&gt; <span class="type">CGFloat</span></span><br><span class="line"><span class="comment">//询问代理用于特定部分的页脚的高度。</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">let</span> <span class="title">automaticDimension</span>: <span class="title">CGFloat</span></span></span><br><span class="line"><span class="class">//表示给定维度的默认值的常量。</span></span><br></pre></td></tr></table></figure><h3 id="估计表格内容的高度"><a href="#估计表格内容的高度" class="headerlink" title="估计表格内容的高度"></a>估计表格内容的高度</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">tableView</span><span class="params">(UITableView, estimatedHeightForRowAt: IndexPath)</span></span> -&gt; <span class="type">CGFloat</span></span><br><span class="line"><span class="comment">//询问代理指定位置中行的估计高度。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">tableView</span><span class="params">(UITableView, estimatedHeightForHeaderInSection: Int)</span></span> -&gt; <span class="type">CGFloat</span></span><br><span class="line"><span class="comment">//询问代理特定部分标题的估计高度。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">tableView</span><span class="params">(UITableView, estimatedHeightForFooterInSection: Int)</span></span> -&gt; <span class="type">CGFloat</span></span><br><span class="line"><span class="comment">//询问代理特定部分的页脚估计高度。</span></span><br></pre></td></tr></table></figure><h3 id="管理附件视图-1"><a href="#管理附件视图-1" class="headerlink" title="管理附件视图"></a>管理附件视图</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">tableView</span><span class="params">(UITableView, accessoryButtonTappedForRowWith: IndexPath)</span></span></span><br><span class="line"><span class="comment">//告诉代理用户点击了指定行的详细信息按钮。</span></span><br></pre></td></tr></table></figure><h3 id="响应行动作"><a href="#响应行动作" class="headerlink" title="响应行动作"></a>响应行动作</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">tableView</span><span class="params">(UITableView, leadingSwipeActionsConfigurationForRowAt: IndexPath)</span></span> -&gt; <span class="type">UISwipeActionsConfiguration</span>?</span><br><span class="line"><span class="comment">//返回要在行的前沿显示的滑动操作。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">tableView</span><span class="params">(UITableView, trailingSwipeActionsConfigurationForRowAt: IndexPath)</span></span> -&gt; <span class="type">UISwipeActionsConfiguration</span>?</span><br><span class="line"><span class="comment">//返回要在行的后缘显示的滑动操作。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">tableView</span><span class="params">(UITableView, shouldShowMenuForRowAt: IndexPath)</span></span> -&gt; <span class="type">Bool</span></span><br><span class="line"><span class="comment">//询问代理是否应该为某一行显示编辑菜单。 --弃用</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">tableView</span><span class="params">(UITableView, canPerformAction: Selector, forRowAt: IndexPath, withSender: <span class="keyword">Any</span>?)</span></span> -&gt; <span class="type">Bool</span></span><br><span class="line"><span class="comment">//询问代理是否编辑菜单应省略给定行的复制或粘贴命令。-- 弃用</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">tableView</span><span class="params">(UITableView, performAction: Selector, forRowAt: IndexPath, withSender: <span class="keyword">Any</span>?)</span></span></span><br><span class="line"><span class="comment">//告知委托对给定行的内容执行复制或粘贴操作。-- 弃用</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">tableView</span><span class="params">(UITableView, editActionsForRowAt: IndexPath)</span></span> -&gt; [<span class="type">UITableViewRowAction</span>]?</span><br><span class="line"><span class="comment">//询问代理是否响应指定行中的滑动而显示的操作。</span></span><br></pre></td></tr></table></figure><h3 id="管理表格视图亮点"><a href="#管理表格视图亮点" class="headerlink" title="管理表格视图亮点"></a>管理表格视图亮点</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">tableView</span><span class="params">(UITableView, shouldHighlightRowAt: IndexPath)</span></span> -&gt; <span class="type">Bool</span></span><br><span class="line"><span class="comment">//询问代理是否应突出显示指定的行。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">tableView</span><span class="params">(UITableView, didHighlightRowAt: IndexPath)</span></span></span><br><span class="line"><span class="comment">//告诉代理指出的行已突出显示。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">tableView</span><span class="params">(UITableView, didUnhighlightRowAt: IndexPath)</span></span></span><br><span class="line"><span class="comment">//告诉委托，突出显示已从指定索引路径的行中删除。</span></span><br></pre></td></tr></table></figure><h3 id="编辑表行"><a href="#编辑表行" class="headerlink" title="编辑表行"></a>编辑表行</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">tableView</span><span class="params">(UITableView, willBeginEditingRowAt: IndexPath)</span></span></span><br><span class="line"><span class="comment">//告诉代理表视图即将进入编辑模式。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">tableView</span><span class="params">(UITableView, didEndEditingRowAt: IndexPath?)</span></span></span><br><span class="line"><span class="comment">//告诉代理表视图已离开编辑模式。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">tableView</span><span class="params">(UITableView, editingStyleForRowAt: IndexPath)</span></span> -&gt; <span class="type">UITableViewCell</span>.<span class="type">EditingStyle</span></span><br><span class="line"><span class="comment">//向代表询问表视图中特定位置的行的编辑样式。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">tableView</span><span class="params">(UITableView, titleForDeleteConfirmationButtonForRowAt: IndexPath)</span></span> -&gt; <span class="type">String</span>?</span><br><span class="line"><span class="comment">//更改删除确认按钮的默认标题。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">tableView</span><span class="params">(UITableView, shouldIndentWhileEditingRowAt: IndexPath)</span></span> -&gt; <span class="type">Bool</span></span><br><span class="line"><span class="comment">//询问代理在表视图处于编辑模式时是否应缩进指定行的背景。</span></span><br></pre></td></tr></table></figure><h3 id="重新排序表行"><a href="#重新排序表行" class="headerlink" title="重新排序表行"></a>重新排序表行</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">tableView</span><span class="params">(UITableView, targetIndexPathForMoveFromRowAt: IndexPath, toProposedIndexPath: IndexPath)</span></span> -&gt; <span class="type">IndexPath</span></span><br><span class="line"><span class="comment">//要求委托者返回一个新的索引路径以重新定位建议的行移动。</span></span><br></pre></td></tr></table></figure><h3 id="跟踪删除视图"><a href="#跟踪删除视图" class="headerlink" title="跟踪删除视图"></a>跟踪删除视图</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">tableView</span><span class="params">(UITableView, canFocusRowAt: IndexPath)</span></span> -&gt; <span class="type">Bool</span></span><br><span class="line"><span class="comment">//询问代理是否指定索引路径的单元格本身是可聚焦的。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">tableView</span><span class="params">(UITableView, shouldUpdateFocusIn: UITableViewFocusUpdateContext)</span></span> -&gt; <span class="type">Bool</span></span><br><span class="line"><span class="comment">//询问代理是否允许发生上下文指定的焦点更新。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">tableView</span><span class="params">(UITableView, didUpdateFocusIn: UITableViewFocusUpdateContext, with: UIFocusAnimationCoordinator)</span></span></span><br><span class="line"><span class="comment">//告诉委托者刚刚发生了上下文指定的焦点更新。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">indexPathForPreferredFocusedView</span><span class="params">(<span class="keyword">in</span>: UITableView)</span></span> -&gt; <span class="type">IndexPath</span>?</span><br><span class="line"><span class="comment">//向委托询问首选焦点视图的表视图的索引路径。</span></span><br></pre></td></tr></table></figure><h1 id="UITableViewDataSource"><a href="#UITableViewDataSource" class="headerlink" title="UITableViewDataSource"></a>UITableViewDataSource</h1><p><code>UITableViewDataSource</code>用于管理数据并为表视图提供单元格的对象采用的方法。</p><p><code>UITableView</code>仅管理其数据的表示; 他们不管理数据本身。要管理数据，请为表提供数据源对象，即实现协议的对象。数据源对象响应来自表的与数据相关的请求。它还可以直接管理表格的数据，或与应用程序的其他部分协调以管理该数据。</p><ul><li>指定表中的节和行数。</li><li>为表的每一行提供单元格。</li><li>为节标题和页脚提供标题。</li><li>配置表的索引（如果有）。</li><li>响应需要更改基础数据的用户或表启动的更新。</li></ul><p><strong>指定行和节的位置</strong></p><p><code>UITableView</code>使用<code>NSIndexPath</code>对象的<code>row</code>和<code>section</code>属性来进行单元格的位置定位。行索引和节索引是从零开始的，所以第一节位于索引0，第二节位于索引1，依此类推。同样，每个节的第一行位于索引0处，这意味着您需要节值和行值来唯一标识行。如果表没有节，则只需要行值。</p><p><img src="rowandsection.png" alt=""></p><p><strong>该协议必须实现两个方法</strong></p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Return the number of rows for the table.     </span></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">tableView</span><span class="params">(<span class="number">_</span> tableView: UITableView, numberOfRowsInSection section: Int)</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Provide a cell object for each row.</span></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">tableView</span><span class="params">(<span class="number">_</span> tableView: UITableView, cellForRowAt indexPath: IndexPath)</span></span> -&gt; <span class="type">UITableViewCell</span> &#123;</span><br><span class="line">   <span class="comment">// Fetch a cell of the appropriate type.</span></span><br><span class="line">   <span class="keyword">let</span> cell = tableView.dequeueReusableCell(withIdentifier: <span class="string">"cellTypeIdentifier"</span>, <span class="keyword">for</span>: indexPath)</span><br><span class="line">   </span><br><span class="line">   <span class="comment">// Configure the cell’s contents.</span></span><br><span class="line">   cell.textLabel!.text = <span class="string">"Cell text"</span></span><br><span class="line">       </span><br><span class="line">   <span class="keyword">return</span> cell</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>使用此协议的其他方法为表启用特定功能。例如，您必须实现该方法以启用行的滑动到删除功能。<a href="https://developer.apple.com/documentation/uikit/uitableviewdatasource/1614871-tableview" target="_blank" rel="noopener"><code>tableView(_:commit:forRowAt:)</code></a></p></blockquote><h2 id="协议方法"><a href="#协议方法" class="headerlink" title="协议方法"></a><strong>协议方法</strong></h2><h3 id="提供行数和节数"><a href="#提供行数和节数" class="headerlink" title="提供行数和节数"></a>提供行数和节数</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">tableView</span><span class="params">(UITableView, numberOfRowsInSection: Int)</span></span> -&gt; <span class="type">Int</span></span><br><span class="line"><span class="comment">//告诉数据源返回表视图的给定部分中的行数。-- 需要。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">numberOfSections</span><span class="params">(<span class="keyword">in</span>: UITableView)</span></span> -&gt; <span class="type">Int</span></span><br><span class="line"><span class="comment">//要求数据源返回表视图中的节数。</span></span><br></pre></td></tr></table></figure><h3 id="提供单元格，页眉和页脚"><a href="#提供单元格，页眉和页脚" class="headerlink" title="提供单元格，页眉和页脚"></a>提供单元格，页眉和页脚</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">tableView</span><span class="params">(UITableView, cellForRowAt: IndexPath)</span></span> -&gt; <span class="type">UITableViewCell</span></span><br><span class="line"><span class="comment">//要求单元格的数据源插入表视图的特定位置。-- 需要。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">tableView</span><span class="params">(UITableView, titleForHeaderInSection: Int)</span></span> -&gt; <span class="type">String</span>?</span><br><span class="line"><span class="comment">//向数据源询问表视图的指定部分的标题的标题。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">tableView</span><span class="params">(UITableView, titleForFooterInSection: Int)</span></span> -&gt; <span class="type">String</span>?</span><br><span class="line"><span class="comment">//向数据源询问表视图的指定部分的页脚标题。</span></span><br></pre></td></tr></table></figure><h3 id="插入或删除表格行"><a href="#插入或删除表格行" class="headerlink" title="插入或删除表格行"></a>插入或删除表格行</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">tableView</span><span class="params">(UITableView, commit: UITableViewCell.EditingStyle, forRowAt: IndexPath)</span></span></span><br><span class="line"><span class="comment">//要求数据源提交插入或删除接收器中的指定行。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">tableView</span><span class="params">(UITableView, canEditRowAt: IndexPath)</span></span> -&gt; <span class="type">Bool</span></span><br><span class="line"><span class="comment">//要求数据源验证给定行是否可编辑。</span></span><br></pre></td></tr></table></figure><h3 id="重新排序表行-1"><a href="#重新排序表行-1" class="headerlink" title="重新排序表行"></a>重新排序表行</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">tableView</span><span class="params">(UITableView, canMoveRowAt: IndexPath)</span></span> -&gt; <span class="type">Bool</span></span><br><span class="line"><span class="comment">//询问数据源是否可以将给定行移动到表视图中的另一个位置。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">tableView</span><span class="params">(UITableView, moveRowAt: IndexPath, to: IndexPath)</span></span></span><br><span class="line"><span class="comment">//告知数据源将表视图中特定位置的行移动到另一个位置。</span></span><br></pre></td></tr></table></figure><h3 id="配置索引"><a href="#配置索引" class="headerlink" title="配置索引"></a>配置索引</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sectionIndexTitles</span><span class="params">(<span class="keyword">for</span>: UITableView)</span></span> -&gt; [<span class="type">String</span>]?</span><br><span class="line"><span class="comment">//要求数据源返回表视图部分的标题。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">tableView</span><span class="params">(UITableView, sectionForSectionIndexTitle: String, at: Int)</span></span> -&gt; <span class="type">Int</span></span><br><span class="line"><span class="comment">//要求数据源返回具有给定标题和节标题索引的节的索引。</span></span><br></pre></td></tr></table></figure><h1 id="UITableViewController"><a href="#UITableViewController" class="headerlink" title="UITableViewController"></a>UITableViewController</h1><p>一个用于专门管理UITableView的控制器。</p><p>当接口由表视图和很少或没有其他内容组成时，子类UITableViewController。表视图控制器已经采用了管理表视图内容和响应更改所需的协议。此外，UITableViewController实现以下行为：</p><ul><li>它自动加载存档在故事板或NIB文件中的表视图。使用TableView属性访问表视图。</li><li>它将表视图的数据源和委托设置为self。</li><li>它实现了<code>viewWillAppear(_:)</code>方法，并在第一次出现时自动为其表视图重新加载数据。每次显示表视图时，它都会清除其选择（有动画或无动画，具体取决于请求）；您可以通过更改<code>ClearSSelectionOnView</code>将显示属性中的值来禁用此行为。</li><li>它实现了<code>viewDidAppear(_:)</code>，并在表视图第一次出现时自动闪烁滚动指示器。</li><li>它实现<code>setEditing(_:animated:)</code>方法，并在用户点击导航栏中的编辑完成按钮时自动切换表的编辑模式。</li><li>它会自动调整其表视图的大小，以适应屏幕键盘的外观或消失。</li></ul><p>为所管理的每个表视图创建UITableViewController的自定义子类。初始化表视图控制器时，必须指定表视图的样式（普通或分组）。您还必须重写数据源和委托方法，以便用数据填充表。您可以重写<code>loadView()</code>或任何其他超类方法，但如果这样做，请确保调用该方法的超类实现，通常作为第一个方法调用。</p><h1 id="UITableView的静态单元格"><a href="#UITableView的静态单元格" class="headerlink" title="UITableView的静态单元格"></a>UITableView的静态单元格</h1><p>静态单元格：不会随数据的改变而改变，当在storyboard中创建好后，显示的数据内容和模板样式都固定不变。需要修改，只能在storyboard中修改。</p><p><strong>在storyboard文件中配置静态表：</strong></p><ol><li>将<a href="https://developer.apple.com/documentation/uikit/uitableviewcontroller" target="_blank" rel="noopener"><code>UITableViewController</code></a>对象添加到故事板。</li><li>选择表视图控制器的表视图。</li><li>将表视图的“内容”属性（在“属性”检查器中）更改为<code>Static Cells</code>。</li><li>使用表视图的Sections属性指定表的节数。</li><li>将每个部分的Row属性设置为所需的行数。</li><li>使用所需的视图和内容配置每个单元格。</li></ol><p><strong>注意</strong>：不能通过在UIView中拖拽UITableView的方式来使用静态单元格，需要创建新的UITableViewController，并在属性中将content改为Static Cells。否则会报该错误：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">error: Static table views are only valid when embedded <span class="keyword">in</span> UITableViewController instances [12]</span><br></pre></td></tr></table></figure><p>使用静态数据的表视图需要一个<a href="https://developer.apple.com/documentation/uikit/uitableviewcontroller" target="_blank" rel="noopener"><code>UITableViewController</code></a>对象来管理该数据。</p><p><strong>单元格Cell的Accessory属性</strong></p><p>通过设置单元格的Accessory属性来改变单元格右侧的图标样式，该属性名称为accessoryType，它是一个UITableViewCellAccessoryType类型的枚举，枚举量主要有以下几种：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">UITableViewCellAccessoryNone</span></span><br><span class="line">  <span class="comment">//单元格右侧没有标志</span></span><br><span class="line"><span class="built_in">UITableViewCellAccessoryDisclosureIndicator</span></span><br><span class="line">  <span class="comment">//单元格右侧有向右的小箭头标志</span></span><br><span class="line"><span class="built_in">UITableViewCellAccessoryDetailDisclosureButton</span></span><br><span class="line">  <span class="comment">//单元格右侧有一个详细信息标志和一个向右小箭头标志</span></span><br><span class="line"><span class="built_in">UITableViewCellAccessoryCheckmark</span></span><br><span class="line">  <span class="comment">//单元格右侧有一个对勾标志</span></span><br><span class="line"><span class="built_in">UITableViewCellAccessoryDetailButton</span></span><br><span class="line">  <span class="comment">//单元格右侧有一个详细信息标志</span></span><br></pre></td></tr></table></figure><blockquote><p>通过cell的<code>accessoryView</code>属性来自定义辅助指示视图,优先级比<code>accessoryType</code>高</p><p>关于它的使用：如果某个界面从加载完毕后就始终不会变化，则可以使用静态单元格。否则应使用动态单元格。静态单元格是在storyboard中创建的，但是它仍然是可以交互的。</p></blockquote><h2 id="案例1：仿一下微信我的"><a href="#案例1：仿一下微信我的" class="headerlink" title="案例1：仿一下微信我的"></a>案例1：仿一下微信我的</h2><p><img src="wechatme.jpeg" alt=""></p><p>在storyboard中创建一个UItableViewController，并将TableView的类型设置为<code>static cells</code>,并设置节数：</p><p><img src="staticlizi1.png" alt=""></p><p>将TableVIew的样式设置为Group：</p><p><img src="staticlizi6.png" alt=""></p><p>添加<code>TableViewCell</code>：</p><p><img src="staticlizi2.png" alt=""></p><p>设置<code>TableViewCell</code>的样式，案例设置为Basic即可。</p><p><img src="staticlizi3.png" alt=""></p><p>设置标题，图片，配置每节中的行数。设置完后的样式：</p><p><img src="staticlizi4.png" alt=""></p><p>也可以配置一下section header的高度</p><p><img src="staticlizi5.png" alt=""></p><p>如果需要设置小箭头则可以选择Accessory属性</p><p><img src="staticlizi8.png" alt=""></p><p>运行效果：</p><p><img src="staticlizi7.png" alt=""></p><h2 id="案例2：仿设置"><a href="#案例2：仿设置" class="headerlink" title="案例2：仿设置"></a>案例2：仿设置</h2><p>我们通常会在一些app中看到一些设置界面，一般都会使用静态单元格来实现，但是来看下面一个例子，</p><p><img src="staticlizi22.png" alt=""></p><p>可以看到推送按钮是经过一些动态变化的，那么如何用静态单元格实现呢，来仿造一下。</p><p>在storyboard中，使用UITableViewController进行图中的设置</p><p><img src="staticlizi23.png" alt=""></p><p>然后新建一个SettingTableViewController，在storyboard中将controller指向该类，实现代码：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> UIKit</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SettingTableViewController</span>: <span class="title">UITableViewController</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@IBOutlet</span> <span class="keyword">var</span> cell: <span class="type">UITableViewCell</span>!</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.viewDidLoad()</span><br><span class="line">        <span class="keyword">let</span> settingswitch = <span class="type">UISwitch</span>(frame: .zero)</span><br><span class="line">        settingswitch.isOn = <span class="literal">true</span></span><br><span class="line">        cell.detailTextLabel?.isHidden = settingswitch.isOn</span><br><span class="line">        settingswitch.addTarget(<span class="keyword">self</span>, action: #selector(onSwitch(sender:)), <span class="keyword">for</span>: <span class="type">UIControl</span>.<span class="type">Event</span>.valueChanged)</span><br><span class="line">        cell.accessoryView = settingswitch</span><br><span class="line">        <span class="comment">// Uncomment the following line to preserve selection between presentations</span></span><br><span class="line">        <span class="comment">// self.clearsSelectionOnViewWillAppear = false</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Uncomment the following line to display an Edit button in the navigation bar for this view controller.</span></span><br><span class="line">        <span class="comment">// self.navigationItem.rightBarButtonItem = self.editButtonItem</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@objc</span> <span class="function"><span class="keyword">func</span> <span class="title">onSwitch</span><span class="params">(sender: UISwitch)</span></span> &#123;</span><br><span class="line">        cell.detailTextLabel?.isHidden = sender.isOn</span><br><span class="line">        <span class="keyword">if</span> sender.isOn &#123;</span><br><span class="line">            cell.detailTextLabel?.text = <span class="literal">nil</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            cell.detailTextLabel?.text = <span class="string">"你可能错过重要通知，点击打开"</span></span><br><span class="line">        &#125;</span><br><span class="line">        cell.layoutSubviews()</span><br><span class="line"><span class="comment">//        print(cell.detailTextLabel?.text)</span></span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src="staticlizi24.png" alt=""></p><h1 id="UITableView的动态单元格"><a href="#UITableView的动态单元格" class="headerlink" title="UITableView的动态单元格"></a>UITableView的动态单元格</h1><p>使用表格（<strong>UITableView</strong>）时，我们可以选择其采用静态单元格（<strong>Static Cell</strong>）还是动态单元格（<strong>Dynamic Cell</strong>）。前者使用方便，但是后者更加灵活。上面已经把一些需要用到的协议，类已经介绍了一遍。这里我们用案例来实战一遍。</p><p>假如这里我们有一批英雄联盟英雄的数据，存放在项目里，是一个plist文件。</p><p><img src="dataplist.png" alt=""></p><p>建立一个模型Hero类</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hero</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> name: <span class="type">String</span>?</span><br><span class="line">    <span class="keyword">var</span> icon: <span class="type">String</span>?</span><br><span class="line">    <span class="keyword">var</span> intro: <span class="type">String</span>?</span><br><span class="line">    <span class="keyword">var</span> url: <span class="type">String</span>?</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">init</span>(dict: [<span class="type">String</span>: <span class="type">AnyObject</span>]) &#123;</span><br><span class="line">        <span class="keyword">self</span>.name = dict[<span class="string">"name"</span>] <span class="keyword">as</span>? <span class="type">String</span></span><br><span class="line">        <span class="keyword">self</span>.icon = dict[<span class="string">"icon"</span>] <span class="keyword">as</span>? <span class="type">String</span></span><br><span class="line">        <span class="keyword">self</span>.intro = dict[<span class="string">"intro"</span>] <span class="keyword">as</span>? <span class="type">String</span></span><br><span class="line">        <span class="keyword">self</span>.url = dict[<span class="string">"url"</span>] <span class="keyword">as</span>? <span class="type">String</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里不使用<code>UITableViewController</code>，我们使用<code>UIViewController</code>来建立一个<code>UITableViewController</code>。并实现<code>UITableViewDelegate</code>, <code>UITableViewDataSource</code>协议。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DymViewController</span>: <span class="title">UIViewController</span>, <span class="title">UITableViewDelegate</span>, <span class="title">UITableViewDataSource</span></span></span><br></pre></td></tr></table></figure><p>新建一个<code>UITableView</code>成员变量，并在viewDIdLoad初始化。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">open</span> <span class="keyword">var</span> tableview: <span class="type">UITableView</span>!</span><br><span class="line"></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">super</span>.viewDidLoad()</span><br><span class="line">  <span class="comment">//如果不指定tableView的样式，则默认使用UITableViewStylePlain样式。</span></span><br><span class="line">  <span class="keyword">self</span>.tableview = <span class="type">UITableView</span>(frame: <span class="keyword">self</span>.view.frame, style: <span class="type">UITableView</span>.<span class="type">Style</span>.plain);</span><br><span class="line">  <span class="keyword">self</span>.tableview.delegate = <span class="keyword">self</span>;</span><br><span class="line">  <span class="keyword">self</span>.tableview.dataSource = <span class="keyword">self</span>;</span><br><span class="line">  <span class="keyword">self</span>.view.addSubview(<span class="keyword">self</span>.tableview)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>新建一个data类来管理用于展示UITableView的数据类</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> data: [<span class="type">Hero</span>] &#123;</span><br><span class="line">  <span class="keyword">let</span> plistdata = <span class="type">NSArray</span>(contentsOfFile: <span class="type">Bundle</span>.main.path(forResource: <span class="string">"heros"</span>, ofType: <span class="string">"plist"</span>)!)!</span><br><span class="line">  <span class="keyword">var</span> heros: [<span class="type">Hero</span>] = [<span class="type">Hero</span>]()</span><br><span class="line">  <span class="keyword">var</span> hero: <span class="type">Hero</span></span><br><span class="line">  <span class="keyword">for</span> item <span class="keyword">in</span> plistdata &#123;</span><br><span class="line">    hero = <span class="type">Hero</span>(dict: item <span class="keyword">as</span>! [<span class="type">String</span>: <span class="type">AnyObject</span>])</span><br><span class="line">    heros.append(hero)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> heros</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现UITableVIewDataSource重要的两个协议方法：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">tableView</span><span class="params">(<span class="number">_</span> tableView: UITableView, numberOfRowsInSection section: Int)</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> data.<span class="built_in">count</span>;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">tableView</span><span class="params">(<span class="number">_</span> tableView: UITableView, cellForRowAt indexPath: IndexPath)</span></span> -&gt; <span class="type">UITableViewCell</span> &#123;</span><br><span class="line">  <span class="comment">//创建样式为Basic的UItableViewCell</span></span><br><span class="line">  <span class="keyword">let</span> cell = <span class="type">UITableViewCell</span>(style: <span class="type">UITableViewCell</span>.<span class="type">CellStyle</span>.subtitle, reuseIdentifier: <span class="literal">nil</span>)</span><br><span class="line">  cell.imageView?.image = <span class="type">UIImage</span>(named: data[indexPath.row].icon!)</span><br><span class="line">  cell.textLabel?.text = data[indexPath.row].name</span><br><span class="line">  cell.detailTextLabel?.text = data[indexPath.row].intro</span><br><span class="line">  <span class="keyword">return</span> cell;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行效果：</p><p><img src="dymlizi1.png" alt=""></p><blockquote><p>性能优化在这里不考虑</p></blockquote><p><strong>但是英雄也有分类，比如有战士、法师、射手等的分类，我们再修改一下plist的文件。</strong></p><p><img src="dymlizi2.png" alt=""></p><p>再新建一个plist存放归类的译文。</p><p><img src="dymlizi3.png" alt=""></p><p>新建一个DymGroupViewController，这里不在原来代码修改。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DymGroupViewController</span>: <span class="title">UIViewController</span>, <span class="title">UITableViewDelegate</span>, <span class="title">UITableViewDataSource</span></span></span><br></pre></td></tr></table></figure><p>新建一个<code>UITableView</code>成员变量，并在viewDIdLoad初始化。这里注意，TableView的样式要做改变。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">open</span> <span class="keyword">var</span> tableview: <span class="type">UITableView</span>!</span><br><span class="line"></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">super</span>.viewDidLoad()</span><br><span class="line">  <span class="comment">//如果不指定tableView的样式，则默认使用UITableViewStylePlain样式。</span></span><br><span class="line">  <span class="keyword">self</span>.tableview = <span class="type">UITableView</span>(frame: <span class="keyword">self</span>.view.frame, style: <span class="type">UITableView</span>.<span class="type">Style</span>.grouped);</span><br><span class="line">  <span class="keyword">self</span>.tableview.delegate = <span class="keyword">self</span>;</span><br><span class="line">  <span class="keyword">self</span>.tableview.dataSource = <span class="keyword">self</span>;</span><br><span class="line">  <span class="keyword">self</span>.view.addSubview(<span class="keyword">self</span>.tableview)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的数据获取也有很大的改动</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//分类key数组：例如Support、Tank</span></span><br><span class="line"><span class="keyword">var</span> categoryname: [<span class="type">String</span>] &#123;</span><br><span class="line">  <span class="keyword">let</span> plistdata = <span class="type">NSDictionary</span>(contentsOfFile: <span class="type">Bundle</span>.main.path(forResource: <span class="string">"category"</span>, ofType: <span class="string">"plist"</span>)!)!</span><br><span class="line">  <span class="keyword">return</span> plistdata.allKeys <span class="keyword">as</span>! [<span class="type">String</span>]</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="comment">//对应分类key数组的译文：例如Support对应辅助，Tank对应坦克</span></span><br><span class="line"><span class="keyword">var</span> categoryvalue: [<span class="type">String</span>] &#123;</span><br><span class="line">  <span class="keyword">let</span> plistdata = <span class="type">NSDictionary</span>(contentsOfFile: <span class="type">Bundle</span>.main.path(forResource: <span class="string">"category"</span>, ofType: <span class="string">"plist"</span>)!)!</span><br><span class="line">  <span class="keyword">return</span> plistdata.allValues <span class="keyword">as</span>! [<span class="type">String</span>]</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="comment">//所有英雄数据的存放，并分类存放了英雄的分类，即用key来存放对应一个英雄的列表数组</span></span><br><span class="line"><span class="keyword">var</span> data: [<span class="type">String</span>: <span class="type">Array</span>&lt;<span class="type">Hero</span>&gt;] &#123;</span><br><span class="line">  <span class="keyword">let</span> plistdata = <span class="type">NSDictionary</span>(contentsOfFile: <span class="type">Bundle</span>.main.path(forResource: <span class="string">"herosgroup"</span>, ofType: <span class="string">"plist"</span>)!)!</span><br><span class="line">  <span class="keyword">var</span> rd: [<span class="type">String</span>: <span class="type">Array</span>&lt;<span class="type">Hero</span>&gt;] = [<span class="type">String</span>: <span class="type">Array</span>&lt;<span class="type">Hero</span>&gt;]()</span><br><span class="line">  <span class="keyword">var</span> heros: [<span class="type">Hero</span>]</span><br><span class="line">  <span class="keyword">for</span> (items,value) <span class="keyword">in</span> plistdata &#123;</span><br><span class="line">    heros = [<span class="type">Hero</span>]()</span><br><span class="line">    <span class="keyword">var</span> hero: <span class="type">Hero</span></span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> value <span class="keyword">as</span>! [[<span class="type">String</span>: <span class="type">AnyObject</span>]] &#123;</span><br><span class="line">      hero = <span class="type">Hero</span>(dict: item)</span><br><span class="line">      heros.append(hero)</span><br><span class="line">    &#125;</span><br><span class="line">    rd[items <span class="keyword">as</span>! <span class="type">String</span>] = heros</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> rd</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>设置好对应的section数和对应section数的行数，并设置section header的标题。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//对数据进行分组展示</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">numberOfSections</span><span class="params">(<span class="keyword">in</span> tableView: UITableView)</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> categoryname.<span class="built_in">count</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//对应每个分组下的英雄列表数量</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">tableView</span><span class="params">(<span class="number">_</span> tableView: UITableView, numberOfRowsInSection section: Int)</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> data[categoryname[section]]!.<span class="built_in">count</span></span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="comment">//列表的展示</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">tableView</span><span class="params">(<span class="number">_</span> tableView: UITableView, cellForRowAt indexPath: IndexPath)</span></span> -&gt; <span class="type">UITableViewCell</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> cell: <span class="type">UITableViewCell</span> = <span class="type">UITableViewCell</span>(style: <span class="type">UITableViewCell</span>.<span class="type">CellStyle</span>.subtitle, reuseIdentifier: <span class="literal">nil</span>)</span><br><span class="line">  <span class="keyword">let</span> hero = data[categoryname[indexPath.section]]![indexPath.row]</span><br><span class="line">  cell.imageView?.image = <span class="type">UIImage</span>(named: hero.icon!)</span><br><span class="line">  cell.textLabel?.text = hero.name</span><br><span class="line">  cell.detailTextLabel?.text = hero.intro</span><br><span class="line">  <span class="keyword">return</span> cell</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">tableView</span><span class="params">(<span class="number">_</span> tableView: UITableView, titleForHeaderInSection section: Int)</span></span> -&gt; <span class="type">String</span>? &#123;</span><br><span class="line">  <span class="keyword">return</span> categoryvalue[section]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行效果：</p><p><img src="dymlizi4.png" alt=""></p><p>到这一步后，我们会发现点击列表没有反应，我们来实现一下跳转到网页，英雄数据里面有一个url属性就是跳转的地址。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">tableView</span><span class="params">(<span class="number">_</span> tableView: UITableView, didSelectRowAt indexPath: IndexPath)</span></span> &#123;</span><br><span class="line">  <span class="built_in">print</span>(indexPath.row, indexPath.section)</span><br><span class="line">  <span class="keyword">let</span> url = <span class="type">URL</span>(string: data[categoryname[indexPath.section]]![indexPath.row].url!)!</span><br><span class="line">  <span class="type">UIApplication</span>.shared.openURL(url)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>跳转后效果：</p><p><img src="dymlizi5.png" alt=""></p><h1 id="自定义UITableViewCell"><a href="#自定义UITableViewCell" class="headerlink" title="自定义UITableViewCell"></a>自定义UITableViewCell</h1><h2 id="静态单元格中使用自定义Cell"><a href="#静态单元格中使用自定义Cell" class="headerlink" title="静态单元格中使用自定义Cell"></a>静态单元格中使用自定义Cell</h2><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://developer.apple.com/documentation/uikit/uitableview" target="_blank" rel="noopener">https://developer.apple.com/documentation/uikit/uitableview</a></p><p><a href="https://developer.apple.com/documentation/uikit/uitableviewdatasource" target="_blank" rel="noopener">https://developer.apple.com/documentation/uikit/uitableviewdatasource</a></p><p><a href="https://developer.apple.com/documentation/uikit/uitableviewdelegate" target="_blank" rel="noopener">https://developer.apple.com/documentation/uikit/uitableviewdelegate</a></p><p><a href="https://developer.apple.com/documentation/uikit/uitableviewcell" target="_blank" rel="noopener">https://developer.apple.com/documentation/uikit/uitableviewcell</a></p><p><a href="https://developer.apple.com/documentation/uikit/views_and_controls/table_views/filling_a_table_with_data" target="_blank" rel="noopener">https://developer.apple.com/documentation/uikit/views_and_controls/table_views/filling_a_table_with_data</a></p><p><a href="https://developer.apple.com/documentation/uikit/views_and_controls/table_views/configuring_the_cells_for_your_table" target="_blank" rel="noopener">https://developer.apple.com/documentation/uikit/views_and_controls/table_views/configuring_the_cells_for_your_table</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;简述&quot;&gt;&lt;a href=&quot;#简述&quot; class=&quot;headerlink&quot; title=&quot;简述&quot;&gt;&lt;/a&gt;简述&lt;/h1&gt;&lt;p&gt;iOS的&lt;code&gt;UITableView&lt;/code&gt;显示单列垂直滚动内容。表格中的每一行都包含一段应用内容。例如，“联系人”应用程序在单独的行中显示每个联系人的姓名，“设置”应用程序的主页面显示可用的设置组。您可以将表配置为显示单个长行列表，也可以将相关行分组为多个部分，以便更轻松地导航内容。&lt;/p&gt;
    
    </summary>
    
      <category term="Ios" scheme="http://hackycy.github.io/categories/Ios/"/>
    
    
      <category term="Ios" scheme="http://hackycy.github.io/tags/Ios/"/>
    
      <category term="Swift" scheme="http://hackycy.github.io/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title>Xcode报错修复Multiple commands produce</title>
    <link href="http://hackycy.github.io/2019/07/13/Xcode%E6%8A%A5%E9%94%99%E4%BF%AE%E5%A4%8DMultiple-commands-produce/"/>
    <id>http://hackycy.github.io/2019/07/13/Xcode报错修复Multiple-commands-produce/</id>
    <published>2019-07-13T09:17:38.000Z</published>
    <updated>2019-07-13T09:41:01.209Z</updated>
    
    <content type="html"><![CDATA[<p><strong>Xcode版本：10.2.1</strong></p><p>今天导入了一个Demo项目，出现了<strong>Multiple commands produce</strong>错误，记录下解决办法。</p><a id="more"></a><p>Xcode10使用了一个的新创建系统，比之前的提供更好的可靠性与创建性能，而且可以获取项目配置问题（默认设置新创建系统）</p><blockquote><p>Build System</p><p>Again, Xcode 10 uses a new build system. The new build system provides improved reliability and build performance, and it catches project configuration problems that the legacy build system does not.<br>The legacy build system is still available in Xcode 10. To use the legacy build system, select it in the File &gt; Project/Workspace Settings sheet. Projects configured to use the legacy build system will display an orange hammer icon in the Activity View.</p></blockquote><p>在苹果文档中，提及Xcode10中的关于旧项目New Build System更改适配中提及到以下两点</p><blockquote><p>The new build system has stricter checks for cycles between elements in the build in order to prevent unnecessary rebuilds.</p><p>It is an error for any individual file in the build to be produced by more than one build command. For example, if two targets each declare the same output file from a shell script phase, factor out the declaration of the output file into a single target.</p></blockquote><p>New Build System会对构建中的元素循环进行严格的检查，避免不必要的重建，这个也是错误出现的原因。</p><p><strong>错误信息</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">error: Multiple commands produce <span class="string">'/Users/zjyzy/Library/Developer/Xcode/DerivedData/UMengComDemo-eisszriydfvwtlgnymkievxxjndx/Build/Products/Debug-iphonesimulator/UMengComDemo.app/Info.plist'</span>:</span><br><span class="line">1) Target <span class="string">'UMengComDemo'</span> (project <span class="string">'UMengComDemo'</span>) has copy <span class="built_in">command</span> from <span class="string">'/Users/zjyzy/WorkPlace/xcode/AllDemo/test/MultiFunctioniOSDemo/UMengComDemo/Info.plist'</span> to <span class="string">'/Users/zjyzy/Library/Developer/Xcode/DerivedData/UMengComDemo-eisszriydfvwtlgnymkievxxjndx/Build/Products/Debug-iphonesimulator/UMengComDemo.app/Info.plist'</span></span><br><span class="line">2) Target <span class="string">'UMengComDemo'</span> (project <span class="string">'UMengComDemo'</span>) has process <span class="built_in">command</span> with output <span class="string">'/Users/zjyzy/Library/Developer/Xcode/DerivedData/UMengComDemo-eisszriydfvwtlgnymkievxxjndx/Build/Products/Debug-iphonesimulator/UMengComDemo.app/Info.plist'</span></span><br></pre></td></tr></table></figure><p><strong>解决方案</strong></p><ul><li><p>不使用<code>New Build System</code></p><p>打开<code>Xcode</code> &gt; <code>File</code> &gt; <code>Project Setting</code></p><p><img src="fix1.png" alt=""></p><p>将<code>Build System</code>选项选择为<code>Legacy Build System</code>即可。</p></li><li><p>根据出错信息，在新创建系统模式下，去除多余的引用重建</p><p><img src="fix2.png" alt=""></p><p>在<code>target</code> -&gt; <code>Build phase</code> &gt; <code>Copy Bundle Resource</code> 中找到<code>info.plist</code>，移除掉<code>info.plist</code>即可。</p></li></ul><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://www.jianshu.com/p/fdb1421f3c8b" target="_blank" rel="noopener">https://www.jianshu.com/p/fdb1421f3c8b</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;Xcode版本：10.2.1&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;今天导入了一个Demo项目，出现了&lt;strong&gt;Multiple commands produce&lt;/strong&gt;错误，记录下解决办法。&lt;/p&gt;
    
    </summary>
    
      <category term="Ios" scheme="http://hackycy.github.io/categories/Ios/"/>
    
    
      <category term="Ios" scheme="http://hackycy.github.io/tags/Ios/"/>
    
  </entry>
  
  <entry>
    <title>Xcode报错修复SWIFT_VERSION &#39;3.0&#39; is unsupported, supported versions are:4.0,4.2,5.0</title>
    <link href="http://hackycy.github.io/2019/07/13/Xcode%E6%8A%A5%E9%94%99%E4%BF%AE%E5%A4%8DSWIFT-VERSION-3-0-is-unsupported-supported-versions-are-4-0-4-2-5-0/"/>
    <id>http://hackycy.github.io/2019/07/13/Xcode报错修复SWIFT-VERSION-3-0-is-unsupported-supported-versions-are-4-0-4-2-5-0/</id>
    <published>2019-07-13T09:01:35.000Z</published>
    <updated>2019-07-13T09:40:57.411Z</updated>
    
    <content type="html"><![CDATA[<p><strong>Xcode版本：10.2.1</strong></p><p>今天导入了一个Demo项目，出现了SWIFT_VERSION ‘3.0’ is unsupported, supported versions are: 4.0, 4.2, 5.0.错误，记录下解决办法。</p><a id="more"></a><p><img src="errorpic.png" alt=""></p><p><img src="errorpic2.png" alt=""></p><p><strong>解决方法：</strong></p><p>找到发生错误的Target：</p><p><img src="fix1.png" alt=""></p><p><img src="fix2.png" alt=""></p><p>步骤： <code>${Target}</code> &gt;<code>Build Settings</code> &gt; <code>Swift Compiler - Language</code> &gt; <code>Swift Language Version</code>选择支持的版本即可。</p><p><img src="fix3.png" alt=""></p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://www.jianshu.com/p/bdfcb8759dee" target="_blank" rel="noopener">https://www.jianshu.com/p/bdfcb8759dee</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;Xcode版本：10.2.1&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;今天导入了一个Demo项目，出现了SWIFT_VERSION ‘3.0’ is unsupported, supported versions are: 4.0, 4.2, 5.0.错误，记录下解决办法。&lt;/p&gt;
    
    </summary>
    
      <category term="Ios" scheme="http://hackycy.github.io/categories/Ios/"/>
    
    
      <category term="Ios" scheme="http://hackycy.github.io/tags/Ios/"/>
    
  </entry>
  
  <entry>
    <title>Android O应用图标适配</title>
    <link href="http://hackycy.github.io/2019/07/13/Android-O%E5%BA%94%E7%94%A8%E5%9B%BE%E6%A0%87%E9%80%82%E9%85%8D/"/>
    <id>http://hackycy.github.io/2019/07/13/Android-O应用图标适配/</id>
    <published>2019-07-13T02:58:52.000Z</published>
    <updated>2019-07-14T07:49:03.600Z</updated>
    
    <content type="html"><![CDATA[<p>Android 8.0现在已经很普及了，甚至有的厂商已经开始升级到Android P，至少我的三星上个星期也是7月初就开始推送Android P让我更新自己的手机系统了，那么应用图标的适配就肯定是板上钉钉的事情了。</p><a id="more"></a><h1 id="前景"><a href="#前景" class="headerlink" title="前景"></a>前景</h1><p><strong>手机应用图标的历史</strong>：其实要从苹果开始讲起。在上世纪80年代，苹果还在设计Lisa和Macintosh电脑的时候，乔布斯就是个圆角矩形的狂热支持者。当时苹果的工程师写出了一套绝妙的算法，可以在电脑上绘制出圆和椭圆，所有观看者都被震惊了，除了乔布斯，因为乔布斯觉得圆和椭圆虽然也不错，但是如果能绘制出带圆角的矩形就更好了。当时那位工程师觉得这是不可能实现的，而且也完全用不着圆角矩形，能满足基本的绘图需求就可以了。乔布斯愤怒地拉着他走了3条街，指出大街上各种应用圆角矩形的例子，最后那位工程师第二天就做出了绘制圆角矩形的功能。</p><p>因此，在2007年一代iPhone诞生的时候，所有应用程序的图标都毫不出乎意料地使用了圆角矩形图标，即使是第三方应用也被强制要求使用圆角矩形图标，并且这一规则一直延续到了今天的iOS 11当中，如下图所示：</p><p><img src="iosicon.jpg" alt=""></p><p>相反，Android系统在设计的时候就不喜欢苹果这样的封闭与强制，而是选择了自由与开放，对应用图标的形状不做任何强制要求，开发者们可以自由进行选择：</p><p><img src="androidicon.jpg" alt=""></p><p>可以看到，在Android上，应用图标可以是方形、圆形、圆角矩形、或者是其他任意不规则图形。</p><p>本来就是两家公司不同的设计理念，也说不上孰高孰低。但由于Android操作系统是开源的，国内一些手机厂商在定制操作系统的时候就把这一特性给改了。比如小米手机，就选择了向苹果靠拢，强制要求应用图标圆角化。如果某些应用的图标不是圆角矩形的呢？小米系统会自动给它加上一个圆角的效果，如下图所示：</p><p><img src="miicon.jpg" alt=""></p><p>小米的这种做法看上去是向苹果学习，但实际上是相当恶心的。因为谁都可以看出来，这种自动添加的圆角矩形非常丑，因此很多公司就索性直接将应用的图标都设计成圆角矩形的，正好Android和iOS都用同一套图标还省事了。</p><p>但是这就让Google不开心了，这不是变向强制要求开发者必须将图标设计成圆角矩形吗？于是在去年的Google I/O大会上，Google点名批评了小米的这种做法，说其违反了Android自由和开放的理念。</p><p>除了变向强制要求应用图标圆角化，小米的这种处理方式还有一个弊端，就是如果应用图标的圆角弧度和小米系统要求的不同，那么会出现异常丑陋的效果。</p><p><img src="miicon2.webp" alt=""></p><p>该问题也存在了非常之久，Google多年来对此也是睁一只眼闭一只眼。终于在Android 8.0系统中，Google下定决心要好好整治一下Android应用图标的规范性了。</p><blockquote><p>原文来自郭林</p></blockquote><h1 id="8-0系统的应用图标适配"><a href="#8-0系统的应用图标适配" class="headerlink" title="8.0系统的应用图标适配"></a>8.0系统的应用图标适配</h1><p>这个问题对于Google来说还是挺难解决的。因为Google一直在强调自由与开放，那么小米强制要求所有应用图标都必须圆角化也是人家的自由呀，你不准人家这么干是不是本身就违背了自由和开放的理念呢？当然我们在这里讨论这个，有点像讨论先有鸡还是先有蛋的感觉，不过Google还是想出了一套完美的解决方案。</p><p>从Android 8.0系统开始，应用程序的图标被分为了两层：前景层和背景层。也就是说，我们在设计应用图标的时候，需要将前景和背景部分分离，前景用来展示应用图标的Logo，背景用来衬托应用图标的Logo。需要注意的是，背景层在设计的时候只允许定义颜色和纹理，但是不能定义形状。</p><p>那么应用图标的形状由谁来定义呢？Google将这个权利就交给手机厂商了。不是有些手机厂商喜欢学习苹果的圆角图标吗？没问题，由于应用图标的设计分为了两层，手机厂商只需要在这两层之上再盖上一层mask，这个mask可以是圆角矩形、圆形或者是方形等等，视具体手机厂商而定，就可以瞬间让手机上的所有应用图标都变成相同的规范。原理示意图如下：</p><p><img src="oicon.gif" alt=""></p><p>可以看到，这里背景层是一张蓝色的网格图，前景层是一张Android机器人Logo图，然后盖上一层圆形的mask，最终就裁剪出了一张圆形的应用图标。</p><p>官方命名为Adaptive Icons。</p><blockquote><p>如果你的APP中的targetSdkVersion是低于26的，那么就可以不用进行应用图标适配，Android 8.0系统仍然是向下兼容的。但是如果你将targetSdkVersion指定到了26或者更高，那么Android系统就会认为你的APP已经做好了8.0系统的适配工作，当然包括了应用图标的适配。(图标会有点丑)</p></blockquote><h1 id="适配方案"><a href="#适配方案" class="headerlink" title="适配方案"></a>适配方案</h1><p>Android Studio 3.0以上的版本中已经内置了8.0系统应用图标适配的功能。</p><p>新建一个项目，并查看app的gradle是否已经将targetSdkVersion设置为26。</p><p>在查看一下AndroidManifest.xml文件</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">application</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:icon</span>=<span class="string">"@mipmap/ic_launcher"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:label</span>=<span class="string">"IconDemo"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:roundIcon</span>=<span class="string">"@mipmap/ic_launcher_round"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:theme</span>=<span class="string">"@style/AppTheme"</span>&gt;</span></span><br><span class="line">  //.....</span><br><span class="line"><span class="tag">&lt;/<span class="name">application</span>&gt;</span></span><br></pre></td></tr></table></figure><p>我们需要关注的点是android:icon这个属性，通过这个属性，我们将应用的图标指定为了mipmap目录下的ic_launcher文件。</p><blockquote><p>还有一个android:roundIcon属性，这是一个只适用在Android 7.1系统上的过渡版本，很快就被8.0系统的应用图标适配所替代了，我们不用去管它。</p></blockquote><p><img src="shipei1.png" alt=""></p><p>在和以前版本不一样的地方就在于多了一个<code>mipmap-anydpi-v26</code>的目录，该目录会使得Android 8.0或以上系统的手机，都会使用这个目录下的ic_launcher来作为图标。</p><p>mipmap-anydpi-v26目录下的ic_launcher并不是一张图片，而是一个XML文件，我们打开这个文件看一下，代码如下所示：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">adaptive-icon</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">background</span> <span class="attr">android:drawable</span>=<span class="string">"@drawable/ic_launcher_background"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">foreground</span> <span class="attr">android:drawable</span>=<span class="string">"@drawable/ic_launcher_foreground"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">adaptive-icon</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这是一个8.0系统应用图标适配的标准写法，在<code>&lt;adaptive-icon&gt;</code>标签中定义一个<code>&lt;background&gt;</code>标签用于指定图标的背景层，定义一个<code>&lt;foreground&gt;</code>标签用于指定图标的前景层。</p><p>再打开ic_launcher_background和ic_launcher_foreground后，发现他们只是一个使用SVG格式绘制出来的带纹理的底图。</p><blockquote><p>SVG格式的图片都是使用AI、PS等图像编辑软件制作之后导出的，基本没有人可以手工编写SVG图片。</p></blockquote><p>一般项目中也可以使用PNG、JPG等格式的图片，或者是一个背景色也可以。</p><p><img src="runprev.png" alt=""></p><p>这就是一个前景层盖在背景层上，然后再被圆形mask进行裁剪之后的效果。</p><h1 id="开始适配"><a href="#开始适配" class="headerlink" title="开始适配"></a>开始适配</h1><p>这里的话拿推特的图标作为例子，案例图在下方：</p><p><img src="tuite.png" alt=""></p><p><img src="tuite_forge.png" alt=""></p><p>背景色用PS提取出来的颜色值是#1da2f2。</p><p>图标已经准备好了，我们开始做图标适配了，回到项目中，然后按下Windows：Ctrl+Shift+A / Mac：command+shft+A 快捷键，并输入Image Asset，如下所示：</p><p><img src="imageassets.png" alt=""></p><p>当然也可以对着app(module)目录下右键新建</p><p><img src="imageassetsother.png" alt=""></p><p>点击回车键打开Asset Studio编辑器，在这里就可以进行应用图标适配了。</p><p><img src="adapter1.png" alt=""></p><p>这个Asset Studio编辑器非常简单好用，一学就会。左边是操作区域，右边是预览区域。</p><p>先来看操作区域，第一行的<code>Icon Type</code>中选择<code>Adaptive and Legacy</code>，表示同时创建兼容8.0系统以及老版本系统的应用图标。第二行的Name用于指定应用图标的名称，这里也保持默认即可。接下来的三个页签，<code>Foreground Layer</code>用于编辑前景层，<code>Background Layer</code>用于编辑背景层，<code>Legacy</code>用于编辑老版本系统的图标。</p><p>再来看预览区域，这个就十分简单了，用于预览应用图标的最终效果。在预览区域中给出了可能生成的图标形状，包括圆形、圆角矩形、方形等等。</p><p><strong>注意每个预览图标中都有一个圆圈，这个圆圈叫作安全区域，必须要保证图标的前景层完全处于安全区域当中才行，否则可能会出现图标被手机厂商的mask裁剪掉的情况。</strong></p><p>放一张GIF操作过程：(PS:图比较大，不太懂的压缩)</p><p><img src="demo.gif" alt=""></p><p>Android Studio会自动帮我们生成适配8.0系统的应用图标，以及适配老版本系统的应用图标。</p><p>来看看运行效果：</p><p><img src="demo2.png" alt=""></p><p>这里适配就完成啦。</p><h1 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h1><p>Asset Studio自动生成的ic_launcher图标和ic_launcher_round分辨率比较低，在vivo厂商上架应用过程中被提示出将其替换为高清图标，按照vivo提示替换即可。</p><h1 id="参数说明"><a href="#参数说明" class="headerlink" title="参数说明"></a>参数说明</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Layer Name - 图层名称</span><br><span class="line">Resize - 制定大小</span><br><span class="line">Round Icon - 仅针对android 7.1 icon处理</span><br><span class="line">Google Play Store Icon - 在google play商店中展示图标</span><br><span class="line">Icon Type - Launcher Icons(Legacy only)</span><br><span class="line">Asset Type - 资源类型，可选图片，剪切画，文本</span><br><span class="line">Path - 资源路径</span><br><span class="line">Name - 如果您不想使用默认名称，可以键入一个新名称。如果资源名称已在项目中存在（向导底部出现错误提示），它将被覆盖。名称只能包含小写字符、下划线和数字。</span><br><span class="line">Trim - 要调整源资产中图标图形与边框之间的边距，请选择 Yes。此操作将移除透明空间，同时保留纵横比。要保持源资产不变，请选择 No。默认值为：No</span><br><span class="line">Padding - 如果您想要调整全部四侧的源资产内边距，请移动滑块。选择 -10% 和 50% 之间的值。如果您也选择了 Trim，则首先会进行剪裁。默认值为：0%</span><br><span class="line">Foreground - 要更改 Clip Art 或 Text 图标的前景色，请点击字段。在 Select Color 对话框中，指定颜色，然后点击 Choose。字段中会显示新值。默认值为：000000</span><br><span class="line">Background - 要更改背景色，请点击字段。在 Select Color 对话框中，指定颜色，然后点击 Choose。字段中会显示新值。默认值为：FFFFFF</span><br><span class="line">Scaling - 要适合图标大小，请选择 Crop 或 Shrink to Fit。选择裁剪，图像边缘会被剪切；选择缩减，图像边缘不会被剪切。源资产仍然不合适时，如果需要，您可以调整内边距。默认值为：Shrink to Fit</span><br><span class="line">Shape - 要为您的源资产添加背景，请选择形状，选项包括圆、正方形、竖直矩形或水平矩形。要想使用透明的背景，请选择 None。默认值为：Square</span><br><span class="line">Effect - 如果您想要为正方形或矩形的右上角添加折角效果，请选择 DogEar。如果不需要，请选择 None。默认值为：None</span><br></pre></td></tr></table></figure><p><a href="https://developer.android.com/studio/write/image-asset-studio?hl=zh-cn" target="_blank" rel="noopener">https://developer.android.com/studio/write/image-asset-studio?hl=zh-cn</a></p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://medium.com/google-design/understanding-android-adaptive-icons-cee8a9de93e2" target="_blank" rel="noopener">https://medium.com/google-design/understanding-android-adaptive-icons-cee8a9de93e2</a></p><p><a href="https://mp.weixin.qq.com/s/WxgHJ1stBjokPi6lTUd1Mg" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/WxgHJ1stBjokPi6lTUd1Mg</a></p><p><a href="https://developer.android.com/guide/practices/ui_guidelines/icon_design_adaptive" target="_blank" rel="noopener">https://developer.android.com/guide/practices/ui_guidelines/icon_design_adaptive</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Android 8.0现在已经很普及了，甚至有的厂商已经开始升级到Android P，至少我的三星上个星期也是7月初就开始推送Android P让我更新自己的手机系统了，那么应用图标的适配就肯定是板上钉钉的事情了。&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="http://hackycy.github.io/categories/Android/"/>
    
    
      <category term="Android" scheme="http://hackycy.github.io/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>解决Android Studio——No toolchains found in the NDK toolchains folder for ABI with prefix: mips64el-linux-android错误</title>
    <link href="http://hackycy.github.io/2019/07/12/%E8%A7%A3%E5%86%B3Android-Studio%E2%80%94%E2%80%94No-toolchains-found-in-the-NDK-toolchains-folder-for-ABI-with-prefix-mips64el-linux-android%E9%94%99%E8%AF%AF/"/>
    <id>http://hackycy.github.io/2019/07/12/解决Android-Studio——No-toolchains-found-in-the-NDK-toolchains-folder-for-ABI-with-prefix-mips64el-linux-android错误/</id>
    <published>2019-07-12T03:11:34.000Z</published>
    <updated>2019-07-12T03:17:29.887Z</updated>
    
    <content type="html"><![CDATA[<p>今天导入了一个比较老一些的项目，AS一直提示出该错误：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">No toolchains found <span class="keyword">in</span> the NDK toolchains folder <span class="keyword">for</span> ABI with prefix: mips64el-linux-android</span><br></pre></td></tr></table></figure><a id="more"></a><p>查了网上一些解决办法，可用的办法是该办法：</p><p><strong>解决方案：</strong></p><ol><li>修改build.gradle中的Gradle Build Tool版本，改为3.1以及以上版本</li><li>将Android Studio升级到3.1以及以上版本</li></ol><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    classpath <span class="string">'com.android.tools.build:gradle:3.2.0'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>问题原因：</strong></p><p>NDK的更新记录里有一段话：</p><blockquote><p>This version of the NDK is incompatible with the Android Gradle plugin<br>version 3.0 or older. If you see an error like<br><code>No toolchains found in the NDK toolchains folder for ABI with prefix: mips64el-linux-android</code>,<br>update your project file to [use plugin version 3.1 or newer]. You will also<br>need to upgrade to Android Studio 3.1 or newer.</p></blockquote><p>即新版本的NDK与3.0及以前旧版的Android Gradle plugin插件不兼容</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://cloud.tencent.com/developer/article/1379721" target="_blank" rel="noopener">https://cloud.tencent.com/developer/article/1379721</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天导入了一个比较老一些的项目，AS一直提示出该错误：&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;No toolchains found &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; the NDK toolchains folder &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; ABI with prefix: mips64el-linux-android&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="Android" scheme="http://hackycy.github.io/categories/Android/"/>
    
    
      <category term="Android" scheme="http://hackycy.github.io/tags/Android/"/>
    
      <category term="Android Studio" scheme="http://hackycy.github.io/tags/Android-Studio/"/>
    
  </entry>
  
  <entry>
    <title>IOS之UIViewController</title>
    <link href="http://hackycy.github.io/2019/07/10/IOS%E4%B9%8BUIViewController/"/>
    <id>http://hackycy.github.io/2019/07/10/IOS之UIViewController/</id>
    <published>2019-07-10T03:06:34.000Z</published>
    <updated>2019-08-16T08:46:49.346Z</updated>
    
    <content type="html"><![CDATA[<p>UIViewController（视图控制器），顾名思义，是 MVC 设计模式中的控制器部分。UIViewController 在 UIKit 中主要功能是用于控制画面的切换，其中的 <code>view</code> 属性（UIView 类型）管理整个画面的外观。</p><a id="more"></a><h1 id="UIViewController生命周期"><a href="#UIViewController生命周期" class="headerlink" title="UIViewController生命周期"></a>UIViewController生命周期</h1><p>用网上拿来的一张图：</p><p><img src="lifecycle.jpg" alt=""></p><p>ViewController 生命周期的第一步是初始化。不过具体调用的方法还有所不同。如果使用 StoryBoard 来创建 ViewController，我们不需要显式地去初始化，Storyboard 会自动使用 <code>initWithCoder:</code> 进行初始化。如果不使用 StoryBoard，我们可以使用 <code>init:</code> 函数进行初始化，<code>init:</code> 函数在实现过程中还会调用 <code>initWithNibName:bundle:</code>。 </p><blockquote><p>尽量避免在 VC 外部调用 <code>initWithNibName:bundle:</code>，而是把它放在 VC 的内部（参考<a href="https://stackoverflow.com/questions/2224077/when-should-i-initialize-a-view-controller-using-initwithnibname" target="_blank" rel="noopener">这里</a>）。</p></blockquote><p>初始化完成后，VC 的生命周期会经过下面几个函数：</p><ul><li><p>(void)loadView</p><p>此时，控制器的 view 还未初始化，可以通过重写这个方法自定义控制器的 View，如果这样做，那就不能调用<code>[super loadView]</code>（上面代码调用是为了方便打印，不然屏幕就是黑的）。</p></li><li><p>(void)viewDidLoad</p><p>在控制器的生命周期中，它只会被调用一次，此时，view 已经初始化好，非常适合做一些页面的初始化任务。由于此时 view 的 bounds 尚未确定，所以不适合写 frame 类型的布局代码，但是给视图添加约束没有影响。</p></li><li><p>(void)viewWillAppear</p><p>它会在控制器的视图将要出现在屏幕中时被调用，在控制器生命周期中可能会被调用多次。在此处，适合做一些与视图出现相关联的任务，例如改变状态栏的方向、风格。</p></li><li><p>(void)viewWillLayoutSubviews</p><p>当 view 的子视图即将布局时，此方法会被调用，触发的条件是：</p><ul><li>view 被添加到视图层次中</li><li>view 的 bounds 发生了改变</li><li>调用了 <code>- setNeedsLayout</code>方法</li><li>调用了 <code>- layoutIfNeeded</code>方法</li></ul><p>这个方法是写 frame 布局代码的好地方，将 view 的子视图布局好，每次 view 大小发生改变时，其子视图布局也会相应改变。</p></li><li><p>(void)viewDidLayoutSubviews</p><p>当 view 的子视图已经布局时，此方法会被调用，触发条件同上。</p></li><li><p>(void)viewDidAppear</p><p>它会在控制器的视图出现在屏幕后被调用，此时，view 的 bounds 已经确定，不过在这里写布局相关代码，可能会反映到屏幕上。</p></li><li><p>(void)viewWillDisappear</p><p>视图即将从屏幕中消失时触发。</p></li><li><p>(void)viewDidDisappear</p><p>视图从屏幕中消失后触发。</p></li></ul><p>代码测试一下：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)loadView</span><br><span class="line">&#123;</span><br><span class="line">    [<span class="keyword">super</span> loadView];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, <span class="built_in">NSStringFromSelector</span>(_cmd));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)viewDidLoad</span><br><span class="line">&#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, <span class="built_in">NSStringFromSelector</span>(_cmd));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)viewWillAppear:(<span class="built_in">BOOL</span>)animated</span><br><span class="line">&#123;</span><br><span class="line">    [<span class="keyword">super</span> viewWillAppear:animated];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, <span class="built_in">NSStringFromSelector</span>(_cmd));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)viewWillLayoutSubviews</span><br><span class="line">&#123;</span><br><span class="line">    [<span class="keyword">super</span> viewWillLayoutSubviews];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, <span class="built_in">NSStringFromSelector</span>(_cmd));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)viewDidLayoutSubviews</span><br><span class="line">&#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLayoutSubviews];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, <span class="built_in">NSStringFromSelector</span>(_cmd));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)viewDidAppear:(<span class="built_in">BOOL</span>)animated</span><br><span class="line">&#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidAppear:animated];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, <span class="built_in">NSStringFromSelector</span>(_cmd));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)viewWillDisappear:(<span class="built_in">BOOL</span>)animated</span><br><span class="line">&#123;</span><br><span class="line">    [<span class="keyword">super</span> viewWillDisappear:animated];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, <span class="built_in">NSStringFromSelector</span>(_cmd));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)viewDidDisappear:(<span class="built_in">BOOL</span>)animated</span><br><span class="line">&#123;</span><br><span class="line">    [<span class="keyword">super</span> viewWillDisappear:animated];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, <span class="built_in">NSStringFromSelector</span>(_cmd));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Demo[3268:99911] loadView</span><br><span class="line">Demo[3268:99911] viewDidLoad</span><br><span class="line">Demo[3268:99911] viewWillAppear:</span><br><span class="line">Demo[3268:99911] viewWillLayoutSubviews</span><br><span class="line">Demo[3268:99911] viewDidLayoutSubviews</span><br><span class="line">Demo[3268:99911] viewDidAppear:</span><br></pre></td></tr></table></figure><p>这是单个控制器情况下，我们在假设现在有一个 AViewController(简称 Avc) 和 BViewController (简称 Bvc)，通过 navigationController 的 push 实现 Avc 到 Bvc 的跳转，下面是各个方法的执行执行顺序：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">A viewDidLoad  </span><br><span class="line">A viewWillAppear  </span><br><span class="line">A viewDidAppear  </span><br><span class="line">B viewDidLoad  </span><br><span class="line">A viewWillDisappear  </span><br><span class="line">B viewWillAppear  </span><br><span class="line">A viewDidDisappear  </span><br><span class="line">B viewDidAppear</span><br></pre></td></tr></table></figure><p>如果再从 Bvc 跳回 Avc，会产生下面的执行顺序：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">B viewWillDisappear  </span><br><span class="line">A viewWillAppear  </span><br><span class="line">B viewDidDisappear  </span><br><span class="line">A viewDidAppear</span><br></pre></td></tr></table></figure><p>可见 viewDidLoad 只会调用一次，再第二次跳回 Avc 的时候，AViewController 仍然存在于内存中，也就不需要 load 了。</p><p>注意上面的生命周期中都没有提到有关 ViewController 销毁的内容，在 iOS 4 &amp; 5 中 ViewController 中有一个 <code>viewDidUnload</code> 方法。当内存不足，应用收到 Memory warning 时，系统会自动调用当前没在界面上的 ViewController 的 <code>viewDidUnload</code>方法。 通常情况下，这些未显示在界面上的 ViewController 是 UINavigationController Push 栈中未在栈顶的 ViewController，以及 UITabBarViewController 中未显示的子 ViewController。这些 View Controller 都会在 Memory Warning 事件发生时，被系统自动调用 <code>viewDidUnload</code>方法。</p><blockquote><p>从 iOS 6 开始，viewDidUnload 方法被废弃掉了，应用受到 memory warning 时也不会再调用 viewDidUnload 方法。我们可以通过重载 <code>- (void)didReceiveMemoryWarning</code> 和 <code>-(void)dealloc</code> 来进行清理工作。</p></blockquote><h1 id="控制器-View-的创建和生命周期"><a href="#控制器-View-的创建和生命周期" class="headerlink" title="控制器 View 的创建和生命周期"></a>控制器 View 的创建和生命周期</h1><p><img src="viewlife.png" alt=""></p><p>图中控制器view的加载过程中有两个很重要的方法：一个是loadView，另外一个是viewDidLoad。</p><p><strong>loadView方法</strong><br>作用：loadView方法是用来负责创建UIViewController的view。</p><p>首先判断下有没有指定storyboard或者xib,如果指定,就会加载它们描述的控制器的view,如果没有指定,创建一个空的view。<br>什么时候调用：每次访问UIViewController的view，当view为nil，就会调用loadView方法。</p><p><strong>viewDidLoad</strong></p><p>作用：一般我们会在这里做界面上的初始化操作，比如往view中添加一些子视图等。<br>什么时候调用：每当view创建完毕的时候，最终都会调用viewDidLoad方法。</p><blockquote><ol><li>通过storyboard创建的控制器，或者通过xib创建的控制器的view，系统会帮我们加载控制器的view，具体内部实现可以看<a href="https://link.juejin.im/?target=http%3A%2F%2Fwww.jianshu.com%2Fp%2Faf2a6a438a0a" target="_blank" rel="noopener">iOS-UIWindow详解</a>，在此不在赘述</li><li><code>ViewController *vc = [[ViewController alloc]init];</code><br>底层也会调用<code>-(instancetype)initWithNibName:(NSString *)nibNameOrNil bundle:(NSBundle *)nibBundleOrNil</code>方法。<br>(1).判断下有没有指定nibName,如果指定了,就会去加载指定的xib<br>(2).如果没有指定,就会判断下有没有跟控制器类名同名的xib,有,就会去加载<br>(3).判断下有没有跟控制器类名同名的xib,但是后缀不带Controller的xib,如果有,就会去加载<br>(4).如果没有任何xib描述控制器的view,就不会加载xib。会创建一个颜色为clearColor的view。</li></ol></blockquote><h1 id="控制器view加载的几种方式"><a href="#控制器view加载的几种方式" class="headerlink" title="控制器view加载的几种方式"></a>控制器view加载的几种方式</h1><h2 id="通过storyboard加载"><a href="#通过storyboard加载" class="headerlink" title="通过storyboard加载"></a>通过storyboard加载</h2><p>当控制器通过storyboard加载时，需要指定storyboard的名称，控制器view最终就是storyboard所描述的样子，这个比较简单，不做详细阐述</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">UIStoryboard</span> *storyboard = [<span class="built_in">UIStoryboard</span> storyboardWithName:<span class="string">@"TestViewController"</span> bundle:<span class="literal">nil</span>];</span><br><span class="line">TestViewController *testVC = [storyboard instantiateInitialViewController];</span><br><span class="line">[<span class="keyword">self</span>.navigationController pushViewController:testVC animated:<span class="literal">YES</span>];</span><br></pre></td></tr></table></figure><blockquote><p>要记住在 attributes inspector中将 Is Initial View Controller选项勾上</p></blockquote><p>或者获取指定Storyboard中Storyboard ID的某个ViewController，例如：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">UIStoryboard</span> *sb = [<span class="built_in">UIStoryboard</span> storyboardWithName:<span class="string">@"Main"</span> bundle:<span class="literal">nil</span>];</span><br><span class="line">SBIDTableViewController *mtvc = [sb instantiateViewControllerWithIdentifier:<span class="string">@"sbid"</span>];</span><br></pre></td></tr></table></figure><h2 id="通过xib加载"><a href="#通过xib加载" class="headerlink" title="通过xib加载"></a>通过xib加载</h2><p>当控制器view通过xib加载的时候，可能会出现三种情况</p><p><strong>1、指定xib名称</strong></p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)touchesBegan:(<span class="built_in">NSSet</span>&lt;<span class="built_in">UITouch</span> *&gt; *)touches withEvent:(<span class="built_in">UIEvent</span> *)event&#123;</span><br><span class="line">  TestViewController *testVC = [[TestViewController alloc] initWithNibName:<span class="string">@"OtherViewController"</span> bundle:<span class="literal">nil</span>];</span><br><span class="line">  [<span class="keyword">self</span>.navigationController pushViewController:testVC animated:<span class="literal">YES</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当我们指定了xib的名称，loadView方法就会去加载对应的xib</p><p><strong>2、不指定xib名称</strong></p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)touchesBegan:(<span class="built_in">NSSet</span>&lt;<span class="built_in">UITouch</span> *&gt; *)touches withEvent:(<span class="built_in">UIEvent</span> *)event&#123;</span><br><span class="line">  TestViewController *testVC = [[TestViewController alloc] init];</span><br><span class="line">  [<span class="keyword">self</span>.navigationController pushViewController:testVC animated:<span class="literal">YES</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当没有指定xib名称，分两种情况：如果有控制器同名的xib则加载，例如TestViewController会加载TestViewController.xib。如果没有与控制器同名的xib文件时，会加载前缀与控制器名相同而不带controller的xib（TestView.xib）</p><p><strong>3、不通过sb\xib加载</strong></p><p>把xib和sb文件都删除掉，什么都不加载。则会默认创建一个UIView，虽然显示为黑色，但其实该颜色是UIWindow的。</p><p><img src="zindex1.png" alt=""></p><p><strong>4、重写loadView方法</strong></p><p>重写控制器的loadView方法:</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)loadView&#123;</span><br><span class="line">  <span class="keyword">self</span>.view = [[<span class="built_in">UIImageView</span> alloc] init];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>控制器view加载出来的时候就是我们设置的UIImageView。如果重写该方法里面什么也不写，和不通过sb\xib加载方式的运行结果相同。不过两者区别是这种方式并没有创建UIView。</p><p><img src="zindex2.png" alt=""></p><p><strong>结论：</strong></p><ul><li>重写loadView方法，则会根据重写的loadView方法创建view</li><li>控制器通过storyboard加载，则根据storyboard的描述创建view</li><li>控制器view通过xib加载，则根据nibName对应的xib创建view</li><li>没有指定nibName，则根据与控制器同名的xib创建view</li><li>没有同名的xib，则根据与控制器名前缀相同不带controller的xib创建view</li><li>如果都没有，则创建一个空白的xib</li><li>storyboard加载的是控制器及控制器view，而xib加载的仅仅只是控制器的view</li></ul><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://hit-alibaba.github.io/interview/iOS/Cocoa-Touch/UIViewController.html" target="_blank" rel="noopener">https://hit-alibaba.github.io/interview/iOS/Cocoa-Touch/UIViewController.html</a></p><p><a href="http://blog.devtang.com/blog/2013/05/18/goodbye-viewdidunload/" target="_blank" rel="noopener">http://blog.devtang.com/blog/2013/05/18/goodbye-viewdidunload/</a></p><p><a href="https://www.jianshu.com/p/23a83706d773" target="_blank" rel="noopener">https://www.jianshu.com/p/23a83706d773</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;UIViewController（视图控制器），顾名思义，是 MVC 设计模式中的控制器部分。UIViewController 在 UIKit 中主要功能是用于控制画面的切换，其中的 &lt;code&gt;view&lt;/code&gt; 属性（UIView 类型）管理整个画面的外观。&lt;/p&gt;
    
    </summary>
    
      <category term="Ios" scheme="http://hackycy.github.io/categories/Ios/"/>
    
    
      <category term="Ios" scheme="http://hackycy.github.io/tags/Ios/"/>
    
      <category term="Objective-C" scheme="http://hackycy.github.io/tags/Objective-C/"/>
    
  </entry>
  
  <entry>
    <title>Android应用内禁止屏幕截图</title>
    <link href="http://hackycy.github.io/2019/07/09/Android%E5%BA%94%E7%94%A8%E5%86%85%E7%A6%81%E6%AD%A2%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE/"/>
    <id>http://hackycy.github.io/2019/07/09/Android应用内禁止屏幕截图/</id>
    <published>2019-07-09T02:18:59.000Z</published>
    <updated>2019-07-09T02:41:34.794Z</updated>
    
    <content type="html"><![CDATA[<p>一个晚上在看了一下微信的收付款功能，想截个图，突然发现提示了一句<strong>由于受安全政策限制，无法截取屏幕截图</strong>，再研究了一下手机的其他APP，中国建设银行APP上也有该提示，出于好奇，查阅了一下该功能的实现方式。</p><a id="more"></a><p>该功能的实现方式很简单，就是在<code>setContentView</code>前加上一句代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">getWindow().setFlags(WindowManager.LayoutParams.FLAG_SECURE, WindowManager.LayoutParams.FLAG_SECURE);</span><br></pre></td></tr></table></figure><p><img src="demo.jpeg" alt=""></p><p>Google官方对于<a href="https://developer.android.com/reference/android/view/WindowManager.LayoutParams.html#FLAG_SECURE" target="_blank" rel="noopener">FLAG_SECURE</a>的解释：</p><blockquote><p>Display flag: Indicates that the display has a secure video output and supports compositing secure surfaces.</p><p>If this flag is set then the display device has a secure video output and is capable of showing secure surfaces. It may also be capable of showing <code>protected buffers</code>.</p><p>If this flag is not set then the display device may not have a secure video output; the user may see a blank region on the screen instead of the contents of secure surfaces or protected buffers.</p><p>Secure surfaces are used to prevent content rendered into those surfaces by applications from appearing in screenshots or from being viewed on non-secure displays. Protected buffers are used by secure video decoders for a similar purpose.</p><p>An application creates a window with a secure surface by specifying the <code>WindowManager.LayoutParams#FLAG_SECURE</code>window flag. Likewise, an application creates a <code>SurfaceView</code> with a secure surface by calling <code>SurfaceView#setSecure</code> before attaching the secure view to its containing window.</p><p>An application can use the absence of this flag as a hint that it should not create secure surfaces or protected buffers on this display because the content may not be visible. For example, if the flag is not set then the application may choose not to show content on this display, show an informative error message, select an alternate content stream or adopt a different strategy for decoding content that does not rely on secure surfaces or protected buffers.</p><p><strong>See also:</strong></p><ul><li><code>getFlags()</code></li></ul><p>Constant Value: 2 (0x00000002)</p></blockquote><p>在设置了该FLAG后，发现该FLAG还可以实现以下功能：</p><ul><li>阻止屏幕截图</li><li>在任务切换界面中（Recent apps）只显示应用名字和图标，不会显示APP具体内容。</li></ul><p><strong>参考资料</strong></p><p><a href="https://developer.android.com/reference/android/view/WindowManager.LayoutParams.html#FLAG_SECURE" target="_blank" rel="noopener">https://developer.android.com/reference/android/view/WindowManager.LayoutParams.html#FLAG_SECURE</a></p><p><a href="https://developer.android.com/reference/android/view/Display.html#FLAG_SECURE" target="_blank" rel="noopener">https://developer.android.com/reference/android/view/Display.html#FLAG_SECURE</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一个晚上在看了一下微信的收付款功能，想截个图，突然发现提示了一句&lt;strong&gt;由于受安全政策限制，无法截取屏幕截图&lt;/strong&gt;，再研究了一下手机的其他APP，中国建设银行APP上也有该提示，出于好奇，查阅了一下该功能的实现方式。&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="http://hackycy.github.io/categories/Android/"/>
    
    
      <category term="Android" scheme="http://hackycy.github.io/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>IOS之UIAlertController使用</title>
    <link href="http://hackycy.github.io/2019/07/08/IOS%E4%B9%8BUIAlertController%E4%BD%BF%E7%94%A8/"/>
    <id>http://hackycy.github.io/2019/07/08/IOS之UIAlertController使用/</id>
    <published>2019-07-08T03:06:30.000Z</published>
    <updated>2019-07-10T02:57:18.162Z</updated>
    
    <content type="html"><![CDATA[<p>当应用需要向用户提示一些重要信息或者提示用户进行选择时，可以使用警告框(Alert)或者操作表(Action Sheet)来进行提示用户。下图中左侧是警告框，右侧是操作表。</p><a id="more"></a><p><img src="tip.png" alt=""></p><p>自iOS 8开始，Apple用继承自<code>UIViewController</code>的<code>UIAlertController</code>取代了<code>UIAlertView</code>和<code>UIAlertSheet</code>。</p><p>警报控制器（UIAlertController）虽然有警告框和操作表两种形式，但其创建步骤是一样的。如下所示：</p><ol><li>创建<code>UIAlertController</code>，指定警报控制器样式。</li><li>向警报控制器添加按钮。</li><li>显示<code>UIAlertController</code>。</li></ol><blockquote><p>“ UIAlertView is deprecated. Use UIAlertController with a preferredStyle of UIAlertControllerStyleAlert instead.”</p><p>“UIActionSheet is deprecated. Use UIAlertController with a preferredStyle of UIAlertControllerStyleActionSheet instead. “</p></blockquote><h1 id="创建警告框"><a href="#创建警告框" class="headerlink" title="创建警告框"></a>创建警告框</h1><h2 id="创建警告控制器"><a href="#创建警告控制器" class="headerlink" title="创建警告控制器"></a>创建警告控制器</h2><p>创建<code>UIAlertController</code>很简单，不需要设置代理或者指定按钮</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">UIAlertController</span> *alert = [<span class="built_in">UIAlertController</span> alertControllerWithTitle:<span class="string">@"标题"</span> message:<span class="string">@"这是message"</span> preferredStyle:<span class="built_in">UIAlertControllerStyleAlert</span>];</span><br></pre></td></tr></table></figure><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="built_in">NS_ENUM</span>(<span class="built_in">NSInteger</span>, <span class="built_in">UIAlertControllerStyle</span>) &#123;</span><br><span class="line">    <span class="built_in">UIAlertControllerStyleActionSheet</span> = <span class="number">0</span>,</span><br><span class="line">    <span class="built_in">UIAlertControllerStyleAlert</span></span><br><span class="line">&#125; <span class="built_in">NS_ENUM_AVAILABLE_IOS</span>(<span class="number">8</span>_0);</span><br></pre></td></tr></table></figure><p>这里的<code>preferredStyle:</code>参数有<code>UIAlertControllerStyleAlert</code>和<code>UIAlertControllerStyleActionSheet</code>两种，这里我们要创建的是<em>Alert View</em>，所以使用第一种。</p><h2 id="添加按钮"><a href="#添加按钮" class="headerlink" title="添加按钮"></a>添加按钮</h2><p><code>UIAlertAction</code>对象由标题、样式和用户单击该按钮时运行的代码块三部分组成。<code>UIAlertActionStyle</code>有三种样式。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="built_in">NS_ENUM</span>(<span class="built_in">NSInteger</span>, <span class="built_in">UIAlertActionStyle</span>) &#123;</span><br><span class="line">    <span class="comment">// 常规样式</span></span><br><span class="line">    <span class="built_in">UIAlertActionStyleDefault</span> = <span class="number">0</span>,</span><br><span class="line">    <span class="comment">// 取消样式</span></span><br><span class="line">    <span class="built_in">UIAlertActionStyleCancel</span>,</span><br><span class="line">    <span class="comment">// 警示样式，按钮字体为红色</span></span><br><span class="line">    <span class="built_in">UIAlertActionStyleDestructive</span></span><br><span class="line">&#125; <span class="built_in">NS_ENUM_AVAILABLE_IOS</span>(<span class="number">8</span>_0);</span><br></pre></td></tr></table></figure><p>创建代码：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">UIAlertAction</span> *sure = [<span class="built_in">UIAlertAction</span> actionWithTitle:<span class="string">@"确定"</span> style:<span class="built_in">UIAlertActionStyleDefault</span> handler:^(<span class="built_in">UIAlertAction</span> * _Nonnull action) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"确定"</span>);</span><br><span class="line">    &#125;];</span><br><span class="line"><span class="built_in">UIAlertAction</span> *cancel = [<span class="built_in">UIAlertAction</span> actionWithTitle:<span class="string">@"取消"</span> style:<span class="built_in">UIAlertActionStyleCancel</span> handler:^(<span class="built_in">UIAlertAction</span> * _Nonnull action) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"取消"</span>);</span><br><span class="line">    &#125;];</span><br><span class="line">[alert addAction:sure];</span><br><span class="line">[alert addAction:cancel];</span><br></pre></td></tr></table></figure><h2 id="显示警告框"><a href="#显示警告框" class="headerlink" title="显示警告框"></a>显示警告框</h2><p>显示alert</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="keyword">self</span> presentViewController:alert animated:<span class="literal">YES</span> completion:<span class="literal">nil</span>];</span><br></pre></td></tr></table></figure><p>运行效果：</p><p><img src="alert.png" alt=""></p><p>如果再添加一个reset按钮并设置成<code>UIAlertActionStyleDestructive</code>样式，再看看效果</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="built_in">UIAlertAction</span> *reset = [<span class="built_in">UIAlertAction</span> actionWithTitle:<span class="string">@"Reset"</span> style:<span class="built_in">UIAlertActionStyleDestructive</span> handler:^(<span class="built_in">UIAlertAction</span> * _Nonnull action) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"Reset Action"</span>);</span><br><span class="line">&#125;];</span><br><span class="line">[alert addAction:reset];</span><br><span class="line"><span class="comment">//show</span></span><br><span class="line">[<span class="keyword">self</span> presentViewController:alert animated:<span class="literal">YES</span> completion:<span class="literal">nil</span>];</span><br></pre></td></tr></table></figure><p><img src="alert2.png" alt=""></p><p>只要上面有<code>UIAlertActionStyleCancel</code>样式的按钮，该按钮总是在最底部，其他按钮顺序由添加顺序决定。如果包含<code>UIAlertActionStyleDestructive</code>样式的按钮，一般先添加，以便在第一个位置显示。每一个警报控制器只能包含一个<em>Cancel</em>按钮，如果你添加了两个或多个，在运行时会抛出<code>NSInternalInconsistencyException</code>的异常。</p><blockquote><p><strong>UIAlertActionStyleDefault 和 UIAlertActionStyleCancel 的区别</strong></p><p>添加UIAlertActionStyleCancel样式后，在UIAlertAction只有两个时，UIAlertActionStyleCancel样式的action都会按苹果的默认风格把取消按钮放在左边；</p><p>添加UIAlertActionStyleCancel样式后，在UIAlertAction有三个及其以上的时候，UIAlertActionStyleCancel样式的action会显示在最下面。</p><p>而添加UIAlertActionStyleDefault样式时，与你addAction到alertController上的顺序有关。</p><p><strong>UIAlertActionStyleDestructive 警示样式</strong></p><p>警示样式的按钮会变成红色。根据苹果官方的定义，“警示”样式的按钮是用在可能会改变或删除数据的操作上，因此用了红色的醒目标识来警示用户。</p></blockquote><h2 id="创建带输入框的警告框"><a href="#创建带输入框的警告框" class="headerlink" title="创建带输入框的警告框"></a>创建带输入框的警告框</h2><p><code>UIAlerController</code>的另一个用途是我们可以向警报控制器中添加任意数量的<code>UITextField</code>作为警报控制器内容视图中的一部分。</p><p>比如这里用一个登录框来进行举例：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取UIAlertController实例</span></span><br><span class="line"><span class="built_in">UIAlertController</span> *alert = [<span class="built_in">UIAlertController</span> alertControllerWithTitle:<span class="string">@"登录框"</span> message:<span class="string">@"请输入用户名和密码"</span> preferredStyle:<span class="built_in">UIAlertControllerStyleAlert</span>];</span><br><span class="line"><span class="comment">//创建UIAlertAction</span></span><br><span class="line"><span class="built_in">UIAlertAction</span> *sure = [<span class="built_in">UIAlertAction</span> actionWithTitle:<span class="string">@"登陆"</span> style:<span class="built_in">UIAlertActionStyleDefault</span> handler:^(<span class="built_in">UIAlertAction</span> * _Nonnull action) &#123;</span><br><span class="line"><span class="comment">//获取textField实例，根据添加的顺序获取</span></span><br><span class="line"><span class="built_in">UITextField</span> *loginname = alert.textFields.firstObject;</span><br><span class="line"><span class="built_in">UITextField</span> *pwd = alert.textFields.lastObject;</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"name:%@,  pwd:%@"</span>, loginname.text, pwd.text);</span><br><span class="line">&#125;];</span><br><span class="line"><span class="built_in">UIAlertAction</span> *cancel = [<span class="built_in">UIAlertAction</span> actionWithTitle:<span class="string">@"取消"</span> style:<span class="built_in">UIAlertActionStyleCancel</span> handler:^(<span class="built_in">UIAlertAction</span> * _Nonnull action) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"取消"</span>);        </span><br><span class="line">&#125;];</span><br><span class="line"><span class="comment">//添加到UIAlertController实例</span></span><br><span class="line">[alert addAction:sure];</span><br><span class="line">[alert addAction:cancel];</span><br><span class="line"><span class="comment">//添加TextField</span></span><br><span class="line">[alert addTextFieldWithConfigurationHandler:^(<span class="built_in">UITextField</span> * _Nonnull textField) &#123;</span><br><span class="line">   [textField setPlaceholder:<span class="string">@"name"</span>];</span><br><span class="line">&#125;];</span><br><span class="line">[alert addTextFieldWithConfigurationHandler:^(<span class="built_in">UITextField</span> * _Nonnull textField) &#123;</span><br><span class="line">    [textField setPlaceholder:<span class="string">@"password"</span>];</span><br><span class="line">    textField.secureTextEntry = <span class="literal">YES</span>;</span><br><span class="line">&#125;];</span><br><span class="line">[<span class="keyword">self</span> presentViewController:alert animated:<span class="literal">YES</span> completion:<span class="literal">nil</span>];</span><br></pre></td></tr></table></figure><p>运行效果：</p><p><img src="alerttextfield.png" alt=""></p><h1 id="创建操作表Action-Sheet"><a href="#创建操作表Action-Sheet" class="headerlink" title="创建操作表Action Sheet"></a>创建操作表Action Sheet</h1><p>操作表一般用于为用户提供一组可供选择的操作选项，如删除、恢复等。一般根据设备尺寸大小决定呈现形式，在iPhone上，操作表由底部滑出；在iPad上，操作表以弹出框（popover)形式出现。</p><p>创建操作表的方法与警告框类似，唯一不同在于<code>preferredStyle:</code>参数的选择。在<code>showActionSheet:</code>方法中创建操作表。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">UIAlertController</span> *sheet = [<span class="built_in">UIAlertController</span> alertControllerWithTitle:<span class="string">@"标题"</span> message:<span class="string">@"这是message"</span> preferredStyle:<span class="built_in">UIAlertControllerStyleActionSheet</span>];</span><br></pre></td></tr></table></figure><p>添加Action Sheet的按钮和添加警告框的按钮代码行为是一致的。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">UIAlertAction</span> *sure = [<span class="built_in">UIAlertAction</span> actionWithTitle:<span class="string">@"确定"</span> style:<span class="built_in">UIAlertActionStyleDefault</span> handler:^(<span class="built_in">UIAlertAction</span> * _Nonnull action) &#123;</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"确定"</span>);</span><br><span class="line">&#125;];</span><br><span class="line"><span class="built_in">UIAlertAction</span> *reset = [<span class="built_in">UIAlertAction</span> actionWithTitle:<span class="string">@"重置"</span> style:<span class="built_in">UIAlertActionStyleDestructive</span> handler:^(<span class="built_in">UIAlertAction</span> * _Nonnull action) &#123;</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"重置"</span>);</span><br><span class="line">&#125;];</span><br><span class="line"><span class="built_in">UIAlertAction</span> *cancel = [<span class="built_in">UIAlertAction</span> actionWithTitle:<span class="string">@"取消"</span> style:<span class="built_in">UIAlertActionStyleCancel</span> handler:^(<span class="built_in">UIAlertAction</span> * _Nonnull action) &#123;</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"取消"</span>);</span><br><span class="line">&#125;];</span><br><span class="line">[sheet addAction:sure];</span><br><span class="line">[sheet addAction:cancel];</span><br><span class="line">[sheet addAction:reset];</span><br><span class="line"><span class="comment">//show</span></span><br><span class="line">[<span class="keyword">self</span> presentViewController:sheet animated:<span class="literal">YES</span> completion:<span class="literal">nil</span>];</span><br></pre></td></tr></table></figure><p>运行效果：</p><p><img src="actionsheet.png" alt=""></p><p>如果<code>Action Sheet</code>中有取消按钮，取消按钮每次都会在底部显示，其他按钮会按照添加的顺序显示。在Action Sheet内不能添加文本框。如果你添加了文本框，在运行时会抛出下面的异常提醒：</p><blockquote><p>Terminating app due to uncaught exception ‘NSInternalInconsistencyException’, reason: ‘Text fields can only be added to an alert controller of style UIAlertControllerStyleAlert’</p></blockquote><p>如上面说到的，在iPad中Action Sheet以弹出框的形式呈现。弹出框总是需要一个锚点，锚点可以是源视图，也可以是按钮。在这个demo中，我们用按钮触发弹出框，所以这里将把按钮作为锚点。<code>showActionSheet:</code>方法更新后如下：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//inner click func</span></span><br><span class="line"><span class="comment">//(IBAction)actionsheet:(UIButton *)sender</span></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="built_in">UIPopoverPresentationController</span> *popover = sheet.popoverPresentationController;</span><br><span class="line"><span class="keyword">if</span> (popover) &#123;</span><br><span class="line">popover.sourceView = sender;</span><br><span class="line">popover.sourceRect = sender.bounds;</span><br><span class="line">popover.permittedArrowDirections = <span class="built_in">UIPopoverArrowDirectionAny</span>;        </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">[<span class="keyword">self</span> presentViewController:sheet animated:<span class="literal">YES</span> completion:<span class="literal">nil</span>];</span><br></pre></td></tr></table></figure><p>如果在iPad中没有添加上面方法，运行时会出现下面崩溃提示：</p><blockquote><p>Terminating app due to uncaught exception ‘NSGenericException’, reason: ‘Your application has presented a UIAlertController (&lt;UIAlertController: 0x7f88c85221f0&gt;) of style UIAlertControllerStyleActionSheet. The modalPresentationStyle of a UIAlertController with this style is UIModalPresentationPopover. You must provide location information for this popover through the alert controller’s popoverPresentationController. You must provide either a sourceView and sourceRect or a barButtonItem.  If this information is not known when you present the alert controller, you may provide it in the UIPopoverPresentationControllerDelegate method -prepareForPopoverPresentation.’</p></blockquote><p>现在，Action Sheet以触发它的按钮为锚点，以弹出框形式展现。</p><p><img src="actionsheetipad.png" alt=""></p><blockquote><p>当Action Sheet以弹出框形式展现时，<code>UIKit</code>会取消显示<em>Cancel</em>按钮。此时，点击popover以外任何区域和点击<em>Cancel</em>按钮效果一致，同时会调用取消按钮的完成处理程序。</p></blockquote><h1 id="退出警告控制器"><a href="#退出警告控制器" class="headerlink" title="退出警告控制器"></a>退出警告控制器</h1><p>警报控制器会在用户点击按钮后自动消失，但在app进入后台时，警告框和选择表并不会自动退出。此时，我们需要通过代码实现退出警报控制器。</p><p>在<strong>通知中心</strong>进行注册，当接收到app进入后台的通知时退出警报控制器。更新后的<code>viewDidLoad</code>如下：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)viewDidLoad</span><br><span class="line">&#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// app 进入后台后隐藏警报控制器</span></span><br><span class="line">    [[<span class="built_in">NSNotificationCenter</span> defaultCenter] addObserverForName:<span class="built_in">UIApplicationDidEnterBackgroundNotification</span> object:<span class="literal">nil</span> queue:<span class="literal">nil</span> usingBlock:^(<span class="built_in">NSNotification</span> * _Nonnull note) &#123;</span><br><span class="line">        [<span class="keyword">self</span>.presentedViewController dismissViewControllerAnimated:<span class="literal">YES</span> completion:<span class="literal">nil</span>];</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)dealloc</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 移除观察者</span></span><br><span class="line">    [[<span class="built_in">NSNotificationCenter</span> defaultCenter] removeObserver:<span class="keyword">self</span> name:<span class="built_in">UIApplicationDidEnterBackgroundNotification</span> object:<span class="literal">nil</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>记得移除观察者，否则会引起崩溃。</p></blockquote><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>下面总结下Alert View和Action Sheet的异同。</p><p>警告框Alert View：</p><ul><li>一般显示在当前视图控制器的中心，点击警告框以外区域不能隐藏警告控制器。</li><li>可以添加任意数量文本框。</li><li>有一个或两个按钮时，横向排布，如果有<em>Cancel</em>按钮，则<em>Cancel</em>按钮显示在左侧；有两个以上按钮时，竖列排布，如果有<em>Cancel</em>按钮，则<em>Cancel</em>按钮显示在最底部。其他按钮按照添加顺序排布。</li></ul><p>操作表Action Sheet：</p><ul><li>在iPhone中自下而上滑出显示在当前控制器的底部，点击action sheet以外区域可以隐藏<code>UIAlertController</code>。</li><li>在iPad中以popover方式、以源视图为锚点显示，点击选择表以外的区域可以隐藏警告控制器。</li><li>不能添加文本框。</li><li>按钮竖列排布，在iPhone中，<em>Cancel</em>按钮默认在底部显示；在iPad中，<em>Cancel</em>按钮默认不显示。</li></ul><p><code>UIAlertController</code>类只能原样使用，不支持子类化。该类的视图层次结构是私有的，不能修改。最后，需要注意的是，警告框和操作表向用户显示信息时会中断应用的当前流程，请只在需要的时候使用，切勿滥用。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://www.jianshu.com/p/7606b6514ec4" target="_blank" rel="noopener">https://www.jianshu.com/p/7606b6514ec4</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;当应用需要向用户提示一些重要信息或者提示用户进行选择时，可以使用警告框(Alert)或者操作表(Action Sheet)来进行提示用户。下图中左侧是警告框，右侧是操作表。&lt;/p&gt;
    
    </summary>
    
      <category term="Ios" scheme="http://hackycy.github.io/categories/Ios/"/>
    
    
      <category term="Ios" scheme="http://hackycy.github.io/tags/Ios/"/>
    
  </entry>
  
  <entry>
    <title>Android系统剪贴板使用</title>
    <link href="http://hackycy.github.io/2019/07/04/Android%E7%B3%BB%E7%BB%9F%E5%89%AA%E8%B4%B4%E6%9D%BF%E4%BD%BF%E7%94%A8/"/>
    <id>http://hackycy.github.io/2019/07/04/Android系统剪贴板使用/</id>
    <published>2019-07-04T02:19:05.000Z</published>
    <updated>2019-07-04T03:05:58.508Z</updated>
    
    <content type="html"><![CDATA[<p>最近公司业务用到了关于Android系统剪贴板的使用，所以记录一下剪贴板的使用。</p><a id="more"></a><h1 id="ClipboardManager介绍"><a href="#ClipboardManager介绍" class="headerlink" title="ClipboardManager介绍"></a>ClipboardManager介绍</h1><p>当需要使用到ClipboardManager时，需要把数据放在一个ClipData里，然后在把这个数据对象放在系统的剪贴板里面。</p><p><strong>ClipData有三种形式：</strong></p><ul><li>Text：文字字符串。文字是直接放在clip对象中，然后放在剪贴板里；粘贴这个字符串的时候直接从剪贴板拿到这个对象，把字符串放入你的应用存储中。</li><li>URI：一个Uri对象。表示任何形式的URI。这种形式主要用于从一个content provider中复制复杂的数据。复制的时候把一个<code>Uri</code> 对象放在一个clip对象中，然后再放在剪贴板里；粘贴的时候取出这个clip对象，得到Uri，把它解析为一个数据资源比如content provider，然后从资源中复制数据到应用存储中。</li><li>Intent：Intent对象。这支持了复制应用快捷方式。复制的时候把Intent对象放在clip对象中，再放入剪贴板；粘贴数据时，从clip对象中得到Intent对象，放入应用存储区域中。</li></ul><blockquote><p>注意：剪贴板里每次仅会持有一个ClipData对象，当应用再放入另一个ClipData对象进来时，前一个就消失了。</p></blockquote><h1 id="相关类"><a href="#相关类" class="headerlink" title="相关类"></a>相关类</h1><h2 id="ClipboardManager"><a href="#ClipboardManager" class="headerlink" title="ClipboardManager"></a>ClipboardManager</h2><p>ClipboardManager代表了系统的剪贴板，可以通过<code>(ClipboardManager) getSystemService(Context.CLIPBOARD_SERVICE)</code>系统服务来获取。</p><p>全名为<strong>android.text.ClipboardManager</strong>从API 11开始就废弃了。</p><p>取而代之的是它的子类：<strong>android.content.ClipboardManager</strong> (since API Level 11)。</p><h2 id="ClipData-ClipDescription-and-ClipData-Item"><a href="#ClipData-ClipDescription-and-ClipData-Item" class="headerlink" title="ClipData, ClipDescription, and ClipData.Item"></a>ClipData, ClipDescription, and ClipData.Item</h2><p>前面说的clip对象就是<strong>ClipData</strong>类的对象，其中包含了一个 <code>ClipDescription</code>对象和一个或多个<code>ClipData.Item</code>对象。</p><p><strong>ClipDescription</strong>对象中包含了一个数组，描述clip对象的MIME类型。</p><p><strong>ClipData.Item</strong>对象中包含文字、URI或者Intent数据。<strong>一个clip对象中可以包含一个或多个Item对象</strong>。</p><p>比如你想要复制list中的多项数据，你可以为list中的每一项创建一个<strong>ClipData.Item</strong>对象，然后把它们放进一个<strong>ClipData</strong>对象中，这样就一次性把多项数据都放在了剪贴板中。</p><blockquote><p>注意ClipData这个类是API 11才有的。</p></blockquote><h2 id="ClipData中的简洁方法"><a href="#ClipData中的简洁方法" class="headerlink" title="ClipData中的简洁方法"></a>ClipData中的简洁方法</h2><ul><li><p><strong>ClipData</strong>类中有一些静态的简洁方法，用于创建只有一个<strong>ClipData.Item</strong>和一条简单描述( <code>ClipDescription</code>)的ClipData对象。</p></li><li><p>newPlainText(label, text)返回ClipData对象，数据是文字text，描述是label，MIME类型是<code>MIMETYPE_TEXT_PLAIN</code>。</p></li><li><p>newUri(resolver, label, URI)</p></li><li><p>newIntent(label, intent)</p></li><li>newHtmlText(label,text, htmlText)</li><li>newRawUri(label, uri)</li></ul><blockquote><p>newHtmlText method need Call requires API level 16</p></blockquote><h1 id="ClipboardFramework架构图"><a href="#ClipboardFramework架构图" class="headerlink" title="ClipboardFramework架构图"></a>ClipboardFramework架构图</h1><p><img src="clipboardframework.png" alt=""></p><h1 id="ClipboardManager使用"><a href="#ClipboardManager使用" class="headerlink" title="ClipboardManager使用"></a>ClipboardManager使用</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取剪贴板服务：</span></span><br><span class="line">ClipboardManager manager = (ClipboardManager) getSystemService(Context.CLIPBOARD_SERVICE);</span><br><span class="line"><span class="comment">//然后把数据放在ClipData对象中</span></span><br><span class="line">ClipData data = ClipData.newPlainText(<span class="string">"label"</span>, <span class="string">"this is clipboard data"</span>);       </span><br><span class="line">manager.setPrimaryClip(data);</span><br></pre></td></tr></table></figure><p>上面的代码就可以将文字放到剪贴板了，然后找个输入框“粘贴”就行啦。</p><blockquote><p>如果需要自由复制TextView等控件的文字，只要在该控件上添加<code>android:textIsSelectable=&quot;true&quot;</code>或者使用代码设置<code>setTextIsSelectable(true)</code>即可。</p></blockquote><p><strong>URI:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Creates a Uri based on a base Uri and a record ID based on the contact's last name</span></span><br><span class="line"><span class="comment">// Declares the base URI string</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String CONTACTS = <span class="string">"content://com.example.contacts"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Declares a path string for URIs that you use to copy data</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String COPY_PATH = <span class="string">"/copy"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Declares the Uri to paste to the clipboard</span></span><br><span class="line">Uri copyUri = Uri.parse(CONTACTS + COPY_PATH + <span class="string">"/"</span> + lastName);</span><br><span class="line"></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Creates a new URI clip object. The system uses the anonymous getContentResolver() object to</span></span><br><span class="line"><span class="comment">// get MIME types from provider. The clip object's label is "URI", and its data is</span></span><br><span class="line"><span class="comment">// the Uri previously created.</span></span><br><span class="line">ClipData clip = ClipData.newUri(getContentResolver(),<span class="string">"URI"</span>,copyUri);</span><br></pre></td></tr></table></figure><p><strong>Intent:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Creates the Intent</span></span><br><span class="line">Intent appIntent = <span class="keyword">new</span> Intent(<span class="keyword">this</span>, com.example.demo.myapplication.class);</span><br><span class="line"></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Creates a clip object with the Intent in it. Its label is "Intent" and its data is</span></span><br><span class="line"><span class="comment">// the Intent object created previously</span></span><br><span class="line">ClipData clip = ClipData.newIntent(<span class="string">"Intent"</span>,appIntent);</span><br></pre></td></tr></table></figure><h1 id="获取剪贴板内容"><a href="#获取剪贴板内容" class="headerlink" title="获取剪贴板内容"></a>获取剪贴板内容</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">ClipboardManager manager = (ClipboardManager) getSystemService(Context.CLIPBOARD_SERVICE);</span><br><span class="line"></span><br><span class="line">String resultString = <span class="string">""</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//检查剪贴板是否有内容</span></span><br><span class="line"><span class="keyword">if</span>(manager.hasPrimaryClip())&#123;</span><br><span class="line">ClipData clipData = manager.getPrimaryClip();</span><br><span class="line"><span class="keyword">int</span> count = clipData.getItemCount();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; ++i) &#123;</span><br><span class="line"></span><br><span class="line">ClipData.Item item = clipData.getItemAt(i);</span><br><span class="line">CharSequence str = item.coerceToText(MainActivity.<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">resultString += str;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">Log.e(<span class="string">"TAG"</span>, resultString);</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li><p>任何时间，都只有一个clip对象在剪贴板里。新的复制操作都会覆盖前一个clip对象，因为用户可能从你的应用中退出，从其他应用中拷贝一个东西，所以你不能假定用户在你的应用中拷贝的上一个东西一定还放在剪贴板里。</p></li><li><p>一个clip对象，即ClipData中的多个<code>ClipData.Item</code> 对象是为了支持多选项的复制粘贴，而不是为了支持单选的多种形式。你通常需要clip对象中的所有的项目，即<a href="http://developer.android.com/reference/android/content/ClipData.Item.html" target="_blank" rel="noopener">ClipData.Item</a>有一样的形式，比如都是文字，都是URI或都是Intent，而不是混合各种形式。</p></li><li><p>当你提供数据时，你可以提供不同的MIME表达方式。将你支持的MIME类型加入到<strong>ClipDescription</strong>中去，然后在你的content provider中实现它。</p></li><li><p>从剪贴板得到数据时，你的应用有责任检查可用的MIME类型，然后决定使用哪一个。即便有一个clip对象在剪贴板中并且用户要求粘贴，你的应用有可能不需要进行粘贴操作。你应该在MIME类型兼容的时候执行粘贴操作。你可以选择使用 <code>coerceToText()</code>方法将粘贴的内容转换为文字。如果你的应用支持多种类型，你可以让用户自己选用哪一个。</p></li></ul><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="http://developer.android.com/guide/topics/text/copy-paste.html" target="_blank" rel="noopener">http://developer.android.com/guide/topics/text/copy-paste.html</a></p><p><a href="https://www.cnblogs.com/zhujiabin/p/7605553.html" target="_blank" rel="noopener">https://www.cnblogs.com/zhujiabin/p/7605553.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近公司业务用到了关于Android系统剪贴板的使用，所以记录一下剪贴板的使用。&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="http://hackycy.github.io/categories/Android/"/>
    
    
      <category term="Android" scheme="http://hackycy.github.io/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Android返回不销毁Activity，直接进入后台</title>
    <link href="http://hackycy.github.io/2019/07/03/Android%E8%BF%94%E5%9B%9E%E4%B8%8D%E9%94%80%E6%AF%81Activity%EF%BC%8C%E7%9B%B4%E6%8E%A5%E8%BF%9B%E5%85%A5%E5%90%8E%E5%8F%B0/"/>
    <id>http://hackycy.github.io/2019/07/03/Android返回不销毁Activity，直接进入后台/</id>
    <published>2019-07-03T02:20:55.000Z</published>
    <updated>2019-07-09T08:44:50.337Z</updated>
    
    <content type="html"><![CDATA[<p>最近打开闲鱼，微信，发现他们点击返回到桌面的时候，他们的activity并没有直接销毁，还是依然保留在返回之前浏览的界面。查了一下资料，的确有可以操作的办法。</p><a id="more"></a><h1 id="isTaskRoot"><a href="#isTaskRoot" class="headerlink" title="isTaskRoot()"></a>isTaskRoot()</h1><p><code>isTaskRoot()</code>方法用来判断该Activity是否为任务栈中的根Activity，即启动应用的第一个Activity。</p><h1 id="moveTaskToBack"><a href="#moveTaskToBack" class="headerlink" title="moveTaskToBack()"></a>moveTaskToBack()</h1><p><code>moveTaskToBack()</code>方法用于将activity退到后台，而不是直接finish掉。</p><p>从生命周期来说，会执行<code>onPause</code>、<code>onStop</code>，但不会执行<code>onDestroy</code> 。恢复的时候也一样，会执行<code>onStart</code>、<code>onResume</code>，但不会执行<code>onCreate</code>。</p><p>参数nonRoot表示的含义是此方法对非根activity是否有效：</p><ul><li>true表示对所有activity均有效，</li><li>false表示只对根activity有效。</li></ul><p>返回值：该activity被退出到后台或者他已经在后台了返回true，否则返回false</p><h1 id="官方文档："><a href="#官方文档：" class="headerlink" title="官方文档："></a>官方文档：</h1><blockquote><p>public boolean moveTaskToBack (boolean nonRoot)<br>Since: API Level 1Move the task containing this activity to the back of the activity stack. The activity’s order within the task is unchanged.<br>Parameters:<br>nonRoot If false then this only works if the activity is the root of a task; if true it will work for any activity in a task.<br>Returns:<br>If the task was moved (or it was already at the back) true is returned, else false.</p></blockquote><h1 id="使用案例"><a href="#使用案例" class="headerlink" title="使用案例"></a>使用案例</h1><p>重写<code>onBackPressed</code>或者<code>onKeyDown</code>事件等来监听返回键事件：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onKeyDown</span><span class="params">(<span class="keyword">int</span> keyCode, KeyEvent event)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (event.getKeyCode() == KeyEvent.KEYCODE_BACK) &#123;</span><br><span class="line">            <span class="keyword">if</span> (isTaskRoot()) &#123;</span><br><span class="line">                moveTaskToBack(<span class="keyword">false</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">super</span>.onKeyDown(keyCode, event);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="http://www.voidcn.com/article/p-wbosovty-bru.html" target="_blank" rel="noopener">http://www.voidcn.com/article/p-wbosovty-bru.html</a></p><p><a href="http://www.voidcn.com/article/p-poscpyhl-bn.html" target="_blank" rel="noopener">http://www.voidcn.com/article/p-poscpyhl-bn.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近打开闲鱼，微信，发现他们点击返回到桌面的时候，他们的activity并没有直接销毁，还是依然保留在返回之前浏览的界面。查了一下资料，的确有可以操作的办法。&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="http://hackycy.github.io/categories/Android/"/>
    
    
      <category term="Android" scheme="http://hackycy.github.io/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>IntelliJ IDEA For Mac 快捷键</title>
    <link href="http://hackycy.github.io/2019/06/30/IntelliJ-IDEA-For-Mac-%E5%BF%AB%E6%8D%B7%E9%94%AE/"/>
    <id>http://hackycy.github.io/2019/06/30/IntelliJ-IDEA-For-Mac-快捷键/</id>
    <published>2019-06-30T09:52:09.000Z</published>
    <updated>2019-06-30T09:59:28.839Z</updated>
    
    <content type="html"><![CDATA[<h1 id="IntelliJ-IDEA-For-Mac-快捷键"><a href="#IntelliJ-IDEA-For-Mac-快捷键" class="headerlink" title="IntelliJ IDEA For Mac 快捷键"></a>IntelliJ IDEA For Mac 快捷键</h1><blockquote><p>建议将 Mac 系统中与 IntelliJ IDEA 冲突的快捷键取消或更改，不建议改 IntelliJ IDEA 的默认快捷键</p></blockquote><a id="more"></a><h4 id="Mac键盘符号和修饰键说明"><a href="#Mac键盘符号和修饰键说明" class="headerlink" title="Mac键盘符号和修饰键说明"></a>Mac键盘符号和修饰键说明</h4><ul><li><code>⌘</code> Command</li><li><code>⇧</code> Shift</li><li><code>⌥</code> Option</li><li><code>⌃</code> Control</li><li><code>↩︎</code> Return/Enter</li><li><code>⌫</code> Delete</li><li><code>⌦</code> 向前删除键（Fn+Delete）</li><li><code>↑</code> 上箭头</li><li><code>↓</code> 下箭头</li><li><code>←</code> 左箭头</li><li><code>→</code> 右箭头</li><li><code>⇞</code> Page Up（Fn+↑）</li><li><code>⇟</code> Page Down（Fn+↓）</li><li><code>Home</code> Fn + ←</li><li><code>End</code> Fn + →</li><li><code>⇥</code> 右制表符（Tab键）</li><li><code>⇤</code> 左制表符（Shift+Tab）</li><li><code>⎋</code> Escape (Esc)</li></ul><h4 id="一、Editing（编辑）"><a href="#一、Editing（编辑）" class="headerlink" title="一、Editing（编辑）"></a>一、Editing（编辑）</h4><ul><li><code>⌃Space</code> 基本的代码补全（补全任何类、方法、变量）</li><li><code>⌃⇧Space</code> 智能代码补全（过滤器方法列表和变量的预期类型）</li><li><code>⌘⇧↩</code> 自动结束代码，行末自动添加分号</li><li><code>⌘P</code> 显示方法的参数信息</li><li><code>⌃J, Mid. button click</code> 快速查看文档</li><li><code>⇧F1</code> 查看外部文档（在某些代码上会触发打开浏览器显示相关文档）</li><li><code>⌘+鼠标放在代码上</code> 显示代码简要信息</li><li><code>⌘F1</code> 在错误或警告处显示具体描述信息</li><li><code>⌘N, ⌃↩, ⌃N</code> 生成代码（getter、setter、构造函数、hashCode/equals,toString）</li><li><code>⌃O</code> 覆盖方法（重写父类方法）</li><li><code>⌃I</code> 实现方法（实现接口中的方法）</li><li><code>⌘⌥T</code> 包围代码（使用if..else, try..catch, for, synchronized等包围选中的代码）</li><li><code>⌘/</code> 注释/取消注释与行注释</li><li><code>⌘⌥/</code> 注释/取消注释与块注释</li><li><code>⌥↑</code> 连续选中代码块</li><li><code>⌥↓</code> 减少当前选中的代码块</li><li><code>⌃⇧Q</code> 显示上下文信息</li><li><code>⌥↩</code> 显示意向动作和快速修复代码</li><li><code>⌘⌥L</code> 格式化代码</li><li><code>⌃⌥O</code> 优化import</li><li><code>⌃⌥I</code> 自动缩进线</li><li><code>⇥ / ⇧⇥</code> 缩进代码 / 反缩进代码</li><li><code>⌘X</code> 剪切当前行或选定的块到剪贴板</li><li><code>⌘C</code> 复制当前行或选定的块到剪贴板</li><li><code>⌘V</code> 从剪贴板粘贴</li><li><code>⌘⇧V</code> 从最近的缓冲区粘贴</li><li><code>⌘D</code> 复制当前行或选定的块</li><li><code>⌘⌫</code> 删除当前行或选定的块的行</li><li><code>⌃⇧J</code> 智能的将代码拼接成一行</li><li><code>⌘↩</code> 智能的拆分拼接的行</li><li><code>⇧↩</code> 开始新的一行</li><li><code>⌘⇧U</code> 大小写切换</li><li><code>⌘⇧] / ⌘⇧[</code> 选择直到代码块结束/开始</li><li><code>⌥⌦</code> 删除到单词的末尾（⌦键为Fn+Delete）</li><li><code>⌥⌫</code> 删除到单词的开头</li><li><code>⌘+ / ⌘-</code> 展开 / 折叠代码块</li><li><code>⌘⇧+</code> 展开所以代码块</li><li><code>⌘⇧-</code> 折叠所有代码块</li><li><code>⌘W</code> 关闭活动的编辑器选项卡</li></ul><h4 id="二、Search-Replace（查询-替换）"><a href="#二、Search-Replace（查询-替换）" class="headerlink" title="二、Search/Replace（查询/替换）"></a>二、Search/Replace（查询/替换）</h4><ul><li><code>Double ⇧</code> 查询任何东西</li><li><code>⌘F</code> 文件内查找</li><li><code>⌘G</code> 查找模式下，向下查找</li><li><code>⌘⇧G</code> 查找模式下，向上查找</li><li><code>⌘R</code> 文件内替换</li><li><code>⌘⇧F</code> 全局查找（根据路径）</li><li><code>⌘⇧R</code> 全局替换（根据路径）</li><li><code>⌘⇧S</code> 查询结构（Ultimate Edition 版专用，需要在Keymap中设置）</li><li><code>⌘⇧M</code> 替换结构（Ultimate Edition 版专用，需要在Keymap中设置）</li></ul><h4 id="三、Usage-Search（使用查询）"><a href="#三、Usage-Search（使用查询）" class="headerlink" title="三、Usage Search（使用查询）"></a>三、Usage Search（使用查询）</h4><ul><li><code>⌥F7 / ⌘F7</code> 在文件中查找用法 / 在类中查找用法</li><li><code>⌘⇧F7</code> 在文件中突出显示的用法</li><li><code>⌘⌥F7</code> 显示用法</li><li><code>⌘⇧I</code> 查看定义的类,快速查看</li></ul><h4 id="四、Compile-and-Run（编译和运行）"><a href="#四、Compile-and-Run（编译和运行）" class="headerlink" title="四、Compile and Run（编译和运行）"></a>四、Compile and Run（编译和运行）</h4><ul><li><code>⌘F9</code> 编译Project</li><li><code>⌘⇧F9</code> 编译选择的文件、包或模块</li><li><code>⌃⌥R</code> 弹出 Run 的可选择菜单</li><li><code>⌃⌥D</code> 弹出 Debug 的可选择菜单</li><li><code>⌃R</code> 运行</li><li><code>⌃D</code> 调试</li><li><code>⌃⇧R, ⌃⇧D</code> 从编辑器运行上下文环境配置</li></ul><h4 id="五、Debugging（调试）"><a href="#五、Debugging（调试）" class="headerlink" title="五、Debugging（调试）"></a>五、Debugging（调试）</h4><ul><li><code>F8</code> 进入下一步，如果当前行断点是一个方法，则不进入当前方法体内</li><li><code>F7</code> 进入下一步，如果当前行断点是一个方法，则进入当前方法体内，如果该方法体还有方法，则不会进入该内嵌的方法中</li><li><code>⇧F7</code> 智能步入，断点所在行上有多个方法调用，会弹出进入哪个方法</li><li><code>⇧F8</code> 跳出</li><li><code>⌥F9</code> 运行到光标处，如果光标前有其他断点会进入到该断点</li><li><code>⌥F8</code> 计算表达式（可以更改变量值使其生效）</li><li><code>⌘⌥R</code> 恢复程序运行，如果该断点下面代码还有断点则停在下一个断点上</li><li><code>⌘F8</code> 切换断点（若光标当前行有断点则取消断点，没有则加上断点）</li><li><code>⌘⇧F8</code> 查看断点信息</li><li></li></ul><h4 id="六、Navigation（导航）"><a href="#六、Navigation（导航）" class="headerlink" title="六、Navigation（导航）"></a>六、Navigation（导航）</h4><ul><li><code>⌘O</code> 查找类文件</li><li><code>⌘⇧O</code> 查找所有类型文件、打开文件、打开目录，打开目录需要在输入的内容前面或后面加一个反斜杠<code>/</code></li><li><code>⌘⌥O</code> 前往指定的变量 / 方法</li><li><code>⌃← / ⌃→</code> 左右切换打开的编辑tab页</li><li><code>F12</code> 返回到前一个工具窗口</li><li><code>⎋</code> 从工具窗口进入代码文件窗口</li><li><code>⇧⎋</code> 隐藏当前或最后一个活动的窗口，且光标进入代码文件窗口</li><li><code>⌘⇧F4</code> 关闭活动run/messages/find/… tab</li><li><code>⌘L</code> 在当前文件跳转到某一行的指定处</li><li><code>⌘E</code> 显示最近打开的文件记录列表</li><li><code>⌘⌥← / ⌘⌥→</code> 退回 / 前进到上一个操作的地方</li><li><code>⌘⇧⌫</code> 跳转到最后一个编辑的地方</li><li><code>⌥F1</code> 显示当前文件选择目标弹出层，弹出层中有很多目标可以进行选择(如在代码编辑窗口可以选择显示该文件的Finder)</li><li><code>⌘B / ⌘ 鼠标点击</code> 进入光标所在的方法/变量的接口或是定义处</li><li><code>⌘⌥B</code> 跳转到实现处，在某个调用的方法名上使用会跳到具体的实现处，可以跳过接口</li><li><code>⌥ Space, ⌘Y</code> 快速打开光标所在方法、类的定义</li><li><code>⌃⇧B</code> 跳转到类型声明处</li><li><code>⌘U</code> 前往当前光标所在方法的父类的方法 / 接口定义</li><li><code>⌃↓ / ⌃↑</code> 当前光标跳转到当前文件的前一个/后一个方法名位置</li><li><code>⌘] / ⌘[</code> 移动光标到当前所在代码的花括号开始/结束位置</li><li><code>⌘F12</code> 弹出当前文件结构层，可以在弹出的层上直接输入进行筛选（可用于搜索类中的方法）</li><li><code>⌃H</code> 显示当前类的层次结构</li><li><code>⌘⇧H</code> 显示方法层次结构</li><li><code>⌃⌥H</code> 显示调用层次结构</li><li><code>F2 / ⇧F2</code> 跳转到下一个/上一个突出错误或警告的位置</li><li><code>F4 / ⌘↓</code> 编辑/查看代码源</li><li><code>⌥ Home</code> 显示到当前文件的导航条</li><li><code>F3</code>选中文件/文件夹/代码行，添加/取消书签</li><li><code>⌥F3</code> 选中文件/文件夹/代码行，使用助记符添加/取消书签</li><li><code>⌃0...⌃9</code> 定位到对应数值的书签位置</li><li><code>⌘F3</code> 显示所有书签</li></ul><h4 id="七、Refactoring（重构）"><a href="#七、Refactoring（重构）" class="headerlink" title="七、Refactoring（重构）"></a>七、Refactoring（重构）</h4><ul><li><code>F5</code> 复制文件到指定目录</li><li><code>F6</code> 移动文件到指定目录</li><li><code>⌘⌫</code> 在文件上为安全删除文件，弹出确认框</li><li><code>⇧F6</code> 重命名文件</li><li><code>⌘F6</code> 更改签名</li><li><code>⌘⌥N</code> 一致性</li><li><code>⌘⌥M</code> 将选中的代码提取为方法</li><li><code>⌘⌥V</code> 提取变量</li><li><code>⌘⌥F</code> 提取字段</li><li><code>⌘⌥C</code> 提取常量</li><li><code>⌘⌥P</code> 提取参数</li></ul><h4 id="八、VCS-Local-History（版本控制-本地历史记录）"><a href="#八、VCS-Local-History（版本控制-本地历史记录）" class="headerlink" title="八、VCS/Local History（版本控制/本地历史记录）"></a>八、VCS/Local History（版本控制/本地历史记录）</h4><ul><li><code>⌘K</code> 提交代码到版本控制器</li><li><code>⌘T</code> 从版本控制器更新代码</li><li><code>⌥⇧C</code> 查看最近的变更记录</li><li><code>⌃C</code> 快速弹出版本控制器操作面板</li></ul><h4 id="九、Live-Templates（动态代码模板）"><a href="#九、Live-Templates（动态代码模板）" class="headerlink" title="九、Live Templates（动态代码模板）"></a>九、Live Templates（动态代码模板）</h4><ul><li><code>⌘⌥J</code> 弹出模板选择窗口，将选定的代码使用动态模板包住</li><li><code>⌘J</code> 插入自定义动态代码模板</li></ul><h4 id="十、General（通用）"><a href="#十、General（通用）" class="headerlink" title="十、General（通用）"></a>十、General（通用）</h4><ul><li><code>⌘1...⌘9</code> 打开相应编号的工具窗口</li><li><code>⌘S</code> 保存所有</li><li><code>⌘⌥Y</code> 同步、刷新</li><li><code>⌃⌘F</code> 切换全屏模式</li><li><code>⌘⇧F12</code> 切换最大化编辑器</li><li><code>⌥⇧F</code> 添加到收藏夹</li><li><code>⌥⇧I</code> 检查当前文件与当前的配置文件</li><li><code>§⌃, ⌃`</code> 快速切换当前的scheme（切换主题、代码样式等）</li><li><code>⌘,</code> 打开IDEA系统设置</li><li><code>⌘;</code> 打开项目结构对话框</li><li><code>⇧⌘A</code> 查找动作（可设置相关选项）</li><li><code>⌃⇥</code> 编辑窗口标签和工具窗口之间切换（如果在切换的过程加按上delete，则是关闭对应选中的窗口）</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;IntelliJ-IDEA-For-Mac-快捷键&quot;&gt;&lt;a href=&quot;#IntelliJ-IDEA-For-Mac-快捷键&quot; class=&quot;headerlink&quot; title=&quot;IntelliJ IDEA For Mac 快捷键&quot;&gt;&lt;/a&gt;IntelliJ IDEA For Mac 快捷键&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;建议将 Mac 系统中与 IntelliJ IDEA 冲突的快捷键取消或更改，不建议改 IntelliJ IDEA 的默认快捷键&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="程序人生" scheme="http://hackycy.github.io/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/"/>
    
    
      <category term="IDEA" scheme="http://hackycy.github.io/tags/IDEA/"/>
    
  </entry>
  
  <entry>
    <title>Android Toolbar 使用详解</title>
    <link href="http://hackycy.github.io/2019/06/27/Android-Toolbar-%E4%BD%BF%E7%94%A8%E8%AF%A6%E8%A7%A3/"/>
    <id>http://hackycy.github.io/2019/06/27/Android-Toolbar-使用详解/</id>
    <published>2019-06-27T02:59:14.000Z</published>
    <updated>2019-08-12T03:23:59.650Z</updated>
    
    <content type="html"><![CDATA[<h1 id="初识Toolbar"><a href="#初识Toolbar" class="headerlink" title="初识Toolbar"></a>初识Toolbar</h1><p><strong>Toolbar</strong> 是在 Android 5.0 开始推出的一个 Material Design 风格的导航控件 ，Google 非常推荐大家使用 <strong>Toolbar</strong> 来作为Android客户端的导航栏，以此来取代之前的 <strong>Actionbar</strong> 。</p><a id="more"></a><p>与 <strong>Actionbar</strong> 相比，<strong>Toolbar</strong> 明显要灵活的多。它不像 <strong>Actionbar</strong> 一样，一定要固定在Activity的顶部，而是可以放到界面的任意位置。除此之外，在设计 <strong>Toolbar</strong> 的时候，Google也留给了开发者很多可定制修改的余地，这些可定制修改的属性在API文档中都有详细介绍，如：</p><ul><li><strong>设置导航栏图标；</strong></li><li><strong>设置App的logo；</strong></li><li><strong>支持设置标题和子标题；</strong></li><li><strong>支持添加一个或多个的自定义控件；</strong></li><li><strong>支持Action Menu；</strong></li></ul><h1 id="使用Toolbar"><a href="#使用Toolbar" class="headerlink" title="使用Toolbar"></a>使用Toolbar</h1><p>前面提到 <strong>Toolbar</strong> 是在 Android 5.0 才开始加上的，Google 为了将这一设计向下兼容，自然也少不了要推出兼容版的 <strong>Toolbar</strong> 。为此，我们需要在工程中引入 <strong>appcompat-v7</strong> 的兼容包，使用 <strong>android.support.v7.widget.Toolbar</strong> 进行开发。但是由于<strong>support</strong>库现在google团队已经不在维护了，最新版本好像是28点多，已经迁移到了<strong>AndroidX</strong>，所以该篇文章使用<strong>AndroidX</strong>，只是包名相对的变化了，使用和v7包没有多大变化。</p><p>先来看看运行效果</p><p><img src="toolbar_show.png" alt="Toolbar演示"></p><p>按照效果图，从左到右分别是我们前面提及到的 <strong>导航栏图标</strong>、<strong>App的logo</strong>、<strong>标题和子标题</strong>、<strong>自定义控件</strong>、以及 <strong>ActionMenu</strong> 。接着，我们来看下布局文件和代码实现。</p><p>首先，在布局文件 <code>activity_main.xml</code>中添加进我们需要的 Toolbar 控件</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">LinearLayout</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:tools</span>=<span class="string">"http://schemas.android.com/tools"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">tools:context</span>=<span class="string">".MainActivity"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">androidx.appcompat.widget.Toolbar</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">"@+id/toolbar"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:background</span>=<span class="string">"@color/colorPrimary"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">"?attr/actionBarSize"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:text</span>=<span class="string">"textview"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">androidx.appcompat.widget.Toolbar</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></span><br></pre></td></tr></table></figure><p>接着创建一个<code>toolbar_menu.xml</code>菜单项</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">menu</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:app</span>=<span class="string">"http://schemas.android.com/apk/res-auto"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">item</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">"@+id/action_search"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:icon</span>=<span class="string">"@android:drawable/ic_input_add"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:title</span>=<span class="string">"menu_search"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:showAsAction</span>=<span class="string">"ifRoom"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">item</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">"@+id/action_notification"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:icon</span>=<span class="string">"@android:drawable/ic_delete"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:title</span>=<span class="string">"menu_notifications"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:showAsAction</span>=<span class="string">"ifRoom"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">item</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">"@+id/action_item1"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:title</span>=<span class="string">"item_01"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:showAsAction</span>=<span class="string">"never"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">item</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">"@+id/action_item2"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:title</span>=<span class="string">"item_02"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:showAsAction</span>=<span class="string">"never"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">menu</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>我的activity继承自AppCompatActivity，并不是原生sdk内部的，因此不能使用<code>android:showAsAction</code>，否则会报错。所以需要使用自定义的命名空间app。</p><p>ifRoom表示有空间则显示，never表示从不显示，而是会通过overflowwindow显示。</p></blockquote><p>最后在<code>MainActivity</code>中调用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Toolbar mToolbar;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">        mToolbar = findViewById(R.id.toolbar);</span><br><span class="line"></span><br><span class="line">        mToolbar.setTitle(<span class="string">"标题"</span>);</span><br><span class="line">        mToolbar.setSubtitle(<span class="string">"子标题"</span>);</span><br><span class="line">        mToolbar.setNavigationIcon(android.R.drawable.ic_menu_info_details);</span><br><span class="line">        mToolbar.setLogo(android.R.drawable.ic_menu_view);</span><br><span class="line">        setSupportActionBar(mToolbar); <span class="comment">//最后设置</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">  菜单栏目</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onCreateOptionsMenu</span><span class="params">(Menu menu)</span> </span>&#123;</span><br><span class="line">        getMenuInflater().inflate(R.menu.toolbar_menu, menu);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.onCreateOptionsMenu(menu);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>更改主题：</p><p>为了能够正常使用ToolBar，我们需要隐藏原来的ActionBar，这个可以在主题中修改</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">"windowNoTitle"</span>&gt;</span>true<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">"windowActionBar"</span>&gt;</span>false<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span><br></pre></td></tr></table></figure><p>或者继承某个父类:<code>Theme.AppCompat.Light.NoActionBar</code></p><p>也可以在代码中</p><p>如果是<code>AppCompatActivity</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">supportRequestWindowFeature(Window.FEATURE_NO_TITLE);</span><br><span class="line"><span class="comment">//setContentView之前调用，否则报错</span></span><br></pre></td></tr></table></figure><p>如果是<code>Activity</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">requestWindowFeature(Window.FEATURE_NO_TITLE);</span><br></pre></td></tr></table></figure><blockquote><p>最后运行就可以有上面图中的效果啦。</p></blockquote><h1 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h1><ul><li>如果你想修改标题和子标题的字体大小、颜色等，可以调用<strong>setTitleTextColor</strong>、<strong>setTitleTextAppearance</strong>、<strong>setSubtitleTextColor</strong>、<strong>setSubtitleTextAppearance</strong> 这些API；</li><li>自定义的View位于 <strong>title</strong>、<strong>subtitle</strong> 和 <strong>actionmenu</strong> 之间，这意味着，如果 <strong>title</strong> 和 <strong>subtitle</strong> 都在，且 <strong>actionmenu选项</strong> 太多的时候，留给自定义View的空间就越小；</li><li><strong>导航图标</strong> 和 <strong>app logo</strong> 的区别在哪？如果你只设置 <strong>导航图标</strong>（ or <strong>app logo</strong>） 和 <strong>title</strong>、<strong>subtitle</strong>，会发现 <strong>app logo</strong> 和 <strong>title</strong>、<strong>subtitle</strong> 的间距比较小，看起来不如 <strong>导航图标</strong> 与 它们两搭配美观；</li><li><strong>Toolbar</strong> 和其他控件一样，很多属性设置方法既支持代码设置，也支持在xml中设置</li><li><strong>如果只是当成一个普通控件使用，即不调用<code>setSupportActionBar(mToolbar);</code>方法，可以使用<code>mToolbar.inflateMenu</code>方法来设置菜单。</strong></li></ul><h1 id="其他样式修改"><a href="#其他样式修改" class="headerlink" title="其他样式修改"></a>其他样式修改</h1><h2 id="修改Toolbar-popup-menu样式"><a href="#修改Toolbar-popup-menu样式" class="headerlink" title="修改Toolbar popup menu样式"></a>修改Toolbar popup menu样式</h2><p>点击右上角的三个点，会弹出一个popup menu，如下所示：</p><p><img src="popup_show.png" alt=""></p><p>可以看到弹出菜单的样式是白底黑字，那么有没有办法改变它的背景颜色呢，使得菜单显示为黑底白字。这肯定是有的。</p><p>在<code>styles.xml</code>文件中新建一个主题</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- toolbar弹出菜单样式 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">name</span>=<span class="string">"ToolbarPopupTheme"</span> <span class="attr">parent</span>=<span class="string">"@style/ThemeOverlay.AppCompat.Dark"</span>&gt;</span><span class="undefined">   </span></span><br><span class="line"><span class="xml">     <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">"android:colorBackground"</span>&gt;</span>#000000<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure><p>可以看到这个主题的parent是直接继承自<code>ThemeOverlay.AppCompat.Dark</code>，是支持包的一个主题，并且我们在内部声明了<code>android:colorBackground</code>这个属性，我们只要更改这个属性就能变更菜单的背景颜色了。接下来我们在布局文件中引入这个主题，这也很简单，为toolbar添加额外的属性如下:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">app:popupTheme="@style/ToolbarPopupTheme"</span><br></pre></td></tr></table></figure><p>运行效果：</p><p><img src="popup_show2.png" alt=""></p><h2 id="修改Toolbar-popup-menu-弹出位置"><a href="#修改Toolbar-popup-menu-弹出位置" class="headerlink" title="修改Toolbar popup menu 弹出位置"></a>修改Toolbar popup menu 弹出位置</h2><p>在上图看到，弹出的菜单的位置是过于偏上的，我们可以修改它的位置，让它在toolbar的下面，这样看起来也美观一些：</p><p>修改<code>styles.xml</code>文件，添加</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- toolbar弹出菜单样式 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">name</span>=<span class="string">"ToolbarPopupTheme"</span> <span class="attr">parent</span>=<span class="string">"@style/ThemeOverlay.AppCompat.Dark"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">"android:colorBackground"</span>&gt;</span>#000000<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">"actionOverflowMenuStyle"</span>&gt;</span>@style/OverflowMenuStyle<span class="tag">&lt;/<span class="name">item</span>&gt;</span> </span></span><br><span class="line"><span class="xml">  <span class="comment">&lt;!--新增一个item，用于控制menu--&gt;</span></span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">name</span>=<span class="string">"OverflowMenuStyle"</span> <span class="attr">parent</span>=<span class="string">"Widget.AppCompat.Light.PopupMenu.Overflow"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">"overlapAnchor"</span>&gt;</span>false<span class="tag">&lt;/<span class="name">item</span>&gt;</span>  </span></span><br><span class="line"><span class="xml">  <span class="comment">&lt;!--把该属性改为false即可使menu位置位于toolbar之下--&gt;</span></span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure><p>布局文件中引用该主题</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">app:popupTheme="@style/ToolbarPopupTheme"</span><br></pre></td></tr></table></figure><p>运行效果：</p><p><img src="popup_show3.png" alt=""></p><h2 id="修改Action-Menu-Item-的文字颜色"><a href="#修改Action-Menu-Item-的文字颜色" class="headerlink" title="修改Action Menu Item 的文字颜色"></a>修改Action Menu Item 的文字颜色</h2><p>在<code>styles.xml</code>文件中，在popup menu的主题添加：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- toolbar弹出菜单样式 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">name</span>=<span class="string">"ToolbarPopupTheme"</span> <span class="attr">parent</span>=<span class="string">"@style/ThemeOverlay.AppCompat.Dark"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">"android:colorBackground"</span>&gt;</span>#000000<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">"actionOverflowMenuStyle"</span>&gt;</span>@style/OverflowMenuStyle<span class="tag">&lt;/<span class="name">item</span>&gt;</span> <span class="comment">&lt;!--新增一个item，用于控制menu--&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">"android:textColorPrimary"</span>&gt;</span>@color/colorPrimary<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure><p>布局文件中引用该主题</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">app:popupTheme="@style/ToolbarPopupTheme"</span><br></pre></td></tr></table></figure><p>运行效果：</p><p><img src="popup_show4.png" alt=""></p><h1 id="踩坑"><a href="#踩坑" class="headerlink" title="踩坑"></a>踩坑</h1><h2 id="设置监听事件不生效"><a href="#设置监听事件不生效" class="headerlink" title="设置监听事件不生效"></a>设置监听事件不生效</h2><p>看一下代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initToolbar</span><span class="params">()</span></span>&#123;</span><br><span class="line">mToolbar = findViewById(R.id.toolbar);</span><br><span class="line">mToolbar.setTitle(<span class="string">""</span>);</span><br><span class="line">mToolbar.setNavigationOnClickListener(<span class="keyword">new</span> View.OnClickListener() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View view)</span> </span>&#123;</span><br><span class="line"><span class="comment">//。。。</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">mToolbar.setOnMenuItemClickListener(<span class="keyword">new</span> Toolbar.OnMenuItemClickListener() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onMenuItemClick</span><span class="params">(MenuItem item)</span> </span>&#123;</span><br><span class="line"><span class="comment">//。。。</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">setSupportActionBar(mToolbar);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码正常设置监听但是就是监听事件就是没有触发，查询后，监听事件必须在<code>setSupportActionBar(mToolbar);</code>之后设置。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initToolbar</span><span class="params">()</span></span>&#123;</span><br><span class="line">mToolbar = findViewById(R.id.toolbar);</span><br><span class="line">mToolbar.setTitle(<span class="string">""</span>);</span><br><span class="line">setSupportActionBar(mToolbar);</span><br><span class="line">  mToolbar.setNavigationOnClickListener(<span class="keyword">new</span> View.OnClickListener() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View view)</span> </span>&#123;</span><br><span class="line"><span class="comment">//。。。</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">mToolbar.setOnMenuItemClickListener(<span class="keyword">new</span> Toolbar.OnMenuItemClickListener() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onMenuItemClick</span><span class="params">(MenuItem item)</span> </span>&#123;</span><br><span class="line"><span class="comment">//。。。</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调换一下位置即可正常运行。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>以上都是一些基本的使用，Toolbar控件的使用还是很灵活的，还有很多一些高级技巧，比如配合上状态栏变成沉浸式，或者配合<code>CoordinatorLayout</code>等实现更炫的效果。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://www.jianshu.com/p/79604c3ddcae" target="_blank" rel="noopener">https://www.jianshu.com/p/79604c3ddcae</a></p><p><a href="https://www.jianshu.com/p/ae0013a4f71a" target="_blank" rel="noopener">https://www.jianshu.com/p/ae0013a4f71a</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;初识Toolbar&quot;&gt;&lt;a href=&quot;#初识Toolbar&quot; class=&quot;headerlink&quot; title=&quot;初识Toolbar&quot;&gt;&lt;/a&gt;初识Toolbar&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;Toolbar&lt;/strong&gt; 是在 Android 5.0 开始推出的一个 Material Design 风格的导航控件 ，Google 非常推荐大家使用 &lt;strong&gt;Toolbar&lt;/strong&gt; 来作为Android客户端的导航栏，以此来取代之前的 &lt;strong&gt;Actionbar&lt;/strong&gt; 。&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="http://hackycy.github.io/categories/Android/"/>
    
    
      <category term="Android" scheme="http://hackycy.github.io/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Activity 的4种启动模式</title>
    <link href="http://hackycy.github.io/2019/06/20/Activity-%E7%9A%844%E7%A7%8D%E5%90%AF%E5%8A%A8%E6%A8%A1%E5%BC%8F/"/>
    <id>http://hackycy.github.io/2019/06/20/Activity-的4种启动模式/</id>
    <published>2019-06-20T03:27:34.000Z</published>
    <updated>2019-06-20T03:43:11.049Z</updated>
    
    <content type="html"><![CDATA[<p>启动模式简单地说就是Activity启动时的策略，在<code>AndroidManifest.xml</code>中的标签的<code>android:launchMode</code>属性设置；启动模式有4种，分别为standard、singleTop、singleTask、singleInstance；</p><a id="more"></a><ul><li>standard 标准模式，每次都新建一个实例对象</li><li>singleTop 如果在任务栈顶发现了相同的实例则重用，否则新建并压入栈顶</li><li>singleTask 如果在任务栈中发现了相同的实例，将其上面的任务终止并移除，重用该实例。否则新建实例并入栈</li><li>singleInstance 允许不同应用，进程线程等共用一个实例，无论从何应用调用该实例都重用</li></ul><h1 id="任务栈"><a href="#任务栈" class="headerlink" title="任务栈"></a>任务栈</h1><p>每个应用都有一个任务栈，是用来存放Activity的，功能类似于函数调用的栈，先后顺序代表了Activity的出现顺序；比如Activity1–&gt;Activity2–&gt;Activity3,则任务栈为：</p><p><img src="taskstack.gif" alt=""></p><h1 id="启动模式"><a href="#启动模式" class="headerlink" title="启动模式"></a>启动模式</h1><h2 id="standard"><a href="#standard" class="headerlink" title="standard"></a>standard</h2><p><img src="standard.gif" alt=""></p><p>每次激活Activity时(startActivity)，都创建Activity实例，并放入任务栈；</p><p>但是每次都新建一个实例的话真是过于浪费，为了优化应该尽量考虑余下三种方式。</p><h2 id="singleTop"><a href="#singleTop" class="headerlink" title="singleTop"></a>singleTop</h2><p><img src="singleTop.gif" alt=""></p><p>每次扫描栈顶，如果在任务栈顶发现了相同的实例则重用，否则新建并压入栈顶。</p><p>在<code>AndroidManifest.xml</code>中</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">activity</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:name</span>=<span class="string">".SingleTopActivity"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:label</span>=<span class="string">"@string/singletop"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:launchMode</span>=<span class="string">"singleTop"</span> &gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">activity</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="singleTask"><a href="#singleTask" class="headerlink" title="singleTask"></a>singleTask</h2><p><img src="singleTask.gif" alt=""></p><p>与singleTop的区别是singleTask会扫描整个任务栈并制定策略。上效果图：</p><p>使用时需要小心因为会将之前入栈的实例之上的实例全部移除，需要格外小心逻辑。</p><p>在<code>AndroidManifest.xml</code>中</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">activity</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:name</span>=<span class="string">".SingleTopActivity"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:label</span>=<span class="string">"@string/singletop"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:launchMode</span>=<span class="string">"singleTop"</span> &gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">activity</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="singleInstance"><a href="#singleInstance" class="headerlink" title="singleInstance"></a>singleInstance</h2><p><img src="singleInstance.gif" alt=""></p><p>这个的理解可以这么看：在微信里点击“用浏览器打开”一个朋友圈，然后切到QQ再用浏览器开一个网页，再跑到哪里再开一个页面。每次我们都在Activity中试图启动另一个浏览器Activity，但是在浏览器端看来，都是调用了同一个自己。因为使用了singleInstance模式，不同应用调用的Activity实际上是共享的。</p><p>在<code>AndroidManifest.xml</code>中</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">activity</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:name</span>=<span class="string">".SingleTopActivity"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:label</span>=<span class="string">"@string/singletop"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:launchMode</span>=<span class="string">"singleTop"</span> &gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">activity</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><ul><li><a href="https://hit-alibaba.github.io/interview/Android/basic/Android中Activity启动模式详解" target="_blank" rel="noopener">http://www.cnblogs.com/fanchangfa/archive/2012/08/25/2657012.html</a></li><li><a href="http://www.cnblogs.com/meizixiong/archive/2013/07/03/3170591.html" target="_blank" rel="noopener">Android入门：Activity四种启动模式</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;启动模式简单地说就是Activity启动时的策略，在&lt;code&gt;AndroidManifest.xml&lt;/code&gt;中的标签的&lt;code&gt;android:launchMode&lt;/code&gt;属性设置；启动模式有4种，分别为standard、singleTop、singleTask、singleInstance；&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="http://hackycy.github.io/categories/Android/"/>
    
    
      <category term="Android" scheme="http://hackycy.github.io/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>IOS之UIApplication</title>
    <link href="http://hackycy.github.io/2019/06/20/IOS%E4%B9%8BUIApplication/"/>
    <id>http://hackycy.github.io/2019/06/20/IOS之UIApplication/</id>
    <published>2019-06-20T03:18:53.000Z</published>
    <updated>2019-08-07T08:21:17.541Z</updated>
    
    <content type="html"><![CDATA[<p>UIApplication 的核心作用是提供了 iOS 程序运行期间的控制和协作工作。</p><p>每一个程序在运行期必须有且仅有一个<code>UIApplication</code>（或则其子类）的一个实例。在程序开始运行的时候，<code>UIApplicationMain</code> 函数是程序进入点，这个函数做了很多工作，其中一个重要的工作就是创建一个 <code>UIApplication</code> 的单例实例。在你的代码中你，你可以通过调用 <code>[UIApplication sharedApplication]</code>来得到这个单例实例的指针。</p><a id="more"></a><p>UIApplication 的一个主要工作是处理用户事件，它会起一个队列，把所有用户事件都放入队列，逐个处理，在处理的时候，它会发送当前事件 到一个合适的处理事件的目标控件。此外，UIApplication 实例还维护一个在本应用中打开的 window 列表（UIWindow 实例），这样它就 可以接触应用中的任何一个 UIView 对象。UIApplication 实例会被赋予一个代理对象，以处理应用程序的生命周期事件（比如程序启动和关闭）、系统事件（比如来电、记事项警告）等等。</p><h1 id="UIApplicaion-生命周期"><a href="#UIApplicaion-生命周期" class="headerlink" title="UIApplicaion 生命周期"></a>UIApplicaion 生命周期</h1><p>一个 UIApplication 可以有如下几种状态：</p><ul><li><code>Not running（未运行）</code>程序没启动</li><li><code>Inactive（未激活）</code>程序在前台运行，不过没有接收到事件。在没有事件处理情况下程序通常停留在这个状态</li><li><code>Active（激活）</code>程序在前台运行而且接收到了事件。这也是前台的一个正常的模式</li><li><code>Background（后台）</code> 程序在后台而且能执行代码，大多数程序进入这个状态后会在在这个状态上停留一会。时间到之后会进入挂起状态 (Suspended)。有的程序经过特殊的请求后可以长期处于 Background 状态</li><li><code>Suspended（挂起）</code>程序在后台不能执行代码。系统会自动把程序变成这个状态而且不会发出通知。当挂起时，程序还是停留在内存中的，当系统内存低时，系统就把挂起的程序清除掉，为前台程序提供更多的内存。</li></ul><p>常见的代理方法有</p><ol><li><p><code>(void)applicationWillResignActive:(UIApplication *)application</code></p><p>说明：当应用程序将要入非活动状态执行，在此期间，应用程序不接收消息或事件，比如来电话了</p></li><li><p><code>(void)applicationDidBecomeActive:(UIApplication *)application</code></p><p>说明：当应用程序入活动状态执行，这个刚好跟上面那个方法相反</p></li><li><p><code>(void)applicationDidEnterBackground:(UIApplication *)application</code></p><p>说明：当程序被推送到后台的时候调用。所以要设置后台继续运行，则在这个函数里面设置即可</p></li><li><p><code>(void)applicationWillEnterForeground:(UIApplication *)application</code></p><p>说明：当程序从后台将要重新回到前台时候调用，这个刚好跟上面的那个方法相反。</p></li><li><p><code>(void)applicationWillTerminate:(UIApplication *)application</code></p><p>说明：当程序将要退出是被调用，通常是用来保存数据和一些退出前的清理工作。这个需要设置 UIApplicationExitsOnSuspend 的键值。</p></li><li><p><code>(void)applicationDidReceiveMemoryWarning:(UIApplication *)application</code></p><p>说明：iPhone 设备只有有限的内存，如果为应用程序分配了太多内存操作系统会终止应用程序的运行，在终止前会执行这个方法，通常可以在这里进行内存清理工作防止程序被终止</p></li><li><p><code>(void)applicationSignificantTimeChange:(UIApplication*)application</code></p><p>说明：当系统时间发生改变时执行</p></li><li><p><code>(void)applicationDidFinishLaunching:(UIApplication*)application</code></p><p>说明：当程序载入后执行</p></li></ol><h1 id="应用入口"><a href="#应用入口" class="headerlink" title="应用入口"></a>应用入口</h1><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">BOOL</span>)application:(<span class="built_in">UIApplication</span> *)application willFinishLaunchingWithOptions:(<span class="built_in">NSDictionary</span> *)launchOptions</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">BOOL</span>)application:(<span class="built_in">UIApplication</span> *)application didFinishLaunchingWithOptions:(<span class="built_in">NSDictionary</span> *)launchOptions</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Override point for customization after application launch.</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>说明：这两个方法的作用几乎完全一样，只是执行顺序有先后。AppDelegate类默认出现的是<code>application: didFinishLaunchingWithOptions:</code>，一般情况下只需要处理这个方法就可以了。</p><p><code>didFinishLaunchingWithOptions</code>函数的参数launchOptions是一个NSDictionary类型的对象，存储的是程序启动的原因。</p><p><code>didFinishLaunchingWithOptions</code>函数的返回值是一个BOOL类型，将决定是否处理URL资源，如果返回YES，则会由<code>application:openURL:sourceApplication:annotation:</code>方法处理URL。如果应用程序有一个远程通知启动，返回值会被忽略。</p><blockquote><p>P.s. 如果同时出现了<code>application: willFinishLaunchingWithOptions:</code>和<code>application: didFinishLaunchingWithOptions:</code>，那么这两个方法都要返回YES，才会处理URL资源。</p></blockquote><h2 id="启动原因"><a href="#启动原因" class="headerlink" title="启动原因"></a>启动原因</h2><ul><li><p><strong>用户直接启动</strong><br>lauchOptions内无数据</p></li><li><p><strong>其他应用程序通过openURL:启动</strong><br>lauchOptions字典内存储:<br>@{UIApplicationLaunchOptionsURLKey:启动URL(NSURL),<br>UIApplicationLaunchOptionsSourceApplicationKey:启动源程序的bundleID(NSString)}</p></li><li><p><strong>本地通知启动</strong><br>lauchOptions字典内存储：<br>@{UIApplicationLaunchOptionsLocalNotificationKey:启动应用程序的本地通知对象（UILocalNotification）}</p></li><li><p><strong>远程通知启动</strong><br> @{UIApplicationLaunchOptionsRemoteNotificationKey:启动应用程序的的远程通知信息userInfo（NSDictionary）}</p></li><li><p><strong>其他的key还有</strong><br> UIApplicationLaunchOptionsAnnotationKey,<br> UIApplicationLaunchOptionsLocationKey,<br> UIApplicationLaunchOptionsNewsstandDownloadsKey</p><blockquote><p>程序launchOptions中的可能键值可以参考UIApplication Class Reference的”Launch Options Keys”。</p></blockquote></li></ul><p>例子：在<code>didFinishLaunchingWithOptions:</code>创建UIWindow</p><blockquote><p>先把指定的Main Interface中mian删除掉</p></blockquote><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">BOOL</span>)application:(<span class="built_in">UIApplication</span> *)application didFinishLaunchingWithOptions:(<span class="built_in">NSDictionary</span> *)launchOptions &#123;</span><br><span class="line">    <span class="comment">//创建窗口对象</span></span><br><span class="line">    <span class="keyword">self</span>.window = [[<span class="built_in">UIWindow</span> alloc]initWithFrame:[<span class="built_in">UIScreen</span> mainScreen].bounds];</span><br><span class="line">    <span class="comment">//创建窗口的根控制器，并且赋值</span></span><br><span class="line">    <span class="built_in">UIViewController</span> *rootVc = [[<span class="built_in">UIViewController</span> alloc]init];</span><br><span class="line">    <span class="keyword">self</span>.window.rootViewController = rootVc;</span><br><span class="line">    <span class="comment">//显示窗口</span></span><br><span class="line">    [<span class="keyword">self</span>.window makeKeyAndVisible];</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="App-生命周期示意图"><a href="#App-生命周期示意图" class="headerlink" title="App 生命周期示意图"></a>App 生命周期示意图</h1><p><img src="lifecycle.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;UIApplication 的核心作用是提供了 iOS 程序运行期间的控制和协作工作。&lt;/p&gt;
&lt;p&gt;每一个程序在运行期必须有且仅有一个&lt;code&gt;UIApplication&lt;/code&gt;（或则其子类）的一个实例。在程序开始运行的时候，&lt;code&gt;UIApplicationMain&lt;/code&gt; 函数是程序进入点，这个函数做了很多工作，其中一个重要的工作就是创建一个 &lt;code&gt;UIApplication&lt;/code&gt; 的单例实例。在你的代码中你，你可以通过调用 &lt;code&gt;[UIApplication sharedApplication]&lt;/code&gt;来得到这个单例实例的指针。&lt;/p&gt;
    
    </summary>
    
      <category term="Ios" scheme="http://hackycy.github.io/categories/Ios/"/>
    
    
      <category term="Ios" scheme="http://hackycy.github.io/tags/Ios/"/>
    
      <category term="Objective-C" scheme="http://hackycy.github.io/tags/Objective-C/"/>
    
  </entry>
  
</feed>
