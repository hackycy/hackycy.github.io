<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>思忆技术</title>
  
  <subtitle>思忆，分享技术</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://hackycy.github.io/"/>
  <updated>2020-05-12T03:43:06.355Z</updated>
  <id>http://hackycy.github.io/</id>
  
  <author>
    <name>hackycy</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>IOS客户端与服务端时间同步方案</title>
    <link href="http://hackycy.github.io/2020/05/12/IOS%E5%AE%A2%E6%88%B7%E7%AB%AF%E4%B8%8E%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%97%B6%E9%97%B4%E5%90%8C%E6%AD%A5%E6%96%B9%E6%A1%88/"/>
    <id>http://hackycy.github.io/2020/05/12/IOS客户端与服务端时间同步方案/</id>
    <published>2020-05-12T02:35:16.000Z</published>
    <updated>2020-05-12T03:43:06.355Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>最近项目的编写中，接口需要提交精确到秒级的时间戳用作校验。但是仅靠<code>new Date().timeIntervalSince1970</code>会面临着本地的时间与服务器时间不一致的问题。那么本文方案能让本地应用时间与服务器时间存在误差范围内保持同步，减少应用出错率。</p><a id="more"></a><h1 id="预备知识"><a href="#预备知识" class="headerlink" title="预备知识"></a>预备知识</h1><ul><li>获取设备当前时间 <code>Now</code>，该值受系统时间影响，用户如果修改时间，值也会随着变化；</li><li>获取设备上次重启的时间 <code>BootTime</code>，该值受系统时间影响，用户如果修改时间，值也会随着变化；</li><li>由上面 <code>iOS</code> 提供的两个接口，我们可以获取到<strong>设备自上次重启后运行的时间</strong>（<code>BootTime - Now</code>），该值与系统时间无关；<span class="label danger">`-`这个不是减，指的是区间，下面同理</span> </li><li>在必要的时刻获取一下服务器时间，然后记录这个时刻的<strong>设备自上次重启后运行的时间</strong>（<code>BootTime - Now</code>）</li><li>后续时间获取：<strong>现在服务器时间 = 以前服务器时间 + 现在设备自上次重启后运行的时间 - 以前服务器时间的获取时刻的设备自上次重启后运行的时间</strong></li><li>利用AFNetworking自动同步时间</li></ul><h1 id="时间的获取"><a href="#时间的获取" class="headerlink" title="时间的获取"></a>时间的获取</h1><p><strong>获取now的Unix Time</strong></p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">func</span> <span class="title">now</span>() -&gt; <span class="title">Int</span> </span>&#123;</span><br><span class="line"><span class="keyword">var</span> now = timeval()</span><br><span class="line"><span class="keyword">var</span> tz = timezone()</span><br><span class="line">gettimeofday(&amp;now, &amp;tz)</span><br><span class="line"><span class="keyword">return</span> now.tv_sec</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>获取设备上次重启的 Unix Time</strong></p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">func</span> <span class="title">boottime</span>() -&gt; <span class="title">Int</span> </span>&#123;</span><br><span class="line"><span class="keyword">var</span> mid = [<span class="type">CTL_KERN</span>, <span class="type">KERN_BOOTTIME</span>]</span><br><span class="line"><span class="keyword">var</span> boottime = timeval()</span><br><span class="line"><span class="keyword">var</span> size = <span class="type">MemoryLayout</span>.size(ofValue: boottime)</span><br><span class="line">  <span class="keyword">if</span> sysctl(&amp;mid, <span class="number">2</span>, &amp;boottime, &amp;size, <span class="literal">nil</span>, <span class="number">0</span>) != -<span class="number">1</span> &#123;</span><br><span class="line"><span class="keyword">return</span> boottime.tv_sec</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>获取设备自上次重启后运行的时间</strong></p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">now() - boottime()</span><br></pre></td></tr></table></figure><h1 id="TimeUtils编写"><a href="#TimeUtils编写" class="headerlink" title="TimeUtils编写"></a>TimeUtils编写</h1><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> UIKit</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TimeUtils</span>: <span class="title">NSObject</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">var</span> isServerTime: <span class="type">Bool</span> = <span class="literal">false</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">var</span> diffTime: <span class="type">Int</span> = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/// 项目中所有获取时间的方法</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">func</span> <span class="title">getServerTime</span>() -&gt; <span class="title">Int</span> </span>&#123;</span><br><span class="line">        objc_sync_enter(<span class="keyword">self</span>)</span><br><span class="line">        <span class="keyword">defer</span> &#123;</span><br><span class="line">            objc_sync_exit(<span class="keyword">self</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> !isServerTime &#123;</span><br><span class="line">            <span class="keyword">let</span> t = <span class="type">Date</span>().timestamp</span><br><span class="line">            <span class="keyword">return</span> t</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">let</span> t = diffTime + (now() - boottime())</span><br><span class="line">        <span class="keyword">return</span> t</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/// 用于计算时间</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">func</span> <span class="title">calibrationTime</span>(<span class="title">lastServerTime</span>: <span class="title">Int</span>) -&gt; <span class="title">Int</span> </span>&#123;</span><br><span class="line">        objc_sync_enter(<span class="keyword">self</span>)</span><br><span class="line">        <span class="keyword">defer</span> &#123;</span><br><span class="line">            objc_sync_exit(<span class="keyword">self</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        diffTime = lastServerTime - (now() - boottime())</span><br><span class="line">        isServerTime = <span class="literal">true</span></span><br><span class="line">        <span class="keyword">return</span> lastServerTime</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/// 获取当前 Unix Time</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">func</span> <span class="title">now</span>() -&gt; <span class="title">Int</span> </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> now = timeval()</span><br><span class="line">        <span class="keyword">var</span> tz = timezone()</span><br><span class="line">        gettimeofday(&amp;now, &amp;tz)</span><br><span class="line">        <span class="keyword">return</span> now.tv_sec</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">  <span class="comment">/// 获取设备上次重启的 Unix Time</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">func</span> <span class="title">boottime</span>() -&gt; <span class="title">Int</span> </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> mid = [<span class="type">CTL_KERN</span>, <span class="type">KERN_BOOTTIME</span>]</span><br><span class="line">        <span class="keyword">var</span> boottime = timeval()</span><br><span class="line">        <span class="keyword">var</span> size = <span class="type">MemoryLayout</span>.size(ofValue: boottime)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> sysctl(&amp;mid, <span class="number">2</span>, &amp;boottime, &amp;size, <span class="literal">nil</span>, <span class="number">0</span>) != -<span class="number">1</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> boottime.tv_sec</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Date</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> timestamp: <span class="type">Int</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> timeInterval: <span class="type">TimeInterval</span> = <span class="keyword">self</span>.timeIntervalSince1970</span><br><span class="line">        <span class="keyword">return</span> <span class="type">Int</span>(timeInterval)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="利用AFNetworking同步时间"><a href="#利用AFNetworking同步时间" class="headerlink" title="利用AFNetworking同步时间"></a>利用AFNetworking同步时间</h1><p>利用AFN发起请求返回时通过HTTP Header来获取服务器时间，时间格式以<a href="https://link.jianshu.com/?t=https%3A%2F%2Ftools.ietf.org%2Fhtml%2Frfc7231%23section-7.1.1.1" target="_blank" rel="noopener">RFC-7231</a>中定义的”HTTP日期”格式来发送，解析该时间需要用到以下的OC代码，Swift项目请自行用<code>Bridging-Header</code></p><p><strong>NSDate+InternetDateTime.h</strong></p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  NSDate+InternetDateTime.h</span></span><br><span class="line"><span class="comment">//  MWFeedParser</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  Created by Michael Waterfall on 07/10/2010.</span></span><br><span class="line"><span class="comment">//  Copyright 2010 Michael Waterfall. All rights reserved.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Formatting hints</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> &#123;</span><br><span class="line">    DateFormatHintNone, </span><br><span class="line">    DateFormatHintRFC822, </span><br><span class="line">    DateFormatHintRFC3339</span><br><span class="line">&#125; DateFormatHint;</span><br><span class="line"></span><br><span class="line"><span class="comment">// A category to parse internet date &amp; time strings</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">NSDate</span> (<span class="title">InternetDateTime</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Get date from RFC3339 or RFC822 string</span></span><br><span class="line"><span class="comment">// - A format/specification hint can be used to speed up, </span></span><br><span class="line"><span class="comment">//   otherwise both will be attempted in order to get a date</span></span><br><span class="line">+ (<span class="built_in">NSDate</span> *)dateFromInternetDateTimeString:(<span class="built_in">NSString</span> *)dateString </span><br><span class="line">                                formatHint:(DateFormatHint)hint;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Get date from a string using a specific date specification</span></span><br><span class="line">+ (<span class="built_in">NSDate</span> *)dateFromRFC3339String:(<span class="built_in">NSString</span> *)dateString;</span><br><span class="line">+ (<span class="built_in">NSDate</span> *)dateFromRFC822String:(<span class="built_in">NSString</span> *)dateString;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p><strong>NSDate+InternetDateTime.m</strong></p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  NSDate+InternetDateTime.m</span></span><br><span class="line"><span class="comment">//  MWFeedParser</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  Created by Michael Waterfall on 07/10/2010.</span></span><br><span class="line"><span class="comment">//  Copyright 2010 Michael Waterfall. All rights reserved.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#import <span class="meta-string">"NSDate+InternetDateTime.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Always keep the formatter around as they're expensive to instantiate</span></span><br><span class="line"><span class="keyword">static</span> <span class="built_in">NSDateFormatter</span> *_internetDateTimeFormatter = <span class="literal">nil</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Good info on internet dates here:</span></span><br><span class="line"><span class="comment">// http://developer.apple.com/iphone/library/qa/qa2010/qa1480.html</span></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">NSDate</span> (<span class="title">InternetDateTime</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Instantiate single date formatter</span></span><br><span class="line">+ (<span class="built_in">NSDateFormatter</span> *)internetDateTimeFormatter &#123;</span><br><span class="line">    <span class="keyword">@synchronized</span>(<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!_internetDateTimeFormatter) &#123;</span><br><span class="line">            <span class="built_in">NSLocale</span> *en_US_POSIX = [[<span class="built_in">NSLocale</span> alloc] initWithLocaleIdentifier:<span class="string">@"en_US_POSIX"</span>];</span><br><span class="line">            _internetDateTimeFormatter = [[<span class="built_in">NSDateFormatter</span> alloc] init];</span><br><span class="line">            [_internetDateTimeFormatter setLocale:en_US_POSIX];</span><br><span class="line">            [_internetDateTimeFormatter setTimeZone:[<span class="built_in">NSTimeZone</span> timeZoneForSecondsFromGMT:<span class="number">0</span>]];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> _internetDateTimeFormatter;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Get a date from a string - hint can be used to speed up</span></span><br><span class="line">+ (<span class="built_in">NSDate</span> *)dateFromInternetDateTimeString:(<span class="built_in">NSString</span> *)dateString formatHint:(DateFormatHint)hint &#123;</span><br><span class="line">     <span class="comment">// Keep dateString around a while (for thread-safety)</span></span><br><span class="line"><span class="built_in">NSDate</span> *date = <span class="literal">nil</span>;</span><br><span class="line">    <span class="keyword">if</span> (dateString) &#123;</span><br><span class="line">        <span class="keyword">if</span> (hint != DateFormatHintRFC3339) &#123;</span><br><span class="line">            <span class="comment">// Try RFC822 first</span></span><br><span class="line">            date = [<span class="built_in">NSDate</span> dateFromRFC822String:dateString];</span><br><span class="line">            <span class="keyword">if</span> (!date) date = [<span class="built_in">NSDate</span> dateFromRFC3339String:dateString];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Try RFC3339 first</span></span><br><span class="line">            date = [<span class="built_in">NSDate</span> dateFromRFC3339String:dateString];</span><br><span class="line">            <span class="keyword">if</span> (!date) date = [<span class="built_in">NSDate</span> dateFromRFC822String:dateString];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">     <span class="comment">// Finished with date string</span></span><br><span class="line"><span class="keyword">return</span> date;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// See http://www.faqs.org/rfcs/rfc822.html</span></span><br><span class="line">+ (<span class="built_in">NSDate</span> *)dateFromRFC822String:(<span class="built_in">NSString</span> *)dateString &#123;</span><br><span class="line">     <span class="comment">// Keep dateString around a while (for thread-safety)</span></span><br><span class="line">    <span class="built_in">NSDate</span> *date = <span class="literal">nil</span>;</span><br><span class="line">    <span class="keyword">if</span> (dateString) &#123;</span><br><span class="line">        <span class="built_in">NSDateFormatter</span> *dateFormatter = [<span class="built_in">NSDate</span> internetDateTimeFormatter];</span><br><span class="line">        <span class="keyword">@synchronized</span>(dateFormatter) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Process</span></span><br><span class="line">            <span class="built_in">NSString</span> *RFC822String = [[<span class="built_in">NSString</span> stringWithString:dateString] uppercaseString];</span><br><span class="line">            <span class="keyword">if</span> ([RFC822String rangeOfString:<span class="string">@","</span>].location != <span class="built_in">NSNotFound</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!date) &#123; <span class="comment">// Sun, 19 May 2002 15:21:36 GMT</span></span><br><span class="line">                    [dateFormatter setDateFormat:<span class="string">@"EEE, d MMM yyyy HH:mm:ss zzz"</span>]; </span><br><span class="line">                    date = [dateFormatter dateFromString:RFC822String];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (!date) &#123; <span class="comment">// Sun, 19 May 2002 15:21 GMT</span></span><br><span class="line">                    [dateFormatter setDateFormat:<span class="string">@"EEE, d MMM yyyy HH:mm zzz"</span>]; </span><br><span class="line">                    date = [dateFormatter dateFromString:RFC822String];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (!date) &#123; <span class="comment">// Sun, 19 May 2002 15:21:36</span></span><br><span class="line">                    [dateFormatter setDateFormat:<span class="string">@"EEE, d MMM yyyy HH:mm:ss"</span>]; </span><br><span class="line">                    date = [dateFormatter dateFromString:RFC822String];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (!date) &#123; <span class="comment">// Sun, 19 May 2002 15:21</span></span><br><span class="line">                    [dateFormatter setDateFormat:<span class="string">@"EEE, d MMM yyyy HH:mm"</span>]; </span><br><span class="line">                    date = [dateFormatter dateFromString:RFC822String];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (!date) &#123; <span class="comment">// 19 May 2002 15:21:36 GMT</span></span><br><span class="line">                    [dateFormatter setDateFormat:<span class="string">@"d MMM yyyy HH:mm:ss zzz"</span>]; </span><br><span class="line">                    date = [dateFormatter dateFromString:RFC822String];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (!date) &#123; <span class="comment">// 19 May 2002 15:21 GMT</span></span><br><span class="line">                    [dateFormatter setDateFormat:<span class="string">@"d MMM yyyy HH:mm zzz"</span>]; </span><br><span class="line">                    date = [dateFormatter dateFromString:RFC822String];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (!date) &#123; <span class="comment">// 19 May 2002 15:21:36</span></span><br><span class="line">                    [dateFormatter setDateFormat:<span class="string">@"d MMM yyyy HH:mm:ss"</span>]; </span><br><span class="line">                    date = [dateFormatter dateFromString:RFC822String];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (!date) &#123; <span class="comment">// 19 May 2002 15:21</span></span><br><span class="line">                    [dateFormatter setDateFormat:<span class="string">@"d MMM yyyy HH:mm"</span>]; </span><br><span class="line">                    date = [dateFormatter dateFromString:RFC822String];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!date) <span class="built_in">NSLog</span>(<span class="string">@"Could not parse RFC822 date: \"%@\" Possible invalid format."</span>, dateString);</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">     <span class="comment">// Finished with date string</span></span><br><span class="line">    <span class="keyword">return</span> date;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// See http://www.faqs.org/rfcs/rfc3339.html</span></span><br><span class="line">+ (<span class="built_in">NSDate</span> *)dateFromRFC3339String:(<span class="built_in">NSString</span> *)dateString &#123;</span><br><span class="line">     <span class="comment">// Keep dateString around a while (for thread-safety)</span></span><br><span class="line">    <span class="built_in">NSDate</span> *date = <span class="literal">nil</span>;</span><br><span class="line">    <span class="keyword">if</span> (dateString) &#123;</span><br><span class="line">        <span class="built_in">NSDateFormatter</span> *dateFormatter = [<span class="built_in">NSDate</span> internetDateTimeFormatter];</span><br><span class="line">        <span class="keyword">@synchronized</span>(dateFormatter) &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// Process date</span></span><br><span class="line">            <span class="built_in">NSString</span> *RFC3339String = [[<span class="built_in">NSString</span> stringWithString:dateString] uppercaseString];</span><br><span class="line">            RFC3339String = [RFC3339String stringByReplacingOccurrencesOfString:<span class="string">@"Z"</span> withString:<span class="string">@"-0000"</span>];</span><br><span class="line">            <span class="comment">// Remove colon in timezone as it breaks NSDateFormatter in iOS 4+.</span></span><br><span class="line">            <span class="comment">// - see https://devforums.apple.com/thread/45837</span></span><br><span class="line">            <span class="keyword">if</span> (RFC3339String.length &gt; <span class="number">20</span>) &#123;</span><br><span class="line">                RFC3339String = [RFC3339String stringByReplacingOccurrencesOfString:<span class="string">@":"</span> </span><br><span class="line">                                                                         withString:<span class="string">@""</span> </span><br><span class="line">                                                                            options:<span class="number">0</span></span><br><span class="line">                                                                              range:<span class="built_in">NSMakeRange</span>(<span class="number">20</span>, RFC3339String.length<span class="number">-20</span>)];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!date) &#123; <span class="comment">// 1996-12-19T16:39:57-0800</span></span><br><span class="line">                [dateFormatter setDateFormat:<span class="string">@"yyyy'-'MM'-'dd'T'HH':'mm':'ssZZZ"</span>]; </span><br><span class="line">                date = [dateFormatter dateFromString:RFC3339String];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!date) &#123; <span class="comment">// 1937-01-01T12:00:27.87+0020</span></span><br><span class="line">                [dateFormatter setDateFormat:<span class="string">@"yyyy'-'MM'-'dd'T'HH':'mm':'ss.SSSZZZ"</span>]; </span><br><span class="line">                date = [dateFormatter dateFromString:RFC3339String];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!date) &#123; <span class="comment">// 1937-01-01T12:00:27</span></span><br><span class="line">                [dateFormatter setDateFormat:<span class="string">@"yyyy'-'MM'-'dd'T'HH':'mm':'ss"</span>]; </span><br><span class="line">                date = [dateFormatter dateFromString:RFC3339String];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!date) <span class="built_in">NSLog</span>(<span class="string">@"Could not parse RFC3339 date: \"%@\" Possible invalid format."</span>, dateString);</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">     <span class="comment">// Finished with date string</span></span><br><span class="line"><span class="keyword">return</span> date;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><blockquote><p>来源：<a href="https://github.com/mwaterfall/MWFeedParser/blob/master/Classes/NSDate+InternetDateTime.m（ARC）" target="_blank" rel="noopener">https://github.com/mwaterfall/MWFeedParser/blob/master/Classes/NSDate+InternetDateTime.m（ARC）</a></p></blockquote><p>在项目中封装一个AFN的请求基类</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> UIKit</span><br><span class="line"><span class="keyword">import</span> AFNetworking</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">HttpMethod</span>: <span class="title">String</span> </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">GET</span> = <span class="string">"GET"</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">POST</span> = <span class="string">"POST"</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HttpClient</span>: <span class="title">NSObject</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">let</span> baseURLString = <span class="string">"http://base.url/"</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">var</span> minResponseTime = <span class="type">Int</span>.<span class="built_in">max</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">let</span> sharedClient: <span class="type">AFHTTPSessionManager</span> = &#123;</span><br><span class="line">        <span class="keyword">let</span> baseUrl = <span class="type">URL</span>(string: baseURLString)</span><br><span class="line">        <span class="keyword">let</span> client = <span class="type">AFHTTPSessionManager</span>(baseURL: baseUrl!)</span><br><span class="line">        <span class="comment">// 设置请求格式</span></span><br><span class="line">        client.requestSerializer = <span class="type">AFJSONRequestSerializer</span>()</span><br><span class="line">        <span class="comment">// 设置返回格式</span></span><br><span class="line">        client.responseSerializer = <span class="type">AFJSONResponseSerializer</span>()</span><br><span class="line">        <span class="comment">// 设置禁止缓存</span></span><br><span class="line">        client.requestSerializer.cachePolicy = .reloadIgnoringLocalCacheData</span><br><span class="line">        <span class="comment">// 设置超时</span></span><br><span class="line">        client.requestSerializer.timeoutInterval = <span class="number">10</span></span><br><span class="line">        <span class="comment">// 以防解析格式不支持</span></span><br><span class="line">        client.responseSerializer.acceptableContentTypes?.insert(<span class="string">"text/html"</span>)</span><br><span class="line">        client.responseSerializer.acceptableContentTypes?.insert(<span class="string">"text/plain"</span>)</span><br><span class="line">        <span class="keyword">return</span> client</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">HttpClient</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// MARK: 请求方式</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/// 项目公共请求类</span></span><br><span class="line">    <span class="comment">/// - Parameters:</span></span><br><span class="line">    <span class="comment">///   - httpMethod: httpMethod</span></span><br><span class="line">    <span class="comment">///   - URLString: URLString</span></span><br><span class="line">    <span class="comment">///   - parameters: 参数</span></span><br><span class="line">    <span class="comment">///   - headers: 请求头</span></span><br><span class="line">    <span class="comment">///   - progress: 进度</span></span><br><span class="line">    <span class="comment">///   - success: 成功回调</span></span><br><span class="line">    <span class="comment">///   - failure: 失败回调</span></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">func</span> <span class="title">request</span>(<span class="title">httpMethod</span>: <span class="title">HttpMethod</span>, <span class="title">URLString</span>: <span class="title">String</span>, <span class="title">parameters</span>: [<span class="title">String</span> : <span class="title">Any</span>]?,</span></span><br><span class="line"><span class="class">                       <span class="title">headers</span>: [<span class="title">String</span> : <span class="title">String</span>]?, <span class="title">progress</span>: ((<span class="title">Progress</span>) -&gt; <span class="title">Void</span>)?,</span></span><br><span class="line"><span class="class">                       <span class="title">success</span>: ((<span class="title">URLSessionDataTask</span>, <span class="title">Any</span>?) -&gt; <span class="title">Void</span>)?, <span class="title">failure</span>: ((<span class="title">URLSessionDataTask</span>?, <span class="title">Error</span>) -&gt; <span class="title">Void</span>)?) </span>&#123;</span><br><span class="line">        <span class="comment">// 记录当前请求开始时间</span></span><br><span class="line">        <span class="keyword">let</span> startTime = <span class="type">Date</span>().timestamp</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 定义通用成功回调</span></span><br><span class="line">        <span class="keyword">let</span> successCallback = &#123; (task: <span class="type">URLSessionDataTask</span>, result: <span class="type">Any?</span>) -&gt; () <span class="keyword">in</span></span><br><span class="line">            <span class="comment">// 当前请求响应的时间间隔</span></span><br><span class="line">            <span class="keyword">let</span> responseTime = <span class="type">Date</span>().timestamp - startTime</span><br><span class="line">            <span class="comment">//如果这一次的请求响应时间小于上一次，则更新本地维护的时间</span></span><br><span class="line">            <span class="keyword">if</span> responseTime &lt;= minResponseTime &#123;</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">let</span> response = task.response <span class="keyword">as</span>? <span class="type">HTTPURLResponse</span> &#123;</span><br><span class="line">                    <span class="comment">// 网络响应头包含Date字段（世界时间）</span></span><br><span class="line">                    <span class="keyword">if</span> response.allHeaderFields[<span class="string">"Date"</span>] <span class="keyword">is</span> <span class="type">String</span> &#123;</span><br><span class="line">                        <span class="keyword">let</span> dateString = response.allHeaderFields[<span class="string">"Date"</span>]! <span class="keyword">as</span>! <span class="type">String</span></span><br><span class="line">                        <span class="keyword">if</span> <span class="keyword">let</span> date = <span class="type">NSDate</span>(fromInternetDateTime: dateString, formatHint: <span class="type">DateFormatHintRFC822</span>) &#123;</span><br><span class="line">                            <span class="keyword">let</span> <span class="number">_</span> = <span class="type">TimeUtils</span>.calibrationTime(lastServerTime: <span class="type">Int</span>(date.timeIntervalSince1970))</span><br><span class="line">                            minResponseTime = responseTime</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            success?(task, result)</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> httpMethod == .<span class="type">GET</span> &#123;</span><br><span class="line">            <span class="keyword">self</span>.sharedClient.<span class="keyword">get</span>(<span class="type">URLString</span>, parameters: parameters, headers: safeHeaders, progress: progress, success: successCallback, failure: failure)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> httpMethod == .<span class="type">POST</span> &#123;</span><br><span class="line">            <span class="keyword">self</span>.sharedClient.post(<span class="type">URLString</span>, parameters: parameters, headers: safeHeaders, progress: progress, success: successCallback, failure: failure)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div class="note warning"><p>该方案下前提必须禁止AFN自带的缓存策略<code>client.requestSerializer.cachePolicy = .reloadIgnoringLocalCacheData</code>。不禁止会出现时间异常的现象，如项目中是使用AFN自带的缓存策略则需要更换项目中的缓存方案。</p></div><blockquote><p>该方案都仅到秒级，如需到毫秒级请做*1000处理</p><p>不足：连接服务器的过程是需要时间的，服务器收到请求时刻的时间与应用收到响应存在一定的时间差，导致误差的存在（误差=服务器发出响应-&gt;到本机收到响应这个时间）。</p><p>但是通过上面的AFN每次判断，可以使得误差逐渐降低</p></blockquote><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://www.jianshu.com/p/48ac0bb1392e" target="_blank" rel="noopener">https://www.jianshu.com/p/48ac0bb1392e</a></p><p><a href="https://www.jianshu.com/p/bb2cbfad3e77" target="_blank" rel="noopener">https://www.jianshu.com/p/bb2cbfad3e77</a></p><p><a href="https://www.jianshu.com/p/df41659b06a9" target="_blank" rel="noopener">https://www.jianshu.com/p/df41659b06a9</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;最近项目的编写中，接口需要提交精确到秒级的时间戳用作校验。但是仅靠&lt;code&gt;new Date().timeIntervalSince1970&lt;/code&gt;会面临着本地的时间与服务器时间不一致的问题。那么本文方案能让本地应用时间与服务器时间存在误差范围内保持同步，减少应用出错率。&lt;/p&gt;
    
    </summary>
    
      <category term="Ios" scheme="http://hackycy.github.io/categories/Ios/"/>
    
    
      <category term="Ios" scheme="http://hackycy.github.io/tags/Ios/"/>
    
  </entry>
  
  <entry>
    <title>IOS填坑之URL编码问题</title>
    <link href="http://hackycy.github.io/2020/05/08/IOS%E5%A1%AB%E5%9D%91%E4%B9%8BURL%E7%BC%96%E7%A0%81%E9%97%AE%E9%A2%98/"/>
    <id>http://hackycy.github.io/2020/05/08/IOS填坑之URL编码问题/</id>
    <published>2020-05-08T03:24:06.000Z</published>
    <updated>2020-05-12T02:36:18.786Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在使用WKWebview的时候，通常都离不开URL，一般的符合网络标准的URL没有什么问题，但是在公司开发的时候遇到了一些特殊URL的时候就踩到了URL编码的坑。</p><p>在1994年订制的RFC1738文档中，对字符串中的除了<code>- _ .</code>之外的所有非字母数字字符都替换成百分号(%)后跟两位十六进制数，十六进制数中字母必须为大写。</p><p>在2005年定义的RFC3986中，将针对<code>- _.~</code>四个字符之外的所有非字母数字字符进行百分号编码。当然 根据URL的类型不同，有也一部分预留字符不需要进行编码，例如查询的<code>URL</code>中可以包含<code>? /</code>字符，不需要转义。更详细文档的可以查看<a href="http://www.ietf.org/rfc/rfc3986.txt" target="_blank" rel="noopener">RFC 3986</a>。</p><a id="more"></a><h1 id="Swift-URL-Encode"><a href="#Swift-URL-Encode" class="headerlink" title="Swift URL Encode"></a>Swift URL Encode</h1><p><code>addingPercentEncoding(withAllowedCharacters:</code>是iOS7之后出现的新API用于<code>url encode</code>。</p><p>官方对该方法的解释：</p><blockquote><p>// Returns a new string made from the receiver by replacing all characters not in the allowedCharacters set with percent encoded characters. UTF-8 encoding is used to determine the correct percent encoded characters. Entire URL strings cannot be percent-encoded. This method is intended to percent-encode an URL component or subcomponent string, NOT the entire URL string. Any characters in allowedCharacters outside of the 7-bit ASCII range are ignored.  </p></blockquote><p>最后一句Any characters in allowedCharacters outside of the 7-bit ASCII range are ignored.，意思就是说，任何非7-bit ASCII字符搁到allowedCharacters里面也将被忽略，也就是<code>allowedCharacters</code>里面的字符跟7-bit ASCII字符不会被编码。</p><p>换句话说，上面方法在处理的时候会编码url的中的非7-bit ASCII字符，如这些【`#%^{}”[]|\&lt;&gt;】，如果需要忽略之，需要通过.allowedCharacters这个参数指定。</p><p>然而并不是，我们来看一下案例：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> url1 = <span class="string">"http://github.com#aaa?name=中文字符&amp;key=!*'();:@&amp;=+$,/?%#[]"</span></span><br><span class="line"><span class="built_in">print</span>(url1.addingPercentEncoding(withAllowedCharacters: <span class="type">CharacterSet</span>(charactersIn: <span class="string">"#%^&#123;&#125;\"[]|\\&lt;&gt;"</span>))!)</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">%68%74%74%70%3A%2F%2F%67%69%74%68%75%62%2E%63%6F%6D<span class="comment">#%61%61%61%3F%6E%61%6D%65%3D%E4%B8%AD%E6%96%87%E5%AD%97%E7%AC%A6%26%6B%65%79%3D%21%2A%27%28%29%3B%3A%40%26%3D%2B%24%2C%2F%3F%#[]</span></span><br><span class="line">Program ended with <span class="built_in">exit</span> code: 0</span><br></pre></td></tr></table></figure><p>可以看到只有后面的%#[]没有被编码，其余都被编码了，<strong>不是我们之前所理解的“allowedCharacters里面的字符跟7-bit ASCII字符不会被编码”，而是只有allowedCharacters里的字符才不会被编码</strong></p><p>正确的方法：使用<code>inverted</code></p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> url1 = <span class="string">"http://github.com#aaa?name=中文字符&amp;key=!*'();:@&amp;=+$,/?%#[]"</span></span><br><span class="line"><span class="built_in">print</span>(url1.addingPercentEncoding(withAllowedCharacters: <span class="type">CharacterSet</span>(charactersIn: <span class="string">"#%^&#123;&#125;\"[]|\\&lt;&gt;"</span>).inverted)!)</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> url1 = <span class="string">"http://github.com#aaa?name=中文字符&amp;key=!*'();:@&amp;=+$,/?%#[]"</span></span><br><span class="line"><span class="built_in">print</span>(url1.addingPercentEncoding(withAllowedCharacters: CharacterSet(charactersIn: <span class="string">"#%^&#123;&#125;\"[]|\\&lt;&gt;"</span>).inverted)!)</span><br></pre></td></tr></table></figure><p>可以看到，通过集合反转之后得到的结果才是我们想要的，但是此处的意思是反的，就是<strong>对集合进行inverted，表示集合内的字符和非7-bit ASCII字符是需要转码</strong>的，所以我们以后使用这个方法进行转码的时候要从反面进行转码，把想要进行转码的特殊字符写在集合里就好了，注意这里说的是想要转码的特殊字符（<strong>!*‘();:@&amp;=+$,/?%#[]</strong>），中文会被认为是非7-bit ASCII字符会自动转码的。</p><h2 id="CharacterSet"><a href="#CharacterSet" class="headerlink" title="CharacterSet"></a>CharacterSet</h2><p><code>CharacterSet</code>是一个结构体，<code>CharacterSet.urlHostAllowed</code>等预制类型包含了所有不需要被转码的字符，<strong>反过来说就是指明了需要被转码的字符</strong>。<code>CharacterSet</code>类中提供了一些常用的URL转码的类型:</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">CharacterSet</span>.urlHostAllowed: 被转义的字符有  <span class="string">"#%/&lt;&gt;?@\^`&#123;|&#125;</span></span><br><span class="line"><span class="string">CharacterSet.urlPathAllowed: 被转义的字符有  "</span>#%;&lt;&gt;?[\]^`&#123;|&#125;</span><br><span class="line"><span class="type">CharacterSet</span>.urlUserAllowed: 被转义的字符有   <span class="string">"#%/:&lt;&gt;?@[\]^`</span></span><br><span class="line"><span class="string">CharacterSet.urlQueryAllowed: 被转义的字符有  "</span>#%&lt;&gt;[\]^`&#123;|&#125;</span><br><span class="line"><span class="type">CharacterSet</span>.urlPasswordAllowed 被转义的字符有 <span class="string">"#%/:&lt;&gt;?@[\]^`&#123;|&#125;</span></span><br><span class="line"><span class="string">CharacterSet.urlFragmentAllowed 被转义的字符有 "</span>#%&lt;&gt;[\]^`&#123;|&#125;</span><br></pre></td></tr></table></figure><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><h3 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> url1 = <span class="string">"http://github.com?name=中文字符&amp;key=!*'();:@&amp;=+$,/?%#[]"</span></span><br><span class="line"><span class="built_in">print</span>(url1.addingPercentEncoding(withAllowedCharacters: .urlQueryAllowed)!)</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">http://github.com?name=%E4%B8%AD%E6%96%87%E5%AD%97%E7%AC%A6&amp;key=!*<span class="string">'();:@&amp;=+$,/?%25%23%5B%5D</span></span><br><span class="line"><span class="string">Program ended with exit code: 0</span></span><br></pre></td></tr></table></figure><h3 id="解码"><a href="#解码" class="headerlink" title="解码"></a>解码</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> encodeUrl1 = <span class="string">"http://github.com%23aaa?name=%E4%B8%AD%E6%96%87%E5%AD%97%E7%AC%A6&amp;key=!*'();:@&amp;=+$,/?%25%23%5B%5D"</span></span><br><span class="line"><span class="built_in">print</span>(encodeUrl1.removingPercentEncoding!)</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">http://github.com<span class="comment">#aaa?name=中文字符&amp;key=!*'();:@&amp;=+$,/?%#[]</span></span><br><span class="line">Program ended with <span class="built_in">exit</span> code: 0</span><br></pre></td></tr></table></figure><h1 id="URL带有-符号的问题"><a href="#URL带有-符号的问题" class="headerlink" title="URL带有#符号的问题"></a>URL带有#符号的问题</h1><p>#是url中的一个重要组成部分，是跟在url参数之后的的最后一部分，作为一个url的锚点，用于浏览器的定位。</p><p>但是在项目中使用的时候发现#号被转义掉了，前端那边就没有办法正常显示。所以需要其他特殊字符正常转义，除去#号。</p><h2 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h2><p>沿用预制类型，采用insert方法</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> urlStr = <span class="string">"http://test.com/中文/main.html#/help"</span></span><br><span class="line"><span class="keyword">var</span> charSet = <span class="type">CharacterSet</span>.urlQueryAllowed</span><br><span class="line">charSet.insert(charactersIn: <span class="string">"#"</span>)</span><br><span class="line"><span class="keyword">let</span> encodingURL = urlStr.addingPercentEncoding(withAllowedCharacters: .urlQueryAllowed)!</span><br><span class="line"><span class="built_in">print</span>(encodingURL)</span><br></pre></td></tr></table></figure><p>这里采用了预制的，insert会反过来被删除掉</p><blockquote><p>至于insert的原因，可以查看一下以下代码</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="keyword">let</span> url1 = <span class="string">"http://github.com#aaa?name=中文字符&amp;key=!*'();:@&amp;=+$,/?%#[]"</span></span><br><span class="line">&gt; <span class="built_in">print</span>(<span class="string">"-----------------未反转情况-------------------------"</span>)</span><br><span class="line">&gt; <span class="keyword">var</span> s1 = <span class="type">CharacterSet</span>(charactersIn: #<span class="string">"[]"</span>#)</span><br><span class="line">&gt; <span class="built_in">print</span>(url1.addingPercentEncoding(withAllowedCharacters: s1.inverted)!)</span><br><span class="line">&gt; s1.insert(charactersIn: <span class="string">"["</span>)</span><br><span class="line">&gt; <span class="built_in">print</span>(url1.addingPercentEncoding(withAllowedCharacters: s1.inverted)!)</span><br><span class="line">&gt; </span><br><span class="line">&gt; <span class="built_in">print</span>(<span class="string">"-----------------反转情况-------------------------"</span>)</span><br><span class="line">&gt; <span class="keyword">var</span> s2 = <span class="type">CharacterSet</span>(charactersIn: #<span class="string">"[]"</span>#).inverted</span><br><span class="line">&gt; <span class="built_in">print</span>(url1.addingPercentEncoding(withAllowedCharacters: s2)!)</span><br><span class="line">&gt; s2.insert(charactersIn: <span class="string">"["</span>)</span><br><span class="line">&gt; <span class="built_in">print</span>(url1.addingPercentEncoding(withAllowedCharacters: s2)!)</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>输出结果，留意最后的[]符号是否被转义</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt; -----------------未反转情况-------------------------</span><br><span class="line">&gt; http://github.com<span class="comment">#aaa?name=%E4%B8%AD%E6%96%87%E5%AD%97%E7%AC%A6&amp;key=!*'();:@&amp;=+$,/?%#%5B%5D</span></span><br><span class="line">&gt; http://github.com<span class="comment">#aaa?name=%E4%B8%AD%E6%96%87%E5%AD%97%E7%AC%A6&amp;key=!*'();:@&amp;=+$,/?%#%5B%5D</span></span><br><span class="line">&gt; -----------------反转情况-------------------------</span><br><span class="line">&gt; http://github.com<span class="comment">#aaa?name=%E4%B8%AD%E6%96%87%E5%AD%97%E7%AC%A6&amp;key=!*'();:@&amp;=+$,/?%#%5B%5D</span></span><br><span class="line">&gt; http://github.com<span class="comment">#aaa?name=%E4%B8%AD%E6%96%87%E5%AD%97%E7%AC%A6&amp;key=!*'();:@&amp;=+$,/?%#[%5D</span></span><br><span class="line">&gt; Program ended with <span class="built_in">exit</span> code: 0</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>还未找到解释理由</p></blockquote><h2 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h2><p>自定义</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> urlStr = <span class="string">"http://test.com/中文/main.html#/help"</span></span><br><span class="line"><span class="keyword">let</span> encodingURL = urlStr.addingPercentEncoding(withAllowedCharacters: <span class="type">CharacterSet</span>(charactersIn: #<span class="string">""</span>%&lt;&gt;[\]^`&#123;|&#125;<span class="string">"#).inverted)!</span></span><br><span class="line"><span class="string">print(encodingURL)</span></span><br></pre></td></tr></table></figure><h1 id="Json的URL编码"><a href="#Json的URL编码" class="headerlink" title="Json的URL编码"></a>Json的URL编码</h1><p>我公司有的链接需要拼接上一大段的json，里面json还有复杂的&amp;等符号，预制的肯定不够用，只能采用自定义方法：</p><p>所以封装了方法：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">String</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">urlEncoding</span><span class="params">()</span></span> -&gt; <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> toSearchword = (<span class="keyword">self</span> <span class="keyword">as</span> <span class="type">NSString</span>).addingPercentEncoding(withAllowedCharacters: <span class="type">CharacterSet</span>(charactersIn: #<span class="string">"?!@#$^&amp;%*+,:;='"</span>`&lt;&gt;()[]&#123;&#125;/\|<span class="string">"#).inverted)</span></span><br><span class="line"><span class="string">        return toSearchword as String? ?? "</span><span class="string">"</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><p>直接使用即可</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> urlStr = <span class="string">"http://test.com/中文/main.html#/help"</span></span><br><span class="line"><span class="built_in">print</span>(urlStr.urlEncoding())</span><br></pre></td></tr></table></figure><h1 id="题外话"><a href="#题外话" class="headerlink" title="题外话"></a>题外话</h1><h2 id="Swift-5-字符串转义字符处理"><a href="#Swift-5-字符串转义字符处理" class="headerlink" title="Swift 5 字符串转义字符处理"></a>Swift 5 字符串转义字符处理</h2><p>增加了 # 符号，使得写字符串更加简单。</p><p><strong>在字符串中包含 “ 时不必再加 \ </strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//before</span><br><span class="line">let rain = &quot;The is\&quot;new\&quot;string&quot; </span><br><span class="line">//after</span><br><span class="line">let rain = #&quot;The is&quot;new&quot;string&quot;#</span><br></pre></td></tr></table></figure><p><strong>包含 \ 反斜杠也不需要再加转义符</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//before</span></span><br><span class="line"><span class="keyword">let</span> rain = <span class="string">"The is\\new string"</span> </span><br><span class="line"><span class="comment">//after</span></span><br><span class="line"><span class="keyword">let</span> rain = <span class="meta">#"The is \new string"#</span></span><br></pre></td></tr></table></figure><p><strong>由于反斜杠作为字符串中的字符，所以在插入值的时候需要在后面再加个 #</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//before</span></span><br><span class="line"><span class="keyword">let</span> age = <span class="number">26</span></span><br><span class="line"><span class="keyword">let</span> dontpanic = <span class="string">"myAge is \(age)"</span></span><br><span class="line"><span class="comment">// after</span></span><br><span class="line"><span class="keyword">let</span> answer = <span class="number">26</span></span><br><span class="line"><span class="keyword">let</span> dontpanic = <span class="meta">#"myAge is \#(age)"#</span></span><br></pre></td></tr></table></figure><p><strong>当字符串包含 # 时， 前后应用 ## 包裹字符串</strong></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="built_in">str</span> = ##<span class="string">"this is "</span>a<span class="string">"#good ideal"</span>##</span><br></pre></td></tr></table></figure><p><strong>用 #””” 开头 “””#结尾 来表示多行字符串</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> multiline = <span class="comment">#"""</span></span><br><span class="line">The answer to life,</span><br><span class="line">the universe,</span><br><span class="line">and everything is \<span class="comment">#(answer).</span></span><br><span class="line"><span class="string">""</span><span class="string">"#</span></span><br></pre></td></tr></table></figure><p><strong>由于不用反斜杠转义 使得正则表达式更加简洁明了</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//before</span></span><br><span class="line"><span class="keyword">let</span> regex1 = <span class="string">"\\\\[A-Z]+[A-Za-z]+\\.[a-z]+"</span></span><br><span class="line"><span class="comment">//after</span></span><br><span class="line"><span class="keyword">let</span> regex2 = <span class="meta">#"\\[A-Z]+[A-Za-z]+\.[a-z]+"#</span></span><br></pre></td></tr></table></figure><h2 id="Objective-C-url-encode"><a href="#Objective-C-url-encode" class="headerlink" title="Objective-C url encode"></a>Objective-C url encode</h2><p>API调用都是一样的,不过网上流传的比较多的是用的<code>C API</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">NSString *ciphertext = @&quot;saf#*&amp;&quot;;        </span><br><span class="line">NSCharacterSet *set = [[NSCharacterSet characterSetWithCharactersInString:@&quot;!*&apos;();:@&amp;=+$,/?%#[]&quot;] invertedSet];</span><br><span class="line">NSString *resultString = [ciphertext stringByAddingPercentEncodingWithAllowedCharacters: set];</span><br></pre></td></tr></table></figure><p>C API</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">NSString *ciphertext = @<span class="string">"saf#*&amp;"</span>;</span><br><span class="line">NSString *encodedStr = (NSString *)CFBridgingRelease(CFURLCreateStringByAddingPercentEscapes</span><br><span class="line">                                                     (kCFAllocatorDefault,</span><br><span class="line">                                                      (CFStringRef)ciphertext,</span><br><span class="line">                                                      <span class="literal">NULL</span>,</span><br><span class="line">                                                      CFSTR(<span class="string">"!*'();:@&amp;=+$,/?%#[]"</span>),</span><br><span class="line">                                                      kCFStringEncodingUTF8));</span><br></pre></td></tr></table></figure><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://www.jianshu.com/p/c135127a3df2" target="_blank" rel="noopener">https://www.jianshu.com/p/c135127a3df2</a></p><p><a href="https://www.jianshu.com/p/74f7c5bbca50" target="_blank" rel="noopener">https://www.jianshu.com/p/74f7c5bbca50</a></p><p><a href="https://www.hangge.com/blog/cache/detail_1583.html" target="_blank" rel="noopener">https://www.hangge.com/blog/cache/detail_1583.html</a></p><p><a href="https://www.cnblogs.com/luoxiaofu/p/7110011.html" target="_blank" rel="noopener">https://www.cnblogs.com/luoxiaofu/p/7110011.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;在使用WKWebview的时候，通常都离不开URL，一般的符合网络标准的URL没有什么问题，但是在公司开发的时候遇到了一些特殊URL的时候就踩到了URL编码的坑。&lt;/p&gt;
&lt;p&gt;在1994年订制的RFC1738文档中，对字符串中的除了&lt;code&gt;- _ .&lt;/code&gt;之外的所有非字母数字字符都替换成百分号(%)后跟两位十六进制数，十六进制数中字母必须为大写。&lt;/p&gt;
&lt;p&gt;在2005年定义的RFC3986中，将针对&lt;code&gt;- _.~&lt;/code&gt;四个字符之外的所有非字母数字字符进行百分号编码。当然 根据URL的类型不同，有也一部分预留字符不需要进行编码，例如查询的&lt;code&gt;URL&lt;/code&gt;中可以包含&lt;code&gt;? /&lt;/code&gt;字符，不需要转义。更详细文档的可以查看&lt;a href=&quot;http://www.ietf.org/rfc/rfc3986.txt&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;RFC 3986&lt;/a&gt;。&lt;/p&gt;
    
    </summary>
    
      <category term="Ios" scheme="http://hackycy.github.io/categories/Ios/"/>
    
    
      <category term="Ios" scheme="http://hackycy.github.io/tags/Ios/"/>
    
  </entry>
  
  <entry>
    <title>记一次 Vivo Y91 调试APK的坑</title>
    <link href="http://hackycy.github.io/2020/04/14/%E8%AE%B0%E4%B8%80%E6%AC%A1-Vivo-Y91-%E8%B0%83%E8%AF%95APK%E7%9A%84%E5%9D%91/"/>
    <id>http://hackycy.github.io/2020/04/14/记一次-Vivo-Y91-调试APK的坑/</id>
    <published>2020-04-14T06:47:46.000Z</published>
    <updated>2020-04-14T06:48:32.916Z</updated>
    
    <content type="html"><![CDATA[<h1 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h1><p>在项目工作测试途中，发现Vivo Y91的机型却一直出现debug安装运行问题</p><a id="more"></a><h1 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h1><p>1.设置Android Studio，关闭<code>Instant Run</code>。<code>File</code>-&gt;<code>Settings</code>-&gt;<code>BUild,Execution…</code>-&gt;<code>Instant Run</code> , 关闭勾选<code>Enable Instant Run</code><br>2.在你的gradle.properties文件添加一句:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">android.injected.testOnly = false</span><br></pre></td></tr></table></figure><h2 id="其他解决方法（未测试）"><a href="#其他解决方法（未测试）" class="headerlink" title="其他解决方法（未测试）"></a>其他解决方法（未测试）</h2><p>根据每个手机不同，未知也不太一样，比如 vivo x21 是在：设置 -&gt; 更多设置 -&gt; 未知xx管理（记不太清楚了）。</p><p>一加3T前段时间更新了 Android 8.0 ，它的位置在： 设置 -&gt; 应用程序 -&gt; 特殊访问权限 -&gt; 安装未知应用。如下图，打开对应的软件即可。</p><h1 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h1><p>关于开发过程中是否开启 Instant Run，我个人建议还是关闭它，我在开发过程中一直都是关闭着的，因为之前开启它，出现了一些莫名其妙的问题，目前我们的神器 Android Studio 已经优化的很好了，即使重新打包，也浪费不了多少时间。</p><p>关于<code>android.injected.testOnly = false</code>的设置，那是因为我们跑的 run apk都是 debug 版本，也就是测试版本，而 vivo 的一些就不支持这个测试apk（网上有人这样说，经过验证，不假，在找答案的过程中，看到过很多吐槽：vivo x21、Y91不适合做测试机，因为它只认正式包）</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;原因&quot;&gt;&lt;a href=&quot;#原因&quot; class=&quot;headerlink&quot; title=&quot;原因&quot;&gt;&lt;/a&gt;原因&lt;/h1&gt;&lt;p&gt;在项目工作测试途中，发现Vivo Y91的机型却一直出现debug安装运行问题&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="http://hackycy.github.io/categories/Android/"/>
    
    
      <category term="Android" scheme="http://hackycy.github.io/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Android客户端与服务端时间同步方案</title>
    <link href="http://hackycy.github.io/2020/03/20/Android%E5%AE%A2%E6%88%B7%E7%AB%AF%E4%B8%8E%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%97%B6%E9%97%B4%E5%90%8C%E6%AD%A5%E6%96%B9%E6%A1%88/"/>
    <id>http://hackycy.github.io/2020/03/20/Android客户端与服务端时间同步方案/</id>
    <published>2020-03-20T03:50:41.000Z</published>
    <updated>2020-05-12T03:23:55.239Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>最近项目的编写中，接口需要提交精确到秒级的时间戳用作校验。但是仅仅使用<code>System.currentTimeMillis()</code>会面临着本地的时间与服务器时间不一致的问题。那么本文方案能让本地应用时间与服务器时间存在误差范围内保持同步，减少应用出错率。</p><a id="more"></a><h1 id="预备知识"><a href="#预备知识" class="headerlink" title="预备知识"></a>预备知识</h1><ul><li><code>SystemClock.elapsedRealtime()</code> ：手机系统开机时间（包含睡眠时间），用户无法在设置里面修改。</li><li>在必要的时刻获取一下服务器时间，然后记录这个时刻的手机开机时间（elapsedRealtime）</li><li>后续时间获取：<strong>现在服务器时间 = 以前服务器时间 + 现在手机开机时间 - 以前服务器时间的获取时刻的手机开机时间</strong></li><li>利用OkHttp的Interceptor自动同步时间</li></ul><h1 id="TimeUtils编写"><a href="#TimeUtils编写" class="headerlink" title="TimeUtils编写"></a>TimeUtils编写</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> android.os.SystemClock;</span><br><span class="line"><span class="keyword">import</span> android.text.TextUtils;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.blankj.utilcode.util.LogUtils;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> okhttp3.Headers;</span><br><span class="line"><span class="keyword">import</span> okhttp3.Interceptor;</span><br><span class="line"><span class="keyword">import</span> okhttp3.Request;</span><br><span class="line"><span class="keyword">import</span> okhttp3.Response;</span><br><span class="line"><span class="keyword">import</span> okhttp3.internal.http.HttpDate;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">TimeUtils</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 以前服务器时间 - 以前服务器时间的获取时刻的系统启动时间</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">long</span> diffTime = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 是否是服务器时间</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> isServerTime = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取当前时间</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">getServerTime</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!isServerTime) &#123;</span><br><span class="line">            <span class="keyword">return</span> System.currentTimeMillis() / <span class="number">1000</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (diffTime + SystemClock.elapsedRealtime()) / <span class="number">1000</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">calibrationTime</span><span class="params">(<span class="keyword">long</span> lastServerTime)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 记录时间差</span></span><br><span class="line">        diffTime = lastServerTime - SystemClock.elapsedRealtime();</span><br><span class="line">        isServerTime = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">return</span> lastServerTime;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 利用OkHttp的Interceptor自动同步时间</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">TimeSyncInterceptor</span> <span class="keyword">implements</span> <span class="title">Interceptor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> minResponseTime = Long.MAX_VALUE;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Response <span class="title">intercept</span><span class="params">(Chain chain)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">            Request request = chain.request();</span><br><span class="line">            <span class="keyword">long</span> startTime = System.nanoTime();</span><br><span class="line">            Response proceed = chain.proceed(request);</span><br><span class="line">            <span class="keyword">long</span> lastTime = System.nanoTime() - startTime;</span><br><span class="line"></span><br><span class="line">            Headers headers = proceed.headers();</span><br><span class="line">            calibration(lastTime, headers);</span><br><span class="line">            <span class="keyword">return</span> proceed;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">calibration</span><span class="params">(<span class="keyword">long</span> responseTime, Headers headers)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (headers == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果这一次的请求响应时间小于上一次，则更新本地维护的时间</span></span><br><span class="line">            <span class="keyword">if</span> (responseTime &gt;= minResponseTime) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">          <span class="comment">// 网络响应头包含Date字段（世界时间）</span></span><br><span class="line">          <span class="comment">// 利用Interceptor记录每次请求响应时间，如果本次网络操作的时间小于上一次网络操作的时间，则获取Date字段，转换时区后更新本地TimeUtils。</span></span><br><span class="line">            String standardTime = headers.get(<span class="string">"Date"</span>);</span><br><span class="line">            <span class="keyword">if</span> (!TextUtils.isEmpty(standardTime)) &#123;</span><br><span class="line"></span><br><span class="line">                Date parse = HttpDate.parse(standardTime);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (parse != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// 客户端请求过程一般大于比收到响应时间耗时，所以没有简单的除2 加上去，而是直接用该时间</span></span><br><span class="line">                    TimeUtils.calibrationTime(parse.getTime());</span><br><span class="line">                    minResponseTime = responseTime;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>原理就是通过HTTP Header来获取服务器时间（注：时间格式以<a href="https://link.jianshu.com/?t=https%3A%2F%2Ftools.ietf.org%2Fhtml%2Frfc7231%23section-7.1.1.1" target="_blank" rel="noopener">RFC-7231</a>中定义的”HTTP日期”格式来发送）</p><p>在OkHttpClient增加该Utils下的拦截器即可。</p><p>由于项目中只需要精确到秒，而获取的都是精确到毫秒级别，所以TimeUtils下获取的时候做了除以1000处理。可能会存在点误差吧。但是在项目中误差范围不大，还在可接受范围内。</p><p>不足：连接服务器的过程是需要时间的，服务器收到请求时刻的时间与应用收到响应存在一定的时间差，导致误差的存在（误差=服务器发出响应-&gt;到本机收到响应这个时间）。</p><p>但是通过上面的TimeSyncInterceptor每次判断，可以使得误差逐渐降低</p></blockquote><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://blog.csdn.net/qinci/article/details/70666631" target="_blank" rel="noopener">https://blog.csdn.net/qinci/article/details/70666631</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;最近项目的编写中，接口需要提交精确到秒级的时间戳用作校验。但是仅仅使用&lt;code&gt;System.currentTimeMillis()&lt;/code&gt;会面临着本地的时间与服务器时间不一致的问题。那么本文方案能让本地应用时间与服务器时间存在误差范围内保持同步，减少应用出错率。&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="http://hackycy.github.io/categories/Android/"/>
    
    
      <category term="Android" scheme="http://hackycy.github.io/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Android TextView富文本之Html标签</title>
    <link href="http://hackycy.github.io/2020/03/19/Android-TextView%E5%AF%8C%E6%96%87%E6%9C%AC%E4%B9%8BHtml%E6%A0%87%E7%AD%BE/"/>
    <id>http://hackycy.github.io/2020/03/19/Android-TextView富文本之Html标签/</id>
    <published>2020-03-19T03:59:58.000Z</published>
    <updated>2020-05-02T14:25:01.779Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>TextView作为一个我们经常使用到的控件，但是在写一些UI的时候会遇到一些特别的情况，来看一下示例图：</p><a id="more"></a><p><img src="anli.png" alt></p><p>券的价格是需要突出显示的，还有原价也需要显示一个删除线。</p><h1 id="TextView的多样化显示"><a href="#TextView的多样化显示" class="headerlink" title="TextView的多样化显示"></a>TextView的多样化显示</h1><p>如果是显示不同样的大小文本字体颜色可以直接使用SpannableString实现。但是这里使用HTML标签来实现效果。</p><p>例如图上的券后文本，可以使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mTextView.setText(Html.fromHtml(<span class="string">"&lt;small&gt;券后仅&lt;/small&gt;&lt;big&gt; 20 &lt;/big&gt;&lt;small&gt;元&lt;/small&gt;"</span>));</span><br></pre></td></tr></table></figure><p>如果在strings.xml中定义时候需要注意，需要转义HTML标签，不然的话 经过Android处理后 所有的HTML标签都给过滤掉了。需要把所有的“&lt;”用“&lt;”替换，例如： </p><p><code>&lt;string name=&quot;htmlText&quot;&gt;&amp;lt;strong&gt;粗体&amp;lt;/strong&gt;&lt;/string&gt;</code></p><p>如果文本内容比较长， 则转义起来比较麻烦，并且阅读也不太方便，这种情况下可以使用XML的CDATA标记， 如下所示：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">string</span> <span class="attr">name</span>=<span class="string">"discount_price2"</span>&gt;</span>&lt;![CDATA[&lt;small&gt;券后仅&lt;/small&gt;&lt;big&gt; %1$s &lt;/big&gt;&lt;small&gt;元&lt;/small&gt;]]&gt;<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>strings.xml中节点是支持占位符的，如下所示：</p><p><code>&lt;string name=&quot;data&quot;&gt;整数型:%1$d，浮点型：%2$.2f，字符串:%3$s&lt;/string&gt;</code></p><p>其中%后面是占位符的位置，从1开始，</p><p><strong>$ 后面是填充数据的类型</strong></p><ul><li>$d：表示整数型；</li><li>$f ：表示浮点型，其中f前面的.2表示小数的位数</li><li>$s：表示字符串</li></ul><p>然后使用<code>Context.getResources().getString(data, ...format)</code>即可</p></blockquote><p>下面是一些常用的HTML标签。</p><table><thead><tr><th style="text-align:left">Tags</th><th style="text-align:left">Format</th></tr></thead><tbody><tr><td style="text-align:left">b, strong</td><td style="text-align:left">Bold</td></tr><tr><td style="text-align:left">i, em, cite, dfn</td><td style="text-align:left">Italics</td></tr><tr><td style="text-align:left">u</td><td style="text-align:left">Underline</td></tr><tr><td style="text-align:left">sub</td><td style="text-align:left">Subtext</td></tr><tr><td style="text-align:left">sup</td><td style="text-align:left">Supertext</td></tr><tr><td style="text-align:left">big</td><td style="text-align:left">Big</td></tr><tr><td style="text-align:left">small</td><td style="text-align:left">Small</td></tr><tr><td style="text-align:left">tt</td><td style="text-align:left">Monospace</td></tr><tr><td style="text-align:left">h1 … h6</td><td style="text-align:left">Headlines</td></tr><tr><td style="text-align:left">img</td><td style="text-align:left">Image</td></tr><tr><td style="text-align:left">font</td><td style="text-align:left">Font face and color</td></tr><tr><td style="text-align:left">blockquote</td><td style="text-align:left">For longer quotes</td></tr><tr><td style="text-align:left">a</td><td style="text-align:left">Link</td></tr><tr><td style="text-align:left">div, p</td><td style="text-align:left">Paragraph</td></tr><tr><td style="text-align:left">br</td><td style="text-align:left">Linefeed</td></tr></tbody></table><p>中文版：</p><table><thead><tr><th>标签</th><th>说明</th></tr></thead><tbody><tr><td><code>&lt;br&gt;</code></td><td>插入一个换行符，标签是空标签</td></tr><tr><td><code>&lt;p&gt;</code></td><td>定义段落，标签会自动在其前后各添加一个空行</td></tr><tr><td><code>&lt;h1&gt;</code></td><td>h1标题</td></tr><tr><td><code>&lt;h2&gt;</code></td><td>h2标题</td></tr><tr><td><code>&lt;h3&gt;</code></td><td>h3标题</td></tr><tr><td><code>&lt;h4&gt;</code></td><td>h4标题</td></tr><tr><td><code>&lt;h5&gt;</code></td><td>h5标题</td></tr><tr><td><code>&lt;h6&gt;</code></td><td>h6标题</td></tr><tr><td><code>&lt;div&gt;</code></td><td>文档分节</td></tr><tr><td><code>&lt;strong&gt;</code></td><td>把文本定义为语气更强的强调的内容。TextView中表现为文本加粗</td></tr><tr><td><code>&lt;b&gt;</code></td><td>文本加粗</td></tr><tr><td><code>&lt;em&gt;</code></td><td>把文本定义为强调的内容。TextView中表现为斜体文本效果。</td></tr><tr><td><code>&lt;cite&gt;</code></td><td>定义引用，TextView中表现为斜体文本效果</td></tr><tr><td><code>&lt;dfn&gt;</code></td><td>标记那些对特殊术语或短语的定义。TextView中表现为斜体文本效果。</td></tr><tr><td><code>&lt;i&gt;</code></td><td>显示斜体文本效果</td></tr><tr><td><code>&lt;big&gt;</code></td><td>呈现大号字体效果</td></tr><tr><td><code>&lt;small&gt;</code></td><td>呈现小号字体效果</td></tr><tr><td><code>&lt;strike&gt;</code></td><td>定义删除线样式的文字</td></tr><tr><td><code>&lt;font size=&quot;...&quot; color=&quot;...&quot; face=&quot;...&quot;&gt;</code></td><td>规定文本的字体、字体尺寸、字体颜色   color：文本颜色；size：文本大小；face：文本字体</td></tr><tr><td><code>&lt;blockquote&gt;</code></td><td>将<code>&lt;blockquote&gt;</code> 与 <code>&lt;/blockquote&gt;</code>之间的文本从常规文本中分离出来,通常在左、右两边进行缩进，有时使用斜体</td></tr><tr><td><code>&lt;tt&gt;</code></td><td>呈现类似打字机或者等宽的文本效果</td></tr><tr><td><code>&lt;a&gt;</code></td><td>定义超链接。最重要的属性是 href 属性，它指示链接的目标。 href：指示链接的目标</td></tr><tr><td><code>&lt;u&gt;</code></td><td>为文本添加下划线</td></tr><tr><td><code>&lt;sup&gt;</code></td><td>定义上标文本</td></tr><tr><td><code>&lt;sub&gt;</code></td><td>定义下标文本</td></tr><tr><td><code>&lt;img src=&quot;...&quot;&gt;</code></td><td>向网页中嵌入一幅图像。<code>&lt;img&gt;</code>标签并不会在网页中插入图像，而是从网页上链接图像。<code>&lt;img&gt;</code> 标签创建的是被引用图像的占位空间。   src：图像的url；alt：图像的替代文本</td></tr></tbody></table><h1 id="strike标签使用注意"><a href="#strike标签使用注意" class="headerlink" title="strike标签使用注意"></a>strike标签使用注意</h1><p>在使用<code>&lt;strike&gt;</code>时，6.0系统可能会不显示。则需要在代码中使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//添加删除线      </span></span><br><span class="line">tv.getPaint().setFlags(Paint.STRIKE_THRU_TEXT_FLAG);  </span><br><span class="line"><span class="comment">//在代码中设置加粗            </span></span><br><span class="line">tv.getPaint().setFlags(Paint.FAKE_BOLD_TEXT_FLAG);  </span><br><span class="line"><span class="comment">//添加下划线        </span></span><br><span class="line">tv.getPaint().setFlags(Paint.UNDERLINE_TEXT_FLAG);</span><br></pre></td></tr></table></figure><p>要什么效果可以自己在代码中设置，选择不同的 Flags 就行了。</p><h1 id="a标签使用注意"><a href="#a标签使用注意" class="headerlink" title="a标签使用注意"></a>a标签使用注意</h1><p>使用a标签后设置了href属性后，不做任何设置是无法进行点击跳转的，需要TextView解析设置一下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tv.setText(Html.fromHtml(url));<span class="comment">//解析html</span></span><br><span class="line">tv.setMovementMethod(LinkMovementMethod.getInstance());<span class="comment">//设置可点击</span></span><br></pre></td></tr></table></figure><p>或着xml中添加</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">android:autoLink="web"</span><br></pre></td></tr></table></figure><p>这样默认是用浏览器打开a标签里面的链接。</p><p><strong>但是如果要获取到a标签的点击事件和链接的话，那么就要换一个方法：</strong></p><blockquote><p>其他方法基本都要涉及到SpannableString的设置；或是自定义UrlSpan，重写它的onClick方法；有些还要遍历文本寻找以http开头的字符串。但是想要找一个比较简单些的方法，所以用了一下方法实现</p></blockquote><p>而该方法使用参考了LinkMovementMethod来实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> android.content.Context;</span><br><span class="line"><span class="keyword">import</span> android.content.Intent;</span><br><span class="line"><span class="keyword">import</span> android.text.Layout;</span><br><span class="line"><span class="keyword">import</span> android.text.Selection;</span><br><span class="line"><span class="keyword">import</span> android.text.Spannable;</span><br><span class="line"><span class="keyword">import</span> android.text.method.LinkMovementMethod;</span><br><span class="line"><span class="keyword">import</span> android.text.method.MovementMethod;</span><br><span class="line"><span class="keyword">import</span> android.text.style.URLSpan;</span><br><span class="line"><span class="keyword">import</span> android.view.MotionEvent;</span><br><span class="line"><span class="keyword">import</span> android.widget.TextView;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> tv.xianqi.test190629.view.activity.WebViewActivity;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebLinkMethod</span> <span class="keyword">extends</span> <span class="title">LinkMovementMethod</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> WebLinkMethod instance;</span><br><span class="line">    <span class="keyword">private</span> Context context;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">WebLinkMethod</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.context = context;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> MovementMethod <span class="title">getInstance</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>)</span><br><span class="line">            instance = <span class="keyword">new</span> WebLinkMethod(context);</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onTouchEvent</span><span class="params">(TextView widget, Spannable buffer, MotionEvent event)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> action = event.getAction();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (action == MotionEvent.ACTION_UP ||</span><br><span class="line">                action == MotionEvent.ACTION_DOWN) &#123;</span><br><span class="line">            <span class="keyword">int</span> x = (<span class="keyword">int</span>) event.getX();</span><br><span class="line">            <span class="keyword">int</span> y = (<span class="keyword">int</span>) event.getY();</span><br><span class="line"></span><br><span class="line">            x -= widget.getTotalPaddingLeft();</span><br><span class="line">            y -= widget.getTotalPaddingTop();</span><br><span class="line"></span><br><span class="line">            x += widget.getScrollX();</span><br><span class="line">            y += widget.getScrollY();</span><br><span class="line"></span><br><span class="line">            Layout layout = widget.getLayout();</span><br><span class="line">            <span class="keyword">int</span> line = layout.getLineForVertical(y);</span><br><span class="line">            <span class="keyword">int</span> off = layout.getOffsetForHorizontal(line, x);</span><br><span class="line"><span class="comment">//          ClickableSpan[] link = buffer.getSpans(off, off, ClickableSpan.class);</span></span><br><span class="line">            URLSpan[] link = buffer.getSpans(off, off, URLSpan<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">            <span class="keyword">if</span> (link.length != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (action == MotionEvent.ACTION_UP) &#123;</span><br><span class="line"><span class="comment">//                  link[0].onClick(widget);</span></span><br><span class="line"><span class="comment">//                  这里改为我们需要做的动作</span></span><br><span class="line">                    WebViewActivity.startWebViewActivity(context, link[<span class="number">0</span>].getURL());</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (action == MotionEvent.ACTION_DOWN) &#123;</span><br><span class="line">                    Selection.setSelection(buffer,</span><br><span class="line">                            buffer.getSpanStart(link[<span class="number">0</span>]),</span><br><span class="line">                            buffer.getSpanEnd(link[<span class="number">0</span>]));</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                Selection.removeSelection(buffer);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.onTouchEvent(widget, buffer, event);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用时则改用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">textView.setMovementMethodCompat(WebLinkMethod.getInstance(<span class="keyword">this</span>));</span><br></pre></td></tr></table></figure><p>由于页面跳转我们需要用到原页面的上下文，于是修改了构造函数，加入了Context；</p><p>URLSpan是ClickableSpan的子类，实现了getURL()的方法，所以这里要换成它我们才能取到链接地址，link[0]就是我们点击到的超链接字符串，通过link[0].getURL()我们可以获得它的链接地址。</p><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="https://blog.csdn.net/github_37847975/article/details/75425633" target="_blank" rel="noopener">https://blog.csdn.net/github_37847975/article/details/75425633</a></p><p><a href="https://blog.csdn.net/bhadx520/article/details/47433203?depth_1-utm_source=distribute.pc_relevant_right.none-task&amp;utm_source=distribute.pc_relevant_right.none-task" target="_blank" rel="noopener">https://blog.csdn.net/bhadx520/article/details/47433203?depth_1-utm_source=distribute.pc_relevant_right.none-task&amp;utm_source=distribute.pc_relevant_right.none-task</a></p><p><a href="https://blog.csdn.net/ganggang1st/article/details/6804086" target="_blank" rel="noopener">https://blog.csdn.net/ganggang1st/article/details/6804086</a></p><p><a href="https://blog.csdn.net/yulyu/article/details/52244925" target="_blank" rel="noopener">https://blog.csdn.net/yulyu/article/details/52244925</a></p><p><a href="https://www.jianshu.com/p/c4e1aacb9685" target="_blank" rel="noopener">https://www.jianshu.com/p/c4e1aacb9685</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;TextView作为一个我们经常使用到的控件，但是在写一些UI的时候会遇到一些特别的情况，来看一下示例图：&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="http://hackycy.github.io/categories/Android/"/>
    
    
      <category term="Android" scheme="http://hackycy.github.io/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>解决Android Studio——Received close_notify during handshake</title>
    <link href="http://hackycy.github.io/2020/02/18/%E8%A7%A3%E5%86%B3Android-Studio%E2%80%94%E2%80%94Received-close-notify-during-handshake/"/>
    <id>http://hackycy.github.io/2020/02/18/解决Android-Studio——Received-close-notify-during-handshake/</id>
    <published>2020-02-18T04:24:13.000Z</published>
    <updated>2020-02-18T05:58:29.194Z</updated>
    
    <content type="html"><![CDATA[<p><strong>问题ERROR ： Received close_notify during handshake</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">* What went wrong:</span><br><span class="line">A problem occurred configuring root project &apos;NotificationDemo&apos;.</span><br><span class="line">&gt; Could not resolve all artifacts for configuration &apos;:classpath&apos;.</span><br><span class="line">   &gt; Could not download guava.jar (com.google.guava:guava:23.0)</span><br><span class="line">      &gt; Could not get resource &apos;https://jcenter.bintray.com/com/google/guava/guava/23.0/guava-23.0.jar&apos;.</span><br><span class="line">         &gt; Could not GET &apos;https://jcenter.bintray.com/com/google/guava/guava/23.0/guava-23.0.jar&apos;.</span><br><span class="line">            &gt; Received close_notify during handshake</span><br><span class="line">   &gt; Could not download kotlin-reflect.jar (org.jetbrains.kotlin:kotlin-reflect:1.2.0)</span><br><span class="line">      &gt; Could not get resource &apos;https://jcenter.bintray.com/org/jetbrains/kotlin/kotlin-reflect/1.2.0/kotlin-reflect-1.2.0.jar&apos;.</span><br><span class="line">         &gt; Could not GET &apos;https://jcenter.bintray.com/org/jetbrains/kotlin/kotlin-reflect/1.2.0/kotlin-reflect-1.2.0.jar&apos;.</span><br><span class="line">            &gt; Received close_notify during handshake</span><br></pre></td></tr></table></figure><a id="more"></a><p>可能是Jcenter一直连接超时了吧，请求不了，所以查了一下资料，暂时使用国内源即可。</p><blockquote><p>有翻墙应该不会出现该问题，但是最近蓝灯好像又连不上了，真是麻鬼烦的玩意。</p></blockquote><p><strong>解决方法</strong></p><p>在项目的 Gradle 文件里，配置国内源（将 <code>Jcenter()</code>注掉或者删掉，替换成下图两行<code>maven</code>配置）</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">maven&#123;url <span class="string">'http://maven.aliyun.com/nexus/content/groups/public/'</span>&#125;</span><br><span class="line">maven&#123;url <span class="string">"https://jitpack.io"</span>&#125;</span><br></pre></td></tr></table></figure><p>重新 <code>Sync</code> 或者 <code>Rebuild</code>即可</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://blog.csdn.net/w13576267399/article/details/82019359" target="_blank" rel="noopener">https://blog.csdn.net/w13576267399/article/details/82019359</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;问题ERROR ： Received close_notify during handshake&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;* What went wrong:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;A problem occurred configuring root project &amp;apos;NotificationDemo&amp;apos;.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;gt; Could not resolve all artifacts for configuration &amp;apos;:classpath&amp;apos;.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &amp;gt; Could not download guava.jar (com.google.guava:guava:23.0)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &amp;gt; Could not get resource &amp;apos;https://jcenter.bintray.com/com/google/guava/guava/23.0/guava-23.0.jar&amp;apos;.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;         &amp;gt; Could not GET &amp;apos;https://jcenter.bintray.com/com/google/guava/guava/23.0/guava-23.0.jar&amp;apos;.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;gt; Received close_notify during handshake&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &amp;gt; Could not download kotlin-reflect.jar (org.jetbrains.kotlin:kotlin-reflect:1.2.0)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &amp;gt; Could not get resource &amp;apos;https://jcenter.bintray.com/org/jetbrains/kotlin/kotlin-reflect/1.2.0/kotlin-reflect-1.2.0.jar&amp;apos;.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;         &amp;gt; Could not GET &amp;apos;https://jcenter.bintray.com/org/jetbrains/kotlin/kotlin-reflect/1.2.0/kotlin-reflect-1.2.0.jar&amp;apos;.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;gt; Received close_notify during handshake&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="Android" scheme="http://hackycy.github.io/categories/Android/"/>
    
    
      <category term="Android" scheme="http://hackycy.github.io/tags/Android/"/>
    
      <category term="Android Studio" scheme="http://hackycy.github.io/tags/Android-Studio/"/>
    
  </entry>
  
  <entry>
    <title>重学Android之Notification</title>
    <link href="http://hackycy.github.io/2020/02/11/%E9%87%8D%E5%AD%A6Android%E4%B9%8BNotification/"/>
    <id>http://hackycy.github.io/2020/02/11/重学Android之Notification/</id>
    <published>2020-02-11T07:48:37.000Z</published>
    <updated>2020-02-18T05:56:30.332Z</updated>
    
    <content type="html"><![CDATA[<h1 id="什么是通知"><a href="#什么是通知" class="headerlink" title="什么是通知"></a>什么是通知</h1><p>通知是一个可以在应用程序正常的用户界面之外显示给用户的消息。<br>通知发出时，它首先出现在状态栏的通知区域中，用户打开通知抽屉可查看通知详情。通知区域和通知抽屉都是用户可以随时查看的系统控制区域。</p><a id="more"></a><p>各种通知的展现形式如图：</p><p><img src="notificationshow.png" alt></p><h1 id="通知的基础用法"><a href="#通知的基础用法" class="headerlink" title="通知的基础用法"></a>通知的基础用法</h1><h2 id="通知创建方式区别"><a href="#通知创建方式区别" class="headerlink" title="通知创建方式区别"></a>通知创建方式区别</h2><p>随着Android系统不断升级，Notification的创建方式也随之变化，主要变化如下:</p><p><strong>Android 3.0之前</strong></p><p>Android 3.0 (API level 11)之前，使用<code>new Notification()</code>方式创建通知:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">NotificationManager mNotifyMgr = </span><br><span class="line">      (NotificationManager) getSystemService(NOTIFICATION_SERVICE);</span><br><span class="line">PendingIntent contentIntent = PendingIntent.getActivity(</span><br><span class="line">      <span class="keyword">this</span>, <span class="number">0</span>, <span class="keyword">new</span> Intent(<span class="keyword">this</span>, ResultActivity<span class="class">.<span class="keyword">class</span>), 0)</span>;</span><br><span class="line"></span><br><span class="line">Notification notification = <span class="keyword">new</span> Notification(icon, tickerText, when);</span><br><span class="line">notification.setLatestEventInfo(<span class="keyword">this</span>, title, content, contentIntent);</span><br><span class="line"></span><br><span class="line">mNotifyMgr.notify(NOTIFICATIONS_ID, notification);</span><br></pre></td></tr></table></figure><p><strong>Android 3.0 (API level 11)及更高版本</strong></p><p>Android 3.0开始弃用<code>new Notification()</code>方式，改用<code>Notification.Builder()</code>来创建通知:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">NotificationManager mNotifyMgr = </span><br><span class="line">      (NotificationManager) getSystemService(NOTIFICATION_SERVICE);</span><br><span class="line">PendingIntent contentIntent = PendingIntent.getActivity(</span><br><span class="line">      <span class="keyword">this</span>, <span class="number">0</span>, <span class="keyword">new</span> Intent(<span class="keyword">this</span>, ResultActivity<span class="class">.<span class="keyword">class</span>), 0)</span>;</span><br><span class="line"></span><br><span class="line">Notification notification = <span class="keyword">new</span> Notification.Builder(<span class="keyword">this</span>)</span><br><span class="line">            .setSmallIcon(R.drawable.notification_icon)</span><br><span class="line">            .setContentTitle(<span class="string">"My notification"</span>)</span><br><span class="line">            .setContentText(<span class="string">"Hello World!"</span>)</span><br><span class="line">            .setContentIntent(contentIntent)</span><br><span class="line">            .build();<span class="comment">// getNotification()</span></span><br><span class="line"></span><br><span class="line">mNotifyMgr.notify(NOTIFICATIONS_ID, notification);</span><br></pre></td></tr></table></figure><blockquote><p>这里需要注意: <code>build()</code> 是Androdi 4.1(API level 16)加入的，用以替代<code>getNotification()</code>。API level 16开始弃用<code>getNotification()</code></p></blockquote><p><strong>兼容Android 3.0之前的版本</strong></p><p>为了兼容<code>API level 11</code>之前的版本，<code>v4 Support Library</code>中提供了<br> <code>NotificationCompat.Builder()</code>这个替代方法。它与<code>Notification.Builder()</code>类似，二者没有太大区别。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">NotificationManager mNotifyMgr = </span><br><span class="line">      (NotificationManager) getSystemService(NOTIFICATION_SERVICE);</span><br><span class="line">PendingIntent contentIntent = PendingIntent.getActivity(</span><br><span class="line">      <span class="keyword">this</span>, <span class="number">0</span>, new Intent(<span class="keyword">this</span>, ResultActivity<span class="class">.<span class="keyword">class</span>), <span class="type">0);</span></span></span><br><span class="line"></span><br><span class="line">NotificationCompat.Builder mBuilder = </span><br><span class="line">      new NotificationCompat.Builder(<span class="keyword">this</span>)</span><br><span class="line">            .setSmallIcon(R.drawable.notification_icon)</span><br><span class="line">            .setContentTitle(<span class="string">"My notification"</span>)</span><br><span class="line">            .setContentText(<span class="string">"Hello World!"</span>)</span><br><span class="line">            .setContentIntent(contentIntent);</span><br><span class="line"></span><br><span class="line">mNotifyMgr.notify(NOTIFICATIONS_ID, mBuilder.build());</span><br></pre></td></tr></table></figure><blockquote><p><strong>注：除特别说明外，本文将根据 <code>NotificationCompat.Builder()</code> 展开解析，<br><code>Notification.Builder()</code>类似。</strong></p></blockquote><h2 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h2><h3 id="通知的必要属性"><a href="#通知的必要属性" class="headerlink" title="通知的必要属性"></a>通知的必要属性</h3><p>一个通知必须包含以下三项属性:</p><ul><li>小图标，对应 setSmallIcon()</li><li>通知标题，对应 setContentTitle()</li><li>详细信息，对应 setContentText()</li></ul><p>其他属性均为可选项，更多属性方法请参考<a href="https://link.jianshu.com?t=http://developer.android.com/reference/android/support/v4/app/NotificationCompat.Builder.html" target="_blank" rel="noopener">NotificationCompat.Builder</a>。</p><p>尽管其他都是可选的，但一般都会为通知添加至少一个动作(Action)，这个动作可以是跳转到Activity、启动一个Service或发送一个Broadcas等。 通过以下方式为通知添加动作:</p><ul><li>使用PendingIntent</li><li>通过大视图通知的 <code>Action Button</code>，仅支持Android 4.1 (API level 16)及更高版本</li></ul><h3 id="创建一个通知"><a href="#创建一个通知" class="headerlink" title="创建一个通知"></a>创建一个通知</h3><p>1、实例化一个NotificationCompat.Builder对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">NotificationCompat.Builder builderNormal = <span class="keyword">new</span> NotificationCompat.Builder(<span class="keyword">this</span>)</span><br><span class="line">                        .setSmallIcon(R.mipmap.ic_launcher)</span><br><span class="line">                        .setContentTitle(<span class="string">"普通的通知标题"</span>)</span><br><span class="line">                        .setContentText(<span class="string">"普通的通知内容"</span>);</span><br></pre></td></tr></table></figure><p>NotificationCompat.Builder自动设置的默认值:</p><ul><li><strong>priority:</strong> PRIORITY_DEFAULT</li><li><strong>when: </strong>System.currentTimeMillis()</li><li><strong>audio stream: </strong>STREAM_DEFAULT</li></ul><p>2、定义并设置一个通知动作(Action)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Intent secIntent = <span class="keyword">new</span> Intent(<span class="keyword">this</span>, SecActivity<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">PendingIntent secPendingIntent = PendingIntent.getActivity(<span class="keyword">this</span>, <span class="number">0</span>,</span><br><span class="line">        secIntent, PendingIntent.FLAG_UPDATE_CURRENT);</span><br><span class="line">builder.setContentIntent(secPendingIntent);</span><br></pre></td></tr></table></figure><p>PendingIntent 是一种特殊的 Intent ，字面意思可以解释为延迟的 Intent ，用于在某个事件结束后执行特定的 Action 。从上面带 Action 的通知也能验证这一点，当用户点击通知时，才会执行。<br>PendingIntent 是 Android 系统管理并持有的用于描述和获取原始数据的对象的标志(引用)。也就是说，<strong>即便创建该PendingIntent对象的进程被杀死了，这个PendingItent对象在其他进程中还是可用的</strong>。<br>日常使用中的短信、闹钟等都用到了 PendingIntent。</p><p>PendingIntent 主要可以通过以下三种方式获取：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取一个用于启动 Activity 的 PendingIntent 对象</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> PendingIntent <span class="title">getActivity</span><span class="params">(Context context, <span class="keyword">int</span> requestCode, Intent intent, <span class="keyword">int</span> flags)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取一个用于启动 Service 的 PendingIntent 对象</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> PendingIntent <span class="title">getService</span><span class="params">(Context context, <span class="keyword">int</span> requestCode, Intent intent, <span class="keyword">int</span> flags)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取一个用于向 BroadcastReceiver 广播的 PendingIntent 对象</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> PendingIntent <span class="title">getBroadcast</span><span class="params">(Context context, <span class="keyword">int</span> requestCode, Intent intent, <span class="keyword">int</span> flags)</span></span></span><br></pre></td></tr></table></figure><p>PendingIntent 具有以下几种 flag：</p><ul><li><strong>FLAG_CANCEL_CURRENT:</strong>如果当前系统中已经存在一个相同的 PendingIntent 对象，那么就将先将已有的 PendingIntent 取消，然后重新生成一个 PendingIntent 对象。</li><li><strong>FLAG_NO_CREATE:</strong>如果当前系统中不存在相同的 PendingIntent 对象，系统将不会创建该 PendingIntent 对象而是直接返回 null 。</li><li><strong>FLAG_ONE_SHOT:</strong>该 PendingIntent 只作用一次。</li><li><strong>FLAG_UPDATE_CURRENT:</strong>如果系统中已存在该 PendingIntent 对象，那么系统将保留该 PendingIntent 对象，但是会使用新的 Intent 来更新之前 PendingIntent 中的 Intent 对象数据，例如更新 Intent 中的 Extras。</li></ul><p>3、生成<code>Notification</code>对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Notification notificationNormal = builderNormal.build();</span><br></pre></td></tr></table></figure><p>4、使用<code>NotificationManager</code>发送通知</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">NotificationManager mNotificationManager;</span><br><span class="line">mNotificationManager = (NotificationManager) getSystemService(NOTIFICATION_SERVICE);</span><br><span class="line"><span class="comment">// 第一个参数为ID，后续更新通知会使用到</span></span><br><span class="line">mNotificationManager.notify(<span class="number">0</span>, notificationNormal);</span><br></pre></td></tr></table></figure><h3 id="更新通知"><a href="#更新通知" class="headerlink" title="更新通知"></a>更新通知</h3><p>更新通知很简单，只需再次发送相同ID的通知即可，如果之前的通知依然存在则会更新通知属性，如果之前通知不存在则重新创建。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">NotificationCompat.Builder builder = <span class="keyword">new</span> NotificationCompat.Builder(<span class="keyword">this</span>)</span><br><span class="line">        .setSmallIcon(R.mipmap.ic_launcher)</span><br><span class="line">        .setContentTitle(<span class="string">"更新的通知标题"</span>)</span><br><span class="line">        .setContentText(<span class="string">"更新的通知内容"</span>);</span><br><span class="line"></span><br><span class="line">builder.setContentIntent(secPendingIntent);</span><br><span class="line"></span><br><span class="line">Notification notificationUpdate = builder.build();</span><br><span class="line"><span class="comment">// 保证与上述创建的相同ID即可。</span></span><br><span class="line">mNotificationManager.notify(<span class="number">0</span>, notificationUpdate);</span><br></pre></td></tr></table></figure><h3 id="取消通知"><a href="#取消通知" class="headerlink" title="取消通知"></a>取消通知</h3><p>取消通知有如下几种方式:</p><ul><li>点击通知栏的清除按钮，会清除所有可清除的通知</li><li>设置了 setAutoCancel() 或 FLAG_AUTO_CANCEL 的通知，点击该通知时会清除它</li><li>通过 NotificationManager 调用 cancel(int id) 方法清除指定 ID 的通知</li><li>通过 NotificationManager 调用 cancel(String tag, int id) 方法清除指定 TAG 和 ID 的通知</li><li>通过 NotificationManager 调用 cancelAll() 方法清除所有该应用之前发送的通知</li></ul><p>添加<code>setAutoCancel</code>方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">NotificationCompat.Builder builderNormal = <span class="keyword">new</span> NotificationCompat.Builder(<span class="keyword">this</span>)</span><br><span class="line">        .setAutoCancel(<span class="keyword">true</span>)</span><br><span class="line">        .setSmallIcon(R.mipmap.ic_launcher)</span><br><span class="line">        .setContentTitle(<span class="string">"普通的通知标题"</span>)</span><br><span class="line">        .setContentText(<span class="string">"普通的通知内容"</span>);</span><br></pre></td></tr></table></figure><h2 id="通知类型"><a href="#通知类型" class="headerlink" title="通知类型"></a>通知类型</h2><h3 id="大视图通知"><a href="#大视图通知" class="headerlink" title="大视图通知"></a>大视图通知</h3><p>通知有两种视图：普通视图和大视图。</p><p>普通视图：</p><p><img src="normalview.png" alt></p><p>大视图（BigText为例）：</p><p><img src="bigtextview.png" alt></p><p>默认情况下为普通视图，可通过<code>NotificationCompat.Builder.setStyle()</code>设置大视图。</p><blockquote><p>注: 大视图(Big Views)由Android 4.1(API level 16)开始引入，且仅支持Android 4.1及更高版本。</p></blockquote><p>以上图为例:<br>1、构建Action Button的PendingIntent</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Intent dismissIntent = <span class="keyword">new</span> Intent(<span class="keyword">this</span>, PingService<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">                dismissIntent.setAction(<span class="string">"dismiss"</span>);</span><br><span class="line">                PendingIntent p1 = PendingIntent.getService(<span class="keyword">this</span>, <span class="number">0</span>, dismissIntent, PendingIntent.FLAG_UPDATE_CURRENT);</span><br><span class="line"></span><br><span class="line">                Intent snoozeIntent = <span class="keyword">new</span> Intent(<span class="keyword">this</span>, PingService<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">                snoozeIntent.setAction(<span class="string">"snooze"</span>);</span><br><span class="line">                PendingIntent p2 = PendingIntent.getService(<span class="keyword">this</span>, <span class="number">0</span>, snoozeIntent, PendingIntent.FLAG_UPDATE_CURRENT);</span><br></pre></td></tr></table></figure><p>2、构建NotificatonCompat.Builder对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">NotificationCompat.Builder builderBig = <span class="keyword">new</span> NotificationCompat.Builder(<span class="keyword">this</span>)</span><br><span class="line">                        .setSmallIcon(R.mipmap.ic_launcher)</span><br><span class="line">                        .setContentTitle(getString(R.string.title))</span><br><span class="line">                        .setContentText(<span class="string">"简要"</span>)</span><br><span class="line">                        .setDefaults(Notification.DEFAULT_ALL)</span><br><span class="line">  <span class="comment">// 注意该步骤</span></span><br><span class="line">                        .setStyle(<span class="keyword">new</span> NotificationCompat.BigTextStyle().bigText(getString(R.string.content)))</span><br><span class="line">                        .addAction(android.R.drawable.ic_input_delete, <span class="string">"dimiss"</span>, p1)</span><br><span class="line">                        .addAction(android.R.drawable.ic_input_add, <span class="string">"snooze"</span>, p2);</span><br></pre></td></tr></table></figure><p>3、其他步骤与普通视图相同</p><h3 id="进度条通知"><a href="#进度条通知" class="headerlink" title="进度条通知"></a>进度条通知</h3><p><strong>明确进度的进度条</strong></p><p>使用<code>setProgress(max, progress, false)</code>来更新进度。</p><ul><li>max: 最大进度值</li><li>progress: 当前进度</li><li>false: 是否是不明确的进度条</li></ul><h2 id="通知常见属性"><a href="#通知常见属性" class="headerlink" title="通知常见属性"></a>通知常见属性</h2><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://developer.android.com/guide/topics/ui/notifiers/notifications.html" target="_blank" rel="noopener">https://developer.android.com/guide/topics/ui/notifiers/notifications.html</a></p><p><a href="https://developer.android.com/reference/android/app/Notification.html" target="_blank" rel="noopener">https://developer.android.com/reference/android/app/Notification.html</a></p><p><a href="https://www.cnblogs.com/travellife/p/Android-Notification-xiang-jie-yiji-ben-cao-zuo.html" target="_blank" rel="noopener">https://www.cnblogs.com/travellife/p/Android-Notification-xiang-jie-yiji-ben-cao-zuo.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;什么是通知&quot;&gt;&lt;a href=&quot;#什么是通知&quot; class=&quot;headerlink&quot; title=&quot;什么是通知&quot;&gt;&lt;/a&gt;什么是通知&lt;/h1&gt;&lt;p&gt;通知是一个可以在应用程序正常的用户界面之外显示给用户的消息。&lt;br&gt;通知发出时，它首先出现在状态栏的通知区域中，用户打开通知抽屉可查看通知详情。通知区域和通知抽屉都是用户可以随时查看的系统控制区域。&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="http://hackycy.github.io/categories/Android/"/>
    
    
      <category term="Notification" scheme="http://hackycy.github.io/tags/Notification/"/>
    
  </entry>
  
  <entry>
    <title>Android进程保活探讨</title>
    <link href="http://hackycy.github.io/2020/02/04/Android%E8%BF%9B%E7%A8%8B%E4%BF%9D%E6%B4%BB%E6%8E%A2%E8%AE%A8/"/>
    <id>http://hackycy.github.io/2020/02/04/Android进程保活探讨/</id>
    <published>2020-02-04T06:04:19.000Z</published>
    <updated>2020-02-13T09:59:38.183Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>Android 系统为了保持系统运行流畅，在内存吃紧的情况下，会将一些进程 kill ，以释放一部分内存。然而，对于一些（如：IM-QQ 、微信，支付-支付宝等）比较重要、我们希望能及时收到消息的 APP，需要保持进程持续活跃，那么就需要实施一些保活措施来保证进程能够持续存活，即 <strong>Android 进程保活</strong>。</p><a id="more"></a><p><strong>Android 进程拉活包括两个层面：</strong></p><ul><li><p>提供进程优先级，降低进程被杀死的概率</p></li><li><p>在进程被杀死后，进行拉活</p></li></ul><p>在此之前，先来了解下 Android 进程的一些相关概念。</p><h1 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h1><p>默认情况下，同一 APP 的所有组件均运行在相同的进程中，但是也可以根据需要，通过在清单文件中配置来控制某些组件的所属进程。</p><p>内存不足的情况下，Android 系统会选择 kill 某一进程来释放该进程占用的内存，供其它为用户提供更为紧急服务的进程使用。在被关闭的进程中运行的组件也会随着进程的关闭而销毁。</p><p>决定 kill 哪个进程时，Android 系统将权衡所有进程对用户的相对重要程度。例如：相对于托管可见 Activity 的进程而言，更有可能 kill 托管不可见 Activity 的进程。因此，是否终止 kill 某个进程取决于该进程中所运行组件的状态。</p><h1 id="进程的优先级"><a href="#进程的优先级" class="headerlink" title="进程的优先级"></a>进程的优先级</h1><p>Android 系统将尽量长时间地保持应用进程，但为了新建进程或运行更重要的进程，最终需要清除旧进程来回收内存。 为了确定保留或终止哪些进程，系统会根据进程中正在运行的组件以及这些组件的状态，将每个进程放入“重要性层次结构”中。 必要时，系统会首先消除重要性最低的进程，然后是清除重要性稍低一级的进程，依此类推，以回收系统资源。</p><p>进程的重要性，划分5级：</p><ol><li>前台进程 (Foreground process)</li><li>可见进程 (Visible process)</li><li>服务进程 (Service process)</li><li>后台进程 (Background process)</li><li>空进程 (Empty process)</li></ol><p><img src="jinchengyouxianji.jpeg" alt></p><p>前台进程的重要性最高，依次递减，空进程的重要性最低，下面分别来阐述每种级别的进程</p><h2 id="前台进程"><a href="#前台进程" class="headerlink" title="前台进程"></a>前台进程</h2><p>用户当前操作的进程。一个进程满足以下任一条件 ，即视为前台进程：</p><ul><li>托管用户正在交互的 Activity（已调用 onResume() 方法）。</li><li>托管某个 Service ，且 Service 绑定到用户正在交互的 Activity。</li><li>托管正在“前台”运行的 Service（服务已调用startForeground()）。</li><li>托管正在执行生命周期回调的 Service（ onCreate() 、 onStart() 或 onDestory() ）。</li><li>托管正在执行 onReceive() 方法的 BroadcastReceiver。</li></ul><blockquote><p>通常，任意时间的前台进程数据都不多。只有在内存不足以支持它们同时继续运行这一万不得已的情况下，系统才会 kill 它们。</p></blockquote><h2 id="可见进程"><a href="#可见进程" class="headerlink" title="可见进程"></a>可见进程</h2><p>没有任何前台组件、但仍会影响用户在屏幕上所见内容的进程。 如果一个进程满足以下任一条件，即视为可见进程：</p><ul><li>托管不在前台、但仍对用户可见的 Activity（已调用 onPause() 方法）。如：前台 Activity 启动了一个对话框，允许在其后面显示上一个 Activity。</li><li>托管绑定到可见（或前台）的 Activity 的 Service。</li></ul><blockquote><p>可见进程被视为及其重要的进程，除非为了维持所有前台进程同时运行而必须终止，否则系统不会kill这些进程。</p></blockquote><h2 id="服务进程"><a href="#服务进程" class="headerlink" title="服务进程"></a>服务进程</h2><p>正在运行已使用 startService() 方法启动的 Service 且不属于上述两个更高类别进程的进程。</p><blockquote><p>尽管服务进程与用户可见内容没有直接关联，但是它们通常在执行一些用户比较关心的操作（如：在后台播放音乐或从网络下载数据等），因此，除非内部不足以维持所有前台进程和可见进程同时运行，否则系统不会 kill 这些进程。</p></blockquote><h2 id="后台进程"><a href="#后台进程" class="headerlink" title="后台进程"></a>后台进程</h2><p>托管目前对用户不可见的 Activity 的进程（已调用 Activity 的 onStop() 方法）。</p><blockquote><p>后台进程对用户体验没有直接影响，系统可能随时会 kill 它们，以回收内存提供给前台进程、可见进程、服务进程使用。通常会有很多后台进程同时运行，系统将它们保存在 LRU（最近最少使用）列表中，以确保包含用户最近查看的 Activity 的进程最后一个被终止。</p></blockquote><h2 id="空进程"><a href="#空进程" class="headerlink" title="空进程"></a>空进程</h2><p>不包含任何活动组件的进程。</p><blockquote><p>保留这种进程的唯一目的是缓存，以缩短下次在其中运行的组件的启动时间。为使系统总体资源在进程缓存和底层内核缓存之间保持平衡，系统往往会kill这些进程。</p></blockquote><p>根据进程中当前活动的组件的重要程度，Android 系统会将进程评定为可能达到的最高级别。比如，托管服务和可见 Activity 的进程，系统会将其评定为可见进程，而不是服务进程。</p><p>此外，一个进程的级别可能会因为其他进程对其依赖而有所提高，即服务于另一进程的进程其级别不会低于其服务的进程。例如，进程 A 中的 Service 绑定到进程 B 中的组件，则进程 A 始终被视为至少和进程 B 同等级别。</p><p>由于运行 Service 的进程其级别高于托管后台 Activity 的进程，因此在要做长时间后台操作的 Activity 中最好为该操作启动 Service，而不是简单的创建子线程，当操作有可能比 Activity 更持久时更需如此。例如，需要上传较大图片或较大文件的 Activity，应该启动 Service 来执行上传操作，这样，即使 Activity 被销毁，Service 仍能在后台继续执行上传操作。使用 Service 执行较长耗时操作，可以保证不管 Activity 发生什么情况，该操作至少有服务进程的优先级。同理，使用广播接收器时，也当如此。</p><blockquote><p><a href="https://developer.android.com/guide/components/processes-and-threads.html" target="_blank" rel="noopener">https://developer.android.com/guide/components/processes-and-threads.html</a></p></blockquote><h1 id="进程回收策略"><a href="#进程回收策略" class="headerlink" title="进程回收策略"></a>进程回收策略</h1><p>Android 系统回收进程内存的机制叫<code>Low Memory Killer</code>机制，是一种根据 <code>oom_adj</code>阈值级别触发相应力度的内存回收的机制。<code>oom_adj</code> 代表进程的优先级，数值越高，优先级越低，越容易被杀死。</p><p><strong>Andorid的 Low Memory Killer 是在标准的linux lernel的 OOM 基础上修改而来的一种内存管理机制。当系统内存不足时，杀死不必要的进程释放其内存。不必要的进程的选择根据有2个：oom_adj和占用的内存的大小。oom_adj 代表进程的优先级，数值越高，优先级越低，越容易被杀死；对应每个oom_adj都可以有一个空闲进程的阀值。</strong></p><p><strong>Android Kernel每隔一段时间会检测当前空闲内存是否低于某个阀值。假如是，则杀死oom_adj最大的不必要的进程，如果有多个，就根据 oom_score_adj 去杀死进程，直到内存恢复低于阀值的状态。</strong></p><p>关于 oom_adj 的说明如下：</p><p><img src="oomadj.jpeg" alt></p><blockquote><p>其中红色部分代表比较容易被杀死的 Android 进程（OOM_ADJ&gt;=4）,绿色部分表示不容易被杀死的 Android 进程，其他表示非 Android 进程（纯 Linux 进程）。</p><p>在 Lowmemorykiller 回收内存时会根据进程的级别优先杀死 OOM_ADJ 比较大的进程，对于优先级相同的进程则进一步受到进程所占内存和进程存活时间的影响。</p><p><strong>普通app进程的oom_adj&gt;=0,系统进程的oom_adj才可能&lt;0</strong></p><p>查看当前应用进程adj值命令为：<code>cat /proc/进程id/oom_adj</code></p><p>查看当前进程id：<code>ps | grep PackageName</code></p></blockquote><p><strong>LowMemoryKiller 的阈值的设定，主要保存在2个文件之中，分别是:</strong></p><ul><li><code>/sys/module/lowmemorykiller/parameters/adj</code></li><li><code>/sys/module/lowmemorykiller/parameters/minfree</code></li></ul><p>adj保存着当前系统杀进程的等级，minfree则是保存着对应的内存阀值。</p><p>在API为26的Nexus模拟器下打印输出的值为：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">generic_x86:/ <span class="comment"># cat /sys/module/lowmemorykiller/parameters/minfree                                                                                                                                        </span></span><br><span class="line">18432,23040,27648,32256,36864,46080</span><br><span class="line">generic_x86:/ <span class="comment"># cat /sys/module/lowmemorykiller/parameters/adj                                                                                                                                            </span></span><br><span class="line">0,100,200,300,900,906</span><br></pre></td></tr></table></figure><p>内存阀值在不同手机上不一样，一旦低于该值，Android便会杀死对应优先级的进程。<strong>例如上述手机中，当可用内存小于72MB（18432）时，就杀死前台进程；当可用内存小于180MB（46080）时，则杀死空进程。即跟照上述打印顺序依次杀死为<code>前台进程 -&gt; 可见进程 -&gt; 服务进程 -&gt; 后台进程 -&gt; Content Provider -&gt; 空进程</code>。</strong></p><blockquote><p>阀值单位为page，即4kb。</p></blockquote><p><strong>Android 手机中进程被杀死可能有如下情况：</strong></p><p><img src="killevent.jpg" alt></p><p>综上，可以得出减少进程被杀死概率无非就是想办法提高进程优先级，减少进程在内存不足等情况下被杀死的概率。</p><h1 id="提升进程优先级的方案"><a href="#提升进程优先级的方案" class="headerlink" title="提升进程优先级的方案"></a>提升进程优先级的方案</h1><h2 id="利用-Activity-提升权限"><a href="#利用-Activity-提升权限" class="headerlink" title="利用 Activity 提升权限"></a>利用 Activity 提升权限</h2><p>通过监控手机锁屏，在屏幕锁屏时启动1个像素的Activity，在用户解锁时将Activity销毁掉。</p><p>进程的优先级在屏幕锁屏时间由4提升为最高优先级0。</p><p>主要解决第三方应用及系统管理工具在检测到锁屏事件后一段时间（一般为5分钟以内）内会杀死后台进程，已达到省电的目的问题。<strong>但是在Android P之后后台都作了限制后该方案无效。测试7.0前的版本稳定。但是不建议使用。没有销毁掉1像素Activity时候会产生严重的体验问题。</strong></p><h3 id="具体方案实现"><a href="#具体方案实现" class="headerlink" title="具体方案实现"></a>具体方案实现</h3><p>自定义Activity，并且设置Activity大小为1像素。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SinglePixelActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG = SinglePixelActivity<span class="class">.<span class="keyword">class</span>.<span class="title">getSimpleName</span>()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(@Nullable Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        Window window = getWindow();</span><br><span class="line">        window.setGravity(Gravity.LEFT | Gravity.TOP);</span><br><span class="line">        WindowManager.LayoutParams layoutParams = window.getAttributes();</span><br><span class="line">        layoutParams.x = <span class="number">0</span>;</span><br><span class="line">        layoutParams.y = <span class="number">0</span>;</span><br><span class="line">        layoutParams.width = <span class="number">1</span>;</span><br><span class="line">        layoutParams.height = <span class="number">1</span>;</span><br><span class="line">        window.setAttributes(layoutParams);</span><br><span class="line">        <span class="comment">//setting</span></span><br><span class="line">        KeepManager.getInstance().setSinglePixelActivity(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDestroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 作一些唤醒服务动作</span></span><br><span class="line">        <span class="keyword">super</span>.onDestroy();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其次，从 AndroidManifest 中通过如下属性，排除 Activity 在 RecentTask 中的显示：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">activity</span> </span></span><br><span class="line"><span class="tag">           <span class="attr">android:name</span>=<span class="string">".onepixel.SinglePixelActivity"</span> </span></span><br><span class="line"><span class="tag">           <span class="attr">android:configChanges</span>=<span class="string">"keyboardHidden|orientation|screenSize|navigation|keyboard"</span></span></span><br><span class="line"><span class="tag"> <span class="attr">android:excludeFromRecents</span>=<span class="string">"true"</span></span></span><br><span class="line"><span class="tag">           <span class="attr">android:exported</span>=<span class="string">"false"</span></span></span><br><span class="line"><span class="tag">           <span class="attr">android:finishOnTaskLaunch</span>=<span class="string">"false"</span></span></span><br><span class="line"><span class="tag">           <span class="attr">android:launchMode</span>=<span class="string">"singleInstance"</span></span></span><br><span class="line"><span class="tag">           <span class="attr">android:theme</span>=<span class="string">"@style/SinglePixelActivityStyle"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">activity</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p><strong>讲解一下：</strong></p><ul><li><strong>android:launchMode属性：</strong>用于指定activity的启动模式，总共分为四种，即：<ul><li><strong>standar模式</strong>，每次启动activity都会创建其实例，并加入到任务栈的栈顶；</li><li><strong>singleTop模式</strong>，每次启动activity如果栈顶时该activity则无需创建，其余情况都要创建该activity的实例；</li><li><strong>singleTask模式</strong>，如果被启动的activity的实例存在栈中，则不需要创建，只需要把此activity加入到栈顶，并把该activity以上的activity实例全部pop；</li><li><strong>singleInstance模式</strong>：将创建的activity实例放入单独的栈中，该栈只能存储这个实例，且是作为共享实例存在。</li></ul></li><li><strong>android:configChanges属性：</strong>用于捕获手机状态的改变，即当手机状态(如切换横竖屏、屏幕大小)改变时会保存当前活动状态重启Activity，由于SinglePixelActivity肩负着保活的特殊使命，这里使用<strong>android:configChanges</strong>属性：防止Activity重启，它只是调用了<strong>onConfigurationChanged(Configuration newConfig)</strong>来通知手机状态的改变；</li><li><strong>android:excludeFromRecents属性：</strong>用于控制SinglePixelActivity不在最近任务列表中显示；</li><li><strong>android:finishOnTaskLaunch属性：</strong>用于标记当用户再起启动应用(TASK)时是否关闭已经存在的Activity的实例，false表示不关闭；</li><li><strong>android:theme属性：</strong>用于指定Activity显示主题，这里我们自定义主题SingleActivityStyle。</li></ul></blockquote><p>设置Activity样式。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 对1像素Activity进行特殊处理 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">name</span>=<span class="string">"SinglePixelActivityStyle"</span>&gt;</span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">"android:windowBackground"</span>&gt;</span>@android:color/transparent<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">"android:windowIsTranslucent"</span>&gt;</span>true<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">"android:windowFrame"</span>&gt;</span>@null<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">"android:windowNoTitle"</span>&gt;</span>true<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">"android:windowIsFloating"</span>&gt;</span>true<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">"android:windowContentOverlay"</span>&gt;</span>@null<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">"android:backgroundDimEnabled"</span>&gt;</span>false<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">"android:windowAnimationStyle"</span>&gt;</span>@null<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">"android:windowDisablePreview"</span>&gt;</span>true<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">"android:windowNoDisplay"</span>&gt;</span>false<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure><p>自定义广播接收者。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ScreenBroadcastReceiver</span> <span class="keyword">extends</span> <span class="title">BroadcastReceiver</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onReceive</span><span class="params">(Context context, Intent intent)</span> </span>&#123;</span><br><span class="line">        String action = intent.getAction();</span><br><span class="line">      <span class="comment">// Activity 启动与销毁时机的控制：</span></span><br><span class="line">        <span class="keyword">if</span> (Intent.ACTION_SCREEN_OFF.equals(action)) &#123;</span><br><span class="line">            KeepManager.getInstance().startSinglePixelActivity(context);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (Intent.ACTION_SCREEN_ON.equals(action) || Intent.ACTION_USER_PRESENT.equals(action)) &#123;</span><br><span class="line">            KeepManager.getInstance().finishSinglePixelActivity();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>管理类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ScreenManager</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG = ScreenManager<span class="class">.<span class="keyword">class</span>.<span class="title">getSimpleName</span>()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> ScreenManager mInstance = <span class="keyword">new</span> ScreenManager();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ScreenBroadcastReceiver mKeepBroadcastReceiver;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> WeakReference&lt;Activity&gt; mActivity;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ScreenManager <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mInstance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerKeepReceiver</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        mKeepBroadcastReceiver = <span class="keyword">new</span> ScreenBroadcastReceiver();</span><br><span class="line">        IntentFilter filter = <span class="keyword">new</span> IntentFilter();</span><br><span class="line">        filter.addAction(Intent.ACTION_SCREEN_OFF);</span><br><span class="line">        filter.addAction(Intent.ACTION_SCREEN_ON);</span><br><span class="line">        context.registerReceiver(mKeepBroadcastReceiver, filter);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unregisterKeepReceiver</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (mKeepBroadcastReceiver != <span class="keyword">null</span>) &#123;</span><br><span class="line">            context.unregisterReceiver(mKeepBroadcastReceiver);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 持有SinglePixelActivity的弱引用</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> activity</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSinglePixelActivity</span><span class="params">(Activity activity)</span> </span>&#123;</span><br><span class="line">        mActivity = <span class="keyword">new</span> WeakReference&lt;&gt;(activity);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 启动SinglePixelActivity</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startSinglePixelActivity</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        Intent intent = <span class="keyword">new</span> Intent(context, SinglePixelActivity<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);</span><br><span class="line">        context.startActivity(intent);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 结束SinglePixelActivity</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">finishSinglePixelActivity</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (mActivity != <span class="keyword">null</span>) &#123;</span><br><span class="line">            Activity activity = mActivity.get();</span><br><span class="line">            <span class="keyword">if</span> (activity != <span class="keyword">null</span>) &#123;</span><br><span class="line">                activity.finish();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在需要使用的地方使用，如MainActivity：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">        <span class="comment">// 1像素保活</span></span><br><span class="line">        activeSinglePixelActivity();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDestroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onDestroy();</span><br><span class="line">        ScreenManager.getInstance().unregisterKeepReceiver(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">activeSinglePixelActivity</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ScreenManager.getInstance().registerKeepReceiver(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="利用前台-Service-提升权限"><a href="#利用前台-Service-提升权限" class="headerlink" title="利用前台 Service 提升权限"></a>利用前台 Service 提升权限</h2><p>Android 中 Service 的优先级为4，通过 setForeground 接口可以将后台 Service 设置为前台 Service，使进程的优先级由4提升为2，从而使进程的优先级仅仅低于用户当前正在交互的进程，与可见进程优先级一致，使进程被杀死的概率大大降低。</p><p>从 Android2.3 开始调用 setForeground 将后台 Service 设置为前台 Service 时，必须在系统的通知栏发送一条通知，也就是前台 Service 与一条可见的通知时绑定在一起的。</p><p>对于不需要常驻通知栏的应用来说，该方案虽好，但却是用户感知的，无法直接使用。</p><p>对于 API level &lt; 18 ：调用startForeground(ID， new Notification())，发送空的Notification ，图标则不会显示。对于 API level &gt;= 18：在需要提优先级的service A启动一个InnerService，两个服务同时startForeground，且绑定同样的 ID。Stop 掉InnerService ，这样通知栏图标即被移除。这方案实际利用了Android前台service的漏洞。</p><p><strong>该方案适用范围：7.1.1系统以下</strong>，8.0后的系统通知栏API的变更以及前台服务的变更导致通知栏常驻，造成用户感知。</p><h3 id="具体方案实现-1"><a href="#具体方案实现-1" class="headerlink" title="具体方案实现"></a>具体方案实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProcessService</span> <span class="keyword">extends</span> <span class="title">Service</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String TAG = ProcessService<span class="class">.<span class="keyword">class</span>.<span class="title">getSimpleName</span>()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> PROCESS_SERVICE_ID = -<span class="number">10001</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IBinder <span class="title">onBind</span><span class="params">(Intent intent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException(<span class="string">"Not yet implemented"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">onStartCommand</span><span class="params">(Intent intent, <span class="keyword">int</span> flags, <span class="keyword">int</span> startId)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (Build.VERSION.SDK_INT &lt; <span class="number">18</span>) &#123;</span><br><span class="line">            <span class="comment">// API &lt; 18 ，此方法能有效隐藏Notification上的图标</span></span><br><span class="line">            startForeground(PROCESS_SERVICE_ID, <span class="keyword">new</span> Notification());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Intent innerIntent = <span class="keyword">new</span> Intent(<span class="keyword">this</span>, ProcessInnerService<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">            startService(innerIntent);</span><br><span class="line">            startForeground(PROCESS_SERVICE_ID, <span class="keyword">new</span> Notification());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> START_STICKY;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 给 API &gt;= 18 的平台上用的保活手段</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ProcessInnerService</span> <span class="keyword">extends</span> <span class="title">Service</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Nullable</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> IBinder <span class="title">onBind</span><span class="params">(Intent intent)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException(<span class="string">"Not yet implemented"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">onStartCommand</span><span class="params">(Intent intent, <span class="keyword">int</span> flags, <span class="keyword">int</span> startId)</span> </span>&#123;</span><br><span class="line">            startForeground(PROCESS_SERVICE_ID, <span class="keyword">new</span> Notification());</span><br><span class="line">            stopSelf();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">super</span>.onStartCommand(intent, flags, startId);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="进程死后拉活的方案"><a href="#进程死后拉活的方案" class="headerlink" title="进程死后拉活的方案"></a>进程死后拉活的方案</h1><h2 id="利用系统广播拉活"><a href="#利用系统广播拉活" class="headerlink" title="利用系统广播拉活"></a>利用系统广播拉活</h2><p>在发生特定系统事件时，系统会发出响应的广播，通过在 AndroidManifest 中“静态”注册对应的广播监听器，即可在发生响应事件时拉活。</p><p>常用的用于拉活的广播事件包括：</p><p><img src="staticbroadcast.webp" alt></p><p>适用于全部Android平台。但存在如下几个缺点：</p><p>1） 广播接收器被管理软件、系统软件通过“自启管理”等功能禁用的场景无法接收到广播，从而无法自启。</p><p>2） 系统广播事件不可控，只能保证发生事件时拉活进程，但无法保证进程挂掉后立即拉活。</p><blockquote><p>Google已经开始意识到这些问题，所以在最新的Android N取消了 ACTION_NEW_PICTURE（拍照），ACTION_NEW_VIDEO（拍视频），CONNECTIVITY_ACTION（网络切换）等三种广播，无疑给了很多app沉重的打击。</p></blockquote><p>因此，该方案主要作为备用手段。</p><h2 id="利用第三方应用广播拉活"><a href="#利用第三方应用广播拉活" class="headerlink" title="利用第三方应用广播拉活"></a>利用第三方应用广播拉活</h2><p><strong>利用不同的app进程使用广播来进行相互唤醒。举个3个比较常见的场景：</strong></p><ul><li>场景1：接入第三方SDK也会唤醒相应的app进程，如微信sdk会唤醒微信，支付宝sdk会唤醒支付宝。由此发散开去，就会直接触发了下面的 场景3；</li><li>场景2：假如你手机里装了支付宝、淘宝、天猫、UC等阿里系的app，那么你打开任意一个阿里系的app后，有可能就顺便把其他阿里系的app给唤醒了。（只是拿阿里打个比方，其实BAT系都差不多）。</li></ul><p>也可以通过反编译第三方 Top 应用，如：手机QQ、微信、支付宝、UC浏览器等，以及友盟、信鸽、个推等 SDK，找出它们外发的广播，在应用中进行监听，这样当这些应用发出广播时，就会将我们的应用拉活。</p><p>该方案的有效程度除与系统广播一样的因素外，主要受如下因素限制：</p><p>1） 反编译分析过的第三方应用的多少</p><p>2） 第三方应用的广播属于应用私有，当前版本中有效的广播，在后续版本随时就可能被移除或被改为不外发。</p><p>这些因素都影响了拉活的效果。</p><h2 id="利用系统Service机制拉活"><a href="#利用系统Service机制拉活" class="headerlink" title="利用系统Service机制拉活"></a>利用系统Service机制拉活</h2><p>将 Service 设置为 START_STICKY，利用系统机制在 Service 挂掉后自动拉活：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">onStartCommand</span><span class="params">(Intent intent, <span class="keyword">int</span> flags, <span class="keyword">int</span> startId)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> START_STICKY;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是在以下两种情况无法拉活：</p><ol><li>Service 第一次被异常杀死后会在5秒内重启，第二次被杀死会在10秒内重启，第三次会在20秒内重启，一旦在短时间内 Service 被杀死达到5次，则系统不再拉起。</li><li>进程被取得 Root 权限的管理工具或系统工具通过 forestop 停止掉，无法重启。</li></ol><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://mp.weixin.qq.com/s/OXiFQNTyCHpqSP6B9HOiHw" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/OXiFQNTyCHpqSP6B9HOiHw</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;Android 系统为了保持系统运行流畅，在内存吃紧的情况下，会将一些进程 kill ，以释放一部分内存。然而，对于一些（如：IM-QQ 、微信，支付-支付宝等）比较重要、我们希望能及时收到消息的 APP，需要保持进程持续活跃，那么就需要实施一些保活措施来保证进程能够持续存活，即 &lt;strong&gt;Android 进程保活&lt;/strong&gt;。&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="http://hackycy.github.io/categories/Android/"/>
    
    
      <category term="进程保活" scheme="http://hackycy.github.io/tags/%E8%BF%9B%E7%A8%8B%E4%BF%9D%E6%B4%BB/"/>
    
  </entry>
  
  <entry>
    <title>重学Android之Handler</title>
    <link href="http://hackycy.github.io/2020/02/02/%E9%87%8D%E5%AD%A6Android%E4%B9%8BHandler/"/>
    <id>http://hackycy.github.io/2020/02/02/重学Android之Handler/</id>
    <published>2020-02-02T06:09:03.000Z</published>
    <updated>2020-02-04T03:49:19.333Z</updated>
    
    <content type="html"><![CDATA[<p><code>Handler</code> 是 <code>Android</code> 开发过程中非常非常常见的东西。它通常被我们用来做主线程与子线程之间的通信工具，而 Handler 作为 Android 中消息机制的重要一员也确实给我们的开发带来了极大的便利。</p><a id="more"></a><h1 id="重识Handler"><a href="#重识Handler" class="headerlink" title="重识Handler"></a>重识Handler</h1><p>我们可以使用 Handler <strong>发送并处理</strong>与一个线程关联的 Message 和 Runnable 。（注意：<strong>Runnable 会被封装进一个 Message，所以它本质上还是一个 Message</strong> ）</p><p>每个 Handler 都会跟一个线程绑定，并与该线程的 MessageQueue 关联在一起，从而实现消息的管理以及线程间通信。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">android.os.Handler handler = <span class="keyword">new</span> Handler()&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(<span class="keyword">final</span> Message msg)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//这里接受并处理消息</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//发送消息</span></span><br><span class="line">handler.sendMessage(message);</span><br><span class="line">handler.post(runnable);</span><br></pre></td></tr></table></figure><p>实例化一个 Handler 重写 <code>handleMessage</code> 方法 ，然后在需要的时候调用它的 <code>send</code> 以及 <code>post</code> <strong>系列方法</strong>就可以了，非常简单易用，并且支持延时消息。</p><p><strong>一些常用的方法如下</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">sendMessage(Message msg)</span><br><span class="line">sendMessageDelayed(Message msg, <span class="keyword">long</span> uptimeMillis)</span><br><span class="line">post(Runnable r)</span><br><span class="line">postDelayed(Runnable r, <span class="keyword">long</span> uptimeMillis)</span><br><span class="line">sendMessageAtTime(Message msg,<span class="keyword">long</span> when)</span><br><span class="line">  </span><br><span class="line">sendEmptyMessage(<span class="keyword">int</span> what)</span><br><span class="line">sendEmptyMessageDelayed(<span class="keyword">int</span> what, <span class="keyword">long</span> uptimeMillis)</span><br><span class="line">sendEmptyMessageAtTime(<span class="keyword">int</span> what, <span class="keyword">long</span> when)</span><br></pre></td></tr></table></figure><h1 id="Looper、Handler、MessageQueue与Message的关系与相关概念"><a href="#Looper、Handler、MessageQueue与Message的关系与相关概念" class="headerlink" title="Looper、Handler、MessageQueue与Message的关系与相关概念"></a>Looper、Handler、MessageQueue与Message的关系与相关概念</h1><h2 id="Android消息处理机制"><a href="#Android消息处理机制" class="headerlink" title="Android消息处理机制"></a>Android消息处理机制</h2><p>什么是Android消息处理机制？</p><p><strong>“消息”</strong>是windows运行机制中一个基本而又重要的概念。<strong>消息</strong>是一个<strong>报告事件发生的通知</strong>，<strong>消息驱动</strong>是围绕消息的产生与处理展开的，并依靠<strong>消息循环机制</strong>来实现（百度百科）。与Windows系统一样，Android也是<strong>消息驱动型</strong>的系统。引用一下消息驱动机制的四要素：</p><ul><li><p>接收消息的“消息队列”</p></li><li><p>阻塞式地从消息队列中接收消息并进行处理的“线程”</p></li><li><p>可发送的“消息的格式”</p></li><li><p>“消息发送函数”</p></li></ul><p>与之对应，Android系统中对应实现了：</p><ul><li>接收消息的“消息队列” ——　<strong>MessageQueue</strong></li><li>阻塞式地从消息队列中接收消息并进行处理的“线程” ——　<strong>Thread+Looper</strong></li><li>可发送的“消息的格式” ——　<strong>Message</strong></li><li>“消息发送函数”——　<strong>Handler的post()和sendMessage()</strong></li></ul><p>Android有大量的消息驱动方式来进行交互，比如Android的四大组件——<strong>Activity, Service, Broadcast, ContentProvider</strong>的启动过程的交互，都离不开消息机制。</p><h2 id="Handler"><a href="#Handler" class="headerlink" title="Handler"></a>Handler</h2><p>Handler是Android消息机制的上层接口。<strong>Handler并不是专门用来更新UI的，只是开发者常常用它来更新UI</strong>。Handler的主要用于<strong>同一个进程间的线程通信</strong>，Handler用于更新UI的时候是<strong>“子线程与主线程通信”；当然，Handler也可以用于子线程之间通信。</strong></p><p>Handler的消息机制主要是就指“Handler的运行机制”，Handler的运行机制时需要底层的<strong>MessageQueue和Looper</strong>支持的。</p><h2 id="MessageQueue"><a href="#MessageQueue" class="headerlink" title="MessageQueue"></a>MessageQueue</h2><p>MessageQueue翻译过来是”消息队列”的意思，实际上它内部的数据结构不是队列，而是<strong>单向链表</strong>；MessageQueue中储存了大量的<strong>消息</strong>，由于<strong>一个线程同一时间只能处理一条消息，所以我们建了一个链表，将我们需要处理的消息按顺序储存起来，然后一项一项的交给需要的线程处理</strong>，这就是MessageQueue存在的价值。</p><h2 id="Looper"><a href="#Looper" class="headerlink" title="Looper"></a>Looper</h2><p>Looper和MessageQueue的消息就像水泵和井(里边装的是水)的关系一样，我们有了消息(水)，但是为了把水从井中抽取出来(循环起来)，我们得有一个水泵作为<strong>动力</strong>，这个动力就是Looper。</p><p>如果我们在一个线程中调用<code>Looper.prepare()...Looper.loop()</code>，那么你的线程就成功升级为了一个<strong>Looper线程</strong>，这意味着<strong>你的线程有了一个消息泵(Looper)和一个消息队列(MessageQueue),此时你就可以调用Handler来进行线程间的通信了。</strong></p><p>我们应用的UI线程也就是主线程，在应用启动的时候，系统会自动初始化一个Looper，也就是说，我们的UI线程默认是Looper线程。这也就是为什么主线程中直接调用Handler没什么事，但是再子线程中创建Handler需要手动调用<code>Looper.prepare()...Looper.loop()</code>的和原因。</p><h2 id="Message"><a href="#Message" class="headerlink" title="Message"></a>Message</h2><p>Message也就是消息，井中的水。一个Message包括了消息类型(what),消息内容(arg1,arg2),发送它的Handler(target),Runnable回调接口等：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span> what;        <span class="comment">//数据类型</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span> arg1;        <span class="comment">//简单的整数值</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span> arg2;        <span class="comment">//简单的整数值可以直接发送，是一种替代setData（Bundle）的低成本方案，更加省资源</span></span><br><span class="line"><span class="keyword">public</span> Object obj;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*package*/</span> <span class="keyword">int</span> flags;</span><br><span class="line"><span class="comment">/*package*/</span> <span class="keyword">long</span> when;          <span class="comment">//Handler发送一个消息之后，返回此消息的目标交付时间（以毫秒为单位）。</span></span><br><span class="line"><span class="comment">/*package*/</span> Bundle data;        <span class="comment">//Bundle可以携带更复杂的数据类型</span></span><br><span class="line"><span class="comment">/*package*/</span> Handler target;     <span class="comment">//哪个Handler发送的消息</span></span><br><span class="line"><span class="comment">/*package*/</span> Runnable callback;  <span class="comment">//回调方法</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//可以看到，Message带了一个指向一下个节点的链，也就是说，MessageQueue内部维护的实际上是一个链表</span></span><br><span class="line"><span class="comment">/*package*/</span> Message next;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object sPoolSync = <span class="keyword">new</span> Object();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Message sPool;       <span class="comment">//消息池</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> sPoolSize = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_POOL_SIZE = <span class="number">50</span>;    <span class="comment">//消息池的最大容量</span></span><br></pre></td></tr></table></figure><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>Handler 的背后有着 Looper 以及 MessageQueue 的协助，三者通力合作，分工明确。</p><ul><li><strong>Message</strong>：消息分为硬件产生的消息(如按钮、触摸)和软件生成的消息；</li><li><strong>MessageQueue</strong>：消息队列的主要功能向消息池投递消息(<code>MessageQueue.enqueueMessage</code>)和取走消息池的消息(<code>MessageQueue.next</code>)；</li><li><strong>Handler</strong>：消息辅助类，主要功能向消息池发送各种消息事件(<code>Handler.sendMessage</code>)和处理相应消息事件(<code>Handler.handleMessage</code>)；</li><li><strong>Looper</strong>：不断循环执行(<code>Looper.loop</code>)，按分发机制将消息分发给目标处理者。</li></ul><p>一张图来了解一下它们之间的关系：</p><p><img src="messagequene.png" alt></p><h1 id="Handler原理解析（Java层）"><a href="#Handler原理解析（Java层）" class="headerlink" title="Handler原理解析（Java层）"></a>Handler原理解析（Java层）</h1><p>来分析原理前，先明确一下问题：</p><ol><li><strong>Handler 是如何与线程关联的？</strong></li><li><strong>Handler 发出去的消息是谁管理的？</strong></li><li><strong>消息又是怎么回到 handleMessage() 方法的？</strong></li><li><strong>线程的切换是怎么回事？</strong></li></ol><p>带着问题去寻找答案。</p><h2 id="Handler与Looper的关联"><a href="#Handler与Looper的关联" class="headerlink" title="Handler与Looper的关联"></a>Handler与Looper的关联</h2><p>实例化 Handler 的时候 Handler 会去检查当前线程的 Looper 是否存在，如果不存在则会报异常，也就是说<strong>在创建 Handler 之前一定需要先创建 Looper</strong> 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Handler</span><span class="params">(@Nullable Callback callback, <span class="keyword">boolean</span> async)</span> </span>&#123;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">//检查当前的线程是否有 Looper</span></span><br><span class="line">mLooper = Looper.myLooper();</span><br><span class="line"><span class="keyword">if</span> (mLooper == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(</span><br><span class="line">                <span class="string">"Can't create handler inside thread "</span> + Thread.currentThread()</span><br><span class="line">                        + <span class="string">" that has not called Looper.prepare()"</span>);</span><br><span class="line">&#125;</span><br><span class="line">  <span class="comment">//Looper 持有一个 MessageQueue</span></span><br><span class="line">mQueue = mLooper.mQueue;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>这个异常可能有的不熟悉，因为平时直接使用感受不到这个异常是因为主线程已经为我们创建好了 Looper</p></blockquote><p>一个完整的 Handler 使用例子其实是这样的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LooperThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> Handler mHandler;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Looper.prepare();</span><br><span class="line">        mHandler = <span class="keyword">new</span> Handler() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">                <span class="comment">// process incoming messages here</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        Looper.loop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Looper.prepare()</strong></p><p>对于无参的情况，默认调用<code>prepare(true)</code>，表示的是这个Looper允许退出，而对于false的情况则表示当前Looper不允许退出。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">prepare</span><span class="params">()</span> </span>&#123;</span><br><span class="line">prepare(<span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">prepare</span><span class="params">(<span class="keyword">boolean</span> quitAllowed)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (sThreadLocal.get() != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Only one Looper may be created per thread"</span>);</span><br><span class="line">&#125;</span><br><span class="line">sThreadLocal.set(<span class="keyword">new</span> Looper(quitAllowed));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的<code>sThreadLocal</code>是ThreadLocal类型，下面，先说说ThreadLocal。</p><p><strong>ThreadLocal</strong>： 线程本地存储区（Thread Local Storage，简称为TLS），每个线程都有自己的私有的本地存储区域，不同线程之间彼此不能访问对方的TLS区域。</p><p>Looper类中其定义如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;Looper&gt; sThreadLocal = <span class="keyword">new</span> ThreadLocal&lt;Looper&gt;();</span><br></pre></td></tr></table></figure><p>可见<code>sThreadLocal</code>的get()和set()操作的类型都是<code>Looper</code>类型。</p><blockquote><p>另外，与prepare()相近功能的，还有一个<code>prepareMainLooper()</code>方法，该方法主要在ActivityThread类中使用。</p></blockquote><p>Looper 提供了 <code>Looper.prepare()</code> 方法来创建 Looper ，并且会<strong>借助 ThreadLocal 来实现与当前线程的绑定</strong>功能。<strong>Looper.loop() 则会开始不断尝试从 MessageQueue 中获取 Message , 并分发给对应的 Handler</strong></p><p><strong>也就是说 Handler 跟线程的关联是靠 Looper 来实现的。</strong></p><h2 id="Message-的发送"><a href="#Message-的发送" class="headerlink" title="Message 的发送"></a>Message 的发送</h2><p>发送消息调用链：</p><p><img src="java_sendmessage.png" alt></p><p>不管我们调用什么方法，最终都会走到 <code>MessageQueue.enqueueMessage(Message,long)</code> 方法。</p><p>例如<code>sendEmptyMessage</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">sendEmptyMessage</span><span class="params">(<span class="keyword">int</span> what)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> sendEmptyMessageDelayed(what, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// -&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">sendEmptyMessageDelayed</span><span class="params">(<span class="keyword">int</span> what, <span class="keyword">long</span> delayMillis)</span> </span>&#123;</span><br><span class="line">Message msg = Message.obtain();</span><br><span class="line">msg.what = what;</span><br><span class="line"><span class="keyword">return</span> sendMessageDelayed(msg, delayMillis);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// -&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">sendMessageDelayed</span><span class="params">(@NonNull Message msg, <span class="keyword">long</span> delayMillis)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (delayMillis &lt; <span class="number">0</span>) &#123;</span><br><span class="line">delayMillis = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> sendMessageAtTime(msg, SystemClock.uptimeMillis() + delayMillis);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// -&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">sendMessageAtTime</span><span class="params">(@NonNull Message msg, <span class="keyword">long</span> uptimeMillis)</span> </span>&#123;</span><br><span class="line">MessageQueue queue = mQueue;</span><br><span class="line"><span class="keyword">if</span> (queue == <span class="keyword">null</span>) &#123;</span><br><span class="line">RuntimeException e = <span class="keyword">new</span> RuntimeException(</span><br><span class="line">   <span class="keyword">this</span> + <span class="string">" sendMessageAtTime() called with no mQueue"</span>);</span><br><span class="line">Log.w(<span class="string">"Looper"</span>, e.getMessage(), e);</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> enqueueMessage(queue, msg, uptimeMillis);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Handler.sendEmptyMessage()</code>等系列方法最终调用<code>MessageQueue.enqueueMessage(msg, uptimeMillis)</code>，将消息添加到消息队列中，其中uptimeMillis为系统当前的运行时间，不包括休眠时间。</p><p><strong>enqueueMessage</strong></p><p>添加一条消息到消息队列</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">enqueueMessage</span><span class="params">(Message msg, <span class="keyword">long</span> when)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 每一个普通Message必须有一个target</span></span><br><span class="line">    <span class="keyword">if</span> (msg.target == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Message must have a target."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (msg.isInUse()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(msg + <span class="string">" This message is already in use."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mQuitting) &#123;  <span class="comment">//正在退出时，回收msg，加入到消息池</span></span><br><span class="line">            msg.recycle();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        msg.markInUse();</span><br><span class="line">        msg.when = when;</span><br><span class="line">        Message p = mMessages;</span><br><span class="line">        <span class="keyword">boolean</span> needWake;</span><br><span class="line">        <span class="keyword">if</span> (p == <span class="keyword">null</span> || when == <span class="number">0</span> || when &lt; p.when) &#123;</span><br><span class="line">            <span class="comment">//p为null(代表MessageQueue没有消息） 或者msg的触发时间是队列中最早的， 则进入该该分支</span></span><br><span class="line">            msg.next = p;</span><br><span class="line">            mMessages = msg;</span><br><span class="line">            needWake = mBlocked; <span class="comment">//当阻塞时需要唤醒</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//将消息按时间顺序插入到MessageQueue。一般地，不需要唤醒事件队列，除非</span></span><br><span class="line">            <span class="comment">//消息队头存在barrier，并且同时Message是队列中最早的异步消息。</span></span><br><span class="line">            needWake = mBlocked &amp;&amp; p.target == <span class="keyword">null</span> &amp;&amp; msg.isAsynchronous();</span><br><span class="line">            Message prev;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                prev = p;</span><br><span class="line">                p = p.next;</span><br><span class="line">                <span class="keyword">if</span> (p == <span class="keyword">null</span> || when &lt; p.when) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (needWake &amp;&amp; p.isAsynchronous()) &#123;</span><br><span class="line">                    needWake = <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            msg.next = p;</span><br><span class="line">            prev.next = msg;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//消息没有退出，我们认为此时mPtr != 0</span></span><br><span class="line">        <span class="keyword">if</span> (needWake) &#123;</span><br><span class="line">            nativeWake(mPtr);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>MessageQueue</code>是按照Message触发时间的先后顺序排列的，队头的消息是将要最早触发的消息。当有消息需要加入消息队列时，会从队列头开始遍历，直到找到消息应该插入的合适位置，以保证所有消息的时间顺序。</p><h2 id="Message的分发"><a href="#Message的分发" class="headerlink" title="Message的分发"></a>Message的分发</h2><p><code>Looper.loop()</code>方法来进行消息的分发：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Looper</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">loop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Looper me = myLooper(); <span class="comment">//获取TLS存储的Looper对象</span></span><br><span class="line">    <span class="keyword">if</span> (me == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"No Looper; Looper.prepare() wasn't called on this thread."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">final</span> MessageQueue queue = me.mQueue; <span class="comment">//获取Looper对象中的消息队列</span></span><br><span class="line">  </span><br><span class="line">  Binder.clearCallingIdentity();</span><br><span class="line">    <span class="comment">//确保在权限检查时基于本地进程，而不是调用进程。</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> ident = Binder.clearCallingIdentity();</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">       <span class="comment">// 不断从 MessageQueue 获取 消息</span></span><br><span class="line">        Message msg = queue.next(); <span class="comment">// might block</span></span><br><span class="line">        <span class="comment">//退出 Looper </span></span><br><span class="line">        <span class="keyword">if</span> (msg == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// No message indicates that the message queue is quitting.</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            msg.target.dispatchMessage(msg);</span><br><span class="line">            end = (slowDispatchThresholdMs == <span class="number">0</span>) ? <span class="number">0</span> : SystemClock.uptimeMillis();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//...</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">      <span class="comment">//恢复调用者信息</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> newIdent = Binder.clearCallingIdentity();</span><br><span class="line"><span class="comment">//回收 message</span></span><br><span class="line">        msg.recycleUnchecked();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>loop()进入循环模式，不断重复下面的操作，直到没有消息时退出循环</p><ul><li>读取MessageQueue的下一条Message；</li><li>把Message分发给相应的target；</li><li>再把分发后的Message回收到消息池，以便重复利用。</li></ul><p>这是这个消息处理的核心部分。另外，上面代码中可以看到有logging方法，这是用于debug的，默认情况下<code>logging == null</code>，通过设置setMessageLogging()用来开启debug工作。</p><p><code>loop()</code> 里调用了 <code>MessageQueue.next()</code> :</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Message <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> ptr = mPtr;</span><br><span class="line">    <span class="keyword">if</span> (ptr == <span class="number">0</span>) &#123; <span class="comment">//当消息循环已经退出，则直接返回</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> pendingIdleHandlerCount = -<span class="number">1</span>; <span class="comment">// 循环迭代的首次为-1</span></span><br><span class="line">    <span class="keyword">int</span> nextPollTimeoutMillis = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nextPollTimeoutMillis != <span class="number">0</span>) &#123;</span><br><span class="line">            Binder.flushPendingCommands();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//阻塞操作，当等待nextPollTimeoutMillis时长，或者消息队列被唤醒，都会返回</span></span><br><span class="line">        nativePollOnce(ptr, nextPollTimeoutMillis);</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">long</span> now = SystemClock.uptimeMillis();</span><br><span class="line">            Message prevMsg = <span class="keyword">null</span>;</span><br><span class="line">            Message msg = mMessages;</span><br><span class="line">            <span class="comment">//当消息的Handler为空时，则查询异步消息</span></span><br><span class="line">            <span class="keyword">if</span> (msg != <span class="keyword">null</span> &amp;&amp; msg.target == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">//当查询到异步消息，则立刻退出循环</span></span><br><span class="line">                <span class="keyword">do</span> &#123;</span><br><span class="line">                    prevMsg = msg;</span><br><span class="line">                    msg = msg.next;</span><br><span class="line">                &#125; <span class="keyword">while</span> (msg != <span class="keyword">null</span> &amp;&amp; !msg.isAsynchronous());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (msg != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (now &lt; msg.when) &#123;</span><br><span class="line">                    <span class="comment">//当异步消息触发时间大于当前时间，则设置下一次轮询的超时时长</span></span><br><span class="line">                    nextPollTimeoutMillis = (<span class="keyword">int</span>) Math.min(msg.when - now, Integer.MAX_VALUE);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 获取一条消息，并返回</span></span><br><span class="line">                    mBlocked = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">if</span> (prevMsg != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        prevMsg.next = msg.next;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        mMessages = msg.next;</span><br><span class="line">                    &#125;</span><br><span class="line">                    msg.next = <span class="keyword">null</span>;</span><br><span class="line">                    <span class="comment">//设置消息的使用状态，即flags |= FLAG_IN_USE</span></span><br><span class="line">                    msg.markInUse();</span><br><span class="line">                    <span class="keyword">return</span> msg;   <span class="comment">//成功地获取MessageQueue中的下一条即将要执行的消息</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//没有消息</span></span><br><span class="line">                nextPollTimeoutMillis = -<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//消息正在退出，返回null</span></span><br><span class="line">            <span class="keyword">if</span> (mQuitting) &#123;</span><br><span class="line">                dispose();</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//当消息队列为空，或者是消息队列的第一个消息时</span></span><br><span class="line">            <span class="keyword">if</span> (pendingIdleHandlerCount &lt; <span class="number">0</span> &amp;&amp; (mMessages == <span class="keyword">null</span> || now &lt; mMessages.when)) &#123;</span><br><span class="line">                pendingIdleHandlerCount = mIdleHandlers.size();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (pendingIdleHandlerCount &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">//没有idle handlers 需要运行，则循环并等待。</span></span><br><span class="line">                mBlocked = <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (mPendingIdleHandlers == <span class="keyword">null</span>) &#123;</span><br><span class="line">                mPendingIdleHandlers = <span class="keyword">new</span> IdleHandler[Math.max(pendingIdleHandlerCount, <span class="number">4</span>)];</span><br><span class="line">            &#125;</span><br><span class="line">            mPendingIdleHandlers = mIdleHandlers.toArray(mPendingIdleHandlers);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//只有第一次循环时，会运行idle handlers，执行完成后，重置pendingIdleHandlerCount为0.</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pendingIdleHandlerCount; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> IdleHandler idler = mPendingIdleHandlers[i];</span><br><span class="line">            mPendingIdleHandlers[i] = <span class="keyword">null</span>; <span class="comment">//去掉handler的引用</span></span><br><span class="line">            <span class="keyword">boolean</span> keep = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                keep = idler.queueIdle();  <span class="comment">//idle时执行的方法</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                Log.wtf(TAG, <span class="string">"IdleHandler threw exception"</span>, t);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!keep) &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">                    mIdleHandlers.remove(idler);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//重置idle handler个数为0，以保证不会再次重复运行</span></span><br><span class="line">        pendingIdleHandlerCount = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//当调用一个空闲handler时，一个新message能够被分发，因此无需等待可以直接查询pending message.</span></span><br><span class="line">        nextPollTimeoutMillis = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><code>nativePollOnce</code>是阻塞操作，其中<code>nextPollTimeoutMillis</code>代表下一个消息到来前，还需要等待的时长；当nextPollTimeoutMillis = -1时，表示消息队列中无消息，会一直等待下去。</p><p>当处于空闲时，往往会执行<code>IdleHandler</code>中的方法。当nativePollOnce()返回后，next()从<code>mMessages</code>中提取一个消息。</p></blockquote><p>并且loop方法调用了 <code>msg.target.dispatchMessage(msg)</code> ，msg.target 就是发送该消息的 Handler</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Handler</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dispatchMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//msg.callback 是 Runnable ，如果是 post方法则会走这个 if</span></span><br><span class="line">  <span class="keyword">if</span> (msg.callback != <span class="keyword">null</span>) &#123;</span><br><span class="line">    handleCallback(msg);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//callback </span></span><br><span class="line">    <span class="keyword">if</span> (mCallback != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (mCallback.handleMessage(msg)) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//回调到 Handler 的 handleMessage 方法</span></span><br><span class="line">    handleMessage(msg);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>dispatchMessage() 方法针对 Runnable 的方法做了特殊处理，如果是 ，则会直接执行 <code>Runnable.run()</code> 。</strong></p></blockquote><p><strong>Looper.loop() 是个死循环，会不断调用 MessageQueue.next() 获取 Message ，并调用 <code>msg.target.dispatchMessage(msg)</code> 回到了 Handler 来分发消息，以此来完成消息的回调</strong>。</p><p><img src="yuanli.webp" alt></p><h2 id="线程的切换"><a href="#线程的切换" class="headerlink" title="线程的切换"></a>线程的切换</h2><p>先将所涉及的方法调用栈画出来，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Thread.foo()&#123;</span><br><span class="line">Looper.loop()</span><br><span class="line"> -&gt; MessageQueue.next()</span><br><span class="line">   -&gt; Message.target.dispatchMessage()</span><br><span class="line">    -&gt; Handler.handleMessage()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>显而易见，Handler.handleMessage() 所在的线程最终由调用 Looper.loop() 的线程所决定。</strong></p><p>平时我们用的时候从异步线程发送消息到 Handler，这个 Handler 的 <code>handleMessage()</code> 方法是在主线程调用的，所以消息就从异步线程切换到了主线程。</p><h1 id="Handler的正确使用姿势"><a href="#Handler的正确使用姿势" class="headerlink" title="Handler的正确使用姿势"></a>Handler的正确使用姿势</h1><p>Handler很常用，但是也有很多需要注意的。</p><h2 id="为什么主线程可以直接使用-Handler，不需要创建-Looper"><a href="#为什么主线程可以直接使用-Handler，不需要创建-Looper" class="headerlink" title="为什么主线程可以直接使用 Handler，不需要创建 Looper"></a>为什么主线程可以直接使用 Handler，不需要创建 Looper</h2><p>前面我们提到了每个Handler 的线程都有一个 Looper ，主线程当然也不例外，但是我们不曾准备过主线程的 Looper 而可以直接使用，这是为何？</p><p><strong>注意：通常我们认为 ActivityThread 就是主线程。事实上它并不是一个线程，而是主线程操作的管理者，所以吧，我觉得把 ActivityThread 认为就是主线程无可厚非，另外主线程也可以说成 UI 线程。</strong></p><p>在 ActivityThread.main() 方法中有如下代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">//android.app.ActivityThread</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">  //...</span><br><span class="line">  Looper.prepareMainLooper();</span><br><span class="line"></span><br><span class="line">  ActivityThread thread = new ActivityThread();</span><br><span class="line">  thread.attach(false);</span><br><span class="line"></span><br><span class="line">  if (sMainThreadHandler == null) &#123;</span><br><span class="line">    sMainThreadHandler = thread.getHandler();</span><br><span class="line">  &#125;</span><br><span class="line">  //...</span><br><span class="line">  Looper.loop();</span><br><span class="line"></span><br><span class="line">  throw new RuntimeException(&quot;Main thread loop unexpectedly exited&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Looper.prepareMainLooper(); 代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Initialize the current thread as a looper, marking it as an</span><br><span class="line"> * application&apos;s main looper. The main looper for your application</span><br><span class="line"> * is created by the Android environment, so you should never need</span><br><span class="line"> * to call this function yourself.  See also: &#123;@link #prepare()&#125;</span><br><span class="line"> */</span><br><span class="line">public static void prepareMainLooper() &#123;</span><br><span class="line">    prepare(false);</span><br><span class="line">    synchronized (Looper.class) &#123;</span><br><span class="line">        if (sMainLooper != null) &#123;</span><br><span class="line">            throw new IllegalStateException(&quot;The main Looper has already been prepared.&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        sMainLooper = myLooper();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到<strong>在 ActivityThread 里 调用了 Looper.prepareMainLooper() 方法创建了 主线程的 Looper ,并且调用了 loop() 方法</strong>，所以我们就可以直接使用 Handler 了。</p><p><strong>注意：<code>Looper.loop()</code> 是个死循环，后面的代码正常情况不会执行。</strong></p><h2 id="主线程的-Looper-不允许退出"><a href="#主线程的-Looper-不允许退出" class="headerlink" title="主线程的 Looper 不允许退出"></a>主线程的 Looper 不允许退出</h2><p>如果你尝试退出 Looper ，你会得到以下错误信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Caused by: java.lang.IllegalStateException: Main thread not allowed to quit.</span><br><span class="line">  at android.os.MessageQueue.quit(MessageQueue.java:415)</span><br><span class="line">  at android.os.Looper.quit(Looper.java:240)</span><br></pre></td></tr></table></figure><p> 其实原因很简单，<strong>主线程不允许退出</strong>，退出就意味 APP 要挂。</p><h2 id="为什么Looper-loop方法不会卡死主线程"><a href="#为什么Looper-loop方法不会卡死主线程" class="headerlink" title="为什么Looper.loop方法不会卡死主线程"></a>为什么Looper.loop方法不会卡死主线程</h2><p>参考：<a href="https://www.zhihu.com/question/34652589/answer/90344494" target="_blank" rel="noopener">https://www.zhihu.com/question/34652589/answer/90344494</a></p><h2 id="Handler-里藏着的-Callback-能干什么"><a href="#Handler-里藏着的-Callback-能干什么" class="headerlink" title="Handler 里藏着的 Callback 能干什么"></a>Handler 里藏着的 Callback 能干什么</h2><p>在 Handler 的构造方法中有几个 要求传入 Callback ，那它是什么，又能做什么呢？</p><p>来看看 <code>Handler.dispatchMessage(msg)</code> 方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public void dispatchMessage(Message msg) &#123;</span><br><span class="line">  //这里的 callback 是 Runnable</span><br><span class="line">  if (msg.callback != null) &#123;</span><br><span class="line">    handleCallback(msg);</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    //如果 callback 处理了该 msg 并且返回 true， 就不会再回调 handleMessage</span><br><span class="line">    if (mCallback != null) &#123;</span><br><span class="line">      if (mCallback.handleMessage(msg)) &#123;</span><br><span class="line">        return;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    handleMessage(msg);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到 Handler.Callback 有<strong>优先处理消息的权利</strong> ，当一条消息被 Callback 处理<strong>并拦截（返回 true）</strong>，那么 Handler 的 <code>handleMessage(msg)</code> 方法就不会被调用了；如果 Callback 处理了消息，但是并没有拦截，那么就意味着<strong>一个消息可以同时被 Callback 以及 Handler 处理</strong>。</p><p><strong>我们可以利用 Callback 这个拦截机制来拦截 Handler 的消息！</strong></p><blockquote><p> 场景：Hook <code>ActivityThread.mH</code>， 在 ActivityThread 中有个成员变量 <code>mH</code> ，它是个 Handler，又是个极其重要的类，几乎所有的插件化框架都使用了这个方法。</p></blockquote><h2 id="创建-Message-实例的方式"><a href="#创建-Message-实例的方式" class="headerlink" title="创建 Message 实例的方式"></a>创建 Message 实例的方式</h2><p>先来看看消息池：</p><p>在代码中，可能经常看到recycle()方法，咋一看，可能是在做虚拟机的gc()相关的工作，其实不然，这是用于把消息加入到消息池的作用。这样的好处是，当消息池不为空时，可以直接从消息池中获取Message对象，而不是直接创建，提高效率。</p><p>静态变量<code>sPool</code>的数据类型为Message，通过next成员变量，维护一个消息池；静态变量<code>MAX_POOL_SIZE</code>代表消息池的可用大小；消息池的默认大小为50。</p><p>消息池常用的操作方法是obtain()和recycle()。</p><p><strong>obtain</strong></p><p>从消息池中获取消息</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Message <span class="title">obtain</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (sPoolSync) &#123;</span><br><span class="line">        <span class="keyword">if</span> (sPool != <span class="keyword">null</span>) &#123;</span><br><span class="line">            Message m = sPool;</span><br><span class="line">            sPool = m.next;</span><br><span class="line">            m.next = <span class="keyword">null</span>; <span class="comment">//从sPool中取出一个Message对象，并消息链表断开</span></span><br><span class="line">            m.flags = <span class="number">0</span>; <span class="comment">// 清除in-use flag</span></span><br><span class="line">            sPoolSize--; <span class="comment">//消息池的可用大小进行减1操作</span></span><br><span class="line">            <span class="keyword">return</span> m;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Message(); <span class="comment">// 当消息池为空时，直接创建Message对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>obtain()，从消息池取Message，都是把消息池表头的Message取走，再把表头指向next;</p><p><strong>recycle</strong></p><p>把不再使用的消息加入消息池</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">recycle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (isInUse()) &#123; <span class="comment">//判断消息是否正在使用</span></span><br><span class="line">        <span class="keyword">if</span> (gCheckRecycle) &#123; <span class="comment">//Android 5.0以后的版本默认为true,之前的版本默认为false.</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"This message cannot be recycled because it is still in use."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    recycleUnchecked();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//对于不再使用的消息，加入到消息池</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">recycleUnchecked</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//将消息标示位置为IN_USE，并清空消息所有的参数。</span></span><br><span class="line">    flags = FLAG_IN_USE;</span><br><span class="line">    what = <span class="number">0</span>;</span><br><span class="line">    arg1 = <span class="number">0</span>;</span><br><span class="line">    arg2 = <span class="number">0</span>;</span><br><span class="line">    obj = <span class="keyword">null</span>;</span><br><span class="line">    replyTo = <span class="keyword">null</span>;</span><br><span class="line">    sendingUid = -<span class="number">1</span>;</span><br><span class="line">    when = <span class="number">0</span>;</span><br><span class="line">    target = <span class="keyword">null</span>;</span><br><span class="line">    callback = <span class="keyword">null</span>;</span><br><span class="line">    data = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">synchronized</span> (sPoolSync) &#123;</span><br><span class="line">        <span class="keyword">if</span> (sPoolSize &lt; MAX_POOL_SIZE) &#123; <span class="comment">//当消息池没有满时，将Message对象加入消息池</span></span><br><span class="line">            next = sPool;</span><br><span class="line">            sPool = <span class="keyword">this</span>;</span><br><span class="line">            sPoolSize++; <span class="comment">//消息池的可用大小进行加1操作</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>recycle()，将Message加入到消息池的过程，都是把Message加到链表的表头；</p><p><strong>所以由于 Handler 极为常用，所以为了节省开销，Android 给 Message 设计了回收机制，所以我们在使用的时候尽量复用 Message ，减少内存消耗。</strong></p><ul><li><p>1、通过 Message 的静态方法 <code>Message.obtain();</code>  获取；</p></li><li><p>2、通过 Handler 的公有方法 <code>handler.obtainMessage();</code> 。</p></li></ul><h2 id="Handler-引起的内存泄露原因以及解决方案"><a href="#Handler-引起的内存泄露原因以及解决方案" class="headerlink" title="Handler 引起的内存泄露原因以及解决方案"></a>Handler 引起的内存泄露原因以及解决方案</h2><p>Handler 允许我们发送<strong>延时消息</strong>，如果在延时期间用户关闭了 Activity，那么该 Activity 会泄露。</p><p>这个泄露是因为 Message 会持有 Handler，而又因为 <strong>Java 的特性，内部类会持有外部类</strong>，使得 Activity 会被 Handler 持有，这样最终就导致 Activity 泄露。</p><p>解决该问题的最有效的方法是：<strong>将 Handler 定义成静态的内部类，在内部持有 Activity 的弱引用，并及时移除所有消息</strong>。</p><p>示例代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SafeHandler</span> <span class="keyword">extends</span> <span class="title">Handler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> WeakReference&lt;DemoActivity&gt; ref;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SafeHandler</span><span class="params">(DemoActivity activity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.ref = <span class="keyword">new</span> WeakReference(activity);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(<span class="keyword">final</span> Message msg)</span> </span>&#123;</span><br><span class="line">        DemoActivity activity = ref.get();</span><br><span class="line">        <span class="keyword">if</span> (activity != <span class="keyword">null</span>) &#123;</span><br><span class="line">            activity.handleMessage(msg);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">private</span> SafeHandler mSafeHandler = <span class="keyword">new</span> SafeHandler(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// .... do somthing</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//移除消息，加一层保障：</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDestroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  mSafeHandler.removeCallbacksAndMessages(<span class="keyword">null</span>);</span><br><span class="line">  <span class="keyword">super</span>.onDestroy();</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>注意：单纯的在 <code>onDestroy</code> 移除消息并不保险，因为 <code>onDestroy</code> 并不一定执行。</strong></p></blockquote><h2 id="子线程里弹-Toast"><a href="#子线程里弹-Toast" class="headerlink" title="子线程里弹 Toast"></a>子线程里弹 Toast</h2><p>当我们尝试在子线程里直接去弹 Toast 的时候，会 crash ：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java.lang.RuntimeException: Can&apos;t create handler inside thread that has not called Looper.prepare()</span><br></pre></td></tr></table></figure><p><strong>本质上是因为 Toast 的实现依赖于 Handler</strong>，同理的还有 Dialog。</p><p>正确使用代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Looper.prepare();</span><br><span class="line">    Toast.makeText(HandlerActivity.<span class="keyword">this</span>, <span class="string">"子线程下测试不会崩溃啦！"</span>, Toast.LENGTH_SHORT).show();</span><br><span class="line">    Looper.loop();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;).start();</span><br></pre></td></tr></table></figure><h2 id="巧妙利用-Looper-机制"><a href="#巧妙利用-Looper-机制" class="headerlink" title="巧妙利用 Looper 机制"></a>巧妙利用 Looper 机制</h2><p>我们可以利用 Looper 的机制来帮助我们做一些事情：</p><ol><li>将 Runnable post 到主线程执行；</li><li>利用 Looper 判断当前线程是否是主线程。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">MainThread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">MainThread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Handler HANDLER = <span class="keyword">new</span> Handler(Looper.getMainLooper());</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(@NonNull Runnable runnable)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isMainThread()) &#123;</span><br><span class="line">            runnable.run();</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            HANDLER.post(runnable);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isMainThread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Looper.myLooper() == Looper.getMainLooper();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://www.jianshu.com/p/f70ee1765a61" target="_blank" rel="noopener">https://www.jianshu.com/p/f70ee1765a61</a></p><p><a href="http://gityuan.com/2015/12/26/handler-message-framework/" target="_blank" rel="noopener">http://gityuan.com/2015/12/26/handler-message-framework/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;Handler&lt;/code&gt; 是 &lt;code&gt;Android&lt;/code&gt; 开发过程中非常非常常见的东西。它通常被我们用来做主线程与子线程之间的通信工具，而 Handler 作为 Android 中消息机制的重要一员也确实给我们的开发带来了极大的便利。&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="http://hackycy.github.io/categories/Android/"/>
    
    
      <category term="Handler" scheme="http://hackycy.github.io/tags/Handler/"/>
    
  </entry>
  
  <entry>
    <title>解决Android Studio——Configuration on demand is not supported by the current version of the Android Gradle</title>
    <link href="http://hackycy.github.io/2020/01/17/%E8%A7%A3%E5%86%B3Android-Studio%E2%80%94%E2%80%94Configuration-on-demand-is-not-supported-by-the-current-version-of-the-Android-Gradle/"/>
    <id>http://hackycy.github.io/2020/01/17/解决Android-Studio——Configuration-on-demand-is-not-supported-by-the-current-version-of-the-Android-Gradle/</id>
    <published>2020-01-17T06:45:50.000Z</published>
    <updated>2020-01-17T06:57:04.136Z</updated>
    
    <content type="html"><![CDATA[<p>【错误】<br>Configuration on demand is not supported by the current version of the Android Gradle plugin since you are using Gradle version 4.6 or above. </p><p>Suggestion: disable configuration on demand by setting org.gradle.configureondemand=false in your gradle.properties file or use a Gradle version less than 4.6.</p><p>【翻译】<br>由于使用你正在使用 Gradle 版本4.6或以上，当前版本的Android的 Gradle 插件不支持按需配置。</p><p>建议：通过在你的 gradle.properties 文件中设置 org.gradle.configureondemand=false 禁用按需配置，或者使用一个低于4.6版本的 Gradle。</p><a id="more"></a><p><strong>解决方案1：降级</strong></p><p>打开 <strong>gradle-wrapper.properties</strong> 文件，修改 <strong>distributionUrl</strong> 参数，将其后面修改为低于4.6版本的 Gradle。如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">distributionUrl=https\://services.gradle.org/distributions/gradle-4.1-all.zip</span><br></pre></td></tr></table></figure><p><img src="properties.png" alt></p><p><strong>解决方法2：禁用按需配置</strong></p><p>1、打开 <strong>gradle.properties</strong> 文件，共有两个：<strong>Global Properties</strong> 和 <strong>Project Properties</strong>，将其中的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">org.gradle.configureondemand=true</span><br></pre></td></tr></table></figure><p>修改为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">org.gradle.configureondemand=false</span><br></pre></td></tr></table></figure><blockquote><p>或删除该语句，或注释掉该语句。</p></blockquote><p>2、或者通过 <strong>Preferences</strong> 菜单，找到 <strong>Build, Execution, Deployment</strong> 里面的 <strong>Compiler</strong>，将右面的 <strong>Configure on demand</strong> 取消勾选。</p><p><img src="panel.png" alt></p><p><strong>参考链接</strong></p><p><a href="https://stackoverflow.com/questions/49990933/configuration-on-demand-is-not-supported-by-the-current-version-of-the-android-g" target="_blank" rel="noopener">https://stackoverflow.com/questions/49990933/configuration-on-demand-is-not-supported-by-the-current-version-of-the-android-g</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;【错误】&lt;br&gt;Configuration on demand is not supported by the current version of the Android Gradle plugin since you are using Gradle version 4.6 or above. &lt;/p&gt;
&lt;p&gt;Suggestion: disable configuration on demand by setting org.gradle.configureondemand=false in your gradle.properties file or use a Gradle version less than 4.6.&lt;/p&gt;
&lt;p&gt;【翻译】&lt;br&gt;由于使用你正在使用 Gradle 版本4.6或以上，当前版本的Android的 Gradle 插件不支持按需配置。&lt;/p&gt;
&lt;p&gt;建议：通过在你的 gradle.properties 文件中设置 org.gradle.configureondemand=false 禁用按需配置，或者使用一个低于4.6版本的 Gradle。&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="http://hackycy.github.io/categories/Android/"/>
    
    
      <category term="Android" scheme="http://hackycy.github.io/tags/Android/"/>
    
      <category term="Android Studio" scheme="http://hackycy.github.io/tags/Android-Studio/"/>
    
  </entry>
  
  <entry>
    <title>Java 8 新特性一览</title>
    <link href="http://hackycy.github.io/2020/01/04/Java-8-%E6%96%B0%E7%89%B9%E6%80%A7%E4%B8%80%E8%A7%88/"/>
    <id>http://hackycy.github.io/2020/01/04/Java-8-新特性一览/</id>
    <published>2020-01-04T02:13:58.000Z</published>
    <updated>2020-01-04T04:10:31.097Z</updated>
    
    <content type="html"><![CDATA[<p>Java 8 (又称为 jdk 1.8) 是 Java 语言开发的一个主要版本。 Oracle 公司于 2014 年 3 月 18 日发布 Java 8 ，它支持函数式编程，新的 JavaScript 引擎，新的日期 API，新的Stream API 等。</p><a id="more"></a><h1 id="新特性"><a href="#新特性" class="headerlink" title="新特性"></a>新特性</h1><p>Java8 新增了非常多的特性，我们主要讨论以下几个：</p><ul><li><strong>Lambda 表达式</strong> − Lambda 允许把函数作为一个方法的参数（函数作为参数传递到方法中）。</li><li><strong>方法引用</strong> − 方法引用提供了非常有用的语法，可以直接引用已有Java类或对象（实例）的方法或构造器。与lambda联合使用，方法引用可以使语言的构造更紧凑简洁，减少冗余代码。</li><li><strong>默认方法</strong> − 默认方法就是一个在接口里面有了一个实现的方法。</li><li><strong>Stream API</strong> −新添加的Stream API（java.util.stream） 把真正的函数式编程风格引入到Java中。</li><li><strong>Date Time API</strong> − 加强对日期与时间的处理。</li><li><strong>Optional 类</strong> − Optional 类已经成为 Java 8 类库的一部分，用来解决空指针异常。</li></ul><blockquote><p>更多相关请浏览-&gt;<a href="https://www.oracle.com/technetwork/java/javase/8-whats-new-2157071.html" target="_blank" rel="noopener">https://www.oracle.com/technetwork/java/javase/8-whats-new-2157071.html</a></p></blockquote><h1 id="Lambda-表达式"><a href="#Lambda-表达式" class="headerlink" title="Lambda 表达式"></a>Lambda 表达式</h1><p>Lambda 表达式，也可称为闭包，它是推动 Java 8 发布的最重要新特性。</p><p>Lambda 允许把函数作为一个方法的参数（函数作为参数传递进方法中）。</p><p>使用 Lambda 表达式可以使代码变的更加简洁紧凑。</p><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><p>lambda 表达式的语法格式如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(parameters) -&gt; expression </span><br><span class="line"><span class="comment">// or</span></span><br><span class="line">(parameters) -&gt;&#123; statements; &#125;</span><br></pre></td></tr></table></figure><ul><li><strong>可选类型声明：</strong>不需要声明参数类型，编译器可以统一识别参数值。</li><li><strong>可选的参数圆括号：</strong>一个参数无需定义圆括号，但多个参数需要定义圆括号。</li><li><strong>可选的大括号：</strong>如果主体包含了一个语句，就不需要使用大括号。</li><li><strong>可选的返回关键字：</strong>如果主体只有一个表达式返回值则编译器会自动返回值，大括号需要指定明表达式返回了一个数值。</li></ul><p>来看一下最简单的使用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Lambda</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"匿名内部类实现"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">"Lambda实现"</span>);</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        Lambda lambda = <span class="keyword">new</span> Lambda();</span><br><span class="line">        lambda.printFunc(() -&gt; System.out.println(<span class="string">"hello, lambda"</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printFunc</span><span class="params">(Functional func)</span> </span>&#123;</span><br><span class="line">        func.accept();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">interface</span> <span class="title">Functional</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">accept</span><span class="params">()</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">匿名内部类实现</span><br><span class="line">Lambda实现</span><br><span class="line">hello, lambda</span><br></pre></td></tr></table></figure><p><strong>更多实例</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 不需要参数,返回值为 5  </span></span><br><span class="line">() -&gt; <span class="number">5</span>  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// 2. 接收一个参数(数字类型),返回其2倍的值  </span></span><br><span class="line">x -&gt; <span class="number">2</span> * x  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// 3. 接受2个参数(数字),并返回他们的差值  </span></span><br><span class="line">(x, y) -&gt; x – y  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// 4. 接收2个int型整数,返回他们的和  </span></span><br><span class="line">(<span class="keyword">int</span> x, <span class="keyword">int</span> y) -&gt; x + y  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// 5. 接受一个 string 对象,并在控制台打印,不返回任何值(看起来像是返回void)  </span></span><br><span class="line">(String s) -&gt; System.out.print(s)</span><br></pre></td></tr></table></figure><h2 id="前提条件"><a href="#前提条件" class="headerlink" title="前提条件"></a>前提条件</h2><p>Lambda的语法非常简洁，但并不是可以随便使用的，使用时有几个条件需要特别注意：</p><ul><li><strong>方法的参数</strong>或者<strong>局部变量类型</strong>必须为<strong>接口</strong>才能使用Lambda</li><li>接口中有且仅有一个抽象方法</li></ul><h2 id="函数式接口"><a href="#函数式接口" class="headerlink" title="函数式接口"></a>函数式接口</h2><p>函数式接口在Java中指的是：<strong>有且仅有一个抽象方法的接口</strong>。</p><p>函数式接口，即适用于函数式变成场景的接口，而Java中的函数式编程体现就是Lambda，所以函数式接口就是可以适用于Lambda使用的接口。只有确保接口中有且仅有一个抽象方法，Java中的Lambda才能顺利进行推导。</p><p><code>@FunctionalInterface</code>注解</p><p>与<code>@Override</code>注解的作用类似，Java 8中专门为函数式接口引入了一个新的注解：<code>@FunctionalInterface</code>。该注解可以用于一个接口的定义上。</p><blockquote><p>默认方法和静态方法不会破坏函数式接口的定义，因此如下的代码是合法的。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">FunctionalDefaultMethods</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">defaultMethod</span><span class="params">()</span> </span>&#123;&#125;        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Lambda与匿名内部类对比"><a href="#Lambda与匿名内部类对比" class="headerlink" title="Lambda与匿名内部类对比"></a>Lambda与匿名内部类对比</h2><ul><li>所需要的类型不一样：匿名内部类需要的类型可以是类、抽象类、接口。Lambda表达式需要的类型必须是接口。</li><li>抽象方法的数量不一样：匿名内部类所需的接口中抽象方法数量随意，Lambda表达式所需的接口有且只能有一个抽象方法。</li><li>实现原理不同：匿名内部类是在编译后形成class，Lambda表达式是在程序运行时动态生成class。</li></ul><h2 id="常用的内置函数式接口"><a href="#常用的内置函数式接口" class="headerlink" title="常用的内置函数式接口"></a>常用的内置函数式接口</h2><p>Lambda表达式的前提是需要有函数式接口。而Lambda使用时不需要关心接口名、抽象方法名。只关心抽象方法的参数列表和返回值类型。因此为了让我们使用Lambda方便，JDK提供了大量的函数式接口。都在<code>java.util.function</code>包下可以查看。</p><p>常用的几个接口：</p><h3 id="Supplier"><a href="#Supplier" class="headerlink" title="Supplier"></a>Supplier</h3><p>该接口意味着“供给”，对应的Lambda表达式需要对外提供一个符合泛型类型的对象数据。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Supplier</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function">T <span class="title">get</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Consumer"><a href="#Consumer" class="headerlink" title="Consumer"></a>Consumer</h3><p>该接口与Supplier正好相反，它不是生产一个数据，而是消费一个数据，其数据类型由泛型参数决定。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Consumer</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">accept</span><span class="params">(T t)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Function"><a href="#Function" class="headerlink" title="Function"></a>Function</h3><p>该接口用来提供一个类型的数据得到另一个类型的数据，前者称为前置条件，后者称为后置条件，有参数有返回值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Function</span>&lt;<span class="title">T</span>, <span class="title">R</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function">R <span class="title">apply</span><span class="params">(T t)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Predicate"><a href="#Predicate" class="headerlink" title="Predicate"></a>Predicate</h3><p>有时候需要对某种类型数据进行判断，从而得到一个布尔值的接口，这时可以使用该接口。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Predicate</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">test</span><span class="params">(T t)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="接口默认方法"><a href="#接口默认方法" class="headerlink" title="接口默认方法"></a>接口默认方法</h1><p>Java 8 新增了接口的默认方法。</p><p>简单说，默认方法就是接口可以有实现方法，而且不需要实现类去实现其方法。</p><p>我们只需在方法名前面加个 default 关键字即可实现默认方法。</p><blockquote><p><strong>为什么要有这个特性？</strong></p><p>首先，之前的接口是个双刃剑，好处是面向抽象而不是面向具体编程，缺陷是，当需要修改接口时候，需要修改全部实现该接口的类，目前的 java 8 之前的集合框架没有 foreach 方法，通常能想到的解决办法是在JDK里给相关的接口添加新的方法及实现。然而，对于已经发布的版本，是没法在给接口添加新方法的同时不影响已有的实现。所以引进的默认方法。他们的目的是为了解决接口的修改与现有的实现不兼容的问题。</p></blockquote><h2 id="语法-1"><a href="#语法-1" class="headerlink" title="语法"></a>语法</h2><h3 id="默认方法语法："><a href="#默认方法语法：" class="headerlink" title="默认方法语法："></a>默认方法语法：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Vehicle</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;</span><br><span class="line">      System.out.println(<span class="string">"我是一辆车!"</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="多个默认方法"><a href="#多个默认方法" class="headerlink" title="多个默认方法"></a>多个默认方法</h3><p>一个接口有默认方法，考虑这样的情况，一个类实现了多个接口，且这些接口有相同的默认方法，以下实例说明了这种情况的解决方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Vehicle</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;</span><br><span class="line">      System.out.println(<span class="string">"我是一辆车!"</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">FourWheeler</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;</span><br><span class="line">      System.out.println(<span class="string">"我是一辆四轮车!"</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="静态默认方法"><a href="#静态默认方法" class="headerlink" title="静态默认方法"></a>静态默认方法</h2><p>Java 8 的另一个特性是接口可以声明（并且可以提供实现）静态方法。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Vehicle</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;</span><br><span class="line">      System.out.println(<span class="string">"我是一辆车!"</span>);</span><br><span class="line">   &#125;</span><br><span class="line">    <span class="comment">// 静态方法</span></span><br><span class="line">   <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">blowHorn</span><span class="params">()</span></span>&#123;</span><br><span class="line">      System.out.println(<span class="string">"按喇叭!!!"</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>尽管默认方法有这么多好处，但在实际开发中应该谨慎使用：在复杂的继承体系中，默认方法可能引起歧义和编译错误。</p></blockquote><h1 id="方法引用"><a href="#方法引用" class="headerlink" title="方法引用"></a>方法引用</h1><p>方法引用使得开发者可以直接引用现存的方法、Java类的构造方法或者实例对象。方法引用和Lambda表达式配合使用，使得java类的构造方法看起来紧凑而简洁，没有很多复杂的模板代码。</p><p>方法引用使用一对冒号 <strong>::</strong> </p><ul><li><strong>构造器引用：</strong>它的语法是<code>Class::new</code>，或者更一般的<code>Class&lt; T &gt;::new</code>实例如下：</li><li><strong>静态方法引用：</strong>它的语法是<code>Class::static_method</code>，实例如下：</li><li><strong>特定类的任意对象的方法引用：</strong>它的语法是<code>Class::method</code>实例如下：</li><li><strong>特定对象的方法引用：</strong>它的语法是<code>instance::method</code>实例如下：</li></ul><p>我们来用一个案例来理解一下为什么需要方法引用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MethodRef</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">getMax</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> n : arr) &#123;</span><br><span class="line">            sum += n;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(sum);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      <span class="comment">// 直接重复拷贝代码</span></span><br><span class="line">        printMax((arr) -&gt; &#123;</span><br><span class="line">            <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> n : arr) &#123;</span><br><span class="line">                sum += n;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(sum);</span><br><span class="line">        &#125;);</span><br><span class="line"><span class="comment">// 在Lambda中调用另一个函数</span></span><br><span class="line">        printMax((arr) -&gt; &#123;</span><br><span class="line">            getMax(arr);</span><br><span class="line">        &#125;);</span><br><span class="line"><span class="comment">// 直接使用方法引用</span></span><br><span class="line">        printMax(MethodRef::getMax);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printMax</span><span class="params">(Consumer&lt;<span class="keyword">int</span>[]&gt; consumer)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span>, <span class="number">14</span>, <span class="number">15</span>&#125;;</span><br><span class="line">        consumer.accept(arr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在main函数中的使用的三个对比，这就是减少了代码的冗余。</p><h1 id="Stream流"><a href="#Stream流" class="headerlink" title="Stream流"></a>Stream流</h1><p>Java 8 API添加了一个新的抽象称为流Stream，可以让你以一种声明的方式处理数据。</p><p>Stream 使用一种类似用 SQL 语句从数据库查询数据的直观方式来提供一种对 Java 集合运算和表达的高阶抽象。</p><p>Stream API可以极大提高Java程序员的生产力，让程序员写出高效率、干净、简洁的代码。</p><p>这种风格将要处理的元素集合看作一种流， 流在管道中传输， 并且可以在管道的节点上进行处理， 比如筛选， 排序，聚合等。</p><p>元素流在管道中经过中间操作（intermediate operation）的处理，最后由最终操作(terminal operation)得到前面处理的结果。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">+--------------------+       +------+   +------+   +---+   +-------+</span><br><span class="line">| stream of elements +-----&gt; |filter+-&gt; |sorted+-&gt; |map+-&gt; |collect|</span><br><span class="line">+--------------------+       +------+   +------+   +---+   +-------+</span><br></pre></td></tr></table></figure><p>以上的流程转换为 Java 代码为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; transactionsIds = </span><br><span class="line">widgets.stream()</span><br><span class="line">             .filter(b -&gt; b.getColor() == RED)</span><br><span class="line">             .sorted((x,y) -&gt; x.getWeight() - y.getWeight())</span><br><span class="line">             .mapToInt(Widget::getWeight)</span><br><span class="line">             .sum();</span><br></pre></td></tr></table></figure><h2 id="什么是-Stream"><a href="#什么是-Stream" class="headerlink" title="什么是 Stream"></a>什么是 Stream</h2><p>Stream（流）是一个来自数据源的元素队列并支持聚合操作</p><ul><li>元素是特定类型的对象，形成一个队列。 Java中的Stream并不会存储元素，而是按需计算。</li><li><strong>数据源</strong> 流的来源。 可以是集合，数组，I/O channel， 产生器generator 等。</li><li><strong>聚合操作</strong> 类似SQL语句一样的操作， 比如filter, map, reduce, find, match, sorted等。</li></ul><p>和以前的Collection操作不同， Stream操作还有两个基础的特征：</p><ul><li><strong>Pipelining</strong>: 中间操作都会返回流对象本身。 这样多个操作可以串联成一个管道， 如同流式风格（fluent style）。 这样做可以对操作进行优化， 比如延迟执行(laziness)和短路( short-circuiting)。</li><li><strong>内部迭代</strong>： 以前对集合遍历都是通过Iterator或者For-Each的方式, 显式的在集合外部进行迭代， 这叫做外部迭代。 Stream提供了内部迭代的方式， 通过访问者模式(Visitor)实现。</li></ul><h2 id="生成流"><a href="#生成流" class="headerlink" title="生成流"></a>生成流</h2><p>在 Java 8 中, 集合接口有两个方法来生成流：</p><ul><li><strong>stream()</strong> − 为集合创建串行流。</li><li><strong>parallelStream()</strong> − 为集合创建并行流。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; strings = Arrays.asList(<span class="string">"abc"</span>, <span class="string">""</span>, <span class="string">"bc"</span>, <span class="string">"efg"</span>, <span class="string">"abcd"</span>,<span class="string">""</span>, <span class="string">"jkl"</span>);</span><br><span class="line">List&lt;String&gt; filtered = strings.stream().filter(string -&gt; !string.isEmpty()).collect(Collectors.toList());</span><br></pre></td></tr></table></figure><h2 id="forEach"><a href="#forEach" class="headerlink" title="forEach"></a>forEach</h2><p>Stream 提供了新的方法 ‘forEach’ 来迭代流中的每个数据。以下代码片段使用 forEach 输出了10个随机数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Random random = <span class="keyword">new</span> Random();</span><br><span class="line">random.ints().limit(<span class="number">10</span>).forEach(System.out::println);</span><br></pre></td></tr></table></figure><h2 id="map"><a href="#map" class="headerlink" title="map"></a>map</h2><p>map 方法用于映射每个元素到对应的结果，以下代码片段使用 map 输出了元素对应的平方数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; numbers = Arrays.asList(<span class="number">3</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">7</span>, <span class="number">3</span>, <span class="number">5</span>);</span><br><span class="line"><span class="comment">// 获取对应的平方数</span></span><br><span class="line">List&lt;Integer&gt; squaresList = numbers.stream().map( i -&gt; i*i).distinct().collect(Collectors.toList());</span><br></pre></td></tr></table></figure><h2 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h2><p>filter 方法用于通过设置的条件过滤出元素。以下代码片段使用 filter 方法过滤出空字符串：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt;strings = Arrays.asList(<span class="string">"abc"</span>, <span class="string">""</span>, <span class="string">"bc"</span>, <span class="string">"efg"</span>, <span class="string">"abcd"</span>,<span class="string">""</span>, <span class="string">"jkl"</span>);</span><br><span class="line"><span class="comment">// 获取空字符串的数量</span></span><br><span class="line"><span class="keyword">long</span> count = strings.stream().filter(string -&gt; string.isEmpty()).count();</span><br></pre></td></tr></table></figure><h2 id="limit"><a href="#limit" class="headerlink" title="limit"></a>limit</h2><p>limit 方法用于获取指定数量的流。 以下代码片段使用 limit 方法打印出 10 条数据：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Random random = <span class="keyword">new</span> Random();</span><br><span class="line">random.ints().limit(<span class="number">10</span>).forEach(System.out::println);</span><br></pre></td></tr></table></figure><h2 id="sorted"><a href="#sorted" class="headerlink" title="sorted"></a>sorted</h2><p>sorted 方法用于对流进行排序。以下代码片段使用 sorted 方法对输出的 10 个随机数进行排序：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Random random = <span class="keyword">new</span> Random();</span><br><span class="line">random.ints().limit(<span class="number">10</span>).sorted().forEach(System.out::println);</span><br></pre></td></tr></table></figure><h2 id="并行（parallel）程序"><a href="#并行（parallel）程序" class="headerlink" title="并行（parallel）程序"></a>并行（parallel）程序</h2><p>parallelStream 是流并行处理程序的代替方法。以下实例我们使用 parallelStream 来输出空字符串的数量：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; strings = Arrays.asList(<span class="string">"abc"</span>, <span class="string">""</span>, <span class="string">"bc"</span>, <span class="string">"efg"</span>, <span class="string">"abcd"</span>,<span class="string">""</span>, <span class="string">"jkl"</span>);</span><br><span class="line"><span class="comment">// 获取空字符串的数量</span></span><br><span class="line"><span class="keyword">int</span> count = strings.parallelStream().filter(string -&gt; string.isEmpty()).count();</span><br></pre></td></tr></table></figure><p>我们可以很容易的在顺序运行和并行直接切换。</p><h2 id="Collectors"><a href="#Collectors" class="headerlink" title="Collectors"></a>Collectors</h2><p>Collectors 类实现了很多归约操作，例如将流转换成集合和聚合元素。Collectors 可用于返回列表或字符串：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt;strings = Arrays.asList(<span class="string">"abc"</span>, <span class="string">""</span>, <span class="string">"bc"</span>, <span class="string">"efg"</span>, <span class="string">"abcd"</span>,<span class="string">""</span>, <span class="string">"jkl"</span>);</span><br><span class="line">List&lt;String&gt; filtered = strings.stream().filter(string -&gt; !string.isEmpty()).collect(Collectors.toList());</span><br><span class="line"> </span><br><span class="line">System.out.println(<span class="string">"筛选列表: "</span> + filtered);</span><br><span class="line">String mergedString = strings.stream().filter(string -&gt; !string.isEmpty()).collect(Collectors.joining(<span class="string">", "</span>));</span><br><span class="line">System.out.println(<span class="string">"合并字符串: "</span> + mergedString);</span><br></pre></td></tr></table></figure><h2 id="统计"><a href="#统计" class="headerlink" title="统计"></a>统计</h2><p>另外，一些产生统计结果的收集器也非常有用。它们主要用于int、double、long等基本类型上，它们可以用来产生类似如下的统计结果。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; numbers = Arrays.asList(<span class="number">3</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">7</span>, <span class="number">3</span>, <span class="number">5</span>);</span><br><span class="line"> </span><br><span class="line">IntSummaryStatistics stats = numbers.stream().mapToInt((x) -&gt; x).summaryStatistics();</span><br><span class="line"> </span><br><span class="line">System.out.println(<span class="string">"列表中最大的数 : "</span> + stats.getMax());</span><br><span class="line">System.out.println(<span class="string">"列表中最小的数 : "</span> + stats.getMin());</span><br><span class="line">System.out.println(<span class="string">"所有数之和 : "</span> + stats.getSum());</span><br><span class="line">System.out.println(<span class="string">"平均数 : "</span> + stats.getAverage());</span><br></pre></td></tr></table></figure><blockquote><p>更多Api请翻阅文档：<a href="https://docs.oracle.com/javase/8/docs/api/java/util/stream/package-summary.html" target="_blank" rel="noopener">https://docs.oracle.com/javase/8/docs/api/java/util/stream/package-summary.html</a></p></blockquote><h1 id="Date-Time-API"><a href="#Date-Time-API" class="headerlink" title="Date/Time API"></a>Date/Time API</h1><p>Java 8通过发布新的Date-Time API (JSR 310)来进一步加强对日期与时间的处理。</p><p>在旧版的 Java 中，日期时间 API 存在诸多问题，其中有：</p><ul><li><strong>非线程安全</strong> − java.util.Date 是非线程安全的，所有的日期类都是可变的，这是Java日期类最大的问题之一。</li><li><strong>设计很差</strong> − Java的日期/时间类的定义并不一致，在java.util和java.sql的包中都有日期类，此外用于格式化和解析的类在java.text包中定义。java.util.Date同时包含日期和时间，而java.sql.Date仅包含日期，将其纳入java.sql包并不合理。另外这两个类都有相同的名字，这本身就是一个非常糟糕的设计。</li><li><strong>时区处理麻烦</strong> − 日期类并不提供国际化，没有时区支持，因此Java引入了java.util.Calendar和java.util.TimeZone类，但他们同样存在上述所有的问题。</li></ul><p>Java 8 在 <strong>java.time</strong> 包下提供了很多新的 API。以下为两个比较重要的 API：</p><ul><li><strong>Local(本地)</strong> − 简化了日期时间的处理，没有时区的问题。</li><li><strong>Zoned(时区)</strong> − 通过制定的时区处理日期时间。</li></ul><p>新的java.time包涵盖了所有处理日期，时间，日期/时间，时区，时刻（instants），过程（during）与时钟（clock）的操作。</p><blockquote><p><a href="https://docs.oracle.com/javase/8/docs/technotes/guides/datetime/index.html" target="_blank" rel="noopener">https://docs.oracle.com/javase/8/docs/technotes/guides/datetime/index.html</a></p></blockquote><h2 id="本地化日期时间-API"><a href="#本地化日期时间-API" class="headerlink" title="本地化日期时间 API"></a>本地化日期时间 API</h2><p><code>LocalDate/LocalTime</code> 和 <code>LocalDateTime</code> 类可以在处理时区不是必须的情况。代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取当前的日期时间</span></span><br><span class="line">LocalDateTime currentTime = LocalDateTime.now();</span><br><span class="line">System.out.println(<span class="string">"当前时间: "</span> + currentTime);</span><br><span class="line">        </span><br><span class="line">LocalDate date1 = currentTime.toLocalDate();</span><br><span class="line">System.out.println(<span class="string">"date1: "</span> + date1);</span><br><span class="line">        </span><br><span class="line">Month month = currentTime.getMonth();</span><br><span class="line"><span class="keyword">int</span> day = currentTime.getDayOfMonth();</span><br><span class="line"><span class="keyword">int</span> seconds = currentTime.getSecond();</span><br><span class="line">        </span><br><span class="line">System.out.println(<span class="string">"月: "</span> + month +<span class="string">", 日: "</span> + day +<span class="string">", 秒: "</span> + seconds);</span><br><span class="line">        </span><br><span class="line">LocalDateTime date2 = currentTime.withDayOfMonth(<span class="number">10</span>).withYear(<span class="number">2012</span>);</span><br><span class="line">System.out.println(<span class="string">"date2: "</span> + date2);</span><br><span class="line">        </span><br><span class="line"><span class="comment">// 12 december 2014</span></span><br><span class="line">LocalDate date3 = LocalDate.of(<span class="number">2014</span>, Month.DECEMBER, <span class="number">12</span>);</span><br><span class="line">System.out.println(<span class="string">"date3: "</span> + date3);</span><br><span class="line">        </span><br><span class="line"><span class="comment">// 22 小时 15 分钟</span></span><br><span class="line">LocalTime date4 = LocalTime.of(<span class="number">22</span>, <span class="number">15</span>);</span><br><span class="line">System.out.println(<span class="string">"date4: "</span> + date4);</span><br><span class="line">        </span><br><span class="line"><span class="comment">// 解析字符串</span></span><br><span class="line">LocalTime date5 = LocalTime.parse(<span class="string">"20:15:30"</span>);</span><br><span class="line">System.out.println(<span class="string">"date5: "</span> + date5);</span><br></pre></td></tr></table></figure><blockquote><p> output</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt; 当前时间: 2016-04-15T16:55:48.668</span><br><span class="line">&gt; date1: 2016-04-15</span><br><span class="line">&gt; 月: APRIL, 日: 15, 秒: 48</span><br><span class="line">&gt; date2: 2012-04-10T16:55:48.668</span><br><span class="line">&gt; date3: 2014-12-12</span><br><span class="line">&gt; date4: 22:15</span><br><span class="line">&gt; date5: 20:15:30</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><h2 id="使用时区的日期时间API"><a href="#使用时区的日期时间API" class="headerlink" title="使用时区的日期时间API"></a>使用时区的日期时间API</h2><p>如果我们需要考虑到时区，就可以使用时区<code>ZonedDateTime</code>的日期时间API：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取当前时间日期</span></span><br><span class="line">ZonedDateTime date1 = ZonedDateTime.parse(<span class="string">"2015-12-03T10:15:30+05:30[Asia/Shanghai]"</span>);</span><br><span class="line">System.out.println(<span class="string">"date1: "</span> + date1);</span><br><span class="line">        </span><br><span class="line">ZoneId id = ZoneId.of(<span class="string">"Europe/Paris"</span>);</span><br><span class="line">System.out.println(<span class="string">"ZoneId: "</span> + id);</span><br><span class="line">        </span><br><span class="line">ZoneId currentZone = ZoneId.systemDefault();</span><br><span class="line">System.out.println(<span class="string">"当期时区: "</span> + currentZone);</span><br></pre></td></tr></table></figure><blockquote><p>output</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; date1: 2015-12-03T10:15:30+08:00[Asia/Shanghai]</span><br><span class="line">&gt; ZoneId: Europe/Paris</span><br><span class="line">&gt; 当期时区: Asia/Shanghai</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>更多示例<a href="https://www.javacodegeeks.com/2014/04/java-8-date-time-api-tutorial-localdatetime.html" target="_blank" rel="noopener">https://www.javacodegeeks.com/2014/04/java-8-date-time-api-tutorial-localdatetime.html</a></p></blockquote><h1 id="Optional-类"><a href="#Optional-类" class="headerlink" title="Optional 类"></a>Optional 类</h1><p>Optional 类是一个可以为null的容器对象。如果值存在则isPresent()方法会返回true，调用get()方法会返回该对象。</p><p>Optional 是个容器：它可以保存类型T的值，或者仅仅保存null。Optional提供很多有用的方法，这样我们就不用显式进行空值检测。</p><p>Optional 类的引入很好的解决空指针异常。</p><h2 id="类声明"><a href="#类声明" class="headerlink" title="类声明"></a>类声明</h2><p>以下是一个 <strong>java.util.Optional</strong> 类的声明：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Optional</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">Object</span></span></span><br></pre></td></tr></table></figure><h2 id="类方法"><a href="#类方法" class="headerlink" title="类方法"></a>类方法</h2><table><thead><tr><th style="text-align:left">序号</th><th style="text-align:left">方法 &amp; 描述</th></tr></thead><tbody><tr><td style="text-align:left">1</td><td style="text-align:left"><strong>static  Optional empty()</strong>返回空的 Optional 实例。</td></tr><tr><td style="text-align:left">2</td><td style="text-align:left"><strong>boolean equals(Object obj)</strong>判断其他对象是否等于 Optional。</td></tr><tr><td style="text-align:left">3</td><td style="text-align:left"><strong>Optional filter(Predicate predicate)</strong>如果值存在，并且这个值匹配给定的 predicate，返回一个Optional用以描述这个值，否则返回一个空的Optional。</td></tr><tr><td style="text-align:left">4</td><td style="text-align:left"><strong> Optional flatMap(Function&gt; mapper)</strong>如果值存在，返回基于Optional包含的映射方法的值，否则返回一个空的Optional</td></tr><tr><td style="text-align:left">5</td><td style="text-align:left"><strong>T get()</strong>如果在这个Optional中包含这个值，返回值，否则抛出异常：NoSuchElementException</td></tr><tr><td style="text-align:left">6</td><td style="text-align:left"><strong>int hashCode()</strong>返回存在值的哈希码，如果值不存在 返回 0。</td></tr><tr><td style="text-align:left">7</td><td style="text-align:left"><strong>void ifPresent(Consumer consumer)</strong>如果值存在则使用该值调用 consumer , 否则不做任何事情。</td></tr><tr><td style="text-align:left">8</td><td style="text-align:left"><strong>boolean isPresent()</strong>如果值存在则方法会返回true，否则返回 false。</td></tr><tr><td style="text-align:left">9</td><td style="text-align:left"><strong>Optional map(Function mapper)</strong>如果有值，则对其执行调用映射函数得到返回值。如果返回值不为 null，则创建包含映射返回值的Optional作为map方法返回值，否则返回空Optional。</td></tr><tr><td style="text-align:left">10</td><td style="text-align:left"><strong>static  Optional of(T value)</strong>返回一个指定非null值的Optional。</td></tr><tr><td style="text-align:left">11</td><td style="text-align:left"><strong>static  Optional ofNullable(T value)</strong>如果为非空，返回 Optional 描述的指定值，否则返回空的 Optional。</td></tr><tr><td style="text-align:left">12</td><td style="text-align:left"><strong>T orElse(T other)</strong>如果存在该值，返回值， 否则返回 other。</td></tr><tr><td style="text-align:left">13</td><td style="text-align:left"><strong>T orElseGet(Supplier other)</strong>如果存在该值，返回值， 否则触发 other，并返回 other 调用的结果。</td></tr><tr><td style="text-align:left">14</td><td style="text-align:left"><strong> T orElseThrow(Supplier exceptionSupplier)</strong>如果存在该值，返回包含的值，否则抛出由 Supplier 继承的异常</td></tr><tr><td style="text-align:left">15</td><td style="text-align:left"><strong>String toString()</strong>返回一个Optional的非空字符串，用来调试</td></tr></tbody></table><p><strong>注意：</strong> 这些方法是从 <strong>java.lang.Object</strong> 类继承来的。</p><h2 id="Optional实例"><a href="#Optional实例" class="headerlink" title="Optional实例"></a>Optional实例</h2><p>通过以下实例来更好的了解 Optional 类的使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OptionalDemo</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</span><br><span class="line">   </span><br><span class="line">      OptionalDemo optionalDemo = <span class="keyword">new</span> OptionalDemo();</span><br><span class="line">      Integer value1 = <span class="keyword">null</span>;</span><br><span class="line">      Integer value2 = <span class="keyword">new</span> Integer(<span class="number">10</span>);</span><br><span class="line">        </span><br><span class="line">      <span class="comment">// Optional.ofNullable - 允许传递为 null 参数</span></span><br><span class="line">      Optional&lt;Integer&gt; a = Optional.ofNullable(value1);</span><br><span class="line">        </span><br><span class="line">      <span class="comment">// Optional.of - 如果传递的参数是 null，抛出异常 NullPointerException</span></span><br><span class="line">      Optional&lt;Integer&gt; b = Optional.of(value2);</span><br><span class="line">      System.out.println(optionalDemo.sum(a,b));</span><br><span class="line">   &#125;</span><br><span class="line">    </span><br><span class="line">   <span class="function"><span class="keyword">public</span> Integer <span class="title">sum</span><span class="params">(Optional&lt;Integer&gt; a, Optional&lt;Integer&gt; b)</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">      <span class="comment">// Optional.isPresent - 判断值是否存在</span></span><br><span class="line">      System.out.println(<span class="string">"第一个参数值存在: "</span> + a.isPresent());</span><br><span class="line">      System.out.println(<span class="string">"第二个参数值存在: "</span> + b.isPresent());</span><br><span class="line">        </span><br><span class="line">      <span class="comment">// Optional.orElse - 如果值存在，返回它，否则返回默认值</span></span><br><span class="line">      Integer value1 = a.orElse(<span class="keyword">new</span> Integer(<span class="number">0</span>));</span><br><span class="line">        </span><br><span class="line">      <span class="comment">//Optional.get - 获取值，值需要存在</span></span><br><span class="line">      Integer value2 = b.get();</span><br><span class="line">      <span class="keyword">return</span> value1 + value2;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>output</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; 第一个参数值存在: false</span><br><span class="line">&gt; 第二个参数值存在: true</span><br><span class="line">&gt; 10</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://www.jianshu.com/p/5b800057f2d8" target="_blank" rel="noopener">https://www.jianshu.com/p/5b800057f2d8</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Java 8 (又称为 jdk 1.8) 是 Java 语言开发的一个主要版本。 Oracle 公司于 2014 年 3 月 18 日发布 Java 8 ，它支持函数式编程，新的 JavaScript 引擎，新的日期 API，新的Stream API 等。&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="http://hackycy.github.io/categories/Java/"/>
    
    
      <category term="Java" scheme="http://hackycy.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>i18n（国际化）地域标识码</title>
    <link href="http://hackycy.github.io/2019/12/16/i18n%EF%BC%88%E5%9B%BD%E9%99%85%E5%8C%96%EF%BC%89%E5%9C%B0%E5%9F%9F%E6%A0%87%E8%AF%86%E7%A0%81/"/>
    <id>http://hackycy.github.io/2019/12/16/i18n（国际化）地域标识码/</id>
    <published>2019-12-16T09:00:27.000Z</published>
    <updated>2020-01-18T08:13:02.376Z</updated>
    
    <content type="html"><![CDATA[<p>i18n(国际化) 和l18n(本地化)时的地域标识代码 格式如 zh-CN(语言-国家)</p><a id="more"></a><table><thead><tr><th style="text-align:left">国家</th><th style="text-align:left">语言</th><th style="text-align:left">语言编码</th><th style="text-align:left">国家编码</th></tr></thead><tbody><tr><td style="text-align:left">中国</td><td style="text-align:left">汉语</td><td style="text-align:left">zh</td><td style="text-align:left">CN</td></tr><tr><td style="text-align:left">中国香港</td><td style="text-align:left"></td><td style="text-align:left">zh</td><td style="text-align:left">HK</td></tr><tr><td style="text-align:left">中国澳门</td><td style="text-align:left"></td><td style="text-align:left">zh</td><td style="text-align:left">MO</td></tr><tr><td style="text-align:left">中国台湾</td><td style="text-align:left"></td><td style="text-align:left">zh</td><td style="text-align:left">TW</td></tr><tr><td style="text-align:left">新加坡</td><td style="text-align:left">汉语</td><td style="text-align:left">zh</td><td style="text-align:left">SG</td></tr><tr><td style="text-align:left">中国简体中文</td><td style="text-align:left">zh-CHS</td><td style="text-align:left"></td><td style="text-align:left"></td></tr><tr><td style="text-align:left">中国繁体中文</td><td style="text-align:left">zh-CHT</td><td style="text-align:left"></td><td style="text-align:left"></td></tr><tr><td style="text-align:left">英国</td><td style="text-align:left">英语</td><td style="text-align:left">en</td><td style="text-align:left">GB</td></tr><tr><td style="text-align:left">美国</td><td style="text-align:left">英语</td><td style="text-align:left">en</td><td style="text-align:left">US</td></tr><tr><td style="text-align:left">俄罗斯</td><td style="text-align:left">俄罗斯 Tatar 语</td><td style="text-align:left">tt</td><td style="text-align:left">RU</td></tr><tr><td style="text-align:left">俄罗斯</td><td style="text-align:left">俄罗斯语</td><td style="text-align:left">ru</td><td style="text-align:left">RU</td></tr><tr><td style="text-align:left">德国</td><td style="text-align:left">德语</td><td style="text-align:left">de</td><td style="text-align:left">DE</td></tr><tr><td style="text-align:left">瑞士</td><td style="text-align:left">德语</td><td style="text-align:left">de</td><td style="text-align:left">CH</td></tr><tr><td style="text-align:left">卢森堡</td><td style="text-align:left">德语</td><td style="text-align:left">de</td><td style="text-align:left">LU</td></tr><tr><td style="text-align:left">奥地利</td><td style="text-align:left">德语</td><td style="text-align:left">de</td><td style="text-align:left">AT</td></tr><tr><td style="text-align:left">列支敦士登</td><td style="text-align:left">德语</td><td style="text-align:left">de</td><td style="text-align:left">LI</td></tr><tr><td style="text-align:left">加拿大</td><td style="text-align:left">法语</td><td style="text-align:left">fr</td><td style="text-align:left">CA</td></tr><tr><td style="text-align:left">法国</td><td style="text-align:left">法语</td><td style="text-align:left">fr</td><td style="text-align:left">FR</td></tr><tr><td style="text-align:left">卢森堡</td><td style="text-align:left">法语</td><td style="text-align:left">fr</td><td style="text-align:left">LU</td></tr><tr><td style="text-align:left">比利时</td><td style="text-align:left">法语</td><td style="text-align:left">fr</td><td style="text-align:left">BE</td></tr><tr><td style="text-align:left">摩纳哥</td><td style="text-align:left">法语</td><td style="text-align:left">fr</td><td style="text-align:left">MC</td></tr><tr><td style="text-align:left">瑞士</td><td style="text-align:left">法语</td><td style="text-align:left">fr</td><td style="text-align:left">CH</td></tr><tr><td style="text-align:left">意大利</td><td style="text-align:left">意大利</td><td style="text-align:left">it</td><td style="text-align:left">IT</td></tr><tr><td style="text-align:left">日本</td><td style="text-align:left">日语</td><td style="text-align:left">ja</td><td style="text-align:left">JP</td></tr><tr><td style="text-align:left">韩国</td><td style="text-align:left">韩国</td><td style="text-align:left">ko</td><td style="text-align:left">KR</td></tr><tr><td style="text-align:left">哈萨克</td><td style="text-align:left">哈萨克(Kazakh)</td><td style="text-align:left">kk</td><td style="text-align:left">KZ</td></tr><tr><td style="text-align:left">芬兰</td><td style="text-align:left">芬兰语</td><td style="text-align:left">fi</td><td style="text-align:left">FI</td></tr><tr><td style="text-align:left">瑞典</td><td style="text-align:left">芬兰语</td><td style="text-align:left">sv</td><td style="text-align:left">FI</td></tr><tr><td style="text-align:left">瑞典</td><td style="text-align:left">瑞典语</td><td style="text-align:left">sv</td><td style="text-align:left">SE</td></tr><tr><td style="text-align:left">匈牙利</td><td style="text-align:left">匈牙利</td><td style="text-align:left">hu</td><td style="text-align:left">HU</td></tr><tr><td style="text-align:left">冰岛</td><td style="text-align:left">冰岛</td><td style="text-align:left">is</td><td style="text-align:left">IS</td></tr><tr><td style="text-align:left">印尼</td><td style="text-align:left">印尼</td><td style="text-align:left">id</td><td style="text-align:left">ID</td></tr><tr><td style="text-align:left">瑞士</td><td style="text-align:left">意大利</td><td style="text-align:left">it</td><td style="text-align:left">CH</td></tr><tr><td style="text-align:left">土耳其</td><td style="text-align:left">土耳其语</td><td style="text-align:left">tr</td><td style="text-align:left">TR</td></tr><tr><td style="text-align:left">乌克兰</td><td style="text-align:left">乌克兰语</td><td style="text-align:left">uk</td><td style="text-align:left">UA</td></tr><tr><td style="text-align:left">巴基斯坦</td><td style="text-align:left">巴基斯坦 Urdu 语</td><td style="text-align:left">ur</td><td style="text-align:left">PK</td></tr><tr><td style="text-align:left">加拿大</td><td style="text-align:left">英语</td><td style="text-align:left">en</td><td style="text-align:left">CA</td></tr><tr><td style="text-align:left">爱尔兰</td><td style="text-align:left">英语</td><td style="text-align:left">en</td><td style="text-align:left">IE</td></tr><tr><td style="text-align:left">捷克</td><td style="text-align:left">捷克</td><td style="text-align:left">cs</td><td style="text-align:left">CZ</td></tr><tr><td style="text-align:left">瑞士</td><td style="text-align:left">法语</td><td style="text-align:left">fr</td><td style="text-align:left">CH</td></tr><tr><td style="text-align:left">加勒比海</td><td style="text-align:left">英语</td><td style="text-align:left">en</td><td style="text-align:left">CB</td></tr><tr><td style="text-align:left">澳洲</td><td style="text-align:left">英语</td><td style="text-align:left">en</td><td style="text-align:left">AU</td></tr><tr><td style="text-align:left">新西兰</td><td style="text-align:left">英语</td><td style="text-align:left">en</td><td style="text-align:left">NZ</td></tr><tr><td style="text-align:left">比利时</td><td style="text-align:left">法语</td><td style="text-align:left">fr</td><td style="text-align:left">BE</td></tr><tr><td style="text-align:left">菲律宾</td><td style="text-align:left">英语</td><td style="text-align:left">en</td><td style="text-align:left">PH</td></tr><tr><td style="text-align:left">牙买加</td><td style="text-align:left">英语</td><td style="text-align:left">en</td><td style="text-align:left">JM</td></tr><tr><td style="text-align:left">伯利兹</td><td style="text-align:left">英语</td><td style="text-align:left">en</td><td style="text-align:left">BZ</td></tr><tr><td style="text-align:left">千里达托贝哥共和国英语</td><td style="text-align:left"></td><td style="text-align:left">en</td><td style="text-align:left">TT</td></tr><tr><td style="text-align:left">津巴布韦</td><td style="text-align:left">英语</td><td style="text-align:left">en</td><td style="text-align:left">ZW</td></tr><tr><td style="text-align:left">爱沙尼亚</td><td style="text-align:left">爱沙尼亚</td><td style="text-align:left">et</td><td style="text-align:left">EE</td></tr><tr><td style="text-align:left">法罗群岛</td><td style="text-align:left">法罗语(Faroese)</td><td style="text-align:left">fo</td><td style="text-align:left">FO</td></tr><tr><td style="text-align:left">摩纳哥</td><td style="text-align:left">法语</td><td style="text-align:left">fr</td><td style="text-align:left">MC</td></tr><tr><td style="text-align:left">西班牙</td><td style="text-align:left">西班牙语</td><td style="text-align:left">es</td><td style="text-align:left">ES</td></tr><tr><td style="text-align:left">阿根廷</td><td style="text-align:left">西班牙语</td><td style="text-align:left">es</td><td style="text-align:left">AR</td></tr><tr><td style="text-align:left">墨西哥</td><td style="text-align:left">西班牙语</td><td style="text-align:left">es</td><td style="text-align:left">MX</td></tr><tr><td style="text-align:left">玻利维亚</td><td style="text-align:left">西班牙语</td><td style="text-align:left">es</td><td style="text-align:left">BO</td></tr><tr><td style="text-align:left">智利</td><td style="text-align:left">西班牙语</td><td style="text-align:left">es</td><td style="text-align:left">CL</td></tr><tr><td style="text-align:left">巴拿马</td><td style="text-align:left">西班牙语</td><td style="text-align:left">es</td><td style="text-align:left">PA</td></tr><tr><td style="text-align:left">委内瑞拉</td><td style="text-align:left">西班牙语</td><td style="text-align:left">es</td><td style="text-align:left">VE</td></tr><tr><td style="text-align:left">哥伦比亚</td><td style="text-align:left">西班牙语</td><td style="text-align:left">es</td><td style="text-align:left">CO</td></tr><tr><td style="text-align:left">秘鲁</td><td style="text-align:left">西班牙语</td><td style="text-align:left">es</td><td style="text-align:left">PE</td></tr><tr><td style="text-align:left">哥斯达黎加</td><td style="text-align:left">西班牙语</td><td style="text-align:left">es</td><td style="text-align:left">CR</td></tr><tr><td style="text-align:left">多米尼加共和国</td><td style="text-align:left">西班牙语</td><td style="text-align:left">es</td><td style="text-align:left">DO</td></tr><tr><td style="text-align:left">厄瓜多尔</td><td style="text-align:left">西班牙语</td><td style="text-align:left">es</td><td style="text-align:left">EC</td></tr><tr><td style="text-align:left">萨尔瓦多</td><td style="text-align:left">西班牙语</td><td style="text-align:left">es</td><td style="text-align:left">SV</td></tr><tr><td style="text-align:left">危地马拉</td><td style="text-align:left">西班牙语</td><td style="text-align:left">es</td><td style="text-align:left">GT</td></tr><tr><td style="text-align:left">洪都拉斯</td><td style="text-align:left">西班牙语</td><td style="text-align:left">es</td><td style="text-align:left">HN</td></tr><tr><td style="text-align:left">尼加拉瓜</td><td style="text-align:left">西班牙语</td><td style="text-align:left">es</td><td style="text-align:left">NI</td></tr><tr><td style="text-align:left">巴拉圭</td><td style="text-align:left">西班牙语</td><td style="text-align:left">es</td><td style="text-align:left">PY</td></tr><tr><td style="text-align:left">波多黎各</td><td style="text-align:left">西班牙语</td><td style="text-align:left">es</td><td style="text-align:left">PR</td></tr><tr><td style="text-align:left">乌拉圭</td><td style="text-align:left">西班牙语</td><td style="text-align:left">es</td><td style="text-align:left">UY</td></tr><tr><td style="text-align:left">印度</td><td style="text-align:left">坦米尔语</td><td style="text-align:left">ta</td><td style="text-align:left">IN</td></tr><tr><td style="text-align:left">印度</td><td style="text-align:left">印度语(Gujarati)</td><td style="text-align:left">gu</td><td style="text-align:left">IN</td></tr><tr><td style="text-align:left">印度</td><td style="text-align:left">北印度语</td><td style="text-align:left">hi</td><td style="text-align:left">IN</td></tr><tr><td style="text-align:left">印度</td><td style="text-align:left">卡纳达语</td><td style="text-align:left">kn</td><td style="text-align:left">IN</td></tr><tr><td style="text-align:left">印度</td><td style="text-align:left">Konkani</td><td style="text-align:left">kok</td><td style="text-align:left">IN</td></tr><tr><td style="text-align:left">印度</td><td style="text-align:left">马拉地语</td><td style="text-align:left">mr</td><td style="text-align:left">IN</td></tr><tr><td style="text-align:left">印度</td><td style="text-align:left">Punjab 语</td><td style="text-align:left">pa</td><td style="text-align:left">IN</td></tr><tr><td style="text-align:left">印度</td><td style="text-align:left">梵文</td><td style="text-align:left">sa</td><td style="text-align:left">IN</td></tr><tr><td style="text-align:left">印度</td><td style="text-align:left">印度 Telugu 语</td><td style="text-align:left">te</td><td style="text-align:left">IN</td></tr><tr><td style="text-align:left">挪威</td><td style="text-align:left">挪威</td><td style="text-align:left">nb</td><td style="text-align:left">NO</td></tr><tr><td style="text-align:left">挪威</td><td style="text-align:left">挪威(Nynorsk)</td><td style="text-align:left">nn</td><td style="text-align:left">NO</td></tr><tr><td style="text-align:left">波兰</td><td style="text-align:left">波兰</td><td style="text-align:left">pl</td><td style="text-align:left">PL</td></tr><tr><td style="text-align:left">巴西</td><td style="text-align:left">葡萄牙语</td><td style="text-align:left">pt</td><td style="text-align:left">BR</td></tr><tr><td style="text-align:left">葡萄牙</td><td style="text-align:left">葡萄牙语</td><td style="text-align:left">pt</td><td style="text-align:left">PT</td></tr><tr><td style="text-align:left">越南</td><td style="text-align:left">越南语</td><td style="text-align:left">vi</td><td style="text-align:left">VN</td></tr><tr><td style="text-align:left">泰国</td><td style="text-align:left">泰语</td><td style="text-align:left">th</td><td style="text-align:left">TH</td></tr><tr><td style="text-align:left">南非</td><td style="text-align:left">英语</td><td style="text-align:left">en</td><td style="text-align:left">ZA</td></tr><tr><td style="text-align:left">南非</td><td style="text-align:left">公用荷兰语</td><td style="text-align:left">af</td><td style="text-align:left">ZA</td></tr><tr><td style="text-align:left">白俄罗斯</td><td style="text-align:left">白俄罗斯语(Belarusian)</td><td style="text-align:left">be</td><td style="text-align:left">BY</td></tr><tr><td style="text-align:left">伊朗王国</td><td style="text-align:left">波斯语</td><td style="text-align:left">fa</td><td style="text-align:left">IR</td></tr><tr><td style="text-align:left">以色列</td><td style="text-align:left">希伯来文</td><td style="text-align:left">he</td><td style="text-align:left">IL</td></tr><tr><td style="text-align:left">丹麦</td><td style="text-align:left">丹麦</td><td style="text-align:left">da</td><td style="text-align:left">DK</td></tr><tr><td style="text-align:left">马尔代夫</td><td style="text-align:left">马尔代夫(Dhivehi)</td><td style="text-align:left">div</td><td style="text-align:left">MV</td></tr><tr><td style="text-align:left">比利时</td><td style="text-align:left">荷兰语</td><td style="text-align:left">nl</td><td style="text-align:left">BE</td></tr><tr><td style="text-align:left">荷兰</td><td style="text-align:left">荷兰语</td><td style="text-align:left">nl</td><td style="text-align:left">NL</td></tr><tr><td style="text-align:left">希腊</td><td style="text-align:left">希腊</td><td style="text-align:left">el</td><td style="text-align:left">GR</td></tr><tr><td style="text-align:left">沙特阿拉伯</td><td style="text-align:left">阿拉伯语</td><td style="text-align:left">ar</td><td style="text-align:left">SA</td></tr><tr><td style="text-align:left">埃及</td><td style="text-align:left">阿拉伯语</td><td style="text-align:left">ar</td><td style="text-align:left">EG</td></tr><tr><td style="text-align:left">伊拉克</td><td style="text-align:left">阿拉伯语</td><td style="text-align:left">ar</td><td style="text-align:left">IQ</td></tr><tr><td style="text-align:left">约旦</td><td style="text-align:left">阿拉伯语</td><td style="text-align:left">ar</td><td style="text-align:left">JO</td></tr><tr><td style="text-align:left">科威特</td><td style="text-align:left">阿拉伯语</td><td style="text-align:left">ar</td><td style="text-align:left">KW</td></tr><tr><td style="text-align:left">黎巴嫩</td><td style="text-align:left">阿拉伯语</td><td style="text-align:left">ar</td><td style="text-align:left">LB</td></tr><tr><td style="text-align:left">利比亚</td><td style="text-align:left">阿拉伯语</td><td style="text-align:left">ar</td><td style="text-align:left">LY</td></tr><tr><td style="text-align:left">卡塔尔</td><td style="text-align:left">阿拉伯语</td><td style="text-align:left">ar</td><td style="text-align:left">QA</td></tr><tr><td style="text-align:left">叙利亚共和国</td><td style="text-align:left">阿拉伯语</td><td style="text-align:left">ar</td><td style="text-align:left">SY</td></tr><tr><td style="text-align:left">叙利亚共和国</td><td style="text-align:left">叙利亚语(Syriac)</td><td style="text-align:left">syr</td><td style="text-align:left">SY</td></tr><tr><td style="text-align:left">保加利亚</td><td style="text-align:left">保加利亚</td><td style="text-align:left">bg</td><td style="text-align:left">BG</td></tr><tr><td style="text-align:left">阿尔巴尼亚</td><td style="text-align:left">阿尔巴尼亚</td><td style="text-align:left">sq</td><td style="text-align:left">AL</td></tr><tr><td style="text-align:left">阿尔及利亚</td><td style="text-align:left">阿拉伯语</td><td style="text-align:left">ar</td><td style="text-align:left">DZ</td></tr><tr><td style="text-align:left">巴林</td><td style="text-align:left">阿拉伯语</td><td style="text-align:left">ar</td><td style="text-align:left">BH</td></tr><tr><td style="text-align:left">摩洛哥</td><td style="text-align:left">阿拉伯语</td><td style="text-align:left">ar</td><td style="text-align:left">MA</td></tr><tr><td style="text-align:left">阿曼</td><td style="text-align:left">阿拉伯语</td><td style="text-align:left">ar</td><td style="text-align:left">OM</td></tr><tr><td style="text-align:left">北非的共和国</td><td style="text-align:left">阿拉伯语</td><td style="text-align:left">ar</td><td style="text-align:left">TN</td></tr><tr><td style="text-align:left">阿拉伯联合酋长国</td><td style="text-align:left">阿拉伯语</td><td style="text-align:left">ar</td><td style="text-align:left">AE</td></tr><tr><td style="text-align:left">也门</td><td style="text-align:left">阿拉伯语</td><td style="text-align:left">ar</td><td style="text-align:left">YE</td></tr><tr><td style="text-align:left">亚美尼亚</td><td style="text-align:left">亚美尼亚语</td><td style="text-align:left">hy</td><td style="text-align:left">AM</td></tr><tr><td style="text-align:left">巴斯克</td><td style="text-align:left">巴斯克</td><td style="text-align:left">eu</td><td style="text-align:left">ES</td></tr><tr><td style="text-align:left">嘉泰罗尼亚</td><td style="text-align:left">嘉泰罗尼亚</td><td style="text-align:left">ca</td><td style="text-align:left">ES</td></tr><tr><td style="text-align:left">肯尼亚</td><td style="text-align:left">肯尼亚(Swahili)语</td><td style="text-align:left">sw</td><td style="text-align:left">KE</td></tr><tr><td style="text-align:left">克罗埃西亚</td><td style="text-align:left">克罗埃西亚</td><td style="text-align:left">hr</td><td style="text-align:left">HR</td></tr><tr><td style="text-align:left">加利西亚</td><td style="text-align:left">加利西亚</td><td style="text-align:left">gl</td><td style="text-align:left">ES</td></tr><tr><td style="text-align:left">格鲁吉亚州</td><td style="text-align:left">格鲁吉亚州</td><td style="text-align:left">ka</td><td style="text-align:left">GE</td></tr><tr><td style="text-align:left">哈萨克</td><td style="text-align:left">Kyrgyz</td><td style="text-align:left">ky</td><td style="text-align:left">KZ</td></tr><tr><td style="text-align:left">拉脱维亚</td><td style="text-align:left">拉脱维亚</td><td style="text-align:left">lv</td><td style="text-align:left">LV</td></tr><tr><td style="text-align:left">立陶宛</td><td style="text-align:left">立陶宛</td><td style="text-align:left">lt</td><td style="text-align:left">LT</td></tr><tr><td style="text-align:left">马其顿</td><td style="text-align:left">马其顿</td><td style="text-align:left">mk</td><td style="text-align:left">MK</td></tr><tr><td style="text-align:left">汶莱</td><td style="text-align:left">马来语</td><td style="text-align:left">ms</td><td style="text-align:left">BN</td></tr><tr><td style="text-align:left">马来西亚</td><td style="text-align:left">马来西亚语</td><td style="text-align:left">ms</td><td style="text-align:left">MY</td></tr><tr><td style="text-align:left">蒙古</td><td style="text-align:left">蒙古</td><td style="text-align:left">mn</td><td style="text-align:left">MN</td></tr><tr><td style="text-align:left">罗马尼亚</td><td style="text-align:left">罗马尼亚语</td><td style="text-align:left">ro</td><td style="text-align:left">RO</td></tr><tr><td style="text-align:left">塞尔维亚(西里尔字母的)</td><td style="text-align:left">sr-SP-Cyrl</td><td style="text-align:left"></td><td style="text-align:left"></td></tr><tr><td style="text-align:left">塞尔(拉丁文)</td><td style="text-align:left">sr-SP-Latn</td><td style="text-align:left"></td><td style="text-align:left"></td></tr><tr><td style="text-align:left">斯洛伐克</td><td style="text-align:left">斯洛伐克</td><td style="text-align:left">sk</td><td style="text-align:left">SK</td></tr><tr><td style="text-align:left">斯洛文尼亚</td><td style="text-align:left">斯洛文尼亚</td><td style="text-align:left">sl</td><td style="text-align:left">SI</td></tr><tr><td style="text-align:left">乌兹别克</td><td style="text-align:left">乌兹别克(西里尔字母的)</td><td style="text-align:left">uz</td><td style="text-align:left">uz-UZ-Cyrl</td></tr><tr><td style="text-align:left">乌兹别克</td><td style="text-align:left">乌兹别克(拉丁文的)</td><td style="text-align:left">uz</td><td style="text-align:left">UZ-Latn</td></tr><tr><td style="text-align:left">塞浦路斯</td><td style="text-align:left">希腊文</td><td style="text-align:left">el</td><td style="text-align:left">CY</td></tr><tr><td style="text-align:left">英语(全球)</td><td style="text-align:left">en-WW</td><td style="text-align:left"></td></tr></tbody></table><blockquote><p>内容转载于<a href="https://www.cnblogs.com/isdom/p/webclips009.html" target="_blank" rel="noopener">https://www.cnblogs.com/isdom/p/webclips009.html</a></p></blockquote><p>更为详细的一个表格：</p><table><thead><tr><th>Language</th><th>English Name</th><th>Chinese Name</th><th>Code</th><th>GB</th><th>ICS</th><th>JB</th><th>KK</th></tr></thead><tbody><tr><td>العربية</td><td>Arabic(Israel)</td><td>阿拉伯语(以色列)</td><td>ar_IL</td><td>Y</td><td>Y</td><td>Y</td><td>Y</td></tr><tr><td></td><td>Arabic(Egypt)</td><td>阿拉伯语(埃及)</td><td>ar_EG</td><td>GD_MN</td><td>GD_MN</td><td>GD_MN</td><td>GD_MN</td></tr><tr><td>中文</td><td>Chinese Simplified</td><td>中文简体</td><td>zh_TW</td><td>Y</td><td>Y</td><td>Y</td><td>Y</td></tr><tr><td></td><td>Chinese Tradition</td><td>中文繁体</td><td>zh_CN</td><td>Y</td><td>Y</td><td>Y</td><td>Y</td></tr><tr><td></td><td>Chinese</td><td>中文(香港)</td><td>zh_HK</td><td>N</td><td>N</td><td>P</td><td>P</td></tr><tr><td>Nederlands</td><td>Dutch (Netherlands)</td><td>荷兰语</td><td>nl_NL</td><td>Y</td><td>Y</td><td>Y</td><td>Y</td></tr><tr><td></td><td>Dutch (Netherlands)</td><td>荷兰语(比利时)</td><td>nl_BE</td><td>GD_MN</td><td>GD_MN</td><td>GD_MN</td><td>GD_MN</td></tr><tr><td>English</td><td>English(United States)</td><td>英语(美国)</td><td>en_US</td><td>Y</td><td>Y</td><td>Y</td><td>Y</td></tr><tr><td></td><td>English(Australia)</td><td>英语(澳大利亚)</td><td>en_AU</td><td>GD_MN</td><td>GD_MN</td><td>GD_MN</td><td>GD_MN</td></tr><tr><td></td><td>English(Canada)</td><td>英语(加拿大)</td><td>en_CA</td><td>GD_MN</td><td>GD_MN</td><td>GD_MN</td><td>GD_MN</td></tr><tr><td></td><td>English(India)</td><td>英语(印度)</td><td>en_IN</td><td>GD_MN</td><td>GD_MN</td><td>GD_MN</td><td>GD_MN</td></tr><tr><td></td><td>English(Ireland)</td><td>英语(爱尔兰)</td><td>en_IE</td><td>GD_MN</td><td>GD_MN</td><td>GD_MN</td><td>GD_MN</td></tr><tr><td></td><td>English(New Zealand)</td><td>英语(新西兰)</td><td>en_NZ</td><td>GD_MN</td><td>GD_MN</td><td>GD_MN</td><td>GD_MN</td></tr><tr><td></td><td>English(Singapore)</td><td>英语(新加波)</td><td>en_SG</td><td>GD_MN</td><td>GD_MN</td><td>GD_MN</td><td>GD_MN</td></tr><tr><td></td><td>English(South Africa)</td><td>英语(南非)</td><td>en_ZA</td><td>GD_MN</td><td>GD_MN</td><td>GD_MN</td><td>GD_MN</td></tr><tr><td></td><td>English(United Kingdom)</td><td>英语(英国)</td><td>en_GB</td><td>GD_MN</td><td>GD_MN</td><td>GD_MN</td><td>Y</td></tr><tr><td>Français</td><td>French</td><td>法语</td><td>fr_FR</td><td>Y</td><td>Y</td><td>Y</td><td>Y</td></tr><tr><td></td><td>French</td><td>法语(比利时)</td><td>fr_BE</td><td>GD_MN</td><td>GD_MN</td><td>GD_MN</td><td>GD_MN</td></tr><tr><td></td><td>French</td><td>法语(加拿大)</td><td>fr_CA</td><td>GD_MN</td><td>GD_MN</td><td>GD_MN</td><td>GD_MN</td></tr><tr><td></td><td>French</td><td>法语(瑞士)</td><td>fr_CH</td><td>GD_MN</td><td>GD_MN</td><td>GD_MN</td><td>GD_MN</td></tr><tr><td>Deutsch</td><td>German</td><td>德语</td><td>de_DE</td><td>Y</td><td>Y</td><td>Y</td><td>Y</td></tr><tr><td></td><td>German</td><td>德语(列支敦斯登)</td><td>de_LI</td><td>GD_MN</td><td>GD_MN</td><td>GD_MN</td><td>GD_MN</td></tr><tr><td></td><td>German</td><td>德语(奥地利)</td><td>de_AT</td><td>GD_MN</td><td>GD_MN</td><td>GD_MN</td><td>Y</td></tr><tr><td></td><td>German</td><td>德语(瑞士)</td><td>de_CH</td><td>GD_MN</td><td>GD_MN</td><td>GD_MN</td><td>GD_MN</td></tr><tr><td>Italiano</td><td>Italian</td><td>意大利语</td><td>it_IT</td><td>Y</td><td>Y</td><td>Y</td><td>Y</td></tr><tr><td></td><td>Italian</td><td>意大利语(瑞士)</td><td>it_CH</td><td>GD_MN</td><td>GD_MN</td><td>GD_MN</td><td>GD_MN</td></tr><tr><td>Protuguês</td><td>Portuguese</td><td>葡萄牙语（巴西）</td><td>pt_BR</td><td>Y</td><td>Y</td><td>Y</td><td>Y</td></tr><tr><td></td><td>Portuguese</td><td>葡萄牙语</td><td>pt_PT</td><td>Y</td><td>Y</td><td>Y</td><td>Y</td></tr><tr><td>Español</td><td>Spanish</td><td>西班牙语</td><td>es_ES</td><td>Y</td><td>Y</td><td>Y</td><td>Y</td></tr><tr><td></td><td>Spanish</td><td>西班牙语(美国)</td><td>es_US</td><td>GD_MN</td><td>GD_MN</td><td>P</td><td>Y</td></tr><tr><td>বাংলা</td><td>Bengali</td><td>孟加拉语</td><td>bn_BD</td><td>Y</td><td>N</td><td>N</td><td>N</td></tr><tr><td></td><td>Bengali</td><td>孟加拉语(印度)</td><td>bn_IN</td><td>Y</td><td>Y</td><td>Y</td><td>Y</td></tr><tr><td>hrvatski</td><td>Croatian</td><td>克罗地亚语</td><td>hr_HR</td><td>GD_MN</td><td>GD_MN</td><td>P</td><td>Y</td></tr><tr><td>čeština</td><td>Czech</td><td>捷克语</td><td>cs_CZ</td><td>Y</td><td>Y</td><td>Y</td><td>Y</td></tr><tr><td>Dansk</td><td>Danish</td><td>丹麦语</td><td>da_DK</td><td>GD_MN</td><td>GD_MN</td><td>P</td><td>Y</td></tr><tr><td>ελληνικά</td><td>Greek</td><td>希腊语</td><td>el_GR</td><td>GD_MN</td><td>Y</td><td>Y</td><td>Y</td></tr><tr><td>עברית</td><td>Hebrew</td><td>希伯来语(以色列)</td><td>he_IL</td><td>GD_MN</td><td>GD_MN</td><td>GD_MN</td><td>GD_MN</td></tr><tr><td></td><td>Hebrew</td><td>希伯来语(以色列)</td><td>iw_IL</td><td>GD_MN</td><td>GD_MN</td><td>Y</td><td>Y</td></tr><tr><td>हिंदी</td><td>Hindi</td><td>印度语</td><td>hi_IN</td><td>Y</td><td>Y</td><td>Y</td><td>Y</td></tr><tr><td>Magyar</td><td>Hungarian</td><td>匈牙利语</td><td>hu_HU</td><td>GD_MN</td><td>Y</td><td>Y</td><td>Y</td></tr><tr><td></td><td>Indonesian</td><td>印度尼西亚语</td><td>in_ID</td><td>Y</td><td>Y</td><td>Y</td><td>Y</td></tr><tr><td>日本語の言語</td><td>Japanese</td><td>日语</td><td>ja_JP</td><td>GD_MN</td><td>GD_MN</td><td>P</td><td>P</td></tr><tr><td>한국의</td><td>Korean</td><td>韩语（朝鲜语）</td><td>ko_KR</td><td>GD_MN</td><td>GD_MN</td><td>Y</td><td>Y</td></tr><tr><td>Bahasa Melayu</td><td>Malay</td><td>马来语</td><td>ms_MY</td><td>Y</td><td>Y</td><td>Y</td><td>Y</td></tr><tr><td>فارسی</td><td>Perisan</td><td>波斯语</td><td>fa_IR</td><td>Y</td><td>Y</td><td>Y</td><td>Y</td></tr><tr><td>Polski</td><td>Polish</td><td>波兰语</td><td>pl_PL</td><td>GD_MN</td><td>GD_MN</td><td>P</td><td>Y</td></tr><tr><td>româna</td><td>Romanian</td><td>罗马尼亚语</td><td>ro_RO</td><td>GD_MN</td><td>Y</td><td>Y</td><td>Y</td></tr><tr><td>Русский</td><td>Russian</td><td>俄罗斯语</td><td>ru_RU</td><td>Y</td><td>Y</td><td>Y</td><td>Y</td></tr><tr><td>српски</td><td>Serbian</td><td>塞尔维亚语</td><td>sr_RS</td><td>GD_MN</td><td>GD_MN</td><td>P</td><td>P</td></tr><tr><td>Svenska</td><td>Swedish</td><td>瑞典语</td><td>sv_SE</td><td>GD_MN</td><td>GD_MN</td><td>P</td><td>Y</td></tr><tr><td>ไทย</td><td>Thai</td><td>泰语</td><td>th_TH</td><td>Y</td><td>Y</td><td>Y</td><td>Y</td></tr><tr><td>Türkçe</td><td>Turkey</td><td>土耳其语</td><td>tr_TR</td><td>Y</td><td>Y</td><td>Y</td><td>Y</td></tr><tr><td>اردو</td><td>Urdu</td><td>乌尔都语</td><td>ur_PK</td><td>Y</td><td>Y</td><td>Y</td><td>Y</td></tr><tr><td>tiếng việt</td><td>Vietnamese</td><td>越南语</td><td>vi_VN</td><td>Y</td><td>Y</td><td>Y</td><td>Y</td></tr><tr><td>catalá</td><td>Catalan</td><td>加泰隆语(西班牙)</td><td>ca_ES</td><td>GD_MN</td><td>GD_MN</td><td>P</td><td>P</td></tr><tr><td>latviešu</td><td>Latviesu</td><td>拉脱维亚语</td><td>lv_LV</td><td>GD_MN</td><td>GD_MN</td><td>P</td><td>Y</td></tr><tr><td>Lietuvių</td><td>Lithuanian</td><td>立陶宛语</td><td>lt_LT</td><td>GD_MN</td><td>GD_MN</td><td>P</td><td>Y</td></tr><tr><td>Norsk bokmal</td><td>Norwegian</td><td>挪威语</td><td>nb_NO</td><td>GD_MN</td><td>GD_MN</td><td>P</td><td>Y</td></tr><tr><td>Slovenčina</td><td>slovencina</td><td>斯洛伐克语</td><td>sk_SK</td><td>GD_MN</td><td>GD_MN</td><td>P</td><td>Y</td></tr><tr><td>Slovenščina</td><td>Slovenian</td><td>斯洛文尼亚语</td><td>sl_SI</td><td>GD_MN</td><td>GD_MN</td><td>P</td><td>P</td></tr><tr><td>български</td><td>bulgarian</td><td>保加利亚语</td><td>bg_BG</td><td>GD_MN</td><td>GD_MN</td><td>P</td><td>Y</td></tr><tr><td>українська</td><td>Ukrainian</td><td>乌克兰语</td><td>uk_UA</td><td>GD_MN</td><td>GD_MN</td><td>P</td><td>Y</td></tr><tr><td>Tagalog</td><td>Filipino</td><td>菲律宾语</td><td>tl_PH</td><td>GD_MN</td><td>Y</td><td>Y</td><td>Y</td></tr><tr><td>Suomi</td><td>Finnish</td><td>芬兰语</td><td>fi_FI</td><td>GD_MN</td><td>GD_MN</td><td>P</td><td>Y</td></tr><tr><td>Afrikaans</td><td>Afrikaans</td><td>南非语</td><td>af_ZA</td><td>N</td><td>GD_MN</td><td>GD_MN</td><td>GD_MN</td></tr><tr><td>Rumantsch</td><td>Romansh</td><td>罗曼什语(瑞士)</td><td>rm_CH</td><td>GD_MN</td><td>GD_MN</td><td>GD_MN</td><td>GD_MN</td></tr><tr><td>ဗမာ</td><td>Burmese(Zawgyi)</td><td>缅甸语(民间)</td><td>my_ZG</td><td>N</td><td>N</td><td>P</td><td>P</td></tr><tr><td></td><td>Burmese(Paduak)</td><td>缅甸语(官方)</td><td>my_MM</td><td>N</td><td>N</td><td>Y</td><td>Y</td></tr><tr><td>មែរ</td><td>Khmer</td><td>柬埔寨语</td><td>km_KH</td><td>N</td><td>N</td><td>Y</td><td>Y</td></tr><tr><td>አማርኛ</td><td>Amharic</td><td>阿姆哈拉语(埃塞俄比亚)</td><td>am_ET</td><td>N</td><td>GD_MN</td><td>GD_MN</td><td>GD_MN</td></tr><tr><td>беларуская</td><td>Belarusian</td><td>白俄罗斯语</td><td>be_BY</td><td>N</td><td>GD_MN</td><td>GD_MN</td><td>GD_MN</td></tr><tr><td>eesti</td><td>Estonian</td><td>爱沙尼亚语</td><td>et_EE</td><td>N</td><td>GD_MN</td><td>P</td><td>P</td></tr><tr><td>Kiswahili</td><td>Swahili</td><td>斯瓦希里语(坦桑尼亚)</td><td>sw_TZ</td><td>N</td><td>GD_MN</td><td>GD_MN</td><td>GD_MN</td></tr><tr><td>isiZulu</td><td>Zulu</td><td>祖鲁语(南非)</td><td>zu_ZA</td><td>N</td><td>GD_MN</td><td>GD_MN</td><td>GD_MN</td></tr><tr><td>azərbaycanca</td><td>Azerbaijani</td><td>阿塞拜疆语</td><td>az_AZ</td><td>N</td><td>N</td><td>N</td><td>GD_MN</td></tr><tr><td>Հայերէն</td><td>Armenian</td><td>亚美尼亚语(亚美尼亚)</td><td>hy_AM</td><td>N</td><td>N</td><td>P</td><td>P</td></tr><tr><td>ქართული</td><td>Georgian</td><td>格鲁吉亚语(格鲁吉亚)</td><td>ka_GE</td><td>N</td><td>N</td><td>N</td><td>GD_MN</td></tr><tr><td>ລາວ</td><td>Laotian</td><td>老挝语(老挝)</td><td>lo_LA</td><td>N</td><td>N</td><td>N</td><td>GD_MN</td></tr><tr><td>Монгол</td><td>Mongolian</td><td>蒙古语</td><td>mn_MN</td><td>N</td><td>N</td><td>N</td><td>GD_MN</td></tr><tr><td>नेपाली</td><td>Nepali</td><td>尼泊尔语</td><td>ne_NP</td><td>N</td><td>N</td><td>N</td><td>GD_MN</td></tr><tr><td>қазақ тілі</td><td>Kazakh</td><td>哈萨克语</td><td>kk_KZ</td><td>N</td><td>N</td><td>P</td><td>P</td></tr><tr><td>සිංහල</td><td>Sinhala</td><td>僧加罗语(斯里兰卡)</td><td>si_LK</td><td>N</td><td>N</td><td>N</td><td>GD_MN</td></tr></tbody></table><blockquote><p>1、标记“N”表示当前版本不支持；标记“Y”表示mtk、google均支持；标记“GD_MN”表示Google默认支持，MTK不支持。<br>2、对于GD_MN，如果要支持的话，只需翻译mtk新增的部分字串就行。<br>3、如若打开或者添加语言，可以参考如下FAQ，<br>   如何打开一种语言：FAQ04326<br>4、标记“P”是mtk后面新支持的一些语言,如果要支持，可以通过PMS系统直接申请Patch，ALPS01686452  支持除民间缅甸语以外所有版本的多国语言（这个PATCH的民间缅甸语只支持KK.MP1 , KK.MP6 , KK.MP7）<br>5、关于民间缅甸语的情况<br>目前MTK JB3.MP,JB5.MP,JB9.MP,KK.MP1,KK.MP6已经可以支持Zawgyi。如果需要的话可以通过PMS系统申请patch,请按以下操作：<br>1).申请strings patch 和字库PATCH<br>   JBX:<br>      ALPS01561463<br>      ALPS01400558<br>      ALPS01444813<br>      ALPS01444868<br>KK.MP1 , KK.MP6 , KK.MP7<br>ALPS01686452<br>3).需要注意的是padauk(my_MM)和zawgyi(my_ZG)不能同时开,只能打开一个.<br>4)如果遇到访问一些缅甸语语网站时出现大量圈圈，可能是该网站是民间缅甸语网站，可以申请这些patch</p></blockquote><p>摘抄自：<a href="https://blog.csdn.net/ouyang_peng/article/details/50209789" target="_blank" rel="noopener">https://blog.csdn.net/ouyang_peng/article/details/50209789</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;i18n(国际化) 和l18n(本地化)时的地域标识代码 格式如 zh-CN(语言-国家)&lt;/p&gt;
    
    </summary>
    
      <category term="程序人生" scheme="http://hackycy.github.io/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/"/>
    
    
      <category term="i18n" scheme="http://hackycy.github.io/tags/i18n/"/>
    
  </entry>
  
  <entry>
    <title>网页布局之Flex布局</title>
    <link href="http://hackycy.github.io/2019/12/14/%E7%BD%91%E9%A1%B5%E5%B8%83%E5%B1%80%E4%B9%8BFlex%E5%B8%83%E5%B1%80/"/>
    <id>http://hackycy.github.io/2019/12/14/网页布局之Flex布局/</id>
    <published>2019-12-14T03:24:47.000Z</published>
    <updated>2019-12-15T09:03:57.121Z</updated>
    
    <content type="html"><![CDATA[<p>网页布局（layout）是 CSS 的一个重点应用。布局的传统解决方案，基于<a href="https://developer.mozilla.org/en-US/docs/Web/CSS/box_model" target="_blank" rel="noopener">盒状模型</a>，依赖 <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/display" target="_blank" rel="noopener"><code>display</code></a> 属性 + <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/position" target="_blank" rel="noopener"><code>position</code></a>属性 + <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/float" target="_blank" rel="noopener"><code>float</code></a>属性。它对于那些特殊布局非常不方便，比如，<a href="https://css-tricks.com/centering-css-complete-guide/" target="_blank" rel="noopener">垂直居中</a>就不容易实现。</p><a id="more"></a><p><img src="flexbg.png" alt></p><p>2009年，W3C 提出了一种新的方案—-Flex 布局，可以简便、完整、响应式地实现各种页面布局。目前，它已经得到了所有浏览器的支持，这意味着，现在就能很安全地使用这项功能。</p><p><img src="caniuseflex.png" alt></p><h1 id="Flex布局是什么"><a href="#Flex布局是什么" class="headerlink" title="Flex布局是什么"></a>Flex布局是什么</h1><p>Flex是Flexible Box的缩写。译为“弹性布局”，用来作为盒状模型提供最大的灵活性。</p><p>任何一个容器都可以指定为Flex布局。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span>&#123;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>行内元素也可以使用Flex布局。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span>&#123;</span><br><span class="line">  <span class="attribute">display</span>: inline-flex;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Webkit内核的浏览器，必须加上<code>-webkit</code>前缀。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span>&#123;</span><br><span class="line">  <span class="attribute">display</span>: -webkit-flex;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意，设为 Flex 布局以后，子元素的<code>float</code>、<code>clear</code>和<code>vertical-align</code>属性将失效。</p></blockquote><h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><p>采用 Flex 布局的元素，称为 Flex 容器（flex container），简称”容器”。它的所有子元素自动成为容器成员，称为 Flex 项目（flex item），简称”项目”。</p><p>我们把一个容器的 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/display" target="_blank" rel="noopener"><code>display</code></a> 属性值改为 <code>flex</code> 或者 <code>inline-flex</code> 完成这一步之后，容器中的直系子元素就会变为 <strong>flex 元素</strong>。所有CSS属性都会有一个初始值，所以 flex 容器中的所有 flex 元素都会有下列行为：</p><ul><li>元素排列为一行 (<code>flex-direction</code> 属性的初始值是 <code>row</code>)。</li><li>元素从主轴的起始线开始。</li><li>元素不会在主维度方向拉伸，但是可以缩小。</li><li>元素被拉伸来填充交叉轴大小。</li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/flex-basis" target="_blank" rel="noopener"><code>flex-basis</code></a> 属性为 <code>auto。</code></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/flex-wrap" target="_blank" rel="noopener"><code>flex-wrap</code></a> 属性为 <code>nowrap。</code></li></ul><p>容器默认存在两根轴：主轴和交叉轴。主轴由 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/flex-direction" target="_blank" rel="noopener"><code>flex-direction</code></a> 定义，另一根轴垂直于它。而Flexbox的所有属性都与这两根主轴有关。</p><h2 id="主轴"><a href="#主轴" class="headerlink" title="主轴"></a>主轴</h2><p>主轴（main axis）由<code>flex-direction</code>定义，可以取四个值。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flex-direction: column | column-reverse | row | row-reverse;</span><br></pre></td></tr></table></figure><blockquote><p>选择了 <code>row</code> 或者 <code>row-reverse</code>，你的主轴将沿着 <strong>inline</strong> 方向延伸。</p><p>选择 <code>column</code> 或者 <code>column-reverse</code> 时，你的主轴会沿着上下方向延伸 — 也就是 <strong>block 排列的方向。</strong></p></blockquote><h2 id="交叉轴"><a href="#交叉轴" class="headerlink" title="交叉轴"></a>交叉轴</h2><p>交叉轴（cross axis）垂直于主轴</p><blockquote><p><code>flex-direction</code> (主轴) 设成了 <code>row</code> 或者 <code>row-reverse</code> 的话，交叉轴的方向就是沿着列向下的。</p><p>主轴方向设成了 <code>column</code> 或者 <code>column-reverse</code>，交叉轴就是水平方向。</p></blockquote><h2 id="起始线和终止线"><a href="#起始线和终止线" class="headerlink" title="起始线和终止线"></a>起始线和终止线</h2><p>主轴的开始位置（与边框的交叉点）叫做<code>main start</code>，结束位置叫做<code>main end</code>；交叉轴的开始位置叫做<code>cross start</code>，结束位置叫做<code>cross end</code>。</p><p>项目默认沿主轴排列。单个项目占据的主轴空间叫做<code>main size</code>，占据的交叉轴空间叫做<code>cross size</code>。</p><p><img src="axis.png" alt></p><h1 id="容器的属性"><a href="#容器的属性" class="headerlink" title="容器的属性"></a>容器的属性</h1><p>以下6个属性设置在容器上。</p><ul><li>flex-direction</li><li>flex-wrap</li><li>flex-flow</li><li>justify-content</li><li>align-items</li><li>align-content</li></ul><h2 id="flex-direction属性"><a href="#flex-direction属性" class="headerlink" title="flex-direction属性"></a>flex-direction属性</h2><p><code>flex-direction</code>属性决定主轴的方向（即项目的排列方向）。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flex-direction: row | row-reverse | column | column-reverse;</span><br></pre></td></tr></table></figure><p>它可能取四个值：</p><ul><li><code>row</code>（默认值）：主轴为水平方向，起点在左端。</li><li><code>row-reverse</code>：主轴为水平方向，起点在右端。</li><li><code>column</code>：主轴为垂直方向，起点在上沿。</li><li><code>column-reverse</code>：主轴为垂直方向，起点在下沿。</li></ul><p><img src="flexdirection.png" alt></p><h2 id="flex-wrap属性"><a href="#flex-wrap属性" class="headerlink" title="flex-wrap属性"></a>flex-wrap属性</h2><p>默认情况下，项目都排在一条线（又称”轴线”）上。<code>flex-wrap</code>属性定义，如果一条轴线排不下，如何换行。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flex-wrap: nowrap | wrap | wrap-reverse;</span><br></pre></td></tr></table></figure><p>它可能取三个值：</p><ul><li><code>nowrap</code>（默认）：不换行。</li><li><code>wrap</code>：换行，第一行在上方。</li><li><code>wrap-reverse</code>：换行，第一行在下方。</li></ul><p><img src="flexwrap.png" alt></p><h2 id="flex-flow属性"><a href="#flex-flow属性" class="headerlink" title="flex-flow属性"></a>flex-flow属性</h2><p><code>flex-flow</code>属性是<code>flex-direction</code>属性和<code>flex-wrap</code>属性的简写形式，默认值为<code>row nowrap</code>。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flex-flow: &lt;flex-direction&gt; || &lt;flex-wrap&gt;;</span><br></pre></td></tr></table></figure><h2 id="justify-content属性"><a href="#justify-content属性" class="headerlink" title="justify-content属性"></a>justify-content属性</h2><p><code>justify-content</code>属性定义了项目在主轴上的对齐方式。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">justify-content: flex-start | flex-end | center | space-between | space-around;</span><br></pre></td></tr></table></figure><p>它可能取5个值，具体对齐方式与轴的方向有关。</p><ul><li><code>flex-start</code>（默认值）：主轴的起点对齐</li><li><code>flex-end</code>：主轴的终点对齐</li><li><code>center</code>： 主轴的中点对齐</li><li><code>space-between</code>：主轴两端对齐，项目之间的间隔都相等。</li><li><code>space-around</code>：每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍。</li></ul><p><img src="justifycontent.png" alt></p><h2 id="align-items属性"><a href="#align-items属性" class="headerlink" title="align-items属性"></a>align-items属性</h2><p><code>align-items</code>属性定义项目在交叉轴上如何对齐。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">align-items: flex-start | flex-end | center | baseline | stretch;</span><br></pre></td></tr></table></figure><p>它可能取5个值。具体的对齐方式与交叉轴的方向有关，下面假设交叉轴从上到下。</p><ul><li><code>flex-start</code>：交叉轴的起点对齐。</li><li><code>flex-end</code>：交叉轴的终点对齐。</li><li><code>center</code>：交叉轴的中点对齐。</li><li><code>baseline</code>: 项目的第一行文字的基线对齐。</li><li><code>stretch</code>（默认值）：如果项目未设置高度或设为auto，将占满整个容器的高度。</li></ul><p><img src="alignitems.png" alt></p><h2 id="align-content属性"><a href="#align-content属性" class="headerlink" title="align-content属性"></a>align-content属性</h2><p><code>align-content</code>属性定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。</p><p>即该属性对单行弹性盒子模型无效。（即：带有 <code>flex-wrap: nowrap</code>）。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">align-content: flex-start | flex-end | center | space-between | space-around | stretch;</span><br></pre></td></tr></table></figure><p>该属性可能取6个值。</p><ul><li><code>flex-start</code>：与交叉轴的起点对齐。</li><li><code>flex-end</code>：与交叉轴的终点对齐。</li><li><code>center</code>：与交叉轴的中点对齐。</li><li><code>space-between</code>：与交叉轴两端对齐，轴线之间的间隔平均分布。</li><li><code>space-around</code>：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍。</li><li><code>stretch</code>（默认值）：轴线占满整个交叉轴。</li></ul><p><img src="aligncontent.png" alt></p><h1 id="项目的属性"><a href="#项目的属性" class="headerlink" title="项目的属性"></a>项目的属性</h1><p>以下6个属性设置在项目上。</p><ul><li><code>order</code></li><li><code>flex-grow</code></li><li><code>flex-shrink</code></li><li><code>flex-basis</code></li><li><code>flex</code></li><li><code>align-self</code></li></ul><h2 id="order属性"><a href="#order属性" class="headerlink" title="order属性"></a>order属性</h2><p><code>order</code>属性定义项目的排列顺序。数值越小，排列越靠前，默认为0。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">order</span>: &lt;<span class="selector-tag">integer</span>&gt;; <span class="comment">/* default 0 */</span></span><br></pre></td></tr></table></figure><p><img src="order.png" alt></p><h2 id="flex-grow属性"><a href="#flex-grow属性" class="headerlink" title="flex-grow属性"></a>flex-grow属性</h2><p><code>flex-grow</code>属性定义项目的放大比例，默认为<code>0</code>，即如果存在剩余空间，也不放大。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">flex-grow</span>: &lt;<span class="selector-tag">number</span>&gt;; <span class="comment">/* default 0 */</span></span><br></pre></td></tr></table></figure><p><img src="flexgrow.png" alt></p><p>如果所有项目的<code>flex-grow</code>属性都为1，则它们将等分剩余空间（如果有的话）。如果一个项目的<code>flex-grow</code>属性为2，其他项目都为1，则前者占据的剩余空间将比其他项多一倍。</p><h2 id="flex-shrink属性"><a href="#flex-shrink属性" class="headerlink" title="flex-shrink属性"></a>flex-shrink属性</h2><p><code>flex-shrink</code>属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">flex-shrink</span>: &lt;<span class="selector-tag">number</span>&gt;; <span class="comment">/* default 1 */</span></span><br></pre></td></tr></table></figure><p><img src="flexshrink.png" alt></p><p>如果所有项目的<code>flex-shrink</code>属性都为1，当空间不足时，都将等比例缩小。如果一个项目的<code>flex-shrink</code>属性为0，其他项目都为1，则空间不足时，前者不缩小。</p><p>负值对该属性无效。</p><h2 id="flex-basis属性"><a href="#flex-basis属性" class="headerlink" title="flex-basis属性"></a>flex-basis属性</h2><p><code>flex-basis</code>属性定义了在分配多余空间之前，项目占据的主轴空间（main size）。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值是<code>auto</code>，即项目的本来大小。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flex-basis: &lt;length&gt; | auto; /* default auto */</span><br></pre></td></tr></table></figure><p>它可以设为跟<code>width</code>或<code>height</code>属性一样的值（比如350px），则项目将占据固定空间。</p><h2 id="flex属性"><a href="#flex属性" class="headerlink" title="flex属性"></a>flex属性</h2><p><code>flex</code>属性是<code>flex-grow</code>, <code>flex-shrink</code> 和 <code>flex-basis</code>的简写，默认值为<code>0 1 auto</code>。后两个属性可选。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flex: none | [ &lt;'flex-grow'&gt; &lt;'flex-shrink'&gt;? || &lt;'flex-basis'&gt; ]</span><br></pre></td></tr></table></figure><p>该属性有两个快捷值：<code>auto</code> (<code>1 1 auto</code>) 和 none (<code>0 0 auto</code>)。</p><p>建议优先使用这个属性，而不是单独写三个分离的属性，因为浏览器会推算相关值。</p><h2 id="align-self属性"><a href="#align-self属性" class="headerlink" title="align-self属性"></a>align-self属性</h2><p><code>align-self</code>属性允许单个项目有与其他项目不一样的对齐方式，可覆盖<code>align-items</code>属性。默认值为<code>auto</code>，表示继承父元素的<code>align-items</code>属性，如果没有父元素，则等同于<code>stretch</code>。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">align-self: auto | flex-start | flex-end | center | baseline | stretch;</span><br></pre></td></tr></table></figure><p>该属性可能取6个值，除了auto，其他都与align-items属性完全一致。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_Flexible_Box_Layout/Basic_Concepts_of_Flexbox" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_Flexible_Box_Layout/Basic_Concepts_of_Flexbox</a></p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_Box_Alignment/Box_Alignment_in_Flexbox" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_Box_Alignment/Box_Alignment_in_Flexbox</a></p><p><a href="http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;网页布局（layout）是 CSS 的一个重点应用。布局的传统解决方案，基于&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/CSS/box_model&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;盒状模型&lt;/a&gt;，依赖 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/CSS/display&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;&lt;code&gt;display&lt;/code&gt;&lt;/a&gt; 属性 + &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/CSS/position&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;&lt;code&gt;position&lt;/code&gt;&lt;/a&gt;属性 + &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/CSS/float&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;&lt;code&gt;float&lt;/code&gt;&lt;/a&gt;属性。它对于那些特殊布局非常不方便，比如，&lt;a href=&quot;https://css-tricks.com/centering-css-complete-guide/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;垂直居中&lt;/a&gt;就不容易实现。&lt;/p&gt;
    
    </summary>
    
      <category term="CSS" scheme="http://hackycy.github.io/categories/CSS/"/>
    
    
      <category term="CSS" scheme="http://hackycy.github.io/tags/CSS/"/>
    
      <category term="Flex布局" scheme="http://hackycy.github.io/tags/Flex%E5%B8%83%E5%B1%80/"/>
    
  </entry>
  
  <entry>
    <title>Docker入门（六）——Docker Compose</title>
    <link href="http://hackycy.github.io/2019/12/11/Docker%E5%85%A5%E9%97%A8%EF%BC%88%E5%85%AD%EF%BC%89%E2%80%94%E2%80%94Docker-Compose/"/>
    <id>http://hackycy.github.io/2019/12/11/Docker入门（六）——Docker-Compose/</id>
    <published>2019-12-11T03:43:25.000Z</published>
    <updated>2019-12-15T09:01:12.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Docker-Compose简介"><a href="#Docker-Compose简介" class="headerlink" title="Docker Compose简介"></a>Docker Compose简介</h1><p><code>Compose</code> 项目是 Docker 官方的开源项目，负责实现对 Docker 容器集群的快速编排。其代码目前在 <a href="https://github.com/docker/compose" target="_blank" rel="noopener">https://github.com/docker/compose</a> 上开源。</p><p><code>Compose</code> 定位是 「定义和运行多个 Docker 容器的应用（Defining and running multi-container Docker applications）」，其前身是开源项目 Fig。</p><a id="more"></a><p><code>Dockerfile</code> 模板文件可以让用户很方便的定义一个单独的应用容器。但是在平常使用中，经常会碰到需要多个容器相互配合来完成某项任务的情况。例如要实现一个 Web 项目，除了 Web 服务容器本身，往往还需要再加上后端的数据库服务容器，甚至还包括负载均衡容器等。</p><p><code>Compose</code> 恰好满足了这样的需求。它允许用户通过一个单独的 <code>docker-compose.yml</code> 模板文件（YAML 格式）来定义一组相关联的应用容器为一个项目（project）。</p><p><strong><code>Compose</code> 中有两个重要的概念：</strong></p><ul><li>服务 (<code>service</code>)：一个应用的容器，实际上可以包括若干运行相同镜像的容器实例。</li><li>项目 (<code>project</code>)：由一组关联的应用容器组成的一个完整业务单元，在 <code>docker-compose.yml</code> 文件中定义。</li></ul><p><code>Compose</code> 的默认管理对象是项目，通过子命令对项目中的一组容器进行便捷地生命周期管理。</p><p><code>Compose</code> 项目由 Python 编写，实现上调用了 Docker 服务提供的 API 来对容器进行管理。因此，只要所操作的平台支持 Docker API，就可以在其上利用 <code>Compose</code> 来进行编排管理。</p><h1 id="安装与卸载"><a href="#安装与卸载" class="headerlink" title="安装与卸载"></a>安装与卸载</h1><p><code>Compose</code> 支持 Linux、macOS、Windows 10 三大平台。</p><p><code>Compose</code> 可以通过 Python 的包管理工具 <code>pip</code> 进行安装，也可以直接下载编译好的二进制文件使用，甚至能够直接在 Docker 容器中运行。</p><p><code>Docker Desktop for Mac/Windows</code> 自带 <code>docker-compose</code> 二进制文件，安装 Docker 之后可以直接使用。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ docker-compose --version</span><br><span class="line"></span><br><span class="line">docker-compose version 1.24.1, build 4667896b</span><br></pre></td></tr></table></figure><p>Linux 系统请使用以下介绍的方法安装。</p><h2 id="二进制包"><a href="#二进制包" class="headerlink" title="二进制包"></a>二进制包</h2><p>在 Linux 上的也安装十分简单，从 <a href="https://github.com/docker/compose/releases" target="_blank" rel="noopener">官方 GitHub Release</a> 处直接下载编译好的二进制文件即可。</p><p>例如，在 Linux 64 位系统上直接下载对应的二进制包。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ sudo curl -L https://github.com/docker/compose/releases/download/1.24.1/docker-compose-`uname -s`-`uname -m` &gt; /usr/<span class="built_in">local</span>/bin/docker-compose</span><br><span class="line"></span><br><span class="line">$ sudo chmod +x /usr/<span class="built_in">local</span>/bin/docker-compose</span><br></pre></td></tr></table></figure><h2 id="PIP-安装"><a href="#PIP-安装" class="headerlink" title="PIP 安装"></a>PIP 安装</h2><p><em>注：</em> <code>x86_64</code> 架构的 Linux 建议按照上边的方法下载二进制包进行安装，如果您计算机的架构是 <code>ARM</code> (例如，树莓派)，再使用 <code>pip</code> 安装。</p><p>这种方式是将 Compose 当作一个 Python 应用来从 pip 源中安装。</p><p>执行安装命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo pip install -U docker-compose</span><br></pre></td></tr></table></figure><p>可以看到类似如下输出，说明安装成功。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Collecting docker-compose</span><br><span class="line">  Downloading docker-compose-1.24.1.tar.gz (149kB): 149kB downloaded</span><br><span class="line">...</span><br><span class="line">Successfully installed docker-compose cached-property requests texttable websocket-client docker-py dockerpty six enum34 backports.ssl-match-hostname ipaddress</span><br></pre></td></tr></table></figure><h2 id="bash-补全命令"><a href="#bash-补全命令" class="headerlink" title="bash 补全命令"></a>bash 补全命令</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ curl -L https://raw.githubusercontent.com/docker/compose/1.24.1/contrib/completion/bash/docker-compose &gt; /etc/bash_completion.d/docker-compose</span><br></pre></td></tr></table></figure><h2 id="卸载"><a href="#卸载" class="headerlink" title="卸载"></a>卸载</h2><p>如果是二进制包方式安装的，删除二进制文件即可。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo rm /usr/<span class="built_in">local</span>/bin/docker-compose</span><br></pre></td></tr></table></figure><p>如果是通过 <code>pip</code> 安装的，则执行如下命令即可删除。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo pip uninstall docker-compose</span><br></pre></td></tr></table></figure><h1 id="Compose使用"><a href="#Compose使用" class="headerlink" title="Compose使用"></a>Compose使用</h1><h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><p>最常见的项目是 web 网站，该项目应该包含 web 应用和缓存。</p><h2 id="Web应用"><a href="#Web应用" class="headerlink" title="Web应用"></a>Web应用</h2><p>新建文件夹，在该目录中编写 <code>app.py</code> 文件</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask</span><br><span class="line"><span class="keyword">from</span> redis <span class="keyword">import</span> Redis</span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line">redis = Redis(host=<span class="string">'redis'</span>, port=<span class="number">6379</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route('/')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello</span><span class="params">()</span>:</span></span><br><span class="line">    count = redis.incr(<span class="string">'hits'</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'Hello World! 该页面已被访问 &#123;&#125; 次。\n'</span>.format(count)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    app.run(host=<span class="string">"0.0.0.0"</span>, debug=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure><h2 id="Dockerfile"><a href="#Dockerfile" class="headerlink" title="Dockerfile"></a>Dockerfile</h2><p>编写 <code>Dockerfile</code> 文件，内容为</p><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> python:<span class="number">3.6</span>-alpine</span><br><span class="line"><span class="keyword">ADD</span><span class="bash"> . /code</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> /code</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> pip install redis flask</span></span><br><span class="line"><span class="keyword">CMD</span><span class="bash"> [<span class="string">"python"</span>, <span class="string">"app.py"</span>]</span></span><br></pre></td></tr></table></figure><h2 id="docker-compose-yml"><a href="#docker-compose-yml" class="headerlink" title="docker-compose.yml"></a>docker-compose.yml</h2><p>编写 <code>docker-compose.yml</code> 文件，这个是 Compose 使用的主模板文件。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">'3'</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">web:</span></span><br><span class="line">    <span class="attr">build:</span> <span class="string">.</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">     <span class="bullet">-</span> <span class="string">"5000:5000"</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">redis:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">"redis:alpine"</span></span><br></pre></td></tr></table></figure><h2 id="运行compose项目"><a href="#运行compose项目" class="headerlink" title="运行compose项目"></a>运行compose项目</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker-compose up</span><br></pre></td></tr></table></figure><p>此时访问本地 <code>5000</code> 端口，每次刷新页面，计数就会加 1。</p><h1 id="命令说明"><a href="#命令说明" class="headerlink" title="命令说明"></a>命令说明</h1><h2 id="命令对象与格式"><a href="#命令对象与格式" class="headerlink" title="命令对象与格式"></a>命令对象与格式</h2><p>对于 Compose 来说，大部分命令的对象既可以是项目本身，也可以指定为项目中的服务或者容器。如果没有特别的说明，命令对象将是项目，这意味着项目中所有的服务都会受到命令影响。</p><p>执行 <code>docker-compose [COMMAND] --help</code> 或者 <code>docker-compose help [COMMAND]</code> 可以查看具体某个命令的使用格式。</p><p><code>docker-compose</code> 命令的基本的使用格式是</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose [-f=&lt;arg&gt;...] [options] [COMMAND] [ARGS...]</span><br></pre></td></tr></table></figure><h2 id="命令选项"><a href="#命令选项" class="headerlink" title="命令选项"></a>命令选项</h2><ul><li><code>-f, --file FILE</code> 指定使用的 Compose 模板文件，默认为 <code>docker-compose.yml</code>，可以多次指定。</li><li><code>-p, --project-name NAME</code> 指定项目名称，默认将使用所在目录名称作为项目名。</li><li><code>--x-networking</code> 使用 Docker 的可拔插网络后端特性</li><li><code>--x-network-driver DRIVER</code> 指定网络后端的驱动，默认为 <code>bridge</code></li><li><code>--verbose</code> 输出更多调试信息。</li><li><code>-v, --version</code> 打印版本并退出。</li></ul><h2 id="命令使用说明"><a href="#命令使用说明" class="headerlink" title="命令使用说明"></a>命令使用说明</h2><h3 id="build"><a href="#build" class="headerlink" title="build"></a><code>build</code></h3><p>格式为 <code>docker-compose build [options] [SERVICE...]</code>。</p><p>构建（重新构建）项目中的服务容器。</p><p>服务容器一旦构建后，将会带上一个标记名，例如对于 web 项目中的一个 db 容器，可能是 web_db。</p><p>可以随时在项目目录下运行 <code>docker-compose build</code> 来重新构建服务。</p><p>选项包括：</p><ul><li><code>--force-rm</code> 删除构建过程中的临时容器。</li><li><code>--no-cache</code> 构建镜像过程中不使用 cache（这将加长构建过程）。</li><li><code>--pull</code> 始终尝试通过 pull 来获取更新版本的镜像。</li></ul><h3 id="config"><a href="#config" class="headerlink" title="config"></a><code>config</code></h3><p>验证 Compose 文件格式是否正确，若正确则显示配置，若格式错误显示错误原因。</p><h3 id="down"><a href="#down" class="headerlink" title="down"></a><code>down</code></h3><p>此命令将会停止 <code>up</code> 命令所启动的容器，并移除网络</p><h3 id="exec"><a href="#exec" class="headerlink" title="exec"></a><code>exec</code></h3><p>进入指定的容器。</p><h3 id="help"><a href="#help" class="headerlink" title="help"></a><code>help</code></h3><p>获得一个命令的帮助。</p><h3 id="images"><a href="#images" class="headerlink" title="images"></a><code>images</code></h3><p>列出 Compose 文件中包含的镜像。</p><h3 id="kill"><a href="#kill" class="headerlink" title="kill"></a><code>kill</code></h3><p>格式为 <code>docker-compose kill [options] [SERVICE...]</code>。</p><p>通过发送 <code>SIGKILL</code> 信号来强制停止服务容器。</p><p>支持通过 <code>-s</code> 参数来指定发送的信号，例如通过如下指令发送 <code>SIGINT</code> 信号。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker-compose <span class="built_in">kill</span> -s SIGINT</span><br></pre></td></tr></table></figure><h3 id="logs"><a href="#logs" class="headerlink" title="logs"></a><code>logs</code></h3><p>格式为 <code>docker-compose logs [options] [SERVICE...]</code>。</p><p>查看服务容器的输出。默认情况下，docker-compose 将对不同的服务输出使用不同的颜色来区分。可以通过 <code>--no-color</code> 来关闭颜色。</p><p>该命令在调试问题的时候十分有用。</p><h3 id="pause"><a href="#pause" class="headerlink" title="pause"></a><code>pause</code></h3><p>格式为 <code>docker-compose pause [SERVICE...]</code>。</p><p>暂停一个服务容器。</p><h3 id="port"><a href="#port" class="headerlink" title="port"></a><code>port</code></h3><p>格式为 <code>docker-compose port [options] SERVICE PRIVATE_PORT</code>。</p><p>打印某个容器端口所映射的公共端口。</p><p>选项：</p><ul><li><code>--protocol=proto</code> 指定端口协议，tcp（默认值）或者 udp。</li><li><code>--index=index</code> 如果同一服务存在多个容器，指定命令对象容器的序号（默认为 1）。</li></ul><h3 id="ps"><a href="#ps" class="headerlink" title="ps"></a><code>ps</code></h3><p>格式为 <code>docker-compose ps [options] [SERVICE...]</code>。</p><p>列出项目中目前的所有容器。</p><p>选项：</p><ul><li><code>-q</code> 只打印容器的 ID 信息。</li></ul><h3 id="pull"><a href="#pull" class="headerlink" title="pull"></a><code>pull</code></h3><p>格式为 <code>docker-compose pull [options] [SERVICE...]</code>。</p><p>拉取服务依赖的镜像。</p><p>选项：</p><ul><li><code>--ignore-pull-failures</code> 忽略拉取镜像过程中的错误。</li></ul><h3 id="push"><a href="#push" class="headerlink" title="push"></a><code>push</code></h3><p>推送服务依赖的镜像到 Docker 镜像仓库。</p><h3 id="restart"><a href="#restart" class="headerlink" title="restart"></a><code>restart</code></h3><p>格式为 <code>docker-compose restart [options] [SERVICE...]</code>。</p><p>重启项目中的服务。</p><p>选项：</p><ul><li><code>-t, --timeout TIMEOUT</code> 指定重启前停止容器的超时（默认为 10 秒）。</li></ul><h3 id="rm"><a href="#rm" class="headerlink" title="rm"></a><code>rm</code></h3><p>格式为 <code>docker-compose rm [options] [SERVICE...]</code>。</p><p>删除所有（停止状态的）服务容器。推荐先执行 <code>docker-compose stop</code> 命令来停止容器。</p><p>选项：</p><ul><li><code>-f, --force</code> 强制直接删除，包括非停止状态的容器。一般尽量不要使用该选项。</li><li><code>-v</code> 删除容器所挂载的数据卷。</li></ul><h3 id="run"><a href="#run" class="headerlink" title="run"></a><code>run</code></h3><p>格式为 <code>docker-compose run [options] [-p PORT...] [-e KEY=VAL...] SERVICE [COMMAND] [ARGS...]</code>。</p><p>在指定服务上执行一个命令。</p><p>例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker-compose run ubuntu ping docker.com</span><br></pre></td></tr></table></figure><p>将会启动一个 ubuntu 服务容器，并执行 <code>ping docker.com</code> 命令。</p><p>默认情况下，如果存在关联，则所有关联的服务将会自动被启动，除非这些服务已经在运行中。</p><p>该命令类似启动容器后运行指定的命令，相关卷、链接等等都将会按照配置自动创建。</p><p>两个不同点：</p><ul><li>给定命令将会覆盖原有的自动运行命令；</li><li>不会自动创建端口，以避免冲突。</li></ul><p>如果不希望自动启动关联的容器，可以使用 <code>--no-deps</code> 选项，例如</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker-compose run --no-deps web python manage.py shell</span><br></pre></td></tr></table></figure><p>将不会启动 web 容器所关联的其它容器。</p><p>选项：</p><ul><li><code>-d</code> 后台运行容器。</li><li><code>--name NAME</code> 为容器指定一个名字。</li><li><code>--entrypoint CMD</code> 覆盖默认的容器启动指令。</li><li><code>-e KEY=VAL</code> 设置环境变量值，可多次使用选项来设置多个环境变量。</li><li><code>-u, --user=&quot;&quot;</code> 指定运行容器的用户名或者 uid。</li><li><code>--no-deps</code> 不自动启动关联的服务容器。</li><li><code>--rm</code> 运行命令后自动删除容器，<code>d</code> 模式下将忽略。</li><li><code>-p, --publish=[]</code> 映射容器端口到本地主机。</li><li><code>--service-ports</code> 配置服务端口并映射到本地主机。</li><li><code>-T</code> 不分配伪 tty，意味着依赖 tty 的指令将无法运行。</li></ul><h3 id="scale"><a href="#scale" class="headerlink" title="scale"></a><code>scale</code></h3><p>格式为 <code>docker-compose scale [options] [SERVICE=NUM...]</code>。</p><p>设置指定服务运行的容器个数。</p><p>通过 <code>service=num</code> 的参数来设置数量。例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker-compose scale web=3 db=2</span><br></pre></td></tr></table></figure><p>将启动 3 个容器运行 web 服务，2 个容器运行 db 服务。</p><p>一般的，当指定数目多于该服务当前实际运行容器，将新创建并启动容器；反之，将停止容器。</p><p>选项：</p><ul><li><code>-t, --timeout TIMEOUT</code> 停止容器时候的超时（默认为 10 秒）。</li></ul><h3 id="start"><a href="#start" class="headerlink" title="start"></a><code>start</code></h3><p>格式为 <code>docker-compose start [SERVICE...]</code>。</p><p>启动已经存在的服务容器。</p><h3 id="stop"><a href="#stop" class="headerlink" title="stop"></a><code>stop</code></h3><p>格式为 <code>docker-compose stop [options] [SERVICE...]</code>。</p><p>停止已经处于运行状态的容器，但不删除它。通过 <code>docker-compose start</code> 可以再次启动这些容器。</p><p>选项：</p><ul><li><code>-t, --timeout TIMEOUT</code> 停止容器时候的超时（默认为 10 秒）。</li></ul><h3 id="top"><a href="#top" class="headerlink" title="top"></a><code>top</code></h3><p>查看各个服务容器内运行的进程。</p><h3 id="unpause"><a href="#unpause" class="headerlink" title="unpause"></a><code>unpause</code></h3><p>格式为 <code>docker-compose unpause [SERVICE...]</code>。</p><p>恢复处于暂停状态中的服务。</p><h3 id="up"><a href="#up" class="headerlink" title="up"></a><code>up</code></h3><p>格式为 <code>docker-compose up [options] [SERVICE...]</code>。</p><p>该命令十分强大，它将尝试自动完成包括构建镜像，（重新）创建服务，启动服务，并关联服务相关容器的一系列操作。</p><p>链接的服务都将会被自动启动，除非已经处于运行状态。</p><p>可以说，大部分时候都可以直接通过该命令来启动一个项目。</p><p>默认情况，<code>docker-compose up</code> 启动的容器都在前台，控制台将会同时打印所有容器的输出信息，可以很方便进行调试。</p><p>当通过 <code>Ctrl-C</code> 停止命令时，所有容器将会停止。</p><p>如果使用 <code>docker-compose up -d</code>，将会在后台启动并运行所有的容器。一般推荐生产环境下使用该选项。</p><p>默认情况，如果服务容器已经存在，<code>docker-compose up</code> 将会尝试停止容器，然后重新创建（保持使用 <code>volumes-from</code> 挂载的卷），以保证新启动的服务匹配 <code>docker-compose.yml</code> 文件的最新内容。如果用户不希望容器被停止并重新创建，可以使用 <code>docker-compose up --no-recreate</code>。这样将只会启动处于停止状态的容器，而忽略已经运行的服务。如果用户只想重新部署某个服务，可以使用 <code>docker-compose up --no-deps -d</code> 来重新创建服务并后台停止旧服务，启动新服务，并不会影响到其所依赖的服务。</p><p>选项：</p><ul><li><code>-d</code> 在后台运行服务容器。</li><li><code>--no-color</code> 不使用颜色来区分不同的服务的控制台输出。</li><li><code>--no-deps</code> 不启动服务所链接的容器。</li><li><code>--force-recreate</code> 强制重新创建容器，不能与 <code>--no-recreate</code> 同时使用。</li><li><code>--no-recreate</code> 如果容器已经存在了，则不重新创建，不能与 <code>--force-recreate</code> 同时使用。</li><li><code>--no-build</code> 不自动构建缺失的服务镜像。</li><li><code>-t, --timeout TIMEOUT</code> 停止容器时候的超时（默认为 10 秒）。</li></ul><h3 id="version"><a href="#version" class="headerlink" title="version"></a><code>version</code></h3><p>格式为 <code>docker-compose version</code>。</p><p>打印版本信息。</p><h1 id="Compose模版文件"><a href="#Compose模版文件" class="headerlink" title="Compose模版文件"></a>Compose模版文件</h1><p>模板文件是使用 <code>Compose</code> 的核心，涉及到的指令关键字也比较多。但大家不用担心，这里面大部分指令跟 <code>docker run</code> 相关参数的含义都是类似的。</p><p>默认的模板文件名称为 <code>docker-compose.yml</code>，格式为 YAML 格式。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">"3"</span></span><br><span class="line"></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">webapp:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">examples/web</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">"80:80"</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">"/data"</span></span><br></pre></td></tr></table></figure><p>注意每个服务都必须通过 <code>image</code> 指令指定镜像或 <code>build</code> 指令（需要 Dockerfile）等来自动构建生成镜像。</p><p>如果使用 <code>build</code> 指令，在 <code>Dockerfile</code> 中设置的选项(例如：<code>CMD</code>, <code>EXPOSE</code>, <code>VOLUME</code>, <code>ENV</code> 等) 将会自动被获取，无需在 <code>docker-compose.yml</code> 中重复设置。</p><p>下面分别介绍各个指令的用法。</p><h2 id="build-1"><a href="#build-1" class="headerlink" title="build"></a><code>build</code></h2><p>指定 <code>Dockerfile</code> 所在文件夹的路径（可以是绝对路径，或者相对 docker-compose.yml 文件的路径）。 <code>Compose</code> 将会利用它自动构建这个镜像，然后使用这个镜像。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">'3'</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">webapp:</span></span><br><span class="line">    <span class="attr">build:</span> <span class="string">./dir</span></span><br></pre></td></tr></table></figure><p>你也可以使用 <code>context</code> 指令指定 <code>Dockerfile</code> 所在文件夹的路径。</p><p>使用 <code>dockerfile</code> 指令指定 <code>Dockerfile</code> 文件名。</p><p>使用 <code>arg</code> 指令指定构建镜像时的变量。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">'3'</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">webapp:</span></span><br><span class="line">    <span class="attr">build:</span></span><br><span class="line">      <span class="attr">context:</span> <span class="string">./dir</span></span><br><span class="line">      <span class="attr">dockerfile:</span> <span class="string">Dockerfile-alternate</span></span><br><span class="line">      <span class="attr">args:</span></span><br><span class="line">        <span class="attr">buildno:</span> <span class="number">1</span></span><br></pre></td></tr></table></figure><p>使用 <code>cache_from</code> 指定构建镜像的缓存</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">build:</span></span><br><span class="line">  <span class="attr">context:</span> <span class="string">.</span></span><br><span class="line">  <span class="attr">cache_from:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">alpine:latest</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">corp/web_app:3.14</span></span><br></pre></td></tr></table></figure><h2 id="cap-add-cap-drop"><a href="#cap-add-cap-drop" class="headerlink" title="cap_add, cap_drop"></a><code>cap_add, cap_drop</code></h2><p>指定容器的内核能力（capacity）分配。</p><p>例如，让容器拥有所有能力可以指定为：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">cap_add:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">ALL</span></span><br></pre></td></tr></table></figure><p>去掉 NET_ADMIN 能力可以指定为：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">cap_drop:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">NET_ADMIN</span></span><br></pre></td></tr></table></figure><h2 id="command"><a href="#command" class="headerlink" title="command"></a><code>command</code></h2><p>覆盖容器启动后默认执行的命令。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">command:</span> <span class="string">echo</span> <span class="string">"hello world"</span></span><br></pre></td></tr></table></figure><h2 id="configs"><a href="#configs" class="headerlink" title="configs"></a><code>configs</code></h2><p>仅用于 <code>Swarm mode</code>，详细内容请查看 <a href="https://yeasy.gitbooks.io/docker_practice/content/swarm_mode" target="_blank" rel="noopener"><code>Swarm mode</code></a> 一节。</p><h2 id="cgroup-parent"><a href="#cgroup-parent" class="headerlink" title="cgroup_parent"></a><code>cgroup_parent</code></h2><p>指定父 <code>cgroup</code> 组，意味着将继承该组的资源限制。</p><p>例如，创建了一个 cgroup 组名称为 <code>cgroups_1</code>。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">cgroup_parent:</span> <span class="string">cgroups_1</span></span><br></pre></td></tr></table></figure><h2 id="container-name"><a href="#container-name" class="headerlink" title="container_name"></a><code>container_name</code></h2><p>指定容器名称。默认将会使用 <code>项目名称_服务名称_序号</code> 这样的格式。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">container_name:</span> <span class="string">docker-web-container</span></span><br></pre></td></tr></table></figure><blockquote><p>注意: 指定容器名称后，该服务将无法进行扩展（scale），因为 Docker 不允许多个容器具有相同的名称。</p></blockquote><h2 id="deploy"><a href="#deploy" class="headerlink" title="deploy"></a><code>deploy</code></h2><p>仅用于 <code>Swarm mode</code>，详细内容请查看 <a href="https://yeasy.gitbooks.io/docker_practice/content/swarm_mode" target="_blank" rel="noopener"><code>Swarm mode</code></a> 一节</p><h2 id="devices"><a href="#devices" class="headerlink" title="devices"></a><code>devices</code></h2><p>指定设备映射关系。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">devices:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">"/dev/ttyUSB1:/dev/ttyUSB0"</span></span><br></pre></td></tr></table></figure><h2 id="depends-on"><a href="#depends-on" class="headerlink" title="depends_on"></a><code>depends_on</code></h2><p>解决容器的依赖、启动先后的问题。以下例子中会先启动 <code>redis</code> <code>db</code> 再启动 <code>web</code></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">'3'</span></span><br><span class="line"></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">web:</span></span><br><span class="line">    <span class="attr">build:</span> <span class="string">.</span></span><br><span class="line">    <span class="attr">depends_on:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">db</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">redis</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">redis:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">redis</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">db:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">postgres</span></span><br></pre></td></tr></table></figure><blockquote><p>注意：<code>web</code> 服务不会等待 <code>redis</code> <code>db</code> 「完全启动」之后才启动。</p></blockquote><h2 id="dns"><a href="#dns" class="headerlink" title="dns"></a><code>dns</code></h2><p>自定义 <code>DNS</code> 服务器。可以是一个值，也可以是一个列表。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">dns:</span> <span class="number">8.8</span><span class="number">.8</span><span class="number">.8</span></span><br><span class="line"></span><br><span class="line"><span class="attr">dns:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="number">8.8</span><span class="number">.8</span><span class="number">.8</span></span><br><span class="line">  <span class="bullet">-</span> <span class="number">114.114</span><span class="number">.114</span><span class="number">.114</span></span><br></pre></td></tr></table></figure><h2 id="dns-search"><a href="#dns-search" class="headerlink" title="dns_search"></a><code>dns_search</code></h2><p>配置 <code>DNS</code> 搜索域。可以是一个值，也可以是一个列表。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">dns_search:</span> <span class="string">example.com</span></span><br><span class="line"></span><br><span class="line"><span class="attr">dns_search:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">domain1.example.com</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">domain2.example.com</span></span><br></pre></td></tr></table></figure><h2 id="tmpfs"><a href="#tmpfs" class="headerlink" title="tmpfs"></a><code>tmpfs</code></h2><p>挂载一个 tmpfs 文件系统到容器。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">tmpfs:</span> <span class="string">/run</span></span><br><span class="line"><span class="attr">tmpfs:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">/run</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">/tmp</span></span><br></pre></td></tr></table></figure><h2 id="env-file"><a href="#env-file" class="headerlink" title="env_file"></a><code>env_file</code></h2><p>从文件中获取环境变量，可以为单独的文件路径或列表。</p><p>如果通过 <code>docker-compose -f FILE</code> 方式来指定 Compose 模板文件，则 <code>env_file</code> 中变量的路径会基于模板文件路径。</p><p>如果有变量名称与 <code>environment</code> 指令冲突，则按照惯例，以后者为准。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">env_file: .env</span><br><span class="line"></span><br><span class="line">env_file:</span><br><span class="line">  - ./common.env</span><br><span class="line">  - ./apps/web.env</span><br><span class="line">  - /opt/secrets.env</span><br></pre></td></tr></table></figure><p>环境变量文件中每一行必须符合格式，支持 <code>#</code> 开头的注释行。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># common.env: Set development environment</span></span><br><span class="line">PROG_ENV=development</span><br></pre></td></tr></table></figure><h2 id="environment"><a href="#environment" class="headerlink" title="environment"></a><code>environment</code></h2><p>设置环境变量。你可以使用数组或字典两种格式。</p><p>只给定名称的变量会自动获取运行 Compose 主机上对应变量的值，可以用来防止泄露不必要的数据。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">environment:</span></span><br><span class="line">  <span class="attr">RACK_ENV:</span> <span class="string">development</span></span><br><span class="line">  <span class="attr">SESSION_SECRET:</span></span><br><span class="line"></span><br><span class="line"><span class="attr">environment:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">RACK_ENV=development</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">SESSION_SECRET</span></span><br></pre></td></tr></table></figure><p>如果变量名称或者值中用到 <code>true|false，yes|no</code> 等表达 <a href="https://yaml.org/type/bool.html" target="_blank" rel="noopener">布尔</a> 含义的词汇，最好放到引号里，避免 YAML 自动解析某些内容为对应的布尔语义。这些特定词汇，包括</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">y|Y|yes|Yes|YES|n|N|no|No|NO|<span class="literal">true</span>|True|TRUE|<span class="literal">false</span>|False|FALSE|on|On|ON|off|Off|OFF</span><br></pre></td></tr></table></figure><h2 id="expose"><a href="#expose" class="headerlink" title="expose"></a><code>expose</code></h2><p>暴露端口，但不映射到宿主机，只被连接的服务访问。</p><p>仅可以指定内部端口为参数</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">expose:</span></span><br><span class="line"> <span class="bullet">-</span> <span class="string">"3000"</span></span><br><span class="line"> <span class="bullet">-</span> <span class="string">"8000"</span></span><br></pre></td></tr></table></figure><h2 id="external-links"><a href="#external-links" class="headerlink" title="external_links"></a><code>external_links</code></h2><blockquote><p>注意：不建议使用该指令。</p></blockquote><p>链接到 <code>docker-compose.yml</code> 外部的容器，甚至并非 <code>Compose</code> 管理的外部容器。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">external_links:</span></span><br><span class="line"> <span class="bullet">-</span> <span class="string">redis_1</span></span><br><span class="line"> <span class="bullet">-</span> <span class="string">project_db_1:mysql</span></span><br><span class="line"> <span class="bullet">-</span> <span class="string">project_db_1:postgresql</span></span><br></pre></td></tr></table></figure><h2 id="extra-hosts"><a href="#extra-hosts" class="headerlink" title="extra_hosts"></a><code>extra_hosts</code></h2><p>类似 Docker 中的 <code>--add-host</code> 参数，指定额外的 host 名称映射信息。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">extra_hosts:</span></span><br><span class="line"> <span class="bullet">-</span> <span class="string">"googledns:8.8.8.8"</span></span><br><span class="line"> <span class="bullet">-</span> <span class="string">"dockerhub:52.1.157.61"</span></span><br></pre></td></tr></table></figure><p>会在启动后的服务容器中 <code>/etc/hosts</code> 文件中添加如下两条条目。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">8.8.8.8 googledns</span><br><span class="line">52.1.157.61 dockerhub</span><br></pre></td></tr></table></figure><h2 id="healthcheck"><a href="#healthcheck" class="headerlink" title="healthcheck"></a><code>healthcheck</code></h2><p>通过命令检查容器是否健康运行。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">healthcheck:</span></span><br><span class="line">  <span class="attr">test:</span> <span class="string">["CMD",</span> <span class="string">"curl"</span><span class="string">,</span> <span class="string">"-f"</span><span class="string">,</span> <span class="string">"http://localhost"</span><span class="string">]</span></span><br><span class="line">  <span class="attr">interval:</span> <span class="string">1m30s</span></span><br><span class="line">  <span class="attr">timeout:</span> <span class="string">10s</span></span><br><span class="line">  <span class="attr">retries:</span> <span class="number">3</span></span><br></pre></td></tr></table></figure><h2 id="image"><a href="#image" class="headerlink" title="image"></a><code>image</code></h2><p>指定为镜像名称或镜像 ID。如果镜像在本地不存在，<code>Compose</code> 将会尝试拉取这个镜像。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">image:</span> <span class="string">ubuntu</span></span><br><span class="line"><span class="attr">image:</span> <span class="string">orchardup/postgresql</span></span><br><span class="line"><span class="attr">image:</span> <span class="string">a4bc65fd</span></span><br></pre></td></tr></table></figure><h2 id="labels"><a href="#labels" class="headerlink" title="labels"></a><code>labels</code></h2><p>为容器添加 Docker 元数据（metadata）信息。例如可以为容器添加辅助说明信息。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">labels:</span></span><br><span class="line">  <span class="attr">com.startupteam.description:</span> <span class="string">"webapp for a startup team"</span></span><br><span class="line">  <span class="attr">com.startupteam.department:</span> <span class="string">"devops department"</span></span><br><span class="line">  <span class="attr">com.startupteam.release:</span> <span class="string">"rc3 for v1.0"</span></span><br></pre></td></tr></table></figure><h2 id="links"><a href="#links" class="headerlink" title="links"></a><code>links</code></h2><blockquote><p>注意：不推荐使用该指令。</p></blockquote><h2 id="logging"><a href="#logging" class="headerlink" title="logging"></a><code>logging</code></h2><p>配置日志选项。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">logging:</span></span><br><span class="line">  <span class="attr">driver:</span> <span class="string">syslog</span></span><br><span class="line">  <span class="attr">options:</span></span><br><span class="line">    <span class="attr">syslog-address:</span> <span class="string">"tcp://192.168.0.42:123"</span></span><br></pre></td></tr></table></figure><p>目前支持三种日志驱动类型。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">driver:</span> <span class="string">"json-file"</span></span><br><span class="line"><span class="attr">driver:</span> <span class="string">"syslog"</span></span><br><span class="line"><span class="attr">driver:</span> <span class="string">"none"</span></span><br></pre></td></tr></table></figure><p><code>options</code> 配置日志驱动的相关参数。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">options:</span></span><br><span class="line">  <span class="attr">max-size:</span> <span class="string">"200k"</span></span><br><span class="line">  <span class="attr">max-file:</span> <span class="string">"10"</span></span><br></pre></td></tr></table></figure><h2 id="network-mode"><a href="#network-mode" class="headerlink" title="network_mode"></a><code>network_mode</code></h2><p>设置网络模式。使用和 <code>docker run</code> 的 <code>--network</code> 参数一样的值。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">network_mode:</span> <span class="string">"bridge"</span></span><br><span class="line"><span class="attr">network_mode:</span> <span class="string">"host"</span></span><br><span class="line"><span class="attr">network_mode:</span> <span class="string">"none"</span></span><br><span class="line"><span class="attr">network_mode:</span> <span class="string">"service:[service name]"</span></span><br><span class="line"><span class="attr">network_mode:</span> <span class="string">"container:[container name/id]"</span></span><br></pre></td></tr></table></figure><h2 id="networks"><a href="#networks" class="headerlink" title="networks"></a><code>networks</code></h2><p>配置容器连接的网络。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">"3"</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">some-service:</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">     <span class="bullet">-</span> <span class="string">some-network</span></span><br><span class="line">     <span class="bullet">-</span> <span class="string">other-network</span></span><br><span class="line"></span><br><span class="line"><span class="attr">networks:</span></span><br><span class="line">  <span class="attr">some-network:</span></span><br><span class="line">  <span class="attr">other-network:</span></span><br></pre></td></tr></table></figure><h2 id="pid"><a href="#pid" class="headerlink" title="pid"></a><code>pid</code></h2><p>跟主机系统共享进程命名空间。打开该选项的容器之间，以及容器和宿主机系统之间可以通过进程 ID 来相互访问和操作。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">pid:</span> <span class="string">"host"</span></span><br></pre></td></tr></table></figure><h2 id="ports"><a href="#ports" class="headerlink" title="ports"></a><code>ports</code></h2><p>暴露端口信息。</p><p>使用宿主端口：容器端口 <code>(HOST:CONTAINER)</code> 格式，或者仅仅指定容器的端口（宿主将会随机选择端口）都可以。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">ports:</span></span><br><span class="line"> <span class="bullet">-</span> <span class="string">"3000"</span></span><br><span class="line"> <span class="bullet">-</span> <span class="string">"8000:8000"</span></span><br><span class="line"> <span class="bullet">-</span> <span class="string">"49100:22"</span></span><br><span class="line"> <span class="bullet">-</span> <span class="string">"127.0.0.1:8001:8001"</span></span><br></pre></td></tr></table></figure><p><em>注意：当使用 <code>HOST:CONTAINER</code> 格式来映射端口时，如果你使用的容器端口小于 60 并且没放到引号里，可能会得到错误结果，因为 <code>YAML</code> 会自动解析 <code>xx:yy</code> 这种数字格式为 60 进制。为避免出现这种问题，建议数字串都采用引号包括起来的字符串格式。</em></p><h2 id="secrets"><a href="#secrets" class="headerlink" title="secrets"></a><code>secrets</code></h2><p>存储敏感数据，例如 <code>mysql</code> 服务密码。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">"3.1"</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line"></span><br><span class="line"><span class="attr">mysql:</span></span><br><span class="line">  <span class="attr">image:</span> <span class="string">mysql</span></span><br><span class="line">  <span class="attr">environment:</span></span><br><span class="line">    <span class="attr">MYSQL_ROOT_PASSWORD_FILE:</span> <span class="string">/run/secrets/db_root_password</span></span><br><span class="line">  <span class="attr">secrets:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">db_root_password</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">my_other_secret</span></span><br><span class="line"></span><br><span class="line"><span class="attr">secrets:</span></span><br><span class="line">  <span class="attr">my_secret:</span></span><br><span class="line">    <span class="attr">file:</span> <span class="string">./my_secret.txt</span></span><br><span class="line">  <span class="attr">my_other_secret:</span></span><br><span class="line">    <span class="attr">external:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><h2 id="security-opt"><a href="#security-opt" class="headerlink" title="security_opt"></a><code>security_opt</code></h2><p>指定容器模板标签（label）机制的默认属性（用户、角色、类型、级别等）。例如配置标签的用户名和角色名。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">security_opt:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">label:user:USER</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">label:role:ROLE</span></span><br></pre></td></tr></table></figure><h2 id="stop-signal"><a href="#stop-signal" class="headerlink" title="stop_signal"></a><code>stop_signal</code></h2><p>设置另一个信号来停止容器。在默认情况下使用的是 SIGTERM 停止容器。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">stop_signal:</span> <span class="string">SIGUSR1</span></span><br></pre></td></tr></table></figure><h2 id="sysctls"><a href="#sysctls" class="headerlink" title="sysctls"></a><code>sysctls</code></h2><p>配置容器内核参数。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">sysctls:</span></span><br><span class="line">  <span class="attr">net.core.somaxconn:</span> <span class="number">1024</span></span><br><span class="line">  <span class="attr">net.ipv4.tcp_syncookies:</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="attr">sysctls:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">net.core.somaxconn=1024</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">net.ipv4.tcp_syncookies=0</span></span><br></pre></td></tr></table></figure><h2 id="ulimits"><a href="#ulimits" class="headerlink" title="ulimits"></a><code>ulimits</code></h2><p>指定容器的 ulimits 限制值。</p><p>例如，指定最大进程数为 65535，指定文件句柄数为 20000（软限制，应用可以随时修改，不能超过硬限制） 和 40000（系统硬限制，只能 root 用户提高）。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">ulimits:</span></span><br><span class="line">  <span class="attr">nproc:</span> <span class="number">65535</span></span><br><span class="line">  <span class="attr">nofile:</span></span><br><span class="line">    <span class="attr">soft:</span> <span class="number">20000</span></span><br><span class="line">    <span class="attr">hard:</span> <span class="number">40000</span></span><br></pre></td></tr></table></figure><h2 id="volumes"><a href="#volumes" class="headerlink" title="volumes"></a><code>volumes</code></h2><p>数据卷所挂载路径设置。可以设置为宿主机路径(<code>HOST:CONTAINER</code>)或者数据卷名称(<code>VOLUME:CONTAINER</code>)，并且可以设置访问模式 （<code>HOST:CONTAINER:ro</code>）。</p><p>该指令中路径支持相对路径。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">volumes:</span></span><br><span class="line"> <span class="bullet">-</span> <span class="string">/var/lib/mysql</span></span><br><span class="line"> <span class="bullet">-</span> <span class="string">cache/:/tmp/cache</span></span><br><span class="line"> <span class="bullet">-</span> <span class="string">~/configs:/etc/configs/:ro</span></span><br></pre></td></tr></table></figure><p>如果路径为数据卷名称，必须在文件中配置数据卷。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">"3"</span></span><br><span class="line"></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">my_src:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">mysql:8.0</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">mysql_data:/var/lib/mysql</span></span><br><span class="line"></span><br><span class="line"><span class="attr">volumes:</span></span><br><span class="line">  <span class="attr">mysql_data:</span></span><br></pre></td></tr></table></figure><h2 id="其它指令"><a href="#其它指令" class="headerlink" title="其它指令"></a>其它指令</h2><p>此外，还有包括 <code>domainname, entrypoint, hostname, ipc, mac_address, privileged, read_only, shm_size, restart, stdin_open, tty, user, working_dir</code> 等指令，基本跟 <code>docker run</code> 中对应参数的功能一致。</p><p>指定服务容器启动后执行的入口文件。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">entrypoint:</span> <span class="string">/code/entrypoint.sh</span></span><br></pre></td></tr></table></figure><p>指定容器中运行应用的用户名。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">user:</span> <span class="string">nginx</span></span><br></pre></td></tr></table></figure><p>指定容器中工作目录。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">working_dir:</span> <span class="string">/code</span></span><br></pre></td></tr></table></figure><p>指定容器中搜索域名、主机名、mac 地址等。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">domainname:</span> <span class="string">your_website.com</span></span><br><span class="line"><span class="attr">hostname:</span> <span class="string">test</span></span><br><span class="line"><span class="attr">mac_address:</span> <span class="number">08</span><span class="number">-00</span><span class="number">-27</span><span class="number">-00</span><span class="string">-0C-0A</span></span><br></pre></td></tr></table></figure><p>允许容器中运行一些特权命令。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">privileged:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>指定容器退出后的重启策略为始终重启。该命令对保持服务始终运行十分有效，在生产环境中推荐配置为 <code>always</code> 或者 <code>unless-stopped</code>。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">restart:</span> <span class="string">always</span></span><br></pre></td></tr></table></figure><p>以只读模式挂载容器的 root 文件系统，意味着不能对容器内容进行修改。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">read_only:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>打开标准输入，可以接受外部输入。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">stdin_open:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>模拟一个伪终端。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">tty:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><h2 id="读取变量"><a href="#读取变量" class="headerlink" title="读取变量"></a>读取变量</h2><p>Compose 模板文件支持动态读取主机的系统环境变量和当前目录下的 <code>.env</code> 文件中的变量。</p><p>例如，下面的 Compose 文件将从运行它的环境中读取变量 <code>${MONGO_VERSION}</code> 的值，并写入执行的指令中。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">"3"</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line"></span><br><span class="line"><span class="attr">db:</span></span><br><span class="line">  <span class="attr">image:</span> <span class="string">"mongo:$&#123;MONGO_VERSION&#125;"</span></span><br></pre></td></tr></table></figure><p>如果执行 <code>MONGO_VERSION=3.2 docker-compose up</code> 则会启动一个 <code>mongo:3.2</code> 镜像的容器；如果执行 <code>MONGO_VERSION=2.8 docker-compose up</code> 则会启动一个 <code>mongo:2.8</code> 镜像的容器。</p><p>若当前目录存在 <code>.env</code> 文件，执行 <code>docker-compose</code> 命令时将从该文件中读取变量。</p><p>在当前目录新建 <code>.env</code> 文件并写入以下内容。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 支持 # 号注释</span></span><br><span class="line">MONGO_VERSION=3.6</span><br></pre></td></tr></table></figure><p>执行 <code>docker-compose up</code> 则会启动一个 <code>mongo:3.6</code> 镜像的容器。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://docs.docker.com/compose/compose-file/" target="_blank" rel="noopener">https://docs.docker.com/compose/compose-file/</a></p><p>本文章摘抄于：<a href="https://yeasy.gitbooks.io/docker_practice/content/" target="_blank" rel="noopener">https://yeasy.gitbooks.io/docker_practice/content/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Docker-Compose简介&quot;&gt;&lt;a href=&quot;#Docker-Compose简介&quot; class=&quot;headerlink&quot; title=&quot;Docker Compose简介&quot;&gt;&lt;/a&gt;Docker Compose简介&lt;/h1&gt;&lt;p&gt;&lt;code&gt;Compose&lt;/code&gt; 项目是 Docker 官方的开源项目，负责实现对 Docker 容器集群的快速编排。其代码目前在 &lt;a href=&quot;https://github.com/docker/compose&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/docker/compose&lt;/a&gt; 上开源。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Compose&lt;/code&gt; 定位是 「定义和运行多个 Docker 容器的应用（Defining and running multi-container Docker applications）」，其前身是开源项目 Fig。&lt;/p&gt;
    
    </summary>
    
      <category term="Docker" scheme="http://hackycy.github.io/categories/Docker/"/>
    
    
      <category term="Docker" scheme="http://hackycy.github.io/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>Docker入门（五）——Dockerfile</title>
    <link href="http://hackycy.github.io/2019/12/05/Docker%E5%85%A5%E9%97%A8%EF%BC%88%E4%BA%94%EF%BC%89%E2%80%94%E2%80%94Dockerfile/"/>
    <id>http://hackycy.github.io/2019/12/05/Docker入门（五）——Dockerfile/</id>
    <published>2019-12-05T07:23:52.000Z</published>
    <updated>2019-12-15T09:00:50.011Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Dockerfile简介"><a href="#Dockerfile简介" class="headerlink" title="Dockerfile简介"></a>Dockerfile简介</h1><p>Dockerfile 是一个用来构建镜像的文本文件，文本内容包含了一条条构建镜像所需的指令和说明。</p><a id="more"></a><h1 id="利用-commit-理解镜像构成"><a href="#利用-commit-理解镜像构成" class="headerlink" title="利用 commit 理解镜像构成"></a>利用 commit 理解镜像构成</h1><p>理解Dockerfile定制镜像前先来了解一下<code>docker commit</code>。</p><p>镜像是容器的基础，每次执行 <code>docker run</code> 的时候都会指定哪个镜像作为容器运行的基础。在之前的例子中，我们所使用的都是来自于 Docker Hub 的镜像。直接使用这些镜像是可以满足一定的需求，而当这些镜像无法直接满足需求时，我们就需要定制这些镜像。</p><p>镜像是多层存储，每一层是在前一层的基础上进行的修改；而容器同样也是多层存储，是在以镜像为基础层，在其基础上加一层作为容器运行时的存储层。</p><p>现在让我们以定制一个 Web 服务器为例子，来讲解镜像是如何构建的。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker run --name webserver -d -p 80:80 nginx</span><br></pre></td></tr></table></figure><p>这条命令会用 <code>nginx</code> 镜像启动一个容器，命名为 <code>webserver</code>，并且映射了 80 端口，这样我们可以用浏览器去访问这个 <code>nginx</code> 服务器。</p><p>如果是在 Linux 本机运行的 Docker，或者如果使用的是 Docker Desktop for Mac/Windows，那么可以直接访问：<a href="http://localhost/" target="_blank" rel="noopener">http://localhost</a>；如果使用的是 Docker Toolbox，或者是在虚拟机、云服务器上安装的 Docker，则需要将 <code>localhost</code> 换为虚拟机地址或者实际云服务器地址。</p><p>直接用浏览器访问的话，我们会看到默认的 Nginx 欢迎页面。</p><p><img src="commit_hello_nginx.png" alt></p><p>现在，假设我们非常不喜欢这个欢迎页面，我们希望改成欢迎 Docker 的文字，我们可以使用 <code>docker exec</code> 命令进入容器，修改其内容。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ docker <span class="built_in">exec</span> -it webserver bash</span><br><span class="line">root@3e3b6840ce9a:/<span class="comment"># echo '&lt;h1&gt;Hello, Docker!&lt;/h1&gt;' &gt; /usr/share/nginx/html/index.html</span></span><br><span class="line">root@3e3b6840ce9a:/<span class="comment"># exit</span></span><br><span class="line"><span class="built_in">exit</span></span><br></pre></td></tr></table></figure><p>我们以交互式终端方式进入 <code>webserver</code> 容器，并执行了 <code>bash</code> 命令，也就是获得一个可操作的 Shell。</p><p>然后，我们用 <code>Hello, Docker!</code> 覆盖了 <code>/usr/share/nginx/html/index.html</code> 的内容。</p><p>现在我们再刷新浏览器的话，会发现内容被改变了。</p><p><img src="commit_hello_nginx2.png" alt></p><p>现在我们定制好了变化，我们希望能将其保存下来形成镜像。</p><p>要知道，当我们运行一个容器的时候（如果不使用卷的话），我们做的任何文件修改都会被记录于容器存储层里。而 Docker 提供了一个 <code>docker commit</code> 命令，可以将容器的存储层保存下来成为镜像。换句话说，就是在原有镜像的基础上，再叠加上容器的存储层，并构成新的镜像。以后我们运行这个新镜像的时候，就会拥有原有容器最后的文件变化。</p><p><code>docker commit</code> 的语法格式为：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker commit [选项] &lt;容器ID或容器名&gt; [&lt;仓库名&gt;[:&lt;标签&gt;]]</span><br></pre></td></tr></table></figure><p>我们可以用下面的命令将容器保存为镜像：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ docker commit \</span><br><span class="line">    --author <span class="string">"Tao Wang &lt;twang2218@gmail.com&gt;"</span> \</span><br><span class="line">    --message <span class="string">"修改了默认网页"</span> \</span><br><span class="line">    webserver \</span><br><span class="line">    nginx:v2</span><br><span class="line">sha256:07e33465974800ce65751acc279adc6ed2dc5ed4e0838f8b86f0c87aa1795214</span><br></pre></td></tr></table></figure><p>其中 <code>--author</code> 是指定修改的作者，而 <code>--message</code> 则是记录本次修改的内容。这点和 <code>git</code> 版本控制相似，不过这里这些信息可以省略留空。</p><p>我们可以在 <code>docker image ls</code> 中看到这个新定制的镜像：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ docker image ls nginx</span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">nginx               v2                  07e334659748        9 seconds ago       181.5 MB</span><br><span class="line">nginx               1.11                05a60462f8ba        12 days ago         181.5 MB</span><br><span class="line">nginx               latest              e43d811ce2f4        4 weeks ago         181.5 MB</span><br></pre></td></tr></table></figure><p>我们还可以用 <code>docker history</code> 具体查看镜像内的历史记录，如果比较 <code>nginx:latest</code> 的历史记录，我们会发现新增了我们刚刚提交的这一层。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ docker <span class="built_in">history</span> nginx:v2</span><br><span class="line">IMAGE               CREATED             CREATED BY                                      SIZE                COMMENT</span><br><span class="line">07e334659748        54 seconds ago      nginx -g daemon off;                            95 B                修改了默认网页</span><br><span class="line">e43d811ce2f4        4 weeks ago         /bin/sh -c <span class="comment">#(nop)  CMD ["nginx" "-g" "daemon    0 B</span></span><br><span class="line">&lt;missing&gt;           4 weeks ago         /bin/sh -c <span class="comment">#(nop)  EXPOSE 443/tcp 80/tcp        0 B</span></span><br><span class="line">&lt;missing&gt;           4 weeks ago         /bin/sh -c ln -sf /dev/stdout /var/<span class="built_in">log</span>/nginx/   22 B</span><br><span class="line">&lt;missing&gt;           4 weeks ago         /bin/sh -c apt-key adv --keyserver hkp://pgp.   58.46 MB</span><br><span class="line">&lt;missing&gt;           4 weeks ago         /bin/sh -c <span class="comment">#(nop)  ENV NGINX_VERSION=1.11.5-1   0 B</span></span><br><span class="line">&lt;missing&gt;           4 weeks ago         /bin/sh -c <span class="comment">#(nop)  MAINTAINER NGINX Docker Ma   0 B</span></span><br><span class="line">&lt;missing&gt;           4 weeks ago         /bin/sh -c <span class="comment">#(nop)  CMD ["/bin/bash"]            0 B</span></span><br><span class="line">&lt;missing&gt;           4 weeks ago         /bin/sh -c <span class="comment">#(nop) ADD file:23aa4f893e3288698c   123 MB</span></span><br></pre></td></tr></table></figure><p>新的镜像定制好后，我们可以来运行这个镜像。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --name web2 -d -p 81:80 nginx:v2</span><br></pre></td></tr></table></figure><p>这里我们命名为新的服务为 <code>web2</code>，并且映射到 <code>81</code> 端口。如果是 Docker Desktop for Mac/Windows 或 Linux 桌面的话，我们就可以直接访问 <a href="http://localhost:81/" target="_blank" rel="noopener">http://localhost:81</a> 看到结果，其内容应该和之前修改后的 <code>webserver</code> 一样。</p><p>至此，我们第一次完成了定制镜像，使用的是 <code>docker commit</code> 命令，手动操作给旧的镜像添加了新的一层，形成新的镜像，对镜像多层存储应该有了更直观的感觉。</p><blockquote><p>注意： <code>docker commit</code> 命令除了学习之外，还有一些特殊的应用场合，比如被入侵后保存现场等。但是，不要使用 <code>docker commit</code> 定制镜像，使用 <code>docker commit</code> 命令虽然可以比较直观的帮助理解镜像分层存储的概念，但是实际环境中并不会这样使用。</p><p>定制镜像应该使用 <code>Dockerfile</code> 来完成。如果你想要定制镜像请查看下一小节。</p></blockquote><h1 id="Dockerfile定制镜像"><a href="#Dockerfile定制镜像" class="headerlink" title="Dockerfile定制镜像"></a>Dockerfile定制镜像</h1><p>从<code>docker commit</code>中了解到镜像的定制实际上就是定制每一层所添加的配置、文件。</p><p>如果可以把每一层修改、安装、构建、操作的命令都写入一个脚本，用这个脚本来构建、定制镜像，那么之前提及的无法重复的问题、镜像构建透明性的问题、体积的问题就都会解决。这个脚本就是 Dockerfile。</p><p>Dockerfile 是一个文本文件，其内包含了一条条的 <strong>指令(Instruction)</strong>，每一条指令构建一层，因此每一条指令的内容，就是描述该层应当如何构建。</p><p>还以之前定制 <code>nginx</code> 镜像为例，这次我们使用 Dockerfile 来定制。</p><p>在一个空白目录中，建立一个文本文件，并命名为 <code>Dockerfile</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ mkdir mynginx</span><br><span class="line">$ <span class="built_in">cd</span> mynginx</span><br><span class="line">$ touch Dockerfile</span><br></pre></td></tr></table></figure><p>其内容为：</p><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> nginx</span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> <span class="built_in">echo</span> <span class="string">'&lt;h1&gt;Hello, Docker!&lt;/h1&gt;'</span> &gt; /usr/share/nginx/html/index.html</span></span><br></pre></td></tr></table></figure><p>这个 Dockerfile 很简单，一共就两行。涉及到了两条指令，<code>FROM</code> 和 <code>RUN</code>。</p><h2 id="FROM-指定基础镜像"><a href="#FROM-指定基础镜像" class="headerlink" title="FROM 指定基础镜像"></a>FROM 指定基础镜像</h2><p>所谓定制镜像，那一定是以一个镜像为基础，在其上进行定制。就像我们之前运行了一个 <code>nginx</code> 镜像的容器，再进行修改一样，基础镜像是必须指定的。而 <code>FROM</code> 就是指定 <strong>基础镜像</strong>，因此一个 <code>Dockerfile</code> 中 <code>FROM</code> 是必备的指令，并且必须是第一条指令。</p><p>在 <a href="https://hub.docker.com/search?q=&amp;type=image&amp;image_filter=official" target="_blank" rel="noopener">Docker Hub</a> 上有非常多的高质量的官方镜像，有可以直接拿来使用的服务类的镜像，如 <a href="https://hub.docker.com/_/nginx/" target="_blank" rel="noopener"><code>nginx</code></a>、<a href="https://hub.docker.com/_/redis/" target="_blank" rel="noopener"><code>redis</code></a>、<a href="https://hub.docker.com/_/mongo/" target="_blank" rel="noopener"><code>mongo</code></a>、<a href="https://hub.docker.com/_/mysql/" target="_blank" rel="noopener"><code>mysql</code></a>、<a href="https://hub.docker.com/_/httpd/" target="_blank" rel="noopener"><code>httpd</code></a>、<a href="https://hub.docker.com/_/php/" target="_blank" rel="noopener"><code>php</code></a>、<a href="https://hub.docker.com/_/tomcat/" target="_blank" rel="noopener"><code>tomcat</code></a> 等；也有一些方便开发、构建、运行各种语言应用的镜像，如 <a href="https://hub.docker.com/_/node" target="_blank" rel="noopener"><code>node</code></a>、<a href="https://hub.docker.com/_/openjdk/" target="_blank" rel="noopener"><code>openjdk</code></a>、<a href="https://hub.docker.com/_/python/" target="_blank" rel="noopener"><code>python</code></a>、<a href="https://hub.docker.com/_/ruby/" target="_blank" rel="noopener"><code>ruby</code></a>、<a href="https://hub.docker.com/_/golang/" target="_blank" rel="noopener"><code>golang</code></a> 等。可以在其中寻找一个最符合我们最终目标的镜像为基础镜像进行定制。</p><p>如果没有找到对应服务的镜像，官方镜像中还提供了一些更为基础的操作系统镜像，如 <a href="https://hub.docker.com/_/ubuntu/" target="_blank" rel="noopener"><code>ubuntu</code></a>、<a href="https://hub.docker.com/_/debian/" target="_blank" rel="noopener"><code>debian</code></a>、<a href="https://hub.docker.com/_/centos/" target="_blank" rel="noopener"><code>centos</code></a>、<a href="https://hub.docker.com/_/fedora/" target="_blank" rel="noopener"><code>fedora</code></a>、<a href="https://hub.docker.com/_/alpine/" target="_blank" rel="noopener"><code>alpine</code></a> 等，这些操作系统的软件库为我们提供了更广阔的扩展空间。</p><p>除了选择现有镜像为基础镜像外，Docker 还存在一个特殊的镜像，名为 <code>scratch</code>。这个镜像是虚拟的概念，并不实际存在，它表示一个空白的镜像。</p><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> scratch</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>如果你以 <code>scratch</code> 为基础镜像的话，意味着你不以任何镜像为基础，接下来所写的指令将作为镜像第一层开始存在。</p><p>不以任何系统为基础，直接将可执行文件复制进镜像的做法并不罕见，比如 <a href="https://hub.docker.com/_/swarm/" target="_blank" rel="noopener"><code>swarm</code></a>、<a href="https://quay.io/repository/coreos/etcd" target="_blank" rel="noopener"><code>etcd</code></a>。对于 Linux 下静态编译的程序来说，并不需要有操作系统提供运行时支持，所需的一切库都已经在可执行文件里了，因此直接 <code>FROM scratch</code> 会让镜像体积更加小巧。使用 <a href="https://golang.org/" target="_blank" rel="noopener">Go 语言</a> 开发的应用很多会使用这种方式来制作镜像，这也是为什么有人认为 Go 是特别适合容器微服务架构的语言的原因之一。</p><h2 id="RUN-执行命令"><a href="#RUN-执行命令" class="headerlink" title="RUN 执行命令"></a>RUN 执行命令</h2><p><code>RUN</code> 指令是用来执行命令行命令的。由于命令行的强大能力，<code>RUN</code> 指令在定制镜像时是最常用的指令之一。其格式有两种：</p><ul><li><em>shell</em> 格式：<code>RUN &lt;命令&gt;</code>，就像直接在命令行中输入的命令一样。刚才写的 Dockerfile 中的 <code>RUN</code> 指令就是这种格式。</li></ul><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">RUN</span><span class="bash"> <span class="built_in">echo</span> <span class="string">'&lt;h1&gt;Hello, Docker!&lt;/h1&gt;'</span> &gt; /usr/share/nginx/html/index.html</span></span><br></pre></td></tr></table></figure><ul><li><em>exec</em> 格式：<code>RUN [&quot;可执行文件&quot;, &quot;参数1&quot;, &quot;参数2&quot;]</code>，这更像是函数调用中的格式。</li></ul><p>既然 <code>RUN</code> 就像 Shell 脚本一样可以执行命令，那么我们是否就可以像 Shell 脚本一样把每个命令对应一个 RUN 呢？比如这样：</p><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> debian:stretch</span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> apt-get update</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> apt-get install -y gcc libc6-dev make wget</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> wget -O redis.tar.gz <span class="string">"http://download.redis.io/releases/redis-5.0.3.tar.gz"</span></span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> mkdir -p /usr/src/redis</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> tar -xzf redis.tar.gz -C /usr/src/redis --strip-components=1</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> make -C /usr/src/redis</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> make -C /usr/src/redis install</span></span><br></pre></td></tr></table></figure><p>之前说过，Dockerfile 中每一个指令都会建立一层，<code>RUN</code> 也不例外。每一个 <code>RUN</code> 的行为，就和刚才我们手工建立镜像的过程一样：新建立一层，在其上执行这些命令，执行结束后，<code>commit</code> 这一层的修改，构成新的镜像。</p><p>而上面的这种写法，创建了 7 层镜像。这是完全没有意义的，而且很多运行时不需要的东西，都被装进了镜像里，比如编译环境、更新的软件包等等。结果就是产生非常臃肿、非常多层的镜像，不仅仅增加了构建部署的时间，也很容易出错。 这是很多初学 Docker 的人常犯的一个错误。</p><p><em>Union FS 是有最大层数限制的，比如 AUFS，曾经是最大不得超过 42 层，现在是不得超过 127 层。</em></p><p>上面的 <code>Dockerfile</code> 正确的写法应该是这样：</p><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> debian:stretch</span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> buildDeps=<span class="string">'gcc libc6-dev make wget'</span> \</span></span><br><span class="line"><span class="bash">    &amp;&amp; apt-get update \</span></span><br><span class="line"><span class="bash">    &amp;&amp; apt-get install -y <span class="variable">$buildDeps</span> \</span></span><br><span class="line"><span class="bash">    &amp;&amp; wget -O redis.tar.gz <span class="string">"http://download.redis.io/releases/redis-5.0.3.tar.gz"</span> \</span></span><br><span class="line"><span class="bash">    &amp;&amp; mkdir -p /usr/src/redis \</span></span><br><span class="line"><span class="bash">    &amp;&amp; tar -xzf redis.tar.gz -C /usr/src/redis --strip-components=1 \</span></span><br><span class="line"><span class="bash">    &amp;&amp; make -C /usr/src/redis \</span></span><br><span class="line"><span class="bash">    &amp;&amp; make -C /usr/src/redis install \</span></span><br><span class="line"><span class="bash">    &amp;&amp; rm -rf /var/lib/apt/lists/* \</span></span><br><span class="line"><span class="bash">    &amp;&amp; rm redis.tar.gz \</span></span><br><span class="line"><span class="bash">    &amp;&amp; rm -r /usr/src/redis \</span></span><br><span class="line"><span class="bash">    &amp;&amp; apt-get purge -y --auto-remove <span class="variable">$buildDeps</span></span></span><br></pre></td></tr></table></figure><p>首先，之前所有的命令只有一个目的，就是编译、安装 redis 可执行文件。因此没有必要建立很多层，这只是一层的事情。因此，这里没有使用很多个 <code>RUN</code> 对一一对应不同的命令，而是仅仅使用一个 <code>RUN</code> 指令，并使用 <code>&amp;&amp;</code> 将各个所需命令串联起来。将之前的 7 层，简化为了 1 层。在撰写 Dockerfile 的时候，要经常提醒自己，这并不是在写 Shell 脚本，而是在定义每一层该如何构建。</p><p>并且，这里为了格式化还进行了换行。Dockerfile 支持 Shell 类的行尾添加 <code>\</code> 的命令换行方式，以及行首 <code>#</code> 进行注释的格式。良好的格式，比如换行、缩进、注释等，会让维护、排障更为容易，这是一个比较好的习惯。</p><p>此外，还可以看到这一组命令的最后添加了清理工作的命令，删除了为了编译构建所需要的软件，清理了所有下载、展开的文件，并且还清理了 <code>apt</code> 缓存文件。这是很重要的一步，我们之前说过，镜像是多层存储，每一层的东西并不会在下一层被删除，会一直跟随着镜像。因此镜像构建时，一定要确保每一层只添加真正需要添加的东西，任何无关的东西都应该清理掉。</p><p>很多人初学 Docker 制作出了很臃肿的镜像的原因之一，就是忘记了每一层构建的最后一定要清理掉无关文件。</p><h2 id="构建镜像"><a href="#构建镜像" class="headerlink" title="构建镜像"></a>构建镜像</h2><p>好了，让我们再回到之前定制的 nginx 镜像的 Dockerfile 来。现在我们明白了这个 Dockerfile 的内容，那么让我们来构建这个镜像吧。</p><p>在 <code>Dockerfile</code> 文件所在目录执行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ docker build -t nginx:v3 .</span><br><span class="line">Sending build context to Docker daemon 2.048 kB</span><br><span class="line">Step 1 : FROM nginx</span><br><span class="line"> ---&gt; e43d811ce2f4</span><br><span class="line">Step 2 : RUN <span class="built_in">echo</span> <span class="string">'&lt;h1&gt;Hello, Docker!&lt;/h1&gt;'</span> &gt; /usr/share/nginx/html/index.html</span><br><span class="line"> ---&gt; Running <span class="keyword">in</span> 9cdc27646c7b</span><br><span class="line"> ---&gt; 44aa4490ce2c</span><br><span class="line">Removing intermediate container 9cdc27646c7b</span><br><span class="line">Successfully built 44aa4490ce2c</span><br></pre></td></tr></table></figure><p>从命令的输出结果中，我们可以清晰的看到镜像的构建过程。在 <code>Step 2</code> 中，如同我们之前所说的那样，<code>RUN</code> 指令启动了一个容器 <code>9cdc27646c7b</code>，执行了所要求的命令，并最后提交了这一层 <code>44aa4490ce2c</code>，随后删除了所用到的这个容器 <code>9cdc27646c7b</code>。</p><p>这里我们使用了 <code>docker build</code> 命令进行镜像构建。其格式为：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build [选项] &lt;上下文路径/URL/-&gt;</span><br></pre></td></tr></table></figure><p>在这里我们指定了最终镜像的名称 <code>-t nginx:v3</code>，构建成功后，我们可以像之前运行 <code>nginx:v2</code> 那样来运行这个镜像，其结果会和 <code>nginx:v2</code> 一样。</p><h2 id="镜像构建上下文（Context）"><a href="#镜像构建上下文（Context）" class="headerlink" title="镜像构建上下文（Context）"></a>镜像构建上下文（Context）</h2><p>如果注意，会看到 <code>docker build</code> 命令最后有一个 <code>.</code>。<code>.</code> 表示当前目录，而 <code>Dockerfile</code> 就在当前目录，因此不少初学者以为这个路径是在指定 <code>Dockerfile</code> 所在路径，这么理解其实是不准确的。如果对应上面的命令格式，你可能会发现，这是在指定 <strong>上下文路径</strong>。那么什么是上下文呢？</p><p>首先我们要理解 <code>docker build</code> 的工作原理。Docker 在运行时分为 Docker 引擎（也就是服务端守护进程）和客户端工具。Docker 的引擎提供了一组 REST API，被称为 <a href="https://docs.docker.com/develop/sdk/" target="_blank" rel="noopener">Docker Remote API</a>，而如 <code>docker</code> 命令这样的客户端工具，则是通过这组 API 与 Docker 引擎交互，从而完成各种功能。因此，虽然表面上我们好像是在本机执行各种 <code>docker</code> 功能，但实际上，一切都是使用的远程调用形式在服务端（Docker 引擎）完成。也因为这种 C/S 设计，让我们操作远程服务器的 Docker 引擎变得轻而易举。</p><p>当我们进行镜像构建的时候，并非所有定制都会通过 <code>RUN</code> 指令完成，经常会需要将一些本地文件复制进镜像，比如通过 <code>COPY</code> 指令、<code>ADD</code> 指令等。而 <code>docker build</code> 命令构建镜像，其实并非在本地构建，而是在服务端，也就是 Docker 引擎中构建的。那么在这种客户端/服务端的架构中，如何才能让服务端获得本地文件呢？</p><p>这就引入了上下文的概念。当构建的时候，用户会指定构建镜像上下文的路径，<code>docker build</code> 命令得知这个路径后，会将路径下的所有内容打包，然后上传给 Docker 引擎。这样 Docker 引擎收到这个上下文包后，展开就会获得构建镜像所需的一切文件。</p><p>如果在 <code>Dockerfile</code> 中这么写：</p><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">COPY</span><span class="bash"> ./package.json /app/</span></span><br></pre></td></tr></table></figure><p>这并不是要复制执行 <code>docker build</code> 命令所在的目录下的 <code>package.json</code>，也不是复制 <code>Dockerfile</code> 所在目录下的 <code>package.json</code>，而是复制 <strong>上下文（context）</strong> 目录下的 <code>package.json</code>。</p><p>因此，<code>COPY</code> 这类指令中的源文件的路径都是<em>相对路径</em>。这也是初学者经常会问的为什么 <code>COPY ../package.json /app</code> 或者 <code>COPY /opt/xxxx /app</code> 无法工作的原因，因为这些路径已经超出了上下文的范围，Docker 引擎无法获得这些位置的文件。如果真的需要那些文件，应该将它们复制到上下文目录中去。</p><p>现在就可以理解刚才的命令 <code>docker build -t nginx:v3 .</code> 中的这个 <code>.</code>，实际上是在指定上下文的目录，<code>docker build</code> 命令会将该目录下的内容打包交给 Docker 引擎以帮助构建镜像。</p><p>如果观察 <code>docker build</code> 输出，我们其实已经看到了这个发送上下文的过程：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ docker build -t nginx:v3 .</span><br><span class="line">Sending build context to Docker daemon 2.048 kB</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>理解构建上下文对于镜像构建是很重要的，避免犯一些不应该的错误。比如有些初学者在发现 <code>COPY /opt/xxxx /app</code> 不工作后，于是干脆将 <code>Dockerfile</code> 放到了硬盘根目录去构建，结果发现 <code>docker build</code> 执行后，在发送一个几十 GB 的东西，极为缓慢而且很容易构建失败。那是因为这种做法是在让 <code>docker build</code> 打包整个硬盘，这显然是使用错误。</p><p>一般来说，应该会将 <code>Dockerfile</code> 置于一个空目录下，或者项目根目录下。如果该目录下没有所需文件，那么应该把所需文件复制一份过来。如果目录下有些东西确实不希望构建时传给 Docker 引擎，那么可以用 <code>.gitignore</code> 一样的语法写一个 <code>.dockerignore</code>，该文件是用于剔除不需要作为上下文传递给 Docker 引擎的。</p><p>那么为什么会有人误以为 <code>.</code> 是指定 <code>Dockerfile</code> 所在目录呢？这是因为在默认情况下，如果不额外指定 <code>Dockerfile</code> 的话，会将上下文目录下的名为 <code>Dockerfile</code> 的文件作为 Dockerfile。</p><p>这只是默认行为，实际上 <code>Dockerfile</code> 的文件名并不要求必须为 <code>Dockerfile</code>，而且并不要求必须位于上下文目录中，比如可以用 <code>-f ../Dockerfile.php</code> 参数指定某个文件作为 <code>Dockerfile</code>。</p><p>一般使用默认的文件名 <code>Dockerfile</code>，以及会将其置于镜像构建上下文目录中。</p><h2 id="其它-docker-build-的用法"><a href="#其它-docker-build-的用法" class="headerlink" title="其它 docker build 的用法"></a>其它 <code>docker build</code> 的用法</h2><h3 id="直接用-Git-repo-进行构建"><a href="#直接用-Git-repo-进行构建" class="headerlink" title="直接用 Git repo 进行构建"></a>直接用 Git repo 进行构建</h3><p>或许你已经注意到了，<code>docker build</code> 还支持从 URL 构建，比如可以直接从 Git repo 中构建：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ docker build https://github.com/twang2218/gitlab-ce-zh.git<span class="comment">#:11.1</span></span><br><span class="line"></span><br><span class="line">Sending build context to Docker daemon 2.048 kB</span><br><span class="line">Step 1 : FROM gitlab/gitlab-ce:11.1.0-ce.0</span><br><span class="line">11.1.0-ce.0: Pulling from gitlab/gitlab-ce</span><br><span class="line">aed15891ba52: Already exists</span><br><span class="line">773ae8583d14: Already exists</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>这行命令指定了构建所需的 Git repo，并且指定默认的 <code>master</code> 分支，构建目录为 <code>/11.1/</code>，然后 Docker 就会自己去 <code>git clone</code> 这个项目、切换到指定分支、并进入到指定目录后开始构建。</p><h3 id="用给定的-tar-压缩包构建"><a href="#用给定的-tar-压缩包构建" class="headerlink" title="用给定的 tar 压缩包构建"></a>用给定的 tar 压缩包构建</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker build http://server/context.tar.gz</span><br></pre></td></tr></table></figure><p>如果所给出的 URL 不是个 Git repo，而是个 <code>tar</code> 压缩包，那么 Docker 引擎会下载这个包，并自动解压缩，以其作为上下文，开始构建。</p><h3 id="从标准输入中读取-Dockerfile-进行构建"><a href="#从标准输入中读取-Dockerfile-进行构建" class="headerlink" title="从标准输入中读取 Dockerfile 进行构建"></a>从标准输入中读取 Dockerfile 进行构建</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build - &lt; Dockerfile</span><br></pre></td></tr></table></figure><p>或</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat Dockerfile | docker build -</span><br></pre></td></tr></table></figure><p>如果标准输入传入的是文本文件，则将其视为 <code>Dockerfile</code>，并开始构建。这种形式由于直接从标准输入中读取 Dockerfile 的内容，它没有上下文，因此不可以像其他方法那样可以将本地文件 <code>COPY</code> 进镜像之类的事情。</p><h3 id="从标准输入中读取上下文压缩包进行构建"><a href="#从标准输入中读取上下文压缩包进行构建" class="headerlink" title="从标准输入中读取上下文压缩包进行构建"></a>从标准输入中读取上下文压缩包进行构建</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker build - &lt; context.tar.gz</span><br></pre></td></tr></table></figure><p>如果发现标准输入的文件格式是 <code>gzip</code>、<code>bzip2</code> 以及 <code>xz</code> 的话，将会使其为上下文压缩包，直接将其展开，将里面视为上下文，并开始构建。</p><h1 id="Dockerfile指令"><a href="#Dockerfile指令" class="headerlink" title="Dockerfile指令"></a>Dockerfile指令</h1><p>一张图来大概了解一下</p><p><img src="command.webp" alt></p><h2 id="COPY-复制文件"><a href="#COPY-复制文件" class="headerlink" title="COPY 复制文件"></a>COPY 复制文件</h2><p>格式：</p><ul><li><code>COPY [--chown=:] &lt;源路径&gt;... &lt;目标路径&gt;</code></li><li><code>COPY [--chown=:] [&quot;&lt;源路径1&gt;&quot;,... &quot;&lt;目标路径&gt;&quot;]</code></li></ul><p>和 <code>RUN</code> 指令一样，也有两种格式，一种类似于命令行，一种类似于函数调用。</p><p><code>COPY</code> 指令将从构建上下文目录中 <code>&lt;源路径&gt;</code> 的文件/目录复制到新的一层的镜像内的 <code>&lt;目标路径&gt;</code> 位置。比如：</p><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">COPY</span><span class="bash"> package.json /usr/src/app/</span></span><br></pre></td></tr></table></figure><p><code>&lt;源路径&gt;</code> 可以是多个，甚至可以是通配符，其通配符规则要满足 Go 的 <a href="https://golang.org/pkg/path/filepath/#Match" target="_blank" rel="noopener"><code>filepath.Match</code></a> 规则，如：</p><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">COPY</span><span class="bash"> hom* /mydir/</span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> hom?.txt /mydir/</span></span><br></pre></td></tr></table></figure><p><code>&lt;目标路径&gt;</code> 可以是容器内的绝对路径，也可以是相对于工作目录的相对路径（工作目录可以用 <code>WORKDIR</code> 指令来指定）。目标路径不需要事先创建，如果目录不存在会在复制文件前先行创建缺失目录。</p><p>此外，还需要注意一点，使用 <code>COPY</code> 指令，源文件的各种元数据都会保留。比如读、写、执行权限、文件变更时间等。这个特性对于镜像定制很有用。特别是构建相关文件都在使用 Git 进行管理的时候。</p><p>在使用该指令的时候还可以加上 <code>--chown=:</code> 选项来改变文件的所属用户及所属组。</p><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">COPY</span><span class="bash"> --chown=55:mygroup files* /mydir/</span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> --chown=bin files* /mydir/</span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> --chown=1 files* /mydir/</span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> --chown=10:11 files* /mydir/</span></span><br></pre></td></tr></table></figure><h2 id="ADD-更高级的复制文件"><a href="#ADD-更高级的复制文件" class="headerlink" title="ADD 更高级的复制文件"></a>ADD 更高级的复制文件</h2><p><code>ADD</code> 指令和 <code>COPY</code> 的格式和性质基本一致。但是在 <code>COPY</code> 基础上增加了一些功能。</p><p>比如 <code>&lt;源路径&gt;</code> 可以是一个 <code>URL</code>，这种情况下，Docker 引擎会试图去下载这个链接的文件放到 <code>&lt;目标路径&gt;</code> 去。下载后的文件权限自动设置为 <code>600</code>，如果这并不是想要的权限，那么还需要增加额外的一层 <code>RUN</code> 进行权限调整，另外，如果下载的是个压缩包，需要解压缩，也一样还需要额外的一层 <code>RUN</code> 指令进行解压缩。所以不如直接使用 <code>RUN</code> 指令，然后使用 <code>wget</code> 或者 <code>curl</code> 工具下载，处理权限、解压缩、然后清理无用文件更合理。因此，这个功能其实并不实用，而且不推荐使用。</p><p>如果 <code>&lt;源路径&gt;</code> 为一个 <code>tar</code> 压缩文件的话，压缩格式为 <code>gzip</code>, <code>bzip2</code> 以及 <code>xz</code> 的情况下，<code>ADD</code> 指令将会自动解压缩这个压缩文件到 <code>&lt;目标路径&gt;</code> 去。</p><p>在某些情况下，这个自动解压缩的功能非常有用，比如官方镜像 <code>ubuntu</code> 中：</p><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> scratch</span><br><span class="line"><span class="keyword">ADD</span><span class="bash"> ubuntu-xenial-core-cloudimg-amd64-root.tar.gz /</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>但在某些情况下，如果我们真的是希望复制个压缩文件进去，而不解压缩，这时就不可以使用 <code>ADD</code> 命令了。</p><p>在 Docker 官方的 <a href="https://yeasy.gitbooks.io/docker_practice/content/appendix/best_practices.html" target="_blank" rel="noopener">Dockerfile 最佳实践文档</a> 中要求，尽可能的使用 <code>COPY</code>，因为 <code>COPY</code> 的语义很明确，就是复制文件而已，而 <code>ADD</code> 则包含了更复杂的功能，其行为也不一定很清晰。最适合使用 <code>ADD</code> 的场合，就是所提及的需要自动解压缩的场合。</p><p>另外需要注意的是，<code>ADD</code> 指令会令镜像构建缓存失效，从而可能会令镜像构建变得比较缓慢。</p><p>因此在 <code>COPY</code> 和 <code>ADD</code> 指令中选择的时候，可以遵循这样的原则，所有的文件复制均使用 <code>COPY</code> 指令，仅在需要自动解压缩的场合使用 <code>ADD</code>。</p><p>在使用该指令的时候还可以加上 <code>--chown=:</code> 选项来改变文件的所属用户及所属组。</p><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ADD</span><span class="bash"> --chown=55:mygroup files* /mydir/</span></span><br><span class="line"><span class="keyword">ADD</span><span class="bash"> --chown=bin files* /mydir/</span></span><br><span class="line"><span class="keyword">ADD</span><span class="bash"> --chown=1 files* /mydir/</span></span><br><span class="line"><span class="keyword">ADD</span><span class="bash"> --chown=10:11 files* /mydir/</span></span><br></pre></td></tr></table></figure><h2 id="CMD-容器启动命令"><a href="#CMD-容器启动命令" class="headerlink" title="CMD 容器启动命令"></a>CMD 容器启动命令</h2><p><code>CMD</code> 指令的格式和 <code>RUN</code> 相似，也是两种格式：</p><ul><li><code>shell</code> 格式：<code>CMD &lt;命令&gt;</code></li><li><code>exec</code> 格式：<code>CMD [&quot;可执行文件&quot;, &quot;参数1&quot;, &quot;参数2&quot;...]</code></li><li>参数列表格式：<code>CMD [&quot;参数1&quot;, &quot;参数2&quot;...]</code>。在指定了 <code>ENTRYPOINT</code> 指令后，用 <code>CMD</code> 指定具体的参数。</li></ul><p>之前介绍容器的时候曾经说过，Docker 不是虚拟机，容器就是进程。既然是进程，那么在启动容器的时候，需要指定所运行的程序及参数。<code>CMD</code> 指令就是用于指定默认的容器主进程的启动命令的。</p><p>在运行时可以指定新的命令来替代镜像设置中的这个默认命令，比如，<code>ubuntu</code> 镜像默认的 <code>CMD</code> 是 <code>/bin/bash</code>，如果我们直接 <code>docker run -it ubuntu</code> 的话，会直接进入 <code>bash</code>。我们也可以在运行时指定运行别的命令，如 <code>docker run -it ubuntu cat /etc/os-release</code>。这就是用 <code>cat /etc/os-release</code> 命令替换了默认的 <code>/bin/bash</code> 命令了，输出了系统版本信息。</p><p>在指令格式上，一般推荐使用 <code>exec</code> 格式，这类格式在解析时会被解析为 JSON 数组，因此一定要使用双引号 <code>&quot;</code>，而不要使用单引号。</p><p>如果使用 <code>shell</code> 格式的话，实际的命令会被包装为 <code>sh -c</code> 的参数的形式进行执行。比如：</p><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CMD</span><span class="bash"> <span class="built_in">echo</span> <span class="variable">$HOME</span></span></span><br></pre></td></tr></table></figure><p>在实际执行中，会将其变更为：</p><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CMD</span><span class="bash"> [ <span class="string">"sh"</span>, <span class="string">"-c"</span>, <span class="string">"echo <span class="variable">$HOME</span>"</span> ]</span></span><br></pre></td></tr></table></figure><p>这就是为什么我们可以使用环境变量的原因，因为这些环境变量会被 shell 进行解析处理。</p><p>提到 <code>CMD</code> 就不得不提容器中应用在前台执行和后台执行的问题。这是初学者常出现的一个混淆。</p><p>Docker 不是虚拟机，容器中的应用都应该以前台执行，而不是像虚拟机、物理机里面那样，用 <code>systemd</code> 去启动后台服务，容器内没有后台服务的概念。</p><p>一些初学者将 <code>CMD</code> 写为：</p><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CMD</span><span class="bash"> service nginx start</span></span><br></pre></td></tr></table></figure><p>然后发现容器执行后就立即退出了。甚至在容器内去使用 <code>systemctl</code> 命令结果却发现根本执行不了。这就是因为没有搞明白前台、后台的概念，没有区分容器和虚拟机的差异，依旧在以传统虚拟机的角度去理解容器。</p><p><strong>对于容器而言，其启动程序就是容器应用进程，容器就是为了主进程而存在的，主进程退出，容器就失去了存在的意义，从而退出，其它辅助进程不是它需要关心的东西。</strong></p><p>而使用 <code>service nginx start</code> 命令，则是希望 upstart 来以后台守护进程形式启动 <code>nginx</code> 服务。而刚才说了 <code>CMD service nginx start</code> 会被理解为 <code>CMD [ &quot;sh&quot;, &quot;-c&quot;, &quot;service nginx start&quot;]</code>，因此主进程实际上是 <code>sh</code>。那么当 <code>service nginx start</code> 命令结束后，<code>sh</code> 也就结束了，<code>sh</code> 作为主进程退出了，自然就会令容器退出。</p><p>正确的做法是直接执行 <code>nginx</code> 可执行文件，并且要求以前台形式运行。比如：</p><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CMD</span><span class="bash"> [<span class="string">"nginx"</span>, <span class="string">"-g"</span>, <span class="string">"daemon off;"</span>]</span></span><br></pre></td></tr></table></figure><h2 id="ENTRYPOINT-入口点"><a href="#ENTRYPOINT-入口点" class="headerlink" title="ENTRYPOINT 入口点"></a>ENTRYPOINT 入口点</h2><p><code>ENTRYPOINT</code> 的格式和 <code>RUN</code> 指令格式一样，分为 <code>exec</code> 格式和 <code>shell</code> 格式。</p><p><code>ENTRYPOINT</code> 的目的和 <code>CMD</code> 一样，都是在指定容器启动程序及参数。<code>ENTRYPOINT</code> 在运行时也可以替代，不过比 <code>CMD</code> 要略显繁琐，需要通过 <code>docker run</code> 的参数 <code>--entrypoint</code> 来指定。</p><p>当指定了 <code>ENTRYPOINT</code> 后，<code>CMD</code> 的含义就发生了改变，不再是直接的运行其命令，而是将 <code>CMD</code> 的内容作为参数传给 <code>ENTRYPOINT</code> 指令，换句话说实际执行时，将变为：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;ENTRYPOINT&gt; <span class="string">"&lt;CMD&gt;"</span></span><br></pre></td></tr></table></figure><p>那么有了 <code>CMD</code> 后，为什么还要有 <code>ENTRYPOINT</code> 呢？这种 <code>&quot;&quot;</code> 有什么好处么？让我们来看几个场景。</p><h3 id="场景一：让镜像变成像命令一样使用"><a href="#场景一：让镜像变成像命令一样使用" class="headerlink" title="场景一：让镜像变成像命令一样使用"></a>场景一：让镜像变成像命令一样使用</h3><p>假设我们需要一个得知自己当前公网 IP 的镜像，那么可以先用 <code>CMD</code> 来实现：</p><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> ubuntu:<span class="number">18.04</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> apt-get update \</span></span><br><span class="line"><span class="bash">    &amp;&amp; apt-get install -y curl \</span></span><br><span class="line"><span class="bash">    &amp;&amp; rm -rf /var/lib/apt/lists/*</span></span><br><span class="line"><span class="keyword">CMD</span><span class="bash"> [ <span class="string">"curl"</span>, <span class="string">"-s"</span>, <span class="string">"https://ip.cn"</span> ]</span></span><br></pre></td></tr></table></figure><p>假如我们使用 <code>docker build -t myip .</code> 来构建镜像的话，如果我们需要查询当前公网 IP，只需要执行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker run myip</span><br><span class="line">当前 IP：61.148.226.66 来自：北京市 联通</span><br></pre></td></tr></table></figure><p>嗯，这么看起来好像可以直接把镜像当做命令使用了，不过命令总有参数，如果我们希望加参数呢？比如从上面的 <code>CMD</code> 中可以看到实质的命令是 <code>curl</code>，那么如果我们希望显示 HTTP 头信息，就需要加上 <code>-i</code> 参数。那么我们可以直接加 <code>-i</code> 参数给 <code>docker run myip</code> 么？</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker run myip -i</span><br><span class="line">docker: Error response from daemon: invalid header field value <span class="string">"oci runtime error: container_linux.go:247: starting container process caused \"exec: \\\"-i\\\": executable file not found in <span class="variable">$PATH</span>\"\n"</span>.</span><br></pre></td></tr></table></figure><p>我们可以看到可执行文件找不到的报错，<code>executable file not found</code>。之前我们说过，跟在镜像名后面的是 <code>command</code>，运行时会替换 <code>CMD</code> 的默认值。因此这里的 <code>-i</code> 替换了原来的 <code>CMD</code>，而不是添加在原来的 <code>curl -s https://ip.cn</code> 后面。而 <code>-i</code> 根本不是命令，所以自然找不到。</p><p>那么如果我们希望加入 <code>-i</code> 这参数，我们就必须重新完整的输入这个命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker run myip curl -s https://ip.cn -i</span><br></pre></td></tr></table></figure><p>这显然不是很好的解决方案，而使用 <code>ENTRYPOINT</code> 就可以解决这个问题。现在我们重新用 <code>ENTRYPOINT</code> 来实现这个镜像：</p><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> ubuntu:<span class="number">18.04</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> apt-get update \</span></span><br><span class="line"><span class="bash">    &amp;&amp; apt-get install -y curl \</span></span><br><span class="line"><span class="bash">    &amp;&amp; rm -rf /var/lib/apt/lists/*</span></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="bash"> [ <span class="string">"curl"</span>, <span class="string">"-s"</span>, <span class="string">"https://ip.cn"</span> ]</span></span><br></pre></td></tr></table></figure><p>这次我们再来尝试直接使用 <code>docker run myip -i</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">$ docker run myip</span><br><span class="line">当前 IP：61.148.226.66 来自：北京市 联通</span><br><span class="line"></span><br><span class="line">$ docker run myip -i</span><br><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Server: nginx/1.8.0</span><br><span class="line">Date: Tue, 22 Nov 2016 05:12:40 GMT</span><br><span class="line">Content-Type: text/html; charset=UTF-8</span><br><span class="line">Vary: Accept-Encoding</span><br><span class="line">X-Powered-By: PHP/5.6.24-1~dotdeb+7.1</span><br><span class="line">X-Cache: MISS from cache-2</span><br><span class="line">X-Cache-Lookup: MISS from cache-2:80</span><br><span class="line">X-Cache: MISS from proxy-2_6</span><br><span class="line">Transfer-Encoding: chunked</span><br><span class="line">Via: 1.1 cache-2:80, 1.1 proxy-2_6:8006</span><br><span class="line">Connection: keep-alive</span><br><span class="line"></span><br><span class="line">当前 IP：61.148.226.66 来自：北京市 联通</span><br></pre></td></tr></table></figure><p>可以看到，这次成功了。这是因为当存在 <code>ENTRYPOINT</code> 后，<code>CMD</code> 的内容将会作为参数传给 <code>ENTRYPOINT</code>，而这里 <code>-i</code> 就是新的 <code>CMD</code>，因此会作为参数传给 <code>curl</code>，从而达到了我们预期的效果。</p><h3 id="场景二：应用运行前的准备工作"><a href="#场景二：应用运行前的准备工作" class="headerlink" title="场景二：应用运行前的准备工作"></a>场景二：应用运行前的准备工作</h3><p>启动容器就是启动主进程，但有些时候，启动主进程前，需要一些准备工作。</p><p>比如 <code>mysql</code> 类的数据库，可能需要一些数据库配置、初始化的工作，这些工作要在最终的 mysql 服务器运行之前解决。</p><p>此外，可能希望避免使用 <code>root</code> 用户去启动服务，从而提高安全性，而在启动服务前还需要以 <code>root</code> 身份执行一些必要的准备工作，最后切换到服务用户身份启动服务。或者除了服务外，其它命令依旧可以使用 <code>root</code> 身份执行，方便调试等。</p><p>这些准备工作是和容器 <code>CMD</code> 无关的，无论 <code>CMD</code> 为什么，都需要事先进行一个预处理的工作。这种情况下，可以写一个脚本，然后放入 <code>ENTRYPOINT</code> 中去执行，而这个脚本会将接到的参数（也就是 <code></code>）作为命令，在脚本最后执行。比如官方镜像 <code>redis</code> 中就是这么做的：</p><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> alpine:<span class="number">3.4</span></span><br><span class="line">...</span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> addgroup -S redis &amp;&amp; adduser -S -G redis redis</span></span><br><span class="line">...</span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="bash"> [<span class="string">"docker-entrypoint.sh"</span>]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">6379</span></span><br><span class="line"><span class="keyword">CMD</span><span class="bash"> [ <span class="string">"redis-server"</span> ]</span></span><br></pre></td></tr></table></figure><p>可以看到其中为了 redis 服务创建了 redis 用户，并在最后指定了 <code>ENTRYPOINT</code> 为 <code>docker-entrypoint.sh</code> 脚本。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line">...</span><br><span class="line"><span class="comment"># allow the container to be started with `--user`</span></span><br><span class="line"><span class="keyword">if</span> [ <span class="string">"<span class="variable">$1</span>"</span> = <span class="string">'redis-server'</span> -a <span class="string">"<span class="variable">$(id -u)</span>"</span> = <span class="string">'0'</span> ]; <span class="keyword">then</span></span><br><span class="line">    chown -R redis .</span><br><span class="line">    <span class="built_in">exec</span> su-exec redis <span class="string">"<span class="variable">$0</span>"</span> <span class="string">"<span class="variable">$@</span>"</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">exec</span> <span class="string">"<span class="variable">$@</span>"</span></span><br></pre></td></tr></table></figure><p>该脚本的内容就是根据 <code>CMD</code> 的内容来判断，如果是 <code>redis-server</code> 的话，则切换到 <code>redis</code> 用户身份启动服务器，否则依旧使用 <code>root</code> 身份执行。比如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -it redis id</span><br><span class="line">uid=0(root) gid=0(root) groups=0(root)</span><br></pre></td></tr></table></figure><h2 id="ENV-设置环境变量"><a href="#ENV-设置环境变量" class="headerlink" title="ENV 设置环境变量"></a>ENV 设置环境变量</h2><p>格式有两种：</p><ul><li><code>ENV</code></li><li><code>ENV = =...</code></li></ul><p>这个指令很简单，就是设置环境变量而已，无论是后面的其它指令，如 <code>RUN</code>，还是运行时的应用，都可以直接使用这里定义的环境变量。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ENV VERSION=1.0 DEBUG=on \</span><br><span class="line">    NAME=&quot;Happy Feet&quot;</span><br></pre></td></tr></table></figure><p>这个例子中演示了如何换行，以及对含有空格的值用双引号括起来的办法，这和 Shell 下的行为是一致的。</p><p>定义了环境变量，那么在后续的指令中，就可以使用这个环境变量。比如在官方 <code>node</code> 镜像 <code>Dockerfile</code> 中，就有类似这样的代码：</p><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ENV</span> NODE_VERSION <span class="number">7.2</span>.<span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> curl -SLO <span class="string">"https://nodejs.org/dist/v<span class="variable">$NODE_VERSION</span>/node-v<span class="variable">$NODE_VERSION</span>-linux-x64.tar.xz"</span> \</span></span><br><span class="line"><span class="bash">  &amp;&amp; curl -SLO <span class="string">"https://nodejs.org/dist/v<span class="variable">$NODE_VERSION</span>/SHASUMS256.txt.asc"</span> \</span></span><br><span class="line"><span class="bash">  &amp;&amp; gpg --batch --decrypt --output SHASUMS256.txt SHASUMS256.txt.asc \</span></span><br><span class="line"><span class="bash">  &amp;&amp; grep <span class="string">" node-v<span class="variable">$NODE_VERSION</span>-linux-x64.tar.xz\$"</span> SHASUMS256.txt | sha256sum -c - \</span></span><br><span class="line"><span class="bash">  &amp;&amp; tar -xJf <span class="string">"node-v<span class="variable">$NODE_VERSION</span>-linux-x64.tar.xz"</span> -C /usr/<span class="built_in">local</span> --strip-components=1 \</span></span><br><span class="line"><span class="bash">  &amp;&amp; rm <span class="string">"node-v<span class="variable">$NODE_VERSION</span>-linux-x64.tar.xz"</span> SHASUMS256.txt.asc SHASUMS256.txt \</span></span><br><span class="line"><span class="bash">  &amp;&amp; ln -s /usr/<span class="built_in">local</span>/bin/node /usr/<span class="built_in">local</span>/bin/nodejs</span></span><br></pre></td></tr></table></figure><p>在这里先定义了环境变量 <code>NODE_VERSION</code>，其后的 <code>RUN</code> 这层里，多次使用 <code>$NODE_VERSION</code> 来进行操作定制。可以看到，将来升级镜像构建版本的时候，只需要更新 <code>7.2.0</code> 即可，<code>Dockerfile</code> 构建维护变得更轻松了。</p><p>下列指令可以支持环境变量展开： <code>ADD</code>、<code>COPY</code>、<code>ENV</code>、<code>EXPOSE</code>、<code>FROM</code>、<code>LABEL</code>、<code>USER</code>、<code>WORKDIR</code>、<code>VOLUME</code>、<code>STOPSIGNAL</code>、<code>ONBUILD</code>、<code>RUN</code>。</p><p>可以从这个指令列表里感觉到，环境变量可以使用的地方很多，很强大。通过环境变量，我们可以让一份 <code>Dockerfile</code> 制作更多的镜像，只需使用不同的环境变量即可。</p><h2 id="ARG-构建参数"><a href="#ARG-构建参数" class="headerlink" title="ARG 构建参数"></a>ARG 构建参数</h2><p>格式：<code>ARG &lt;参数名&gt;[=&lt;默认值&gt;]</code></p><p>构建参数和 <code>ENV</code> 的效果一样，都是设置环境变量。所不同的是，<code>ARG</code> 所设置的构建环境的环境变量，在将来容器运行时是不会存在这些环境变量的。但是不要因此就使用 <code>ARG</code> 保存密码之类的信息，因为 <code>docker history</code> 还是可以看到所有值的。</p><p><code>Dockerfile</code> 中的 <code>ARG</code> 指令是定义参数名称，以及定义其默认值。该默认值可以在构建命令 <code>docker build</code> 中用 <code>--build-arg &lt;参数名&gt;=&lt;值&gt;</code> 来覆盖。</p><p>在 1.13 之前的版本，要求 <code>--build-arg</code> 中的参数名，必须在 <code>Dockerfile</code> 中用 <code>ARG</code> 定义过了，换句话说，就是 <code>--build-arg</code> 指定的参数，必须在 <code>Dockerfile</code> 中使用了。如果对应参数没有被使用，则会报错退出构建。从 1.13 开始，这种严格的限制被放开，不再报错退出，而是显示警告信息，并继续构建。这对于使用 CI 系统，用同样的构建流程构建不同的 <code>Dockerfile</code> 的时候比较有帮助，避免构建命令必须根据每个 Dockerfile 的内容修改。</p><h2 id="VOLUME-定义匿名卷"><a href="#VOLUME-定义匿名卷" class="headerlink" title="VOLUME 定义匿名卷"></a>VOLUME 定义匿名卷</h2><p>格式为：</p><ul><li><code>VOLUME [&quot;&lt;路径1&gt;&quot;, &quot;&lt;路径2&gt;&quot;...]</code></li><li><code>VOLUME &lt;路径&gt;</code></li></ul><p>之前我们说过，容器运行时应该尽量保持容器存储层不发生写操作，对于数据库类需要保存动态数据的应用，其数据库文件应该保存于卷(volume)中，后面的章节我们会进一步介绍 Docker 卷的概念。为了防止运行时用户忘记将动态文件所保存目录挂载为卷，在 <code>Dockerfile</code> 中，我们可以事先指定某些目录挂载为匿名卷，这样在运行时如果用户不指定挂载，其应用也可以正常运行，不会向容器存储层写入大量数据。</p><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">VOLUME</span><span class="bash"> /data</span></span><br></pre></td></tr></table></figure><p>这里的 <code>/data</code> 目录就会在运行时自动挂载为匿名卷，任何向 <code>/data</code> 中写入的信息都不会记录进容器存储层，从而保证了容器存储层的无状态化。当然，运行时可以覆盖这个挂载设置。比如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -v mydata:/data xxxx</span><br></pre></td></tr></table></figure><p>在这行命令中，就使用了 <code>mydata</code> 这个命名卷挂载到了 <code>/data</code> 这个位置，替代了 <code>Dockerfile</code> 中定义的匿名卷的挂载配置。</p><h2 id="EXPOSE-声明端口"><a href="#EXPOSE-声明端口" class="headerlink" title="EXPOSE 声明端口"></a>EXPOSE 声明端口</h2><p>格式为 <code>EXPOSE &lt;端口1&gt; [&lt;端口2&gt;...]</code>。</p><p><code>EXPOSE</code> 指令是声明运行时容器提供服务端口，这只是一个声明，在运行时并不会因为这个声明应用就会开启这个端口的服务。在 Dockerfile 中写入这样的声明有两个好处，一个是帮助镜像使用者理解这个镜像服务的守护端口，以方便配置映射；另一个用处则是在运行时使用随机端口映射时，也就是 <code>docker run -P</code> 时，会自动随机映射 <code>EXPOSE</code> 的端口。</p><p>要将 <code>EXPOSE</code> 和在运行时使用 <code>-p &lt;宿主端口&gt;:&lt;容器端口&gt;</code> 区分开来。<code>-p</code>，是映射宿主端口和容器端口，换句话说，就是将容器的对应端口服务公开给外界访问，而 <code>EXPOSE</code> 仅仅是声明容器打算使用什么端口而已，并不会自动在宿主进行端口映射。</p><h2 id="WORKDIR-指定工作目录"><a href="#WORKDIR-指定工作目录" class="headerlink" title="WORKDIR 指定工作目录"></a>WORKDIR 指定工作目录</h2><p>格式为 <code>WORKDIR &lt;工作目录路径&gt;</code>。</p><p>使用 <code>WORKDIR</code> 指令可以来指定工作目录（或者称为当前目录），以后各层的当前目录就被改为指定的目录，如该目录不存在，<code>WORKDIR</code> 会帮你建立目录。</p><p>之前提到一些初学者常犯的错误是把 <code>Dockerfile</code> 等同于 Shell 脚本来书写，这种错误的理解还可能会导致出现下面这样的错误：</p><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">RUN</span><span class="bash"> <span class="built_in">cd</span> /app</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> <span class="built_in">echo</span> <span class="string">"hello"</span> &gt; world.txt</span></span><br></pre></td></tr></table></figure><p>如果将这个 <code>Dockerfile</code> 进行构建镜像运行后，会发现找不到 <code>/app/world.txt</code> 文件，或者其内容不是 <code>hello</code>。原因其实很简单，在 Shell 中，连续两行是同一个进程执行环境，因此前一个命令修改的内存状态，会直接影响后一个命令；而在 <code>Dockerfile</code> 中，这两行 <code>RUN</code> 命令的执行环境根本不同，是两个完全不同的容器。这就是对 <code>Dockerfile</code> 构建分层存储的概念不了解所导致的错误。</p><p>之前说过每一个 <code>RUN</code> 都是启动一个容器、执行命令、然后提交存储层文件变更。第一层 <code>RUN cd /app</code> 的执行仅仅是当前进程的工作目录变更，一个内存上的变化而已，其结果不会造成任何文件变更。而到第二层的时候，启动的是一个全新的容器，跟第一层的容器更完全没关系，自然不可能继承前一层构建过程中的内存变化。</p><p>因此如果需要改变以后各层的工作目录的位置，那么应该使用 <code>WORKDIR</code> 指令。</p><h2 id="USER-指定当前用户"><a href="#USER-指定当前用户" class="headerlink" title="USER 指定当前用户"></a>USER 指定当前用户</h2><p>格式：<code>USER &lt;用户名&gt;[:&lt;用户组&gt;]</code></p><p><code>USER</code> 指令和 <code>WORKDIR</code> 相似，都是改变环境状态并影响以后的层。<code>WORKDIR</code> 是改变工作目录，<code>USER</code> 则是改变之后层的执行 <code>RUN</code>, <code>CMD</code> 以及 <code>ENTRYPOINT</code> 这类命令的身份。</p><p>当然，和 <code>WORKDIR</code> 一样，<code>USER</code> 只是帮助你切换到指定用户而已，这个用户必须是事先建立好的，否则无法切换。</p><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">RUN</span><span class="bash"> groupadd -r redis &amp;&amp; useradd -r -g redis redis</span></span><br><span class="line"><span class="keyword">USER</span> redis</span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> [ <span class="string">"redis-server"</span> ]</span></span><br></pre></td></tr></table></figure><p>如果以 <code>root</code> 执行的脚本，在执行期间希望改变身份，比如希望以某个已经建立好的用户来运行某个服务进程，不要使用 <code>su</code> 或者 <code>sudo</code>，这些都需要比较麻烦的配置，而且在 TTY 缺失的环境下经常出错。建议使用 <a href="https://github.com/tianon/gosu" target="_blank" rel="noopener"><code>gosu</code></a>。</p><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 建立 redis 用户，并使用 gosu 换另一个用户执行命令</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> groupadd -r redis &amp;&amp; useradd -r -g redis redis</span></span><br><span class="line"><span class="comment"># 下载 gosu</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> wget -O /usr/<span class="built_in">local</span>/bin/gosu <span class="string">"https://github.com/tianon/gosu/releases/download/1.7/gosu-amd64"</span> \</span></span><br><span class="line"><span class="bash">    &amp;&amp; chmod +x /usr/<span class="built_in">local</span>/bin/gosu \</span></span><br><span class="line"><span class="bash">    &amp;&amp; gosu nobody <span class="literal">true</span></span></span><br><span class="line"><span class="comment"># 设置 CMD，并以另外的用户执行</span></span><br><span class="line"><span class="keyword">CMD</span><span class="bash"> [ <span class="string">"exec"</span>, <span class="string">"gosu"</span>, <span class="string">"redis"</span>, <span class="string">"redis-server"</span> ]</span></span><br></pre></td></tr></table></figure><h2 id="HEALTHCHECK-健康检查"><a href="#HEALTHCHECK-健康检查" class="headerlink" title="HEALTHCHECK 健康检查"></a>HEALTHCHECK 健康检查</h2><p>格式：</p><ul><li><code>HEALTHCHECK [选项] CMD &lt;命令&gt;</code>：设置检查容器健康状况的命令</li><li><code>HEALTHCHECK NONE</code>：如果基础镜像有健康检查指令，使用这行可以屏蔽掉其健康检查指令</li></ul><p><code>HEALTHCHECK</code> 指令是告诉 Docker 应该如何进行判断容器的状态是否正常，这是 Docker 1.12 引入的新指令。</p><p>在没有 <code>HEALTHCHECK</code> 指令前，Docker 引擎只可以通过容器内主进程是否退出来判断容器是否状态异常。很多情况下这没问题，但是如果程序进入死锁状态，或者死循环状态，应用进程并不退出，但是该容器已经无法提供服务了。在 1.12 以前，Docker 不会检测到容器的这种状态，从而不会重新调度，导致可能会有部分容器已经无法提供服务了却还在接受用户请求。</p><p>而自 1.12 之后，Docker 提供了 <code>HEALTHCHECK</code> 指令，通过该指令指定一行命令，用这行命令来判断容器主进程的服务状态是否还正常，从而比较真实的反应容器实际状态。</p><p>当在一个镜像指定了 <code>HEALTHCHECK</code> 指令后，用其启动容器，初始状态会为 <code>starting</code>，在 <code>HEALTHCHECK</code> 指令检查成功后变为 <code>healthy</code>，如果连续一定次数失败，则会变为 <code>unhealthy</code>。</p><p><code>HEALTHCHECK</code> 支持下列选项：</p><ul><li><code>--interval=&lt;间隔&gt;</code>：两次健康检查的间隔，默认为 30 秒；</li><li><code>--timeout=&lt;时长&gt;</code>：健康检查命令运行超时时间，如果超过这个时间，本次健康检查就被视为失败，默认 30 秒；</li><li><code>--retries=&lt;次数&gt;</code>：当连续失败指定次数后，则将容器状态视为 <code>unhealthy</code>，默认 3 次。</li></ul><p>和 <code>CMD</code>, <code>ENTRYPOINT</code> 一样，<code>HEALTHCHECK</code> 只可以出现一次，如果写了多个，只有最后一个生效。</p><p>在 <code>HEALTHCHECK [选项] CMD</code> 后面的命令，格式和 <code>ENTRYPOINT</code> 一样，分为 <code>shell</code> 格式，和 <code>exec</code> 格式。命令的返回值决定了该次健康检查的成功与否：<code>0</code>：成功；<code>1</code>：失败；<code>2</code>：保留，不要使用这个值。</p><p>假设我们有个镜像是个最简单的 Web 服务，我们希望增加健康检查来判断其 Web 服务是否在正常工作，我们可以用 <code>curl</code> 来帮助判断，其 <code>Dockerfile</code> 的 <code>HEALTHCHECK</code> 可以这么写：</p><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> nginx</span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> apt-get update &amp;&amp; apt-get install -y curl &amp;&amp; rm -rf /var/lib/apt/lists/*</span></span><br><span class="line"><span class="keyword">HEALTHCHECK</span><span class="bash"> --interval=5s --timeout=3s \</span></span><br><span class="line"><span class="bash">  CMD curl -fs http://localhost/ || <span class="built_in">exit</span> 1</span></span><br></pre></td></tr></table></figure><p>这里我们设置了每 5 秒检查一次（这里为了试验所以间隔非常短，实际应该相对较长），如果健康检查命令超过 3 秒没响应就视为失败，并且使用 <code>curl -fs http://localhost/ || exit 1</code> 作为健康检查命令。</p><p>使用 <code>docker build</code> 来构建这个镜像：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker build -t myweb:v1 .</span><br></pre></td></tr></table></figure><p>构建好了后，我们启动一个容器：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -d --name web -p 80:80 myweb:v1</span><br></pre></td></tr></table></figure><p>当运行该镜像后，可以通过 <code>docker container ls</code> 看到最初的状态为 <code>(health: starting)</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ docker container ls</span><br><span class="line">CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS                            PORTS               NAMES</span><br><span class="line">03e28eb00bd0        myweb:v1            <span class="string">"nginx -g 'daemon off"</span>   3 seconds ago       Up 2 seconds (health: starting)   80/tcp, 443/tcp     web</span><br></pre></td></tr></table></figure><p>在等待几秒钟后，再次 <code>docker container ls</code>，就会看到健康状态变化为了 <code>(healthy)</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ docker container ls</span><br><span class="line">CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS                    PORTS               NAMES</span><br><span class="line">03e28eb00bd0        myweb:v1            <span class="string">"nginx -g 'daemon off"</span>   18 seconds ago      Up 16 seconds (healthy)   80/tcp, 443/tcp     web</span><br></pre></td></tr></table></figure><p>如果健康检查连续失败超过了重试次数，状态就会变为 <code>(unhealthy)</code>。</p><p>为了帮助排障，健康检查命令的输出（包括 <code>stdout</code> 以及 <code>stderr</code>）都会被存储于健康状态里，可以用 <code>docker inspect</code> 来查看。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ docker inspect --format <span class="string">'&#123;&#123;json .State.Health&#125;&#125;'</span> web | python -m json.tool</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">"FailingStreak"</span>: 0,</span><br><span class="line">    <span class="string">"Log"</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">"End"</span>: <span class="string">"2016-11-25T14:35:37.940957051Z"</span>,</span><br><span class="line">            <span class="string">"ExitCode"</span>: 0,</span><br><span class="line">            <span class="string">"Output"</span>: <span class="string">"&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;head&gt;\n&lt;title&gt;Welcome to nginx!&lt;/title&gt;\n&lt;style&gt;\n    body &#123;\n        width: 35em;\n        margin: 0 auto;\n        font-family: Tahoma, Verdana, Arial, sans-serif;\n    &#125;\n&lt;/style&gt;\n&lt;/head&gt;\n&lt;body&gt;\n&lt;h1&gt;Welcome to nginx!&lt;/h1&gt;\n&lt;p&gt;If you see this page, the nginx web server is successfully installed and\nworking. Further configuration is required.&lt;/p&gt;\n\n&lt;p&gt;For online documentation and support please refer to\n&lt;a href=\"http://nginx.org/\"&gt;nginx.org&lt;/a&gt;.&lt;br/&gt;\nCommercial support is available at\n&lt;a href=\"http://nginx.com/\"&gt;nginx.com&lt;/a&gt;.&lt;/p&gt;\n\n&lt;p&gt;&lt;em&gt;Thank you for using nginx.&lt;/em&gt;&lt;/p&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n"</span>,</span><br><span class="line">            <span class="string">"Start"</span>: <span class="string">"2016-11-25T14:35:37.780192565Z"</span></span><br><span class="line">        &#125;</span><br><span class="line">    ],</span><br><span class="line">    <span class="string">"Status"</span>: <span class="string">"healthy"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="ONBUILD-为他人做嫁衣裳"><a href="#ONBUILD-为他人做嫁衣裳" class="headerlink" title="ONBUILD 为他人做嫁衣裳"></a>ONBUILD 为他人做嫁衣裳</h2><p>格式：<code>ONBUILD &lt;其它指令&gt;</code>。</p><p><code>ONBUILD</code> 是一个特殊的指令，它后面跟的是其它指令，比如 <code>RUN</code>, <code>COPY</code> 等，而这些指令，在当前镜像构建时并不会被执行。只有当以当前镜像为基础镜像，去构建下一级镜像的时候才会被执行。</p><p><code>Dockerfile</code> 中的其它指令都是为了定制当前镜像而准备的，唯有 <code>ONBUILD</code> 是为了帮助别人定制自己而准备的。</p><p>假设我们要制作 Node.js 所写的应用的镜像。我们都知道 Node.js 使用 <code>npm</code> 进行包管理，所有依赖、配置、启动信息等会放到 <code>package.json</code> 文件里。在拿到程序代码后，需要先进行 <code>npm install</code> 才可以获得所有需要的依赖。然后就可以通过 <code>npm start</code> 来启动应用。因此，一般来说会这样写 <code>Dockerfile</code>：</p><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> node:slim</span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> mkdir /app</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> /app</span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> ./package.json /app</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> [ <span class="string">"npm"</span>, <span class="string">"install"</span> ]</span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> . /app/</span></span><br><span class="line"><span class="keyword">CMD</span><span class="bash"> [ <span class="string">"npm"</span>, <span class="string">"start"</span> ]</span></span><br></pre></td></tr></table></figure><p>把这个 <code>Dockerfile</code> 放到 Node.js 项目的根目录，构建好镜像后，就可以直接拿来启动容器运行。但是如果我们还有第二个 Node.js 项目也差不多呢？好吧，那就再把这个 <code>Dockerfile</code> 复制到第二个项目里。那如果有第三个项目呢？再复制么？文件的副本越多，版本控制就越困难，让我们继续看这样的场景维护的问题。</p><p>如果第一个 Node.js 项目在开发过程中，发现这个 <code>Dockerfile</code> 里存在问题，比如敲错字了、或者需要安装额外的包，然后开发人员修复了这个 <code>Dockerfile</code>，再次构建，问题解决。第一个项目没问题了，但是第二个项目呢？虽然最初 <code>Dockerfile</code> 是复制、粘贴自第一个项目的，但是并不会因为第一个项目修复了他们的 <code>Dockerfile</code>，而第二个项目的 <code>Dockerfile</code> 就会被自动修复。</p><p>那么我们可不可以做一个基础镜像，然后各个项目使用这个基础镜像呢？这样基础镜像更新，各个项目不用同步 <code>Dockerfile</code> 的变化，重新构建后就继承了基础镜像的更新？好吧，可以，让我们看看这样的结果。那么上面的这个 <code>Dockerfile</code> 就会变为：</p><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> node:slim</span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> mkdir /app</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> /app</span></span><br><span class="line"><span class="keyword">CMD</span><span class="bash"> [ <span class="string">"npm"</span>, <span class="string">"start"</span> ]</span></span><br></pre></td></tr></table></figure><p>这里我们把项目相关的构建指令拿出来，放到子项目里去。假设这个基础镜像的名字为 <code>my-node</code> 的话，各个项目内的自己的 <code>Dockerfile</code> 就变为：</p><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> my-node</span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> ./package.json /app</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> [ <span class="string">"npm"</span>, <span class="string">"install"</span> ]</span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> . /app/</span></span><br></pre></td></tr></table></figure><p>基础镜像变化后，各个项目都用这个 <code>Dockerfile</code> 重新构建镜像，会继承基础镜像的更新。</p><p>那么，问题解决了么？没有。准确说，只解决了一半。如果这个 <code>Dockerfile</code> 里面有些东西需要调整呢？比如 <code>npm install</code> 都需要加一些参数，那怎么办？这一行 <code>RUN</code> 是不可能放入基础镜像的，因为涉及到了当前项目的 <code>./package.json</code>，难道又要一个个修改么？所以说，这样制作基础镜像，只解决了原来的 <code>Dockerfile</code> 的前4条指令的变化问题，而后面三条指令的变化则完全没办法处理。</p><p><code>ONBUILD</code> 可以解决这个问题。让我们用 <code>ONBUILD</code> 重新写一下基础镜像的 <code>Dockerfile</code>:</p><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> node:slim</span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> mkdir /app</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> /app</span></span><br><span class="line"><span class="keyword">ONBUILD</span> <span class="keyword">COPY</span><span class="bash"> ./package.json /app</span></span><br><span class="line"><span class="keyword">ONBUILD</span> <span class="keyword">RUN</span><span class="bash"> [ <span class="string">"npm"</span>, <span class="string">"install"</span> ]</span></span><br><span class="line"><span class="keyword">ONBUILD</span> <span class="keyword">COPY</span><span class="bash"> . /app/</span></span><br><span class="line"><span class="keyword">CMD</span><span class="bash"> [ <span class="string">"npm"</span>, <span class="string">"start"</span> ]</span></span><br></pre></td></tr></table></figure><p>这次我们回到原始的 <code>Dockerfile</code>，但是这次将项目相关的指令加上 <code>ONBUILD</code>，这样在构建基础镜像的时候，这三行并不会被执行。然后各个项目的 <code>Dockerfile</code> 就变成了简单地：</p><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> my-node</span><br></pre></td></tr></table></figure><p>是的，只有这么一行。当在各个项目目录中，用这个只有一行的 <code>Dockerfile</code> 构建镜像时，之前基础镜像的那三行 <code>ONBUILD</code> 就会开始执行，成功的将当前项目的代码复制进镜像、并且针对本项目执行 <code>npm install</code>，生成应用镜像。</p><h1 id="Dockerfile多阶段构建"><a href="#Dockerfile多阶段构建" class="headerlink" title="Dockerfile多阶段构建"></a>Dockerfile多阶段构建</h1><h2 id="之前的做法"><a href="#之前的做法" class="headerlink" title="之前的做法"></a>之前的做法</h2><p>在 Docker 17.05 版本之前，我们构建 Docker 镜像时，通常会采用两种方式：</p><h3 id="全部放入一个-Dockerfile"><a href="#全部放入一个-Dockerfile" class="headerlink" title="全部放入一个 Dockerfile"></a>全部放入一个 Dockerfile</h3><p>一种方式是将所有的构建过程编包含在一个 <code>Dockerfile</code> 中，包括项目及其依赖库的编译、测试、打包等流程，这里可能会带来的一些问题：</p><ul><li>镜像层次多，镜像体积较大，部署时间变长</li><li>源代码存在泄露的风险</li></ul><p>例如，编写 <code>app.go</code> 文件，该程序输出 <code>Hello World!</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    fmt.Printf(<span class="string">"Hello World!"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编写 <code>Dockerfile.one</code> 文件</p><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> golang:<span class="number">1.9</span>-alpine</span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> apk --no-cache add git ca-certificates</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> /go/src/github.com/go/helloworld/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> app.go .</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> go get -d -v github.com/go-sql-driver/mysql \</span></span><br><span class="line"><span class="bash">  &amp;&amp; CGO_ENABLED=0 GOOS=linux go build -a -installsuffix cgo -o app . \</span></span><br><span class="line"><span class="bash">  &amp;&amp; cp /go/src/github.com/go/helloworld/app /root</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> /root/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">CMD</span><span class="bash"> [<span class="string">"./app"</span>]</span></span><br></pre></td></tr></table></figure><p>构建镜像</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker build -t go/helloworld:1 -f Dockerfile.one .</span><br></pre></td></tr></table></figure><h3 id="分散到多个-Dockerfile"><a href="#分散到多个-Dockerfile" class="headerlink" title="分散到多个 Dockerfile"></a>分散到多个 Dockerfile</h3><p>另一种方式，就是我们事先在一个 <code>Dockerfile</code> 将项目及其依赖库编译测试打包好后，再将其拷贝到运行环境中，这种方式需要我们编写两个 <code>Dockerfile</code> 和一些编译脚本才能将其两个阶段自动整合起来，这种方式虽然可以很好地规避第一种方式存在的风险，但明显部署过程较复杂。</p><p>例如，编写 <code>Dockerfile.build</code> 文件</p><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> golang:<span class="number">1.9</span>-alpine</span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> apk --no-cache add git</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> /go/src/github.com/go/helloworld</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> app.go .</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> go get -d -v github.com/go-sql-driver/mysql \</span></span><br><span class="line"><span class="bash">  &amp;&amp; CGO_ENABLED=0 GOOS=linux go build -a -installsuffix cgo -o app .</span></span><br></pre></td></tr></table></figure><p>编写 <code>Dockerfile.copy</code> 文件</p><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> alpine:latest</span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> apk --no-cache add ca-certificates</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> /root/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> app .</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">CMD</span><span class="bash"> [<span class="string">"./app"</span>]</span></span><br></pre></td></tr></table></figure><p>新建 <code>build.sh</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"><span class="built_in">echo</span> Building go/helloworld:build</span><br><span class="line"></span><br><span class="line">docker build -t go/helloworld:build . -f Dockerfile.build</span><br><span class="line"></span><br><span class="line">docker create --name extract go/helloworld:build</span><br><span class="line">docker cp extract:/go/src/github.com/go/helloworld/app ./app</span><br><span class="line">docker rm -f extract</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> Building go/helloworld:2</span><br><span class="line"></span><br><span class="line">docker build --no-cache -t go/helloworld:2 . -f Dockerfile.copy</span><br><span class="line">rm ./app</span><br></pre></td></tr></table></figure><p>现在运行脚本即可构建镜像</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ chmod +x build.sh</span><br><span class="line"></span><br><span class="line">$ ./build.sh</span><br></pre></td></tr></table></figure><p>对比两种方式生成的镜像大小</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ docker image ls</span><br><span class="line"></span><br><span class="line">REPOSITORY      TAG    IMAGE ID        CREATED         SIZE</span><br><span class="line">go/helloworld   2      f7cf3465432c    22 seconds ago  6.47MB</span><br><span class="line">go/helloworld   1      f55d3e16affc    2 minutes ago   295MB</span><br></pre></td></tr></table></figure><h2 id="使用多阶段构建"><a href="#使用多阶段构建" class="headerlink" title="使用多阶段构建"></a>使用多阶段构建</h2><p>为解决以上问题，Docker v17.05 开始支持多阶段构建 (<code>multistage builds</code>)。使用多阶段构建我们就可以很容易解决前面提到的问题，并且只需要编写一个 <code>Dockerfile</code>：</p><p>例如，编写 <code>Dockerfile</code> 文件</p><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> golang:<span class="number">1.9</span>-alpine as builder</span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> apk --no-cache add git</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> /go/src/github.com/go/helloworld/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> go get -d -v github.com/go-sql-driver/mysql</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> app.go .</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> CGO_ENABLED=0 GOOS=linux go build -a -installsuffix cgo -o app .</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">FROM</span> alpine:latest as prod</span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> apk --no-cache add ca-certificates</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> /root/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> --from=0 /go/src/github.com/go/helloworld/app .</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">CMD</span><span class="bash"> [<span class="string">"./app"</span>]</span></span><br></pre></td></tr></table></figure><p>构建镜像</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker build -t go/helloworld:3 .</span><br></pre></td></tr></table></figure><p>对比三个镜像大小</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ docker image ls</span><br><span class="line"></span><br><span class="line">REPOSITORY        TAG   IMAGE ID         CREATED            SIZE</span><br><span class="line">go/helloworld     3     d6911ed9c846     7 seconds ago      6.47MB</span><br><span class="line">go/helloworld     2     f7cf3465432c     22 seconds ago     6.47MB</span><br><span class="line">go/helloworld     1     f55d3e16affc     2 minutes ago      295MB</span><br></pre></td></tr></table></figure><p>很明显使用多阶段构建的镜像体积小，同时也完美解决了上边提到的问题。</p><h3 id="只构建某一阶段的镜像"><a href="#只构建某一阶段的镜像" class="headerlink" title="只构建某一阶段的镜像"></a>只构建某一阶段的镜像</h3><p>我们可以使用 <code>as</code> 来为某一阶段命名，例如</p><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> golang:<span class="number">1.9</span>-alpine as builder</span><br></pre></td></tr></table></figure><p>例如当我们只想构建 <code>builder</code> 阶段的镜像时，增加 <code>--target=builder</code> 参数即可</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker build --target builder -t username/imagename:tag .</span><br></pre></td></tr></table></figure><h3 id="构建时从其他镜像复制文件"><a href="#构建时从其他镜像复制文件" class="headerlink" title="构建时从其他镜像复制文件"></a>构建时从其他镜像复制文件</h3><p>上面例子中我们使用 <code>COPY --from=0 /go/src/github.com/go/helloworld/app .</code> 从上一阶段的镜像中复制文件，我们也可以复制任意镜像中的文件。</p><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="keyword">COPY</span><span class="bash"> --from=nginx:latest /etc/nginx/nginx.conf /nginx.conf</span></span><br></pre></td></tr></table></figure><h1 id="镜像的实现原理"><a href="#镜像的实现原理" class="headerlink" title="镜像的实现原理"></a>镜像的实现原理</h1><p>Docker 镜像是怎么实现增量的修改和维护的？</p><p>每个镜像都由很多层次构成，Docker 使用 <a href="https://en.wikipedia.org/wiki/UnionFS" target="_blank" rel="noopener">Union FS</a> 将这些不同的层结合到一个镜像中去。</p><p>通常 Union FS 有两个用途, 一方面可以实现不借助 LVM、RAID 将多个 disk 挂到同一个目录下,另一个更常用的就是将一个只读的分支和一个可写的分支联合在一起，Live CD 正是基于此方法可以允许在镜像不变的基础上允许用户在其上进行一些写操作。</p><p>Docker 在 AUFS 上构建的容器也是利用了类似的原理。</p><h1 id="实践指南"><a href="#实践指南" class="headerlink" title="实践指南"></a>实践指南</h1><h2 id="一般性的指南和建议"><a href="#一般性的指南和建议" class="headerlink" title="一般性的指南和建议"></a>一般性的指南和建议</h2><h3 id="容器应该是短暂的"><a href="#容器应该是短暂的" class="headerlink" title="容器应该是短暂的"></a>容器应该是短暂的</h3><p>通过 <code>Dockerfile</code> 构建的镜像所启动的容器应该尽可能短暂（生命周期短）。「短暂」意味着可以停止和销毁容器，并且创建一个新容器并部署好所需的设置和配置工作量应该是极小的。</p><h3 id="使用-dockerignore-文件"><a href="#使用-dockerignore-文件" class="headerlink" title="使用 .dockerignore 文件"></a>使用 <code>.dockerignore</code> 文件</h3><p>使用 <code>Dockerfile</code> 构建镜像时最好是将 <code>Dockerfile</code> 放置在一个新建的空目录下。然后将构建镜像所需要的文件添加到该目录中。为了提高构建镜像的效率，你可以在目录下新建一个 <code>.dockerignore</code> 文件来指定要忽略的文件和目录。<code>.dockerignore</code> 文件的排除模式语法和 Git 的 <code>.gitignore</code> 文件相似。</p><h3 id="使用多阶段构建-1"><a href="#使用多阶段构建-1" class="headerlink" title="使用多阶段构建"></a>使用多阶段构建</h3><p>在 <code>Docker 17.05</code> 以上版本中，你可以使用 <a href="https://yeasy.gitbooks.io/docker_practice/content/image/multistage-builds.md" target="_blank" rel="noopener">多阶段构建</a> 来减少所构建镜像的大小。</p><h3 id="避免安装不必要的包"><a href="#避免安装不必要的包" class="headerlink" title="避免安装不必要的包"></a>避免安装不必要的包</h3><p>为了降低复杂性、减少依赖、减小文件大小、节约构建时间，你应该避免安装任何不必要的包。例如，不要在数据库镜像中包含一个文本编辑器。</p><h3 id="一个容器只运行一个进程"><a href="#一个容器只运行一个进程" class="headerlink" title="一个容器只运行一个进程"></a>一个容器只运行一个进程</h3><p>应该保证在一个容器中只运行一个进程。将多个应用解耦到不同容器中，保证了容器的横向扩展和复用。例如 web 应用应该包含三个容器：web应用、数据库、缓存。</p><p>如果容器互相依赖，你可以使用 <a href="https://yeasy.gitbooks.io/docker_practice/content/network/linking.html" target="_blank" rel="noopener">Docker 自定义网络</a> 来把这些容器连接起来。</p><h3 id="镜像层数尽可能少"><a href="#镜像层数尽可能少" class="headerlink" title="镜像层数尽可能少"></a>镜像层数尽可能少</h3><p>你需要在 <code>Dockerfile</code> 可读性（也包括长期的可维护性）和减少层数之间做一个平衡。</p><h3 id="将多行参数排序"><a href="#将多行参数排序" class="headerlink" title="将多行参数排序"></a>将多行参数排序</h3><p>将多行参数按字母顺序排序（比如要安装多个包时）。这可以帮助你避免重复包含同一个包，更新包列表时也更容易。也便于 <code>PRs</code> 阅读和审查。建议在反斜杠符号 <code>\</code> 之前添加一个空格，以增加可读性。</p><p>下面是来自 <code>buildpack-deps</code> 镜像的例子：</p><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">RUN</span><span class="bash"> apt-get update &amp;&amp; apt-get install -y \</span></span><br><span class="line"><span class="bash">  bzr \</span></span><br><span class="line"><span class="bash">  cvs \</span></span><br><span class="line"><span class="bash">  git \</span></span><br><span class="line"><span class="bash">  mercurial \</span></span><br><span class="line"><span class="bash">  subversion</span></span><br></pre></td></tr></table></figure><h3 id="构建缓存"><a href="#构建缓存" class="headerlink" title="构建缓存"></a>构建缓存</h3><p>在镜像的构建过程中，Docker 会遍历 <code>Dockerfile</code> 文件中的指令，然后按顺序执行。在执行每条指令之前，Docker 都会在缓存中查找是否已经存在可重用的镜像，如果有就使用现存的镜像，不再重复创建。如果你不想在构建过程中使用缓存，你可以在 <code>docker build</code> 命令中使用 <code>--no-cache=true</code> 选项。</p><p>但是，如果你想在构建的过程中使用缓存，你得明白什么时候会，什么时候不会找到匹配的镜像，遵循的基本规则如下：</p><ul><li>从一个基础镜像开始（<code>FROM</code> 指令指定），下一条指令将和该基础镜像的所有子镜像进行匹配，检查这些子镜像被创建时使用的指令是否和被检查的指令完全一样。如果不是，则缓存失效。</li><li>在大多数情况下，只需要简单地对比 <code>Dockerfile</code> 中的指令和子镜像。然而，有些指令需要更多的检查和解释。</li><li>对于 <code>ADD</code> 和 <code>COPY</code> 指令，镜像中对应文件的内容也会被检查，每个文件都会计算出一个校验和。文件的最后修改时间和最后访问时间不会纳入校验。在缓存的查找过程中，会将这些校验和和已存在镜像中的文件校验和进行对比。如果文件有任何改变，比如内容和元数据，则缓存失效。</li><li>除了 <code>ADD</code> 和 <code>COPY</code> 指令，缓存匹配过程不会查看临时容器中的文件来决定缓存是否匹配。例如，当执行完 <code>RUN apt-get -y update</code> 指令后，容器中一些文件被更新，但 Docker 不会检查这些文件。这种情况下，只有指令字符串本身被用来匹配缓存。</li></ul><p>一旦缓存失效，所有后续的 <code>Dockerfile</code> 指令都将产生新的镜像，缓存不会被使用。</p><h2 id="Dockerfile-指令"><a href="#Dockerfile-指令" class="headerlink" title="Dockerfile 指令"></a>Dockerfile 指令</h2><p>下面针对 <code>Dockerfile</code> 中各种指令的最佳编写方式给出建议。</p><h3 id="FROM"><a href="#FROM" class="headerlink" title="FROM"></a>FROM</h3><p>尽可能使用当前官方仓库作为你构建镜像的基础。推荐使用 <a href="https://hub.docker.com/_/alpine/" target="_blank" rel="noopener">Alpine</a> 镜像，因为它被严格控制并保持最小尺寸（目前小于 5 MB），但它仍然是一个完整的发行版。</p><h3 id="LABEL"><a href="#LABEL" class="headerlink" title="LABEL"></a>LABEL</h3><p>你可以给镜像添加标签来帮助组织镜像、记录许可信息、辅助自动化构建等。每个标签一行，由 <code>LABEL</code> 开头加上一个或多个标签对。下面的示例展示了各种不同的可能格式。<code>#</code> 开头的行是注释内容。</p><blockquote><p>注意：如果你的字符串中包含空格，必须将字符串放入引号中或者对空格使用转义。如果字符串内容本身就包含引号，必须对引号使用转义。</p></blockquote><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Set one or more individual labels</span></span><br><span class="line"><span class="keyword">LABEL</span><span class="bash"> com.example.version=<span class="string">"0.0.1-beta"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">LABEL</span><span class="bash"> vendor=<span class="string">"ACME Incorporated"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">LABEL</span><span class="bash"> com.example.release-date=<span class="string">"2015-02-12"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">LABEL</span><span class="bash"> com.example.version.is-production=<span class="string">""</span></span></span><br></pre></td></tr></table></figure><p>一个镜像可以包含多个标签，但建议将多个标签放入到一个 <code>LABEL</code> 指令中。</p><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Set multiple labels at once, using line-continuation characters to break long lines</span></span><br><span class="line"><span class="keyword">LABEL</span><span class="bash"> vendor=ACME\ Incorporated \</span></span><br><span class="line"><span class="bash">      com.example.is-beta= \</span></span><br><span class="line"><span class="bash">      com.example.is-production=<span class="string">""</span> \</span></span><br><span class="line"><span class="bash">      com.example.version=<span class="string">"0.0.1-beta"</span> \</span></span><br><span class="line"><span class="bash">      com.example.release-date=<span class="string">"2015-02-12"</span></span></span><br></pre></td></tr></table></figure><p>关于标签可以接受的键值对，参考 <a href="https://docs.docker.com/config/labels-custom-metadata/" target="_blank" rel="noopener">Understanding object labels</a>。关于查询标签信息，参考 <a href="https://docs.docker.com/config/labels-custom-metadata/" target="_blank" rel="noopener">Managing labels on objects</a>。</p><h3 id="RUN"><a href="#RUN" class="headerlink" title="RUN"></a>RUN</h3><p>为了保持 <code>Dockerfile</code> 文件的可读性，可理解性，以及可维护性，建议将长的或复杂的 <code>RUN</code> 指令用反斜杠 <code>\</code> 分割成多行。</p><h4 id="apt-get"><a href="#apt-get" class="headerlink" title="apt-get"></a>apt-get</h4><p><code>RUN</code> 指令最常见的用法是安装包用的 <code>apt-get</code>。因为 <code>RUN apt-get</code> 指令会安装包，所以有几个问题需要注意。</p><p>不要使用 <code>RUN apt-get upgrade</code> 或 <code>dist-upgrade</code>，因为许多基础镜像中的「必须」包不会在一个非特权容器中升级。如果基础镜像中的某个包过时了，你应该联系它的维护者。如果你确定某个特定的包，比如 <code>foo</code>，需要升级，使用 <code>apt-get install -y foo</code> 就行，该指令会自动升级 <code>foo</code> 包。</p><p>永远将 <code>RUN apt-get update</code> 和 <code>apt-get install</code> 组合成一条 <code>RUN</code> 声明，例如：</p><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">RUN</span><span class="bash"> apt-get update &amp;&amp; apt-get install -y \</span></span><br><span class="line"><span class="bash">        package-bar \</span></span><br><span class="line"><span class="bash">        package-baz \</span></span><br><span class="line"><span class="bash">        package-foo</span></span><br></pre></td></tr></table></figure><p>将 <code>apt-get update</code> 放在一条单独的 <code>RUN</code> 声明中会导致缓存问题以及后续的 <code>apt-get install</code> 失败。比如，假设你有一个 <code>Dockerfile</code> 文件：</p><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> ubuntu:<span class="number">18.04</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> apt-get update</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> apt-get install -y curl</span></span><br></pre></td></tr></table></figure><p>构建镜像后，所有的层都在 Docker 的缓存中。假设你后来又修改了其中的 <code>apt-get install</code> 添加了一个包：</p><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> ubuntu:<span class="number">18.04</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> apt-get update</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> apt-get install -y curl nginx</span></span><br></pre></td></tr></table></figure><p>Docker 发现修改后的 <code>RUN apt-get update</code> 指令和之前的完全一样。所以，<code>apt-get update</code> 不会执行，而是使用之前的缓存镜像。因为 <code>apt-get update</code> 没有运行，后面的 <code>apt-get install</code> 可能安装的是过时的 <code>curl</code> 和 <code>nginx</code> 版本。</p><p>使用 <code>RUN apt-get update &amp;&amp; apt-get install -y</code> 可以确保你的 Dockerfiles 每次安装的都是包的最新的版本，而且这个过程不需要进一步的编码或额外干预。这项技术叫作 <code>cache busting</code>。你也可以显示指定一个包的版本号来达到 <code>cache-busting</code>，这就是所谓的固定版本，例如：</p><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">RUN</span><span class="bash"> apt-get update &amp;&amp; apt-get install -y \</span></span><br><span class="line"><span class="bash">    package-bar \</span></span><br><span class="line"><span class="bash">    package-baz \</span></span><br><span class="line"><span class="bash">    package-foo=1.3.*</span></span><br></pre></td></tr></table></figure><p>固定版本会迫使构建过程检索特定的版本，而不管缓存中有什么。这项技术也可以减少因所需包中未预料到的变化而导致的失败。</p><p>下面是一个 <code>RUN</code> 指令的示例模板，展示了所有关于 <code>apt-get</code> 的建议。</p><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">RUN</span><span class="bash"> apt-get update &amp;&amp; apt-get install -y \</span></span><br><span class="line"><span class="bash">    aufs-tools \</span></span><br><span class="line"><span class="bash">    automake \</span></span><br><span class="line"><span class="bash">    build-essential \</span></span><br><span class="line"><span class="bash">    curl \</span></span><br><span class="line"><span class="bash">    dpkg-sig \</span></span><br><span class="line"><span class="bash">    libcap-dev \</span></span><br><span class="line"><span class="bash">    libsqlite3-dev \</span></span><br><span class="line"><span class="bash">    mercurial \</span></span><br><span class="line"><span class="bash">    reprepro \</span></span><br><span class="line"><span class="bash">    ruby1.9.1 \</span></span><br><span class="line"><span class="bash">    ruby1.9.1-dev \</span></span><br><span class="line"><span class="bash">    s3cmd=1.1.* \</span></span><br><span class="line"><span class="bash"> &amp;&amp; rm -rf /var/lib/apt/lists/*</span></span><br></pre></td></tr></table></figure><p>其中 <code>s3cmd</code> 指令指定了一个版本号 <code>1.1.*</code>。如果之前的镜像使用的是更旧的版本，指定新的版本会导致 <code>apt-get udpate</code> 缓存失效并确保安装的是新版本。</p><p>另外，清理掉 apt 缓存 <code>var/lib/apt/lists</code> 可以减小镜像大小。因为 <code>RUN</code> 指令的开头为 <code>apt-get udpate</code>，包缓存总是会在 <code>apt-get install</code> 之前刷新。</p><blockquote><p>注意：官方的 Debian 和 Ubuntu 镜像会自动运行 apt-get clean，所以不需要显式的调用 apt-get clean。</p></blockquote><h3 id="CMD"><a href="#CMD" class="headerlink" title="CMD"></a>CMD</h3><p><code>CMD</code> 指令用于执行目标镜像中包含的软件，可以包含参数。<code>CMD</code> 大多数情况下都应该以 <code>CMD [&quot;executable&quot;, &quot;param1&quot;, &quot;param2&quot;...]</code> 的形式使用。因此，如果创建镜像的目的是为了部署某个服务(比如 <code>Apache</code>)，你可能会执行类似于 <code>CMD [&quot;apache2&quot;, &quot;-DFOREGROUND&quot;]</code> 形式的命令。我们建议任何服务镜像都使用这种形式的命令。</p><p>多数情况下，<code>CMD</code> 都需要一个交互式的 <code>shell</code> (bash, Python, perl 等)，例如 <code>CMD [&quot;perl&quot;, &quot;-de0&quot;]</code>，或者 <code>CMD [&quot;PHP&quot;, &quot;-a&quot;]</code>。使用这种形式意味着，当你执行类似 <code>docker run -it python</code> 时，你会进入一个准备好的 <code>shell</code> 中。<code>CMD</code> 应该在极少的情况下才能以 <code>CMD [&quot;param&quot;, &quot;param&quot;]</code> 的形式与 <code>ENTRYPOINT</code> 协同使用，除非你和你的镜像使用者都对 <code>ENTRYPOINT</code> 的工作方式十分熟悉。</p><h3 id="EXPOSE"><a href="#EXPOSE" class="headerlink" title="EXPOSE"></a>EXPOSE</h3><p><code>EXPOSE</code> 指令用于指定容器将要监听的端口。因此，你应该为你的应用程序使用常见的端口。例如，提供 <code>Apache</code> web 服务的镜像应该使用 <code>EXPOSE 80</code>，而提供 <code>MongoDB</code> 服务的镜像使用 <code>EXPOSE 27017</code>。</p><p>对于外部访问，用户可以在执行 <code>docker run</code> 时使用一个标志来指示如何将指定的端口映射到所选择的端口。</p><h3 id="ENV"><a href="#ENV" class="headerlink" title="ENV"></a>ENV</h3><p>为了方便新程序运行，你可以使用 <code>ENV</code> 来为容器中安装的程序更新 <code>PATH</code> 环境变量。例如使用 <code>ENV PATH /usr/local/nginx/bin:$PATH</code> 来确保 <code>CMD [&quot;nginx&quot;]</code> 能正确运行。</p><p><code>ENV</code> 指令也可用于为你想要容器化的服务提供必要的环境变量，比如 Postgres 需要的 <code>PGDATA</code>。</p><p>最后，<code>ENV</code> 也能用于设置常见的版本号，比如下面的示例：</p><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ENV</span> PG_MAJOR <span class="number">9.3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">ENV</span> PG_VERSION <span class="number">9.3</span>.<span class="number">4</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> curl -SL http://example.com/postgres-<span class="variable">$PG_VERSION</span>.tar.xz | tar -xJC /usr/src/postgress &amp;&amp; …</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">ENV</span> PATH /usr/local/postgres-$PG_MAJOR/bin:$PATH</span><br></pre></td></tr></table></figure><p>类似于程序中的常量，这种方法可以让你只需改变 <code>ENV</code> 指令来自动的改变容器中的软件版本。</p><h3 id="ADD-和-COPY"><a href="#ADD-和-COPY" class="headerlink" title="ADD 和 COPY"></a>ADD 和 COPY</h3><p>虽然 <code>ADD</code> 和 <code>COPY</code> 功能类似，但一般优先使用 <code>COPY</code>。因为它比 <code>ADD</code> 更透明。<code>COPY</code> 只支持简单将本地文件拷贝到容器中，而 <code>ADD</code> 有一些并不明显的功能（比如本地 tar 提取和远程 URL 支持）。因此，<code>ADD</code> 的最佳用例是将本地 tar 文件自动提取到镜像中，例如 <code>ADD rootfs.tar.xz</code>。</p><p>如果你的 <code>Dockerfile</code> 有多个步骤需要使用上下文中不同的文件。单独 <code>COPY</code> 每个文件，而不是一次性的 <code>COPY</code> 所有文件，这将保证每个步骤的构建缓存只在特定的文件变化时失效。例如：</p><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">COPY</span><span class="bash"> requirements.txt /tmp/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> pip install --requirement /tmp/requirements.txt</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> . /tmp/</span></span><br></pre></td></tr></table></figure><p>如果将 <code>COPY . /tmp/</code> 放置在 <code>RUN</code> 指令之前，只要 <code>.</code> 目录中任何一个文件变化，都会导致后续指令的缓存失效。</p><p>为了让镜像尽量小，最好不要使用 <code>ADD</code> 指令从远程 URL 获取包，而是使用 <code>curl</code> 和 <code>wget</code>。这样你可以在文件提取完之后删掉不再需要的文件来避免在镜像中额外添加一层。比如尽量避免下面的用法：</p><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ADD</span><span class="bash"> http://example.com/big.tar.xz /usr/src/things/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> tar -xJf /usr/src/things/big.tar.xz -C /usr/src/things</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> make -C /usr/src/things all</span></span><br></pre></td></tr></table></figure><p>而是应该使用下面这种方法：</p><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">RUN</span><span class="bash"> mkdir -p /usr/src/things \</span></span><br><span class="line"><span class="bash">    &amp;&amp; curl -SL http://example.com/big.tar.xz \</span></span><br><span class="line"><span class="bash">    | tar -xJC /usr/src/things \</span></span><br><span class="line"><span class="bash">    &amp;&amp; make -C /usr/src/things all</span></span><br></pre></td></tr></table></figure><p>上面使用的管道操作，所以没有中间文件需要删除。</p><p>对于其他不需要 <code>ADD</code> 的自动提取功能的文件或目录，你应该使用 <code>COPY</code>。</p><h3 id="ENTRYPOINT"><a href="#ENTRYPOINT" class="headerlink" title="ENTRYPOINT"></a>ENTRYPOINT</h3><p><code>ENTRYPOINT</code> 的最佳用处是设置镜像的主命令，允许将镜像当成命令本身来运行（用 <code>CMD</code> 提供默认选项）。</p><p>例如，下面的示例镜像提供了命令行工具 <code>s3cmd</code>:</p><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ENTRYPOINT</span><span class="bash"> [<span class="string">"s3cmd"</span>]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">CMD</span><span class="bash"> [<span class="string">"--help"</span>]</span></span><br></pre></td></tr></table></figure><p>现在直接运行该镜像创建的容器会显示命令帮助：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker run s3cmd</span><br></pre></td></tr></table></figure><p>或者提供正确的参数来执行某个命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker run s3cmd ls s3://mybucket</span><br></pre></td></tr></table></figure><p>这样镜像名可以当成命令行的参考。</p><p><code>ENTRYPOINT</code> 指令也可以结合一个辅助脚本使用，和前面命令行风格类似，即使启动工具需要不止一个步骤。</p><p>例如，<code>Postgres</code> 官方镜像使用下面的脚本作为 <code>ENTRYPOINT</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="built_in">set</span> -e</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [ <span class="string">"<span class="variable">$1</span>"</span> = <span class="string">'postgres'</span> ]; <span class="keyword">then</span></span><br><span class="line">    chown -R postgres <span class="string">"<span class="variable">$PGDATA</span>"</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> [ -z <span class="string">"<span class="variable">$(ls -A "$PGDATA")</span>"</span> ]; <span class="keyword">then</span></span><br><span class="line">        gosu postgres initdb</span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">exec</span> gosu postgres <span class="string">"<span class="variable">$@</span>"</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">exec</span> <span class="string">"<span class="variable">$@</span>"</span></span><br></pre></td></tr></table></figure><blockquote><p>注意：该脚本使用了 Bash 的内置命令 exec，所以最后运行的进程就是容器的 PID 为 1 的进程。这样，进程就可以接收到任何发送给容器的 Unix 信号了。</p></blockquote><p>该辅助脚本被拷贝到容器，并在容器启动时通过 <code>ENTRYPOINT</code> 执行：</p><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">COPY</span><span class="bash"> ./docker-entrypoint.sh /</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="bash"> [<span class="string">"/docker-entrypoint.sh"</span>]</span></span><br></pre></td></tr></table></figure><p>该脚本可以让用户用几种不同的方式和 <code>Postgres</code> 交互。</p><p>你可以很简单地启动 <code>Postgres</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker run postgres</span><br></pre></td></tr></table></figure><p>也可以执行 <code>Postgres</code> 并传递参数：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker run postgres postgres --<span class="built_in">help</span></span><br></pre></td></tr></table></figure><p>最后，你还可以启动另外一个完全不同的工具，比如 <code>Bash</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker run --rm -it postgres bash</span><br></pre></td></tr></table></figure><h3 id="VOLUME"><a href="#VOLUME" class="headerlink" title="VOLUME"></a>VOLUME</h3><p><code>VOLUME</code> 指令用于暴露任何数据库存储文件，配置文件，或容器创建的文件和目录。强烈建议使用 <code>VOLUME</code> 来管理镜像中的可变部分和用户可以改变的部分。</p><h3 id="USER"><a href="#USER" class="headerlink" title="USER"></a>USER</h3><p>如果某个服务不需要特权执行，建议使用 <code>USER</code> 指令切换到非 root 用户。先在 <code>Dockerfile</code> 中使用类似 <code>RUN groupadd -r postgres &amp;&amp; useradd -r -g postgres postgres</code> 的指令创建用户和用户组。</p><blockquote><p>注意：在镜像中，用户和用户组每次被分配的 UID/GID 都是不确定的，下次重新构建镜像时被分配到的 UID/GID 可能会不一样。如果要依赖确定的 UID/GID，你应该显示的指定一个 UID/GID。</p></blockquote><p>你应该避免使用 <code>sudo</code>，因为它不可预期的 TTY 和信号转发行为可能造成的问题比它能解决的问题还多。如果你真的需要和 <code>sudo</code> 类似的功能（例如，以 root 权限初始化某个守护进程，以非 root 权限执行它），你可以使用 <a href="https://github.com/tianon/gosu" target="_blank" rel="noopener">gosu</a>。</p><p>最后，为了减少层数和复杂度，避免频繁地使用 <code>USER</code> 来回切换用户。</p><h3 id="WORKDIR"><a href="#WORKDIR" class="headerlink" title="WORKDIR"></a>WORKDIR</h3><p>为了清晰性和可靠性，你应该总是在 <code>WORKDIR</code> 中使用绝对路径。另外，你应该使用 <code>WORKDIR</code> 来替代类似于 <code>RUN cd ... &amp;&amp; do-something</code> 的指令，后者难以阅读、排错和维护。</p><h2 id="官方镜像示例"><a href="#官方镜像示例" class="headerlink" title="官方镜像示例"></a>官方镜像示例</h2><p>这些官方镜像的 Dockerfile 都是参考典范：<a href="https://github.com/docker-library/docs" target="_blank" rel="noopener">https://github.com/docker-library/docs</a></p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>本文章摘抄于：<a href="https://yeasy.gitbooks.io/docker_practice/content/" target="_blank" rel="noopener">https://yeasy.gitbooks.io/docker_practice/content/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Dockerfile简介&quot;&gt;&lt;a href=&quot;#Dockerfile简介&quot; class=&quot;headerlink&quot; title=&quot;Dockerfile简介&quot;&gt;&lt;/a&gt;Dockerfile简介&lt;/h1&gt;&lt;p&gt;Dockerfile 是一个用来构建镜像的文本文件，文本内容包含了一条条构建镜像所需的指令和说明。&lt;/p&gt;
    
    </summary>
    
      <category term="Docker" scheme="http://hackycy.github.io/categories/Docker/"/>
    
    
      <category term="Docker" scheme="http://hackycy.github.io/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>Docker入门（四）——仓库</title>
    <link href="http://hackycy.github.io/2019/12/04/Docker%E5%85%A5%E9%97%A8%EF%BC%88%E5%9B%9B%EF%BC%89%E2%80%94%E2%80%94%E4%BB%93%E5%BA%93/"/>
    <id>http://hackycy.github.io/2019/12/04/Docker入门（四）——仓库/</id>
    <published>2019-12-04T08:28:56.000Z</published>
    <updated>2019-12-15T09:00:29.706Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Docker仓库简介"><a href="#Docker仓库简介" class="headerlink" title="Docker仓库简介"></a>Docker仓库简介</h1><p>仓库（<code>Repository</code>）是集中存放镜像的地方。</p><p>一个容易混淆的概念是注册服务器（<code>Registry</code>）。实际上注册服务器是管理仓库的具体服务器，每个服务器上可以有多个仓库，而每个仓库下面有多个镜像。从这方面来说，仓库可以被认为是一个具体的项目或目录。例如对于仓库地址 <code>dl.dockerpool.com/ubuntu</code> 来说，<code>dl.dockerpool.com</code> 是注册服务器地址，<code>ubuntu</code> 是仓库名。</p><p>大部分时候，并不需要严格区分这两者的概念。</p><a id="more"></a><h1 id="Docker-Hub"><a href="#Docker-Hub" class="headerlink" title="Docker Hub"></a>Docker Hub</h1><p>目前 Docker 官方维护了一个公共仓库 <a href="https://hub.docker.com/" target="_blank" rel="noopener">Docker Hub</a>，其中已经包括了数量超过 <a href="https://hub.docker.com/search/?type=image" target="_blank" rel="noopener">2,650,000</a> 的镜像。大部分需求都可以通过在 Docker Hub 中直接下载镜像来实现。</p><h2 id="注册"><a href="#注册" class="headerlink" title="注册"></a>注册</h2><p>你可以在 <a href="https://hub.docker.com/" target="_blank" rel="noopener">https://hub.docker.com</a> 免费注册一个 Docker 账号。</p><h2 id="登录"><a href="#登录" class="headerlink" title="登录"></a>登录</h2><p>可以通过执行 <code>docker login</code> 命令交互式的输入用户名及密码来完成在命令行界面登录 Docker Hub。</p><p>你可以通过 <code>docker logout</code> 退出登录。</p><h2 id="拉取镜像"><a href="#拉取镜像" class="headerlink" title="拉取镜像"></a>拉取镜像</h2><p>你可以通过 <code>docker search</code> 命令来查找官方仓库中的镜像，并利用 <code>docker pull</code> 命令来将它下载到本地。</p><p>例如以 <code>centos</code> 为关键词进行搜索：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ docker search centos</span><br><span class="line">NAME                                            DESCRIPTION                                     STARS     OFFICIAL   AUTOMATED</span><br><span class="line">centos                                          The official build of CentOS.                   465       [OK]</span><br><span class="line">tianon/centos                                   CentOS 5 and 6, created using rinse instea...   28</span><br><span class="line">blalor/centos                                   Bare-bones base CentOS 6.5 image                6                    [OK]</span><br><span class="line">saltstack/centos-6-minimal                                                                      6                    [OK]</span><br><span class="line">tutum/centos-6.4                                DEPRECATED. Use tutum/centos:6.4 instead. ...   5                    [OK]</span><br></pre></td></tr></table></figure><p>可以看到返回了很多包含关键字的镜像，其中包括镜像名字、描述、收藏数（表示该镜像的受关注程度）、是否官方创建（OFFICIAL）、是否自动构建 （AUTOMATED）。</p><p>根据是否是官方提供，可将镜像分为两类。</p><p>一种是类似 <code>centos</code> 这样的镜像，被称为基础镜像或根镜像。这些基础镜像由 Docker 公司创建、验证、支持、提供。这样的镜像往往使用单个单词作为名字。</p><p>还有一种类型，比如 <code>tianon/centos</code> 镜像，它是由 Docker Hub 的注册用户创建并维护的，往往带有用户名称前缀。可以通过前缀 <code>username/</code> 来指定使用某个用户提供的镜像，比如 tianon 用户。</p><p>另外，在查找的时候通过 <code>--filter=stars=N</code> 参数可以指定仅显示收藏数量为 <code>N</code> 以上的镜像。</p><p>下载官方 <code>centos</code> 镜像到本地。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ docker pull centos</span><br><span class="line">Pulling repository centos</span><br><span class="line">0b443ba03958: Download complete</span><br><span class="line">539c0211cd76: Download complete</span><br><span class="line">511136ea3c5a: Download complete</span><br><span class="line">7064731afe90: Download complete</span><br></pre></td></tr></table></figure><h2 id="推送镜像"><a href="#推送镜像" class="headerlink" title="推送镜像"></a>推送镜像</h2><p>用户也可以在登录后通过 <code>docker push</code> 命令来将自己的镜像推送到 Docker Hub。</p><p>以下命令中的 <code>username</code> 请替换为你的 Docker 账号用户名。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$ docker tag ubuntu:18.04 username/ubuntu:18.04</span><br><span class="line"></span><br><span class="line">$ docker image ls</span><br><span class="line"></span><br><span class="line">REPOSITORY                                               TAG                    IMAGE ID            CREATED             SIZE</span><br><span class="line">ubuntu                                                   18.04                  275d79972a86        6 days ago          94.6MB</span><br><span class="line">username/ubuntu                                          18.04                  275d79972a86        6 days ago          94.6MB</span><br><span class="line"></span><br><span class="line">$ docker push username/ubuntu:18.04</span><br><span class="line"></span><br><span class="line">$ docker search username</span><br><span class="line"></span><br><span class="line">NAME                      DESCRIPTION                                     STARS               OFFICIAL            AUTOMATED</span><br><span class="line">username/ubuntu</span><br></pre></td></tr></table></figure><h2 id="自动构建"><a href="#自动构建" class="headerlink" title="自动构建"></a>自动构建</h2><p>自动构建（Automated Builds）功能对于需要经常升级镜像内程序来说，十分方便。</p><p>有时候，用户构建了镜像，安装了某个软件，当软件发布新版本则需要手动更新镜像。</p><p>而自动构建允许用户通过 Docker Hub 指定跟踪一个目标网站（支持 <a href="https://github.com/" target="_blank" rel="noopener">GitHub</a> 或 <a href="https://bitbucket.org/" target="_blank" rel="noopener">BitBucket</a>）上的项目，一旦项目发生新的提交 （commit）或者创建了新的标签（tag），Docker Hub 会自动构建镜像并推送到 Docker Hub 中。</p><p>要配置自动构建，包括如下的步骤：</p><ul><li>登录 Docker Hub；</li><li>在 Docker Hub 点击右上角头像，在账号设置（Account Settings）中关联（Linked Accounts）目标网站；</li><li>在 Docker Hub 中新建或选择已有的仓库，在 <code>Builds</code> 选项卡中选择 <code>Configure Automated Builds</code>；</li><li>选取一个目标网站中的项目（需要含 <code>Dockerfile</code>）和分支；</li><li>指定 <code>Dockerfile</code> 的位置，并保存。</li></ul><p>之后，可以在 Docker Hub 的仓库页面的 <code>Timeline</code> 选项卡中查看每次构建的状态。</p><h1 id="私有仓库"><a href="#私有仓库" class="headerlink" title="私有仓库"></a>私有仓库</h1><p>有时候使用 Docker Hub 这样的公共仓库可能不方便，用户可以创建一个本地仓库供私人使用。</p><p>本节介绍如何使用本地仓库。</p><p><a href="https://docs.docker.com/registry/" target="_blank" rel="noopener"><code>docker-registry</code></a> 是官方提供的工具，可以用于构建私有的镜像仓库。本文内容基于 <a href="https://github.com/docker/distribution" target="_blank" rel="noopener"><code>docker-registry</code></a> v2.x 版本。</p><h2 id="安装运行-docker-registry"><a href="#安装运行-docker-registry" class="headerlink" title="安装运行 docker-registry"></a>安装运行 docker-registry</h2><h3 id="容器运行"><a href="#容器运行" class="headerlink" title="容器运行"></a>容器运行</h3><p>你可以通过获取官方 <code>registry</code> 镜像来运行。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -d -p 5000:5000 --restart=always --name registry registry</span><br></pre></td></tr></table></figure><p>这将使用官方的 <code>registry</code> 镜像来启动私有仓库。默认情况下，仓库会被创建在容器的 <code>/var/lib/registry</code> 目录下。你可以通过 <code>-v</code> 参数来将镜像文件存放在本地的指定路径。例如下面的例子将上传的镜像放到本地的 <code>/opt/data/registry</code> 目录。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -d \</span><br><span class="line">    -p 5000:5000 \</span><br><span class="line">    -v /opt/data/registry:/var/lib/registry \</span><br><span class="line">    registry</span><br></pre></td></tr></table></figure><h2 id="在私有仓库上传、搜索、下载镜像"><a href="#在私有仓库上传、搜索、下载镜像" class="headerlink" title="在私有仓库上传、搜索、下载镜像"></a>在私有仓库上传、搜索、下载镜像</h2><p>创建好私有仓库之后，就可以使用 <code>docker tag</code> 来标记一个镜像，然后推送它到仓库。例如私有仓库地址为 <code>127.0.0.1:5000</code>。</p><p>先在本机查看已有的镜像。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ docker image ls</span><br><span class="line">REPOSITORY                        TAG                 IMAGE ID            CREATED             VIRTUAL SIZE</span><br><span class="line">ubuntu                            latest              ba5877dc9bec        6 weeks ago         192.7 MB</span><br></pre></td></tr></table></figure><p>使用 <code>docker tag</code> 将 <code>ubuntu:latest</code> 这个镜像标记为 <code>127.0.0.1:5000/ubuntu:latest</code>。</p><p>格式为 <code>docker tag IMAGE[:TAG] [REGISTRY_HOST[:REGISTRY_PORT]/]REPOSITORY[:TAG]</code>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ docker tag ubuntu:latest 127.0.0.1:5000/ubuntu:latest</span><br><span class="line">$ docker image ls</span><br><span class="line">REPOSITORY                        TAG                 IMAGE ID            CREATED             VIRTUAL SIZE</span><br><span class="line">ubuntu                            latest              ba5877dc9bec        6 weeks ago         192.7 MB</span><br><span class="line">127.0.0.1:5000/ubuntu:latest      latest              ba5877dc9bec        6 weeks ago         192.7 MB</span><br></pre></td></tr></table></figure><p>使用 <code>docker push</code> 上传标记的镜像。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ docker push 127.0.0.1:5000/ubuntu:latest</span><br><span class="line">The push refers to repository [127.0.0.1:5000/ubuntu]</span><br><span class="line">373a30c24545: Pushed</span><br><span class="line">a9148f5200b0: Pushed</span><br><span class="line">cdd3de0940ab: Pushed</span><br><span class="line">fc56279bbb33: Pushed</span><br><span class="line">b38367233d37: Pushed</span><br><span class="line">2aebd096e0e2: Pushed</span><br><span class="line">latest: digest: sha256:fe4277621f10b5026266932ddf760f5a756d2facd505a94d2da12f4f52f71f5a size: 1568</span><br></pre></td></tr></table></figure><p>用 <code>curl</code> 查看仓库中的镜像。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ curl 127.0.0.1:5000/v2/_catalog</span><br><span class="line">&#123;<span class="string">"repositories"</span>:[<span class="string">"ubuntu"</span>]&#125;</span><br></pre></td></tr></table></figure><p>这里可以看到 <code>{&quot;repositories&quot;:[&quot;ubuntu&quot;]}</code>，表明镜像已经被成功上传了。</p><p>先删除已有镜像，再尝试从私有仓库中下载这个镜像。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$ docker image rm 127.0.0.1:5000/ubuntu:latest</span><br><span class="line"></span><br><span class="line">$ docker pull 127.0.0.1:5000/ubuntu:latest</span><br><span class="line">Pulling repository 127.0.0.1:5000/ubuntu:latest</span><br><span class="line">ba5877dc9bec: Download complete</span><br><span class="line">511136ea3c5a: Download complete</span><br><span class="line">9bad880da3d2: Download complete</span><br><span class="line">25f11f5fb0cb: Download complete</span><br><span class="line">ebc34468f71d: Download complete</span><br><span class="line">2318d26665ef: Download complete</span><br><span class="line"></span><br><span class="line">$ docker image ls</span><br><span class="line">REPOSITORY                         TAG                 IMAGE ID            CREATED             VIRTUAL SIZE</span><br><span class="line">127.0.0.1:5000/ubuntu:latest       latest              ba5877dc9bec        6 weeks ago         192.7 MB</span><br></pre></td></tr></table></figure><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><p>如果你不想使用 <code>127.0.0.1:5000</code> 作为仓库地址，比如想让本网段的其他主机也能把镜像推送到私有仓库。你就得把例如 <code>192.168.199.100:5000</code> 这样的内网地址作为私有仓库地址，这时你会发现无法成功推送镜像。</p><p>这是因为 Docker 默认不允许非 <code>HTTPS</code> 方式推送镜像。我们可以通过 Docker 的配置选项来取消这个限制，或者查看下一节配置能够通过 <code>HTTPS</code> 访问的私有仓库。</p><h3 id="Ubuntu-16-04-Debian-8-centos-7"><a href="#Ubuntu-16-04-Debian-8-centos-7" class="headerlink" title="Ubuntu 16.04+, Debian 8+, centos 7"></a>Ubuntu 16.04+, Debian 8+, centos 7</h3><p>对于使用 <code>systemd</code> 的系统，请在 <code>/etc/docker/daemon.json</code> 中写入如下内容（如果文件不存在请新建该文件）</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"registry-mirror"</span>: [</span><br><span class="line">    <span class="string">"https://dockerhub.azk8s.cn"</span></span><br><span class="line">  ],</span><br><span class="line">  <span class="attr">"insecure-registries"</span>: [</span><br><span class="line">    <span class="string">"192.168.199.100:5000"</span></span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意：该文件必须符合 <code>json</code> 规范，否则 Docker 将不能启动。</p></blockquote><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>对于 Docker Desktop for Windows 、 Docker Desktop for Mac 在设置中的 <code>Docker Engine</code> 中进行编辑 ，增加和上边一样的字符串即可。</p><h1 id="Nexus3-x-的私有仓库"><a href="#Nexus3-x-的私有仓库" class="headerlink" title="Nexus3.x 的私有仓库"></a>Nexus3.x 的私有仓库</h1><p>使用 Docker 官方的 Registry 创建的仓库面临一些维护问题。比如某些镜像删除以后空间默认是不会回收的，需要一些命令去回收空间然后重启 Registry 程序。在企业中把内部的一些工具包放入 Nexus 中是比较常见的做法，最新版本 <code>Nexus3.x</code> 全面支持 Docker 的私有镜像。所以使用 <a href="https://www.sonatype.com/download-oss-sonatype/" target="_blank" rel="noopener"><code>Nexus3.x</code></a> 一个软件来管理 <code>Docker</code> , <code>Maven</code> , <code>Yum</code> , <code>PyPI</code> 等是一个明智的选择。</p><h2 id="启动-Nexus-容器"><a href="#启动-Nexus-容器" class="headerlink" title="启动 Nexus 容器"></a>启动 Nexus 容器</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -d --name nexus3 --restart=always \</span><br><span class="line">    -p 8081:8081 \</span><br><span class="line">    --mount src=nexus-data,target=/nexus-data \</span><br><span class="line">    sonatype/nexus3</span><br></pre></td></tr></table></figure><p>等待 3-5 分钟，如果 <code>nexus3</code> 容器没有异常退出，那么你可以使用浏览器打开 <code>http://YourIP:8081</code> 访问 Nexus 了。</p><p>第一次启动 Nexus 的默认帐号是 <code>admin</code> 密码是 <code>admin123</code> 登录以后点击页面上方的齿轮按钮进行设置。</p><h2 id="创建仓库"><a href="#创建仓库" class="headerlink" title="创建仓库"></a>创建仓库</h2><p>创建一个私有仓库的方法： <code>Repository-&gt;Repositories</code> 点击右边菜单 <code>Create repository</code> 选择 <code>docker (hosted)</code></p><ul><li>Name: 仓库的名称</li><li>HTTP: 仓库单独的访问端口</li><li>Enable Docker V1 API: 如果需要同时支持 V1 版本请勾选此项（不建议勾选）。</li><li>Hosted -&gt; Deployment pollcy: 请选择 Allow redeploy 否则无法上传 Docker 镜像。</li></ul><p>其它的仓库创建方法请各位自己摸索，还可以创建一个 docker (proxy) 类型的仓库链接到 DockerHub 上。再创建一个 docker (group) 类型的仓库把刚才的 hosted 与 proxy 添加在一起。主机在访问的时候默认下载私有仓库中的镜像，如果没有将链接到 DockerHub 中下载并缓存到 Nexus 中。</p><h2 id="添加访问权限"><a href="#添加访问权限" class="headerlink" title="添加访问权限"></a>添加访问权限</h2><p>菜单 <code>Security-&gt;Realms</code> 把 Docker Bearer Token Realm 移到右边的框中保存。</p><p>添加用户规则：菜单 <code>Security-&gt;Roles</code>-&gt;<code>Create role</code> 在 <code>Privlleges</code> 选项搜索 docker 把相应的规则移动到右边的框中然后保存。</p><p>添加用户：菜单 <code>Security-&gt;Users</code>-&gt;<code>Create local user</code> 在 <code>Roles</code> 选项中选中刚才创建的规则移动到右边的窗口保存。</p><h2 id="NGINX-加密代理"><a href="#NGINX-加密代理" class="headerlink" title="NGINX 加密代理"></a>NGINX 加密代理</h2><p>证书的生成请参见 <a href="https://yeasy.gitbooks.io/docker_practice/content/repository/registry_auth.html" target="_blank" rel="noopener"><code>私有仓库高级配置</code></a> 里面证书生成一节。</p><p>NGINX 示例配置如下</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">upstream</span> register</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attribute">server</span> <span class="string">"YourHostName OR IP"</span>:<span class="number">5001</span>; <span class="comment">#端口为上面添加的私有镜像仓库是设置的 HTTP 选项的端口号</span></span><br><span class="line">    <span class="attribute">check</span> interval=<span class="number">3000</span> rise=<span class="number">2</span> fall=<span class="number">10</span> timeout=<span class="number">1000</span> type=http;</span><br><span class="line">    <span class="attribute">check_http_send</span> <span class="string">"HEAD / HTTP/1.0\r\n\r\n"</span>;</span><br><span class="line">    <span class="attribute">check_http_expect_alive</span> http_4xx;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">server_name</span> YourDomainName;<span class="comment">#如果没有 DNS 服务器做解析，请删除此选项使用本机 IP 地址访问</span></span><br><span class="line">    <span class="attribute">listen</span>       <span class="number">443</span> ssl;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">ssl_certificate</span> key/example.crt;</span><br><span class="line">    <span class="attribute">ssl_certificate_key</span> key/example.key;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">ssl_session_timeout</span>  <span class="number">5m</span>;</span><br><span class="line">    <span class="attribute">ssl_protocols</span> TLSv1 TLSv1.<span class="number">1</span> TLSv1.<span class="number">2</span>;</span><br><span class="line">    <span class="attribute">ssl_ciphers</span>  HIGH:!aNULL:!MD5;</span><br><span class="line">    <span class="attribute">ssl_prefer_server_ciphers</span>   <span class="literal">on</span>;</span><br><span class="line">    <span class="attribute">large_client_header_buffers</span> <span class="number">4</span> <span class="number">32k</span>;</span><br><span class="line">    <span class="attribute">client_max_body_size</span> <span class="number">300m</span>;</span><br><span class="line">    <span class="attribute">client_body_buffer_size</span> <span class="number">512k</span>;</span><br><span class="line">    <span class="attribute">proxy_connect_timeout</span> <span class="number">600</span>;</span><br><span class="line">    <span class="attribute">proxy_read_timeout</span>   <span class="number">600</span>;</span><br><span class="line">    <span class="attribute">proxy_send_timeout</span>   <span class="number">600</span>;</span><br><span class="line">    <span class="attribute">proxy_buffer_size</span>    <span class="number">128k</span>;</span><br><span class="line">    <span class="attribute">proxy_buffers</span>       <span class="number">4</span> <span class="number">64k</span>;</span><br><span class="line">    <span class="attribute">proxy_busy_buffers_size</span> <span class="number">128k</span>;</span><br><span class="line">    <span class="attribute">proxy_temp_file_write_size</span> <span class="number">512k</span>;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">location</span> / &#123;</span><br><span class="line">        <span class="attribute">proxy_set_header</span> Host <span class="variable">$host</span>;</span><br><span class="line">        <span class="attribute">proxy_set_header</span> X-Forwarded-Proto <span class="variable">$scheme</span>;</span><br><span class="line">        <span class="attribute">proxy_set_header</span> X-Forwarded-Port <span class="variable">$server_port</span>;</span><br><span class="line">        <span class="attribute">proxy_set_header</span> X-Forwarded-For <span class="variable">$proxy_add_x_forwarded_for</span>;</span><br><span class="line">        <span class="attribute">proxy_http_version</span> <span class="number">1</span>.<span class="number">1</span>;</span><br><span class="line">        <span class="attribute">proxy_set_header</span> Upgrade <span class="variable">$http_upgrade</span>;</span><br><span class="line">        <span class="attribute">proxy_set_header</span> Connection <span class="variable">$connection_upgrade</span>;</span><br><span class="line">        <span class="attribute">proxy_redirect</span> <span class="literal">off</span>;</span><br><span class="line">        <span class="attribute">proxy_set_header</span> X-Real-IP <span class="variable">$remote_addr</span>;</span><br><span class="line">        <span class="attribute">proxy_pass</span> http://register;</span><br><span class="line">        <span class="attribute">proxy_read_timeout</span> <span class="number">900s</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="attribute">error_page</span>   <span class="number">500</span> <span class="number">502</span> <span class="number">503</span> <span class="number">504</span>  /50x.html;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Docker-主机访问镜像仓库"><a href="#Docker-主机访问镜像仓库" class="headerlink" title="Docker 主机访问镜像仓库"></a>Docker 主机访问镜像仓库</h2><p>如果不启用 SSL 加密可以通过前面章节的方法添加信任地址到 Docker 的配置文件中然后重启 Docker</p><p>使用 SSL 加密以后程序需要访问就不能采用修改配置的访问了。具体方法如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ openssl s_client -showcerts -connect YourDomainName OR HostIP:443 &lt;/dev/null 2&gt;/dev/null|openssl x509 -outform PEM &gt;ca.crt</span><br><span class="line">$ cat ca.crt | sudo tee -a /etc/ssl/certs/ca-certificates.crt</span><br><span class="line">$ systemctl restart docker</span><br></pre></td></tr></table></figure><p>使用 <code>docker login YourDomainName OR HostIP</code> 进行测试，用户名密码填写上面 Nexus 中生成的。</p><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p>本文章摘抄于：<a href="https://yeasy.gitbooks.io/docker_practice/content/" target="_blank" rel="noopener">https://yeasy.gitbooks.io/docker_practice/content/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Docker仓库简介&quot;&gt;&lt;a href=&quot;#Docker仓库简介&quot; class=&quot;headerlink&quot; title=&quot;Docker仓库简介&quot;&gt;&lt;/a&gt;Docker仓库简介&lt;/h1&gt;&lt;p&gt;仓库（&lt;code&gt;Repository&lt;/code&gt;）是集中存放镜像的地方。&lt;/p&gt;
&lt;p&gt;一个容易混淆的概念是注册服务器（&lt;code&gt;Registry&lt;/code&gt;）。实际上注册服务器是管理仓库的具体服务器，每个服务器上可以有多个仓库，而每个仓库下面有多个镜像。从这方面来说，仓库可以被认为是一个具体的项目或目录。例如对于仓库地址 &lt;code&gt;dl.dockerpool.com/ubuntu&lt;/code&gt; 来说，&lt;code&gt;dl.dockerpool.com&lt;/code&gt; 是注册服务器地址，&lt;code&gt;ubuntu&lt;/code&gt; 是仓库名。&lt;/p&gt;
&lt;p&gt;大部分时候，并不需要严格区分这两者的概念。&lt;/p&gt;
    
    </summary>
    
      <category term="Docker" scheme="http://hackycy.github.io/categories/Docker/"/>
    
    
      <category term="Docker" scheme="http://hackycy.github.io/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>Jenkins更换语言</title>
    <link href="http://hackycy.github.io/2019/12/04/Jenkins%E6%9B%B4%E6%8D%A2%E8%AF%AD%E8%A8%80/"/>
    <id>http://hackycy.github.io/2019/12/04/Jenkins更换语言/</id>
    <published>2019-12-04T02:47:49.000Z</published>
    <updated>2019-12-04T03:19:14.463Z</updated>
    
    <content type="html"><![CDATA[<p>最近学习Jenkins中，使用Docker安装完成后，Jenkins的默认语言是狗血的繁体版本，想更换成英文版本或者中文版本。</p><a id="more"></a><h1 id="更换Google浏览器默认语言"><a href="#更换Google浏览器默认语言" class="headerlink" title="更换Google浏览器默认语言"></a>更换Google浏览器默认语言</h1><p>我google之前设置的默认语言第一位是中文繁体版本，我现在直接删除掉了。后面Jenkins就更换回了英文版本。</p><p><img src="changegooglelan.png" alt></p><h1 id="使用Locale插件"><a href="#使用Locale插件" class="headerlink" title="使用Locale插件"></a>使用Locale插件</h1><p>繁体版本下找到插件为<code>管理Jenkins</code>-&gt;<code>外掛程式管理</code></p><p><img src="findplugin.png" alt></p><p>在可用的插件列表搜索Locale插件，选择直接安装。</p><p><img src="findplugin2.png" alt></p><p>安装完成后，进入<code>管理Jenkins</code>-&gt;<code>设定系统</code></p><p><img src="setting.png" alt></p><p>应用并保存即可。</p><blockquote><p>记住Ignore browser preference and force this language to all users这个单选框要勾选上，否则不生效</p></blockquote><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>两种方式中，第二种中文好像并不是完全支持，有些中文有些英文。</p><p>所以我选择了使用第一种方式。学习的情况下还是多些习惯英文吧。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近学习Jenkins中，使用Docker安装完成后，Jenkins的默认语言是狗血的繁体版本，想更换成英文版本或者中文版本。&lt;/p&gt;
    
    </summary>
    
      <category term="Jenkins" scheme="http://hackycy.github.io/categories/Jenkins/"/>
    
    
      <category term="Jenkins" scheme="http://hackycy.github.io/tags/Jenkins/"/>
    
  </entry>
  
  <entry>
    <title>Docker入门（三）——镜像</title>
    <link href="http://hackycy.github.io/2019/12/02/Docker%E5%85%A5%E9%97%A8%EF%BC%88%E4%B8%89%EF%BC%89%E2%80%94%E2%80%94%E9%95%9C%E5%83%8F/"/>
    <id>http://hackycy.github.io/2019/12/02/Docker入门（三）——镜像/</id>
    <published>2019-12-02T08:20:18.000Z</published>
    <updated>2019-12-15T09:00:08.458Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Docker镜像简介"><a href="#Docker镜像简介" class="headerlink" title="Docker镜像简介"></a>Docker镜像简介</h1><p>镜像是 Docker 的三大组件之一。</p><p>Docker 运行容器前需要本地存在对应的镜像，如果本地不存在该镜像，Docker 会从镜像仓库下载该镜像。</p><p>本章将介绍更多关于镜像的内容，包括：</p><ul><li>从仓库获取镜像；</li><li>管理本地主机上的镜像</li></ul><a id="more"></a><h1 id="获取镜像"><a href="#获取镜像" class="headerlink" title="获取镜像"></a>获取镜像</h1><p>之前提到过，<a href="https://hub.docker.com/explore/" target="_blank" rel="noopener">Docker Hub</a> 上有大量的高质量的镜像可以用，这里我们就说一下怎么获取这些镜像。</p><p>从 Docker 镜像仓库获取镜像的命令是 <code>docker pull</code>。其命令格式为：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull [选项] [Docker Registry 地址[:端口号]/]仓库名[:标签]</span><br></pre></td></tr></table></figure><p>具体的选项可以通过 <code>docker pull --help</code> 命令看到，这里我们说一下镜像名称的格式。</p><ul><li>Docker 镜像仓库地址：地址的格式一般是 <code>&lt;域名/IP&gt;[:端口号]</code>。默认地址是 Docker Hub。</li><li>仓库名：如之前所说，这里的仓库名是两段式名称，即 <code>&lt;用户名&gt;/&lt;软件名&gt;</code>。对于 Docker Hub，如果不给出用户名，则默认为 <code>library</code>，也就是官方镜像。</li></ul><p>比如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ docker pull ubuntu:18.04</span><br><span class="line">18.04: Pulling from library/ubuntu</span><br><span class="line">bf5d46315322: Pull complete</span><br><span class="line">9f13e0ac480c: Pull complete</span><br><span class="line">e8988b5b3097: Pull complete</span><br><span class="line">40af181810e7: Pull complete</span><br><span class="line">e6f7c7e5c03e: Pull complete</span><br><span class="line">Digest: sha256:147913621d9cdea08853f6ba9116c2e27a3ceffecf3b492983ae97c3d643fbbe</span><br><span class="line">Status: Downloaded newer image <span class="keyword">for</span> ubuntu:18.04</span><br></pre></td></tr></table></figure><p>上面的命令中没有给出 Docker 镜像仓库地址，因此将会从 Docker Hub 获取镜像。而镜像名称是 <code>ubuntu:18.04</code>，因此将会获取官方镜像 <code>library/ubuntu</code> 仓库中标签为 <code>18.04</code> 的镜像。</p><p>从下载过程中可以看到我们之前提及的分层存储的概念，镜像是由多层存储所构成。下载也是一层层的去下载，并非单一文件。下载过程中给出了每一层的 ID 的前 12 位。并且下载结束后，给出该镜像完整的 <code>sha256</code> 的摘要，以确保下载一致性。</p><p>在使用上面命令的时候，你可能会发现，你所看到的层 ID 以及 <code>sha256</code> 的摘要和这里的不一样。这是因为官方镜像是一直在维护的，有任何新的 bug，或者版本更新，都会进行修复再以原来的标签发布，这样可以确保任何使用这个标签的用户可以获得更安全、更稳定的镜像。</p><p><em>如果从 Docker Hub 下载镜像非常缓慢，可以参照 <a href="https://yeasy.gitbooks.io/docker_practice/content/install/mirror.html" target="_blank" rel="noopener">镜像加速器</a> 一节配置加速器。</em></p><h2 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h2><p>有了镜像后，我们就能够以这个镜像为基础启动并运行一个容器。以上面的 <code>ubuntu:18.04</code> 为例，如果我们打算启动里面的 <code>bash</code> 并且进行交互式操作的话，可以执行下面的命令。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -it --rm \</span><br><span class="line">    ubuntu:18.04 \</span><br><span class="line">    bash</span><br><span class="line"></span><br><span class="line">root@e7009c6ce357:/<span class="comment"># cat /etc/os-release</span></span><br><span class="line">NAME=<span class="string">"Ubuntu"</span></span><br><span class="line">VERSION=<span class="string">"18.04.1 LTS (Bionic Beaver)"</span></span><br><span class="line">ID=ubuntu</span><br><span class="line">ID_LIKE=debian</span><br><span class="line">PRETTY_NAME=<span class="string">"Ubuntu 18.04.1 LTS"</span></span><br><span class="line">VERSION_ID=<span class="string">"18.04"</span></span><br><span class="line">HOME_URL=<span class="string">"https://www.ubuntu.com/"</span></span><br><span class="line">SUPPORT_URL=<span class="string">"https://help.ubuntu.com/"</span></span><br><span class="line">BUG_REPORT_URL=<span class="string">"https://bugs.launchpad.net/ubuntu/"</span></span><br><span class="line">PRIVACY_POLICY_URL=<span class="string">"https://www.ubuntu.com/legal/terms-and-policies/privacy-policy"</span></span><br><span class="line">VERSION_CODENAME=bionic</span><br><span class="line">UBUNTU_CODENAME=bionic</span><br></pre></td></tr></table></figure><p><code>docker run</code> 就是运行容器的命令，具体格式我们会在 <a href="https://yeasy.gitbooks.io/docker_practice/content/container" target="_blank" rel="noopener">容器</a> 一节进行详细讲解，我们这里简要的说明一下上面用到的参数。</p><ul><li><code>-it</code>：这是两个参数，一个是 <code>-i</code>：交互式操作，一个是 <code>-t</code> 终端。我们这里打算进入 <code>bash</code> 执行一些命令并查看返回结果，因此我们需要交互式终端。</li><li><code>--rm</code>：这个参数是说容器退出后随之将其删除。默认情况下，为了排障需求，退出的容器并不会立即删除，除非手动 <code>docker rm</code>。我们这里只是随便执行个命令，看看结果，不需要排障和保留结果，因此使用 <code>--rm</code> 可以避免浪费空间。</li><li><code>ubuntu:18.04</code>：这是指用 <code>ubuntu:18.04</code> 镜像为基础来启动容器。</li><li><code>bash</code>：放在镜像名后的是 <strong>命令</strong>，这里我们希望有个交互式 Shell，因此用的是 <code>bash</code>。</li></ul><p>进入容器后，我们可以在 Shell 下操作，执行任何所需的命令。这里，我们执行了 <code>cat /etc/os-release</code>，这是 Linux 常用的查看当前系统版本的命令，从返回的结果可以看到容器内是 <code>Ubuntu 18.04.1 LTS</code> 系统。</p><p>最后我们通过 <code>exit</code> 退出了这个容器。</p><h1 id="列出镜像"><a href="#列出镜像" class="headerlink" title="列出镜像"></a>列出镜像</h1><p>要想列出已经下载下来的镜像，可以使用 <code>docker image ls</code> 命令。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ docker image ls</span><br><span class="line">REPOSITORY           TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">redis                latest              5f515359c7f8        5 days ago          183 MB</span><br><span class="line">nginx                latest              05a60462f8ba        5 days ago          181 MB</span><br><span class="line">mongo                3.2                 fe9198c04d62        5 days ago          342 MB</span><br><span class="line">&lt;none&gt;               &lt;none&gt;              00285df0df87        5 days ago          342 MB</span><br><span class="line">ubuntu               18.04               f753707788c5        4 weeks ago         127 MB</span><br><span class="line">ubuntu               latest              f753707788c5        4 weeks ago         127 MB</span><br></pre></td></tr></table></figure><p>列表包含了 <code>仓库名</code>、<code>标签</code>、<code>镜像 ID</code>、<code>创建时间</code> 以及 <code>所占用的空间</code>。</p><p>其中仓库名、标签在之前的基础概念章节已经介绍过了。<strong>镜像 ID</strong> 则是镜像的唯一标识，一个镜像可以对应多个 <strong>标签</strong>。因此，在上面的例子中，我们可以看到 <code>ubuntu:18.04</code> 和 <code>ubuntu:latest</code> 拥有相同的 ID，因为它们对应的是同一个镜像。</p><h2 id="镜像体积"><a href="#镜像体积" class="headerlink" title="镜像体积"></a>镜像体积</h2><p>如果仔细观察，会注意到，这里标识的所占用空间和在 Docker Hub 上看到的镜像大小不同。比如，<code>ubuntu:18.04</code> 镜像大小，在这里是 <code>127 MB</code>，但是在 <a href="https://hub.docker.com/r/library/ubuntu/tags/" target="_blank" rel="noopener">Docker Hub</a> 显示的却是 <code>50 MB</code>。这是因为 Docker Hub 中显示的体积是压缩后的体积。在镜像下载和上传过程中镜像是保持着压缩状态的，因此 Docker Hub 所显示的大小是网络传输中更关心的流量大小。而 <code>docker image ls</code> 显示的是镜像下载到本地后，展开的大小，准确说，是展开后的各层所占空间的总和，因为镜像到本地后，查看空间的时候，更关心的是本地磁盘空间占用的大小。</p><p>另外一个需要注意的问题是，<code>docker image ls</code> 列表中的镜像体积总和并非是所有镜像实际硬盘消耗。由于 Docker 镜像是多层存储结构，并且可以继承、复用，因此不同镜像可能会因为使用相同的基础镜像，从而拥有共同的层。由于 Docker 使用 Union FS，相同的层只需要保存一份即可，因此实际镜像硬盘占用空间很可能要比这个列表镜像大小的总和要小的多。</p><p>你可以通过以下命令来便捷的查看镜像、容器、数据卷所占用的空间。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ docker system df</span><br><span class="line"></span><br><span class="line">TYPE                TOTAL               ACTIVE              SIZE                RECLAIMABLE</span><br><span class="line">Images              24                  0                   1.992GB             1.992GB (100%)</span><br><span class="line">Containers          1                   0                   62.82MB             62.82MB (100%)</span><br><span class="line">Local Volumes       9                   0                   652.2MB             652.2MB (100%)</span><br><span class="line">Build Cache                                                 0B                  0B</span><br></pre></td></tr></table></figure><h2 id="虚悬镜像"><a href="#虚悬镜像" class="headerlink" title="虚悬镜像"></a>虚悬镜像</h2><p>上面的镜像列表中，还可以看到一个特殊的镜像，这个镜像既没有仓库名，也没有标签，均为 <code></code>。：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;none&gt;               &lt;none&gt;              00285df0df87        5 days ago          342 MB</span><br></pre></td></tr></table></figure><p>这个镜像原本是有镜像名和标签的，原来为 <code>mongo:3.2</code>，随着官方镜像维护，发布了新版本后，重新 <code>docker pull mongo:3.2</code> 时，<code>mongo:3.2</code> 这个镜像名被转移到了新下载的镜像身上，而旧的镜像上的这个名称则被取消，从而成为了 <code>。除了 `docker pull` 可能导致这种情况，`docker build` 也同样可以导致这种现象。由于新旧镜像同名，旧镜像名称被取消，从而出现仓库名、标签均为</code> 的镜像。这类无标签镜像也被称为 <strong>虚悬镜像(dangling image)</strong> ，可以用下面的命令专门显示这类镜像：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ docker image ls -f dangling=<span class="literal">true</span></span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">&lt;none&gt;              &lt;none&gt;              00285df0df87        5 days ago          342 MB</span><br></pre></td></tr></table></figure><p>一般来说，虚悬镜像已经失去了存在的价值，是可以随意删除的，可以用下面的命令删除。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker image prune</span><br></pre></td></tr></table></figure><h2 id="中间层镜像"><a href="#中间层镜像" class="headerlink" title="中间层镜像"></a>中间层镜像</h2><p>为了加速镜像构建、重复利用资源，Docker 会利用 <strong>中间层镜像</strong>。所以在使用一段时间后，可能会看到一些依赖的中间层镜像。默认的 <code>docker image ls</code> 列表中只会显示顶层镜像，如果希望显示包括中间层镜像在内的所有镜像的话，需要加 <code>-a</code> 参数。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker image ls -a</span><br></pre></td></tr></table></figure><p>这样会看到很多无标签的镜像，与之前的虚悬镜像不同，这些无标签的镜像很多都是中间层镜像，是其它镜像所依赖的镜像。这些无标签镜像不应该删除，否则会导致上层镜像因为依赖丢失而出错。实际上，这些镜像也没必要删除，因为之前说过，相同的层只会存一遍，而这些镜像是别的镜像的依赖，因此并不会因为它们被列出来而多存了一份，无论如何你也会需要它们。只要删除那些依赖它们的镜像后，这些依赖的中间层镜像也会被连带删除。</p><h2 id="列出部分镜像"><a href="#列出部分镜像" class="headerlink" title="列出部分镜像"></a>列出部分镜像</h2><p>不加任何参数的情况下，<code>docker image ls</code> 会列出所有顶层镜像，但是有时候我们只希望列出部分镜像。<code>docker image ls</code> 有好几个参数可以帮助做到这个事情。</p><p>根据仓库名列出镜像</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ docker image ls ubuntu</span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">ubuntu              18.04               f753707788c5        4 weeks ago         127 MB</span><br><span class="line">ubuntu              latest              f753707788c5        4 weeks ago         127 MB</span><br></pre></td></tr></table></figure><p>列出特定的某个镜像，也就是说指定仓库名和标签</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ docker image ls ubuntu:18.04</span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">ubuntu              18.04               f753707788c5        4 weeks ago         127 MB</span><br></pre></td></tr></table></figure><p>除此以外，<code>docker image ls</code> 还支持强大的过滤器参数 <code>--filter</code>，或者简写 <code>-f</code>。之前我们已经看到了使用过滤器来列出虚悬镜像的用法，它还有更多的用法。比如，我们希望看到在 <code>mongo:3.2</code> 之后建立的镜像，可以用下面的命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ docker image ls -f since=mongo:3.2</span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">redis               latest              5f515359c7f8        5 days ago          183 MB</span><br><span class="line">nginx               latest              05a60462f8ba        5 days ago          181 MB</span><br></pre></td></tr></table></figure><p>想查看某个位置之前的镜像也可以，只需要把 <code>since</code> 换成 <code>before</code> 即可。</p><p>此外，如果镜像构建时，定义了 <code>LABEL</code>，还可以通过 <code>LABEL</code> 来过滤。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker image ls -f label=com.example.version=0.1</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h2 id="以特定格式显示"><a href="#以特定格式显示" class="headerlink" title="以特定格式显示"></a>以特定格式显示</h2><p>默认情况下，<code>docker image ls</code> 会输出一个完整的表格，但是我们并非所有时候都会需要这些内容。比如，刚才删除虚悬镜像的时候，我们需要利用 <code>docker image ls</code> 把所有的虚悬镜像的 ID 列出来，然后才可以交给 <code>docker image rm</code> 命令作为参数来删除指定的这些镜像，这个时候就用到了 <code>-q</code> 参数。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ docker image ls -q</span><br><span class="line">5f515359c7f8</span><br><span class="line">05a60462f8ba</span><br><span class="line">fe9198c04d62</span><br><span class="line">00285df0df87</span><br><span class="line">f753707788c5</span><br><span class="line">f753707788c5</span><br><span class="line">1e0c3dd64ccd</span><br></pre></td></tr></table></figure><p><code>--filter</code> 配合 <code>-q</code> 产生出指定范围的 ID 列表，然后送给另一个 <code>docker</code> 命令作为参数，从而针对这组实体成批的进行某种操作的做法在 Docker 命令行使用过程中非常常见，不仅仅是镜像，将来我们会在各个命令中看到这类搭配以完成很强大的功能。因此每次在文档看到过滤器后，可以多注意一下它们的用法。</p><p>另外一些时候，我们可能只是对表格的结构不满意，希望自己组织列；或者不希望有标题，这样方便其它程序解析结果等，这就用到了 <a href="https://gohugo.io/templates/go-templates/" target="_blank" rel="noopener">Go 的模板语法</a>。</p><p>比如，下面的命令会直接列出镜像结果，并且只包含镜像ID和仓库名：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ docker image ls --format <span class="string">"&#123;&#123;.ID&#125;&#125;: &#123;&#123;.Repository&#125;&#125;"</span></span><br><span class="line">5f515359c7f8: redis</span><br><span class="line">05a60462f8ba: nginx</span><br><span class="line">fe9198c04d62: mongo</span><br><span class="line">00285df0df87: &lt;none&gt;</span><br><span class="line">f753707788c5: ubuntu</span><br><span class="line">f753707788c5: ubuntu</span><br><span class="line">1e0c3dd64ccd: ubuntu</span><br></pre></td></tr></table></figure><p>或者打算以表格等距显示，并且有标题行，和默认一样，不过自己定义列：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ docker image ls --format <span class="string">"table &#123;&#123;.ID&#125;&#125;\t&#123;&#123;.Repository&#125;&#125;\t&#123;&#123;.Tag&#125;&#125;"</span></span><br><span class="line">IMAGE ID            REPOSITORY          TAG</span><br><span class="line">5f515359c7f8        redis               latest</span><br><span class="line">05a60462f8ba        nginx               latest</span><br><span class="line">fe9198c04d62        mongo               3.2</span><br><span class="line">00285df0df87        &lt;none&gt;              &lt;none&gt;</span><br><span class="line">f753707788c5        ubuntu              18.04</span><br><span class="line">f753707788c5        ubuntu              latest</span><br></pre></td></tr></table></figure><h1 id="删除本地镜像"><a href="#删除本地镜像" class="headerlink" title="删除本地镜像"></a>删除本地镜像</h1><p>如果要删除本地的镜像，可以使用 <code>docker image rm</code> 命令，其格式为：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker image rm [选项] &lt;镜像1&gt; [&lt;镜像2&gt; ...]</span><br></pre></td></tr></table></figure><h2 id="用-ID、镜像名、摘要删除镜像"><a href="#用-ID、镜像名、摘要删除镜像" class="headerlink" title="用 ID、镜像名、摘要删除镜像"></a>用 ID、镜像名、摘要删除镜像</h2><p>其中，<code>&lt;镜像&gt;</code> 可以是 <code>镜像短 ID</code>、<code>镜像长 ID</code>、<code>镜像名</code> 或者 <code>镜像摘要</code>。</p><p>比如我们有这么一些镜像：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ docker image ls</span><br><span class="line">REPOSITORY                  TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">centos                      latest              0584b3d2cf6d        3 weeks ago         196.5 MB</span><br><span class="line">redis                       alpine              501ad78535f0        3 weeks ago         21.03 MB</span><br><span class="line">docker                      latest              cf693ec9b5c7        3 weeks ago         105.1 MB</span><br><span class="line">nginx                       latest              e43d811ce2f4        5 weeks ago         181.5 MB</span><br></pre></td></tr></table></figure><p>我们可以用镜像的完整 ID，也称为 <code>长 ID</code>，来删除镜像。使用脚本的时候可能会用长 ID，但是人工输入就太累了，所以更多的时候是用 <code>短 ID</code> 来删除镜像。<code>docker image ls</code> 默认列出的就已经是短 ID 了，一般取前3个字符以上，只要足够区分于别的镜像就可以了。</p><p>比如这里，如果我们要删除 <code>redis:alpine</code> 镜像，可以执行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ docker image rm 501</span><br><span class="line">Untagged: redis:alpine</span><br><span class="line">Untagged: redis@sha256:f1ed3708f538b537eb9c2a7dd50dc90a706f7debd7e1196c9264edeea521a86d</span><br><span class="line">Deleted: sha256:501ad78535f015d88872e13fa87a828425117e3d28075d0c117932b05bf189b7</span><br><span class="line">Deleted: sha256:96167737e29ca8e9d74982ef2a0dda76ed7b430da55e321c071f0dbff8c2899b</span><br><span class="line">Deleted: sha256:32770d1dcf835f192cafd6b9263b7b597a1778a403a109e2cc2ee866f74adf23</span><br><span class="line">Deleted: sha256:127227698ad74a5846ff5153475e03439d96d4b1c7f2a449c7a826ef74a2d2fa</span><br><span class="line">Deleted: sha256:1333ecc582459bac54e1437335c0816bc17634e131ea0cc48daa27d32c75eab3</span><br><span class="line">Deleted: sha256:4fc455b921edf9c4aea207c51ab39b10b06540c8b4825ba57b3feed1668fa7c7</span><br></pre></td></tr></table></figure><p>我们也可以用<code>镜像名</code>，也就是 <code>&lt;仓库名&gt;:&lt;标签&gt;</code>，来删除镜像。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ docker image rm centos</span><br><span class="line">Untagged: centos:latest</span><br><span class="line">Untagged: centos@sha256:b2f9d1c0ff5f87a4743104d099a3d561002ac500db1b9bfa02a783a46e0d366c</span><br><span class="line">Deleted: sha256:0584b3d2cf6d235ee310cf14b54667d889887b838d3f3d3033acd70fc3c48b8a</span><br><span class="line">Deleted: sha256:97ca462ad9eeae25941546209454496e1d66749d53dfa2ee32bf1faabd239d38</span><br></pre></td></tr></table></figure><p>当然，更精确的是使用 <code>镜像摘要</code> 删除镜像。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ docker image ls --digests</span><br><span class="line">REPOSITORY                  TAG                 DIGEST                                                                    IMAGE ID            CREATED             SIZE</span><br><span class="line">node                        slim                sha256:b4f0e0bdeb578043c1ea6862f0d40cc4afe32a4a582f3be235a3b164422be228   6e0c4c8e3913        3 weeks ago         214 MB</span><br><span class="line"></span><br><span class="line">$ docker image rm node@sha256:b4f0e0bdeb578043c1ea6862f0d40cc4afe32a4a582f3be235a3b164422be228</span><br><span class="line">Untagged: node@sha256:b4f0e0bdeb578043c1ea6862f0d40cc4afe32a4a582f3be235a3b164422be228</span><br></pre></td></tr></table></figure><h2 id="Untagged-和-Deleted"><a href="#Untagged-和-Deleted" class="headerlink" title="Untagged 和 Deleted"></a>Untagged 和 Deleted</h2><p>如果观察上面这几个命令的运行输出信息的话，你会注意到删除行为分为两类，一类是 <code>Untagged</code>，另一类是 <code>Deleted</code>。我们之前介绍过，镜像的唯一标识是其 ID 和摘要，而一个镜像可以有多个标签。</p><p>因此当我们使用上面命令删除镜像的时候，实际上是在要求删除某个标签的镜像。所以首先需要做的是将满足我们要求的所有镜像标签都取消，这就是我们看到的 <code>Untagged</code> 的信息。因为一个镜像可以对应多个标签，因此当我们删除了所指定的标签后，可能还有别的标签指向了这个镜像，如果是这种情况，那么 <code>Delete</code> 行为就不会发生。所以并非所有的 <code>docker image rm</code> 都会产生删除镜像的行为，有可能仅仅是取消了某个标签而已。</p><p>当该镜像所有的标签都被取消了，该镜像很可能会失去了存在的意义，因此会触发删除行为。镜像是多层存储结构，因此在删除的时候也是从上层向基础层方向依次进行判断删除。镜像的多层结构让镜像复用变得非常容易，因此很有可能某个其它镜像正依赖于当前镜像的某一层。这种情况，依旧不会触发删除该层的行为。直到没有任何层依赖当前层时，才会真实的删除当前层。这就是为什么，有时候会奇怪，为什么明明没有别的标签指向这个镜像，但是它还是存在的原因，也是为什么有时候会发现所删除的层数和自己 <code>docker pull</code> 看到的层数不一样的原因。</p><p>除了镜像依赖以外，还需要注意的是容器对镜像的依赖。如果有用这个镜像启动的容器存在（即使容器没有运行），那么同样不可以删除这个镜像。之前讲过，容器是以镜像为基础，再加一层容器存储层，组成这样的多层存储结构去运行的。因此该镜像如果被这个容器所依赖的，那么删除必然会导致故障。如果这些容器是不需要的，应该先将它们删除，然后再来删除镜像。</p><h2 id="用-docker-image-ls-命令来配合"><a href="#用-docker-image-ls-命令来配合" class="headerlink" title="用 docker image ls 命令来配合"></a>用 docker image ls 命令来配合</h2><p>像其它可以承接多个实体的命令一样，可以使用 <code>docker image ls -q</code> 来配合使用 <code>docker image rm</code>，这样可以成批的删除希望删除的镜像。我们在“镜像列表”章节介绍过很多过滤镜像列表的方式都可以拿过来使用。</p><p>比如，我们需要删除所有仓库名为 <code>redis</code> 的镜像：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker image rm $(docker image ls -q redis)</span><br></pre></td></tr></table></figure><p>或者删除所有在 <code>mongo:3.2</code> 之前的镜像：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker image rm $(docker image ls -q -f before=mongo:3.2)</span><br></pre></td></tr></table></figure><p> Linux 命令行的强大可以完成很多非常赞的功能。</p><h1 id="镜像的实现原理"><a href="#镜像的实现原理" class="headerlink" title="镜像的实现原理"></a>镜像的实现原理</h1><p>Docker 镜像是怎么实现增量的修改和维护的？</p><p>每个镜像都由很多层次构成，Docker 使用 <a href="https://en.wikipedia.org/wiki/UnionFS" target="_blank" rel="noopener">Union FS</a> 将这些不同的层结合到一个镜像中去。</p><p>通常 Union FS 有两个用途, 一方面可以实现不借助 LVM、RAID 将多个 disk 挂到同一个目录下,另一个更常用的就是将一个只读的分支和一个可写的分支联合在一起，Live CD 正是基于此方法可以允许在镜像不变的基础上允许用户在其上进行一些写操作。</p><p>Docker 在 AUFS 上构建的容器也是利用了类似的原理。</p><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p>本文章摘抄于：<a href="https://yeasy.gitbooks.io/docker_practice/content/" target="_blank" rel="noopener">https://yeasy.gitbooks.io/docker_practice/content/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Docker镜像简介&quot;&gt;&lt;a href=&quot;#Docker镜像简介&quot; class=&quot;headerlink&quot; title=&quot;Docker镜像简介&quot;&gt;&lt;/a&gt;Docker镜像简介&lt;/h1&gt;&lt;p&gt;镜像是 Docker 的三大组件之一。&lt;/p&gt;
&lt;p&gt;Docker 运行容器前需要本地存在对应的镜像，如果本地不存在该镜像，Docker 会从镜像仓库下载该镜像。&lt;/p&gt;
&lt;p&gt;本章将介绍更多关于镜像的内容，包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;从仓库获取镜像；&lt;/li&gt;
&lt;li&gt;管理本地主机上的镜像&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Docker" scheme="http://hackycy.github.io/categories/Docker/"/>
    
    
      <category term="Docker" scheme="http://hackycy.github.io/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>Docker入门（二）——容器</title>
    <link href="http://hackycy.github.io/2019/11/28/Docker%E5%85%A5%E9%97%A8%EF%BC%88%E4%BA%8C%EF%BC%89%E2%80%94%E2%80%94%E5%AE%B9%E5%99%A8/"/>
    <id>http://hackycy.github.io/2019/11/28/Docker入门（二）——容器/</id>
    <published>2019-11-28T05:30:20.000Z</published>
    <updated>2019-12-15T08:59:49.418Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Docker容器简介"><a href="#Docker容器简介" class="headerlink" title="Docker容器简介"></a>Docker容器简介</h1><p>容器是 Docker 是一核心概念。</p><p>简单的说，容器是独立运行的一个或一组应用，以及它们的运行态环境。对应的，虚拟机可以理解为模拟运行的一整套操作系统（提供了运行态环境和其他系统环境）和跑在上面的应用。</p><a id="more"></a><p>接下来看看容器的操作使用。</p><h1 id="容器操作"><a href="#容器操作" class="headerlink" title="容器操作"></a>容器操作</h1><h2 id="启动容器"><a href="#启动容器" class="headerlink" title="启动容器"></a>启动容器</h2><p>启动容器有两种方式，一种是基于镜像新建一个容器并启动，另外一个是将在终止状态（<code>stopped</code>）的容器重新启动。</p><h3 id="新建并启动"><a href="#新建并启动" class="headerlink" title="新建并启动"></a>新建并启动</h3><p>所需要的命令主要为 <code>docker run</code>。</p><p>例如，下面的命令输出一个 “Hello World”，之后终止容器。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ docker run ubuntu:18.04 /bin/<span class="built_in">echo</span> <span class="string">'Hello world'</span></span><br><span class="line">Unable to find image <span class="string">'ubuntu:18.04'</span> locally</span><br><span class="line">18.04: Pulling from library/ubuntu</span><br><span class="line">7ddbc47eeb70: Pull complete </span><br><span class="line">c1bbdc448b72: Pull complete </span><br><span class="line">8c3b70e39044: Pull complete </span><br><span class="line">45d437916d57: Pull complete </span><br><span class="line">Digest: sha256:6e9f67fa63b0323e9a1e587fd71c561ba48a034504fb804fd26fd8800039835d</span><br><span class="line">Status: Downloaded newer image <span class="keyword">for</span> ubuntu:18.04</span><br><span class="line">Hello world</span><br></pre></td></tr></table></figure><p>这跟在本地直接执行 <code>/bin/echo &#39;hello world&#39;</code> 几乎感觉不出任何区别。</p><h3 id="启动交互式终端"><a href="#启动交互式终端" class="headerlink" title="启动交互式终端"></a>启动交互式终端</h3><p>我们通过 docker 的两个参数 -i -t，让 docker 运行的容器实现<strong>“对话”</strong>的能力：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -t -i ubuntu:18.04 /bin/bash</span><br><span class="line">root@349a1edaa615:/<span class="comment">#</span></span><br></pre></td></tr></table></figure><p>各个参数解析：</p><ul><li><strong>-t:</strong> 选项让Docker分配一个伪终端（pseudo-tty）并绑定到容器的标准输入上</li><li><strong>-i:</strong> 则让容器的标准输入保持打开。</li><li><strong>ubuntu:18.04</strong>: ubuntu 镜像。</li><li><strong>/bin/bash</strong>：放在镜像名后的是命令，这里我们希望有个交互式 Shell，因此用的是 /bin/bash。</li></ul><p>在交互模式下，用户可以通过所创建的终端来输入命令，例如</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">root@349a1edaa615:/<span class="comment"># pwd</span></span><br><span class="line">/</span><br><span class="line">root@349a1edaa615:/<span class="comment"># ls</span></span><br><span class="line">bin  boot  dev  etc  home  lib  lib64  media  mnt  opt  proc  root  run  sbin  srv  sys  tmp  usr  var</span><br><span class="line">root@349a1edaa615:/<span class="comment"># exit</span></span><br><span class="line"><span class="built_in">exit</span></span><br></pre></td></tr></table></figure><blockquote><p>exit退出交互式 Shell</p></blockquote><p>当利用 <code>docker run</code> 来创建容器时，Docker 在后台运行的标准操作包括：</p><ul><li>检查本地是否存在指定的镜像，不存在就从公有仓库下载</li><li>利用镜像创建并启动一个容器</li><li>分配一个文件系统，并在只读的镜像层外面挂载一层可读写层</li><li>从宿主主机配置的网桥接口中桥接一个虚拟接口到容器中去</li><li>从地址池配置一个 ip 地址给容器</li><li>执行用户指定的应用程序</li><li>执行完毕后容器被终止</li></ul><h3 id="启动已终止容器"><a href="#启动已终止容器" class="headerlink" title="启动已终止容器"></a>启动已终止容器</h3><p>可以利用 <code>docker container start</code> 命令，直接将一个已经终止的容器启动运行。</p><p>容器的核心为所执行的应用程序，所需要的资源都是应用程序运行所必需的。除此之外，并没有其它的资源。可以在伪终端中利用 <code>ps</code> 或 <code>top</code> 来查看进程信息。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">root@181e9d1236d5:/<span class="comment"># ps</span></span><br><span class="line">  PID TTY          TIME CMD</span><br><span class="line">    1 pts/0    00:00:00 bash</span><br><span class="line">   11 pts/0    00:00:00 ps</span><br></pre></td></tr></table></figure><h2 id="守护态运行容器"><a href="#守护态运行容器" class="headerlink" title="守护态运行容器"></a>守护态运行容器</h2><p>如果需要让 Docker 在后台运行而不是直接把执行命令的结果输出在当前宿主机下。此时，可以通过添加 <code>-d</code> 参数来实现。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -d -i -t ubuntu:18.04 /bin/sh</span><br><span class="line">edae8d9d6311b344b3971bafc2a698625242bcf3300e2c850ba1e4ef51d88707</span><br></pre></td></tr></table></figure><p>此时容器启动后会进入后台。如果想要进入容器可以使用<code>docker exec</code>命令，后面会逐渐讲解到。</p><blockquote><p> <strong>注：</strong>容器是否会长久运行，是和 <code>docker run</code> 指定的命令有关，和 <code>-d</code> 参数无关。</p></blockquote><p>使用 <code>-d</code> 参数启动后会返回一个唯一的 id，也可以通过 <code>docker container ls</code> 命令来查看容器信息。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ docker container ls</span><br><span class="line">CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES</span><br><span class="line">edae8d9d6311        ubuntu:18.04        <span class="string">"/bin/sh"</span>           4 minutes ago       Up 4 minutes                            suspicious_pike</span><br></pre></td></tr></table></figure><blockquote><p>要获取容器的输出信息，可以通过 <code>docker container logs</code> 命令。如<code>docker container logs [container ID or NAMES]</code></p></blockquote><h2 id="终止容器"><a href="#终止容器" class="headerlink" title="终止容器"></a>终止容器</h2><p>可以使用 <code>docker container stop</code> 来终止一个运行中的容器。</p><p>此外，当 Docker 容器中指定的应用终结时，容器也自动终止。</p><p>例如对于上一章节中只启动了一个终端的容器，用户通过 <code>exit</code> 命令或 <code>Ctrl+d</code> 来退出终端时，所创建的容器立刻终止。</p><p>终止状态的容器可以用 <code>docker container ls -a</code> 命令看到。例如</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ docker container stop edae</span><br><span class="line">edae</span><br><span class="line">$ docker container ls -a</span><br><span class="line">CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS                        PORTS               NAMES</span><br><span class="line">edae8d9d6311        ubuntu:18.04        <span class="string">"/bin/sh"</span>                7 minutes ago       Exited (137) 36 seconds ago                       suspicious_pike</span><br><span class="line">181e9d1236d5        ubuntu:18.04        <span class="string">"/bin/bash"</span>              2 days ago          Exited (0) 2 days ago                             condescending_feistel</span><br><span class="line">349a1edaa615        ubuntu:18.04        <span class="string">"/bin/bash"</span>              2 days ago          Exited (0) 2 days ago                             suspicious_lehmann</span><br><span class="line">7d6482342da5        ubuntu:18.04        <span class="string">"/bin/echo 'Hello wo…"</span>   2 days ago          Exited (0) 2 days ago                             affectionate_knuth</span><br></pre></td></tr></table></figure><p>处于终止状态的容器，可以通过 <code>docker container start</code> 命令来重新启动。</p><p>此外，<code>docker container restart</code> 命令会将一个运行态的容器终止，然后再重新启动它。</p><blockquote><p>指定容器ID时可以不需要输入完整ID，可以输入ID前几位都可以，只要能够辨识到该容器即可。</p></blockquote><h2 id="进入容器"><a href="#进入容器" class="headerlink" title="进入容器"></a>进入容器</h2><p>在使用 <code>-d</code> 参数时，容器启动后会进入后台。</p><p>某些时候需要进入容器进行操作，包括使用 <code>docker attach</code> 命令或 <code>docker exec</code> 命令，推荐大家使用 <code>docker exec</code> 命令。</p><h3 id="attach命令"><a href="#attach命令" class="headerlink" title="attach命令"></a><code>attach</code>命令</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ docker container ls</span><br><span class="line">CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES</span><br><span class="line">edae8d9d6311        ubuntu:18.04        <span class="string">"/bin/sh"</span>           9 minutes ago       Up 4 seconds                            suspicious_pike</span><br><span class="line">$ docker attach 243c</span><br><span class="line"><span class="comment"># pwd</span></span><br><span class="line">/</span><br><span class="line"><span class="comment"># exit</span></span><br><span class="line">$ docker container ls</span><br><span class="line">CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES</span><br></pre></td></tr></table></figure><p><em>注意：</em> 如果从这个 stdin 中 exit，会导致容器的停止。</p><h3 id="exec命令"><a href="#exec命令" class="headerlink" title="exec命令"></a><code>exec</code>命令</h3><p><code>docker exec</code> 后边可以跟多个参数，这里主要说明 <code>-i</code> <code>-t</code> 参数。</p><p>只用 <code>-i</code> 参数时，由于没有分配伪终端，界面没有我们熟悉的 Linux 命令提示符，但命令执行结果仍然可以返回。</p><p>当 <code>-i</code> <code>-t</code> 参数一起使用时，则可以看到我们熟悉的 Linux 命令提示符。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">$ container ls</span><br><span class="line">CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES</span><br><span class="line">edae8d9d6311        ubuntu:18.04        <span class="string">"/bin/sh"</span>           13 minutes ago      Up 5 seconds                            suspicious_pike</span><br><span class="line">$ docker <span class="built_in">exec</span> -i edae bash</span><br><span class="line">ls</span><br><span class="line">bin</span><br><span class="line">boot</span><br><span class="line">dev</span><br><span class="line">etc</span><br><span class="line">home</span><br><span class="line">lib</span><br><span class="line">lib64</span><br><span class="line">media</span><br><span class="line">mnt</span><br><span class="line">opt</span><br><span class="line">proc</span><br><span class="line">root</span><br><span class="line">run</span><br><span class="line">sbin</span><br><span class="line">srv</span><br><span class="line">sys</span><br><span class="line">tmp</span><br><span class="line">usr</span><br><span class="line">va</span><br><span class="line">$ docker <span class="built_in">exec</span> -i -t edae bash</span><br><span class="line">root@edae8d9d6311:/<span class="comment"># ls</span></span><br><span class="line">bin  boot  dev  etc  home  lib  lib64  media  mnt  opt  proc  root  run  sbin  srv  sys  tmp  usr  var</span><br><span class="line">root@edae8d9d6311:/<span class="comment"># exit</span></span><br><span class="line"><span class="built_in">exit</span></span><br></pre></td></tr></table></figure><p>如果从这个 stdin 中 exit，不会导致容器的停止。这就是为什么推荐大家使用 <code>docker exec</code> 的原因。</p><p>更多参数说明请使用 <code>docker exec --help</code> 查看。</p><h2 id="导出和导入容器"><a href="#导出和导入容器" class="headerlink" title="导出和导入容器"></a>导出和导入容器</h2><h3 id="导出容器"><a href="#导出容器" class="headerlink" title="导出容器"></a>导出容器</h3><p>如果要导出本地某个容器，可以使用 <code>docker export</code> 命令。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ docker container ls -a</span><br><span class="line">CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS                            PORTS               NAMES</span><br><span class="line">edae8d9d6311        ubuntu:18.04        <span class="string">"/bin/sh"</span>                18 minutes ago      Exited (137) About a minute ago                       suspicious_pike</span><br><span class="line">181e9d1236d5        ubuntu:18.04        <span class="string">"/bin/bash"</span>              2 days ago          Exited (0) 2 days ago                                 condescending_feistel</span><br><span class="line">349a1edaa615        ubuntu:18.04        <span class="string">"/bin/bash"</span>              2 days ago          Exited (0) 2 days ago                                 suspicious_lehmann</span><br><span class="line">7d6482342da5        ubuntu:18.04        <span class="string">"/bin/echo 'Hello wo…"</span>   2 days ago          Exited (0) 2 days ago                                 affectionate_knuth</span><br><span class="line">$ docker <span class="built_in">export</span> edae &gt; ubuntu.zip</span><br></pre></td></tr></table></figure><h3 id="导入容器快照"><a href="#导入容器快照" class="headerlink" title="导入容器快照"></a>导入容器快照</h3><p>可以使用 <code>docker import</code> 从容器快照文件中再导入为镜像，例如</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ cat ubuntu.zip | docker import - <span class="built_in">test</span>/ubuntu:v1.0</span><br><span class="line">$ docker image ls</span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED              VIRTUAL SIZE</span><br><span class="line"><span class="built_in">test</span>/ubuntu         v1.0                9d37a6082e97        About a minute ago   171.3 MB</span><br></pre></td></tr></table></figure><p>此外，也可以通过指定 URL 或者某个目录来导入，例如</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker import http://example.com/exampleimage.tgz example/imagerepo</span><br></pre></td></tr></table></figure><blockquote><p><em>注：用户既可以使用 <code>docker load</code> 来导入镜像存储文件到本地镜像库，也可以使用 <code>docker import</code> 来导入一个容器快照到本地镜像库。这两者的区别在于容器快照文件将丢弃所有的历史记录和元数据信息（即仅保存容器当时的快照状态），而镜像存储文件将保存完整记录，体积也要大。此外，从容器快照文件导入时可以重新指定标签等元数据信息。</em></p></blockquote><h2 id="删除容器"><a href="#删除容器" class="headerlink" title="删除容器"></a>删除容器</h2><p>可以使用 <code>docker container rm</code> 来删除一个处于终止状态的容器。例如</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker container rm  edae</span><br><span class="line">edae</span><br></pre></td></tr></table></figure><p>如果要删除一个运行中的容器，可以添加 <code>-f</code> 参数。Docker 会发送 <code>SIGKILL</code> 信号给容器。</p><p><strong>清理所有处于终止状态的容器</strong></p><p>用 <code>docker container ls -a</code> 命令可以查看所有已经创建的包括终止状态的容器，如果数量太多要一个个删除可能会很麻烦，用命令<code>docker container prune</code>可以清理掉所有处于终止状态的容器。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">$ docker container ls -a</span><br><span class="line">CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS                  PORTS               NAMES</span><br><span class="line">181e9d1236d5        ubuntu:18.04        <span class="string">"/bin/bash"</span>              2 days ago          Exited (0) 2 days ago                       condescending_feistel</span><br><span class="line">349a1edaa615        ubuntu:18.04        <span class="string">"/bin/bash"</span>              2 days ago          Exited (0) 2 days ago                       suspicious_lehmann</span><br><span class="line">7d6482342da5        ubuntu:18.04        <span class="string">"/bin/echo 'Hello wo…"</span>   2 days ago          Exited (0) 2 days ago                       affectionate_knuth</span><br><span class="line">$ docker container prune</span><br><span class="line">WARNING! This will remove all stopped containers.</span><br><span class="line">Are you sure you want to <span class="built_in">continue</span>? [y/N] y</span><br><span class="line">Deleted Containers:</span><br><span class="line">181e9d1236d54ee898f8f0ebc5349dbcc0cd2368c34f427f7963c9014c9e1dc8</span><br><span class="line">349a1edaa61597acb426a0961059bf5a73ae0b23350774d5cd5c33963c8b2b12</span><br><span class="line">7d6482342da5f695a5351c15ef17acb521f893548db0891154b5c1268227ce7d</span><br><span class="line"></span><br><span class="line">Total reclaimed space: 20B</span><br><span class="line">$ docker container ls -a</span><br><span class="line">CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES</span><br></pre></td></tr></table></figure><h1 id="数据管理"><a href="#数据管理" class="headerlink" title="数据管理"></a>数据管理</h1><p>在容器中管理数据主要有两种方式：</p><ul><li>数据卷（Volumes）</li><li>挂载主机目录 (Bind mounts)</li></ul><h2 id="数据卷"><a href="#数据卷" class="headerlink" title="数据卷"></a>数据卷</h2><p><code>数据卷</code> 是一个可供一个或多个容器使用的特殊目录，它绕过 UFS，可以提供很多有用的特性：</p><ul><li><code>数据卷</code> 可以在容器之间共享和重用</li><li>对 <code>数据卷</code> 的修改会立马生效</li><li>对 <code>数据卷</code> 的更新，不会影响镜像</li><li><code>数据卷</code> 默认会一直存在，即使容器被删除</li></ul><blockquote><p>注意：<code>数据卷</code> 的使用，类似于 Linux 下对目录或文件进行 mount，镜像中的被指定为挂载点的目录中的文件会隐藏掉，能显示看的是挂载的 <code>数据卷</code>。</p></blockquote><h3 id="创建数据卷"><a href="#创建数据卷" class="headerlink" title="创建数据卷"></a>创建数据卷</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker volume create my-vol</span><br><span class="line">my-vol</span><br></pre></td></tr></table></figure><p>查看所有的 <code>数据卷</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ docker volume ls</span><br><span class="line">DRIVER              VOLUME NAME</span><br><span class="line"><span class="built_in">local</span>               my-vol</span><br></pre></td></tr></table></figure><p>在主机里使用以下命令可以查看指定 <code>数据卷</code> 的信息</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ docker volume inspect my-vol</span><br><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">"CreatedAt"</span>: <span class="string">"2019-12-02T03:25:01Z"</span>,</span><br><span class="line">        <span class="string">"Driver"</span>: <span class="string">"local"</span>,</span><br><span class="line">        <span class="string">"Labels"</span>: &#123;&#125;,</span><br><span class="line">        <span class="string">"Mountpoint"</span>: <span class="string">"/var/lib/docker/volumes/my-vol/_data"</span>,</span><br><span class="line">        <span class="string">"Name"</span>: <span class="string">"my-vol"</span>,</span><br><span class="line">        <span class="string">"Options"</span>: &#123;&#125;,</span><br><span class="line">        <span class="string">"Scope"</span>: <span class="string">"local"</span></span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h3 id="启动一个挂载数据卷的容器"><a href="#启动一个挂载数据卷的容器" class="headerlink" title="启动一个挂载数据卷的容器"></a>启动一个挂载数据卷的容器</h3><p>在用 <code>docker run</code> 命令的时候，使用 <code>--mount</code> 标记来将 <code>数据卷</code> 挂载到容器里。在一次 <code>docker run</code> 中可以挂载多个 <code>数据卷</code>。</p><p>下面创建一个名为 <code>web</code> 的容器，并加载一个 <code>数据卷</code> 到容器的 <code>/webapp</code> 目录。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -d -P \</span><br><span class="line">    --name web \</span><br><span class="line">    <span class="comment"># -v my-vol:/wepapp \</span></span><br><span class="line">    --mount <span class="built_in">source</span>=my-vol,target=/webapp \</span><br><span class="line">    training/webapp \</span><br><span class="line">    python app.py</span><br></pre></td></tr></table></figure><blockquote><p><strong>-P:</strong> 随机端口映射，容器内部端口<strong>随机</strong>映射到主机的高端口</p></blockquote><h3 id="查看数据卷的具体信息"><a href="#查看数据卷的具体信息" class="headerlink" title="查看数据卷的具体信息"></a>查看数据卷的具体信息</h3><p>在主机里使用以下命令可以查看 <code>web</code> 容器的信息</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker inspect web</span><br></pre></td></tr></table></figure><p><code>数据卷</code> 信息在 “Mounts” Key 下面</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">"Mounts": [</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">"Type"</span>: <span class="string">"volume"</span>,</span><br><span class="line">        <span class="attr">"Name"</span>: <span class="string">"my-vol"</span>,</span><br><span class="line">        <span class="attr">"Source"</span>: <span class="string">"/var/lib/docker/volumes/my-vol/_data"</span>,</span><br><span class="line">        <span class="attr">"Destination"</span>: <span class="string">"/app"</span>,</span><br><span class="line">        <span class="attr">"Driver"</span>: <span class="string">"local"</span>,</span><br><span class="line">        <span class="attr">"Mode"</span>: <span class="string">""</span>,</span><br><span class="line">        <span class="attr">"RW"</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="attr">"Propagation"</span>: <span class="string">""</span></span><br><span class="line">    &#125;</span><br><span class="line">],</span><br></pre></td></tr></table></figure><h3 id="删除数据卷"><a href="#删除数据卷" class="headerlink" title="删除数据卷"></a>删除数据卷</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker volume rm my-vol</span><br></pre></td></tr></table></figure><p><code>数据卷</code> 是被设计用来持久化数据的，它的生命周期独立于容器，Docker 不会在容器被删除后自动删除 <code>数据卷</code>，并且也不存在垃圾回收这样的机制来处理没有任何容器引用的 <code>数据卷</code>。如果需要在删除容器的同时移除数据卷。可以在删除容器的时候使用 <code>docker rm -v</code> 这个命令。</p><p>无主的数据卷可能会占据很多空间，要清理请使用以下命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker volume prune</span><br></pre></td></tr></table></figure><h2 id="挂载主机目录"><a href="#挂载主机目录" class="headerlink" title="挂载主机目录"></a>挂载主机目录</h2><h3 id="挂载一个主机目录作为数据卷"><a href="#挂载一个主机目录作为数据卷" class="headerlink" title="挂载一个主机目录作为数据卷"></a>挂载一个主机目录作为数据卷</h3><p>使用 <code>--mount</code> 标记可以指定挂载一个本地主机的目录到容器中去。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -d -P \</span><br><span class="line">    --name web \</span><br><span class="line">    <span class="comment"># -v /src/webapp:/opt/webapp \</span></span><br><span class="line">    --mount <span class="built_in">type</span>=<span class="built_in">bind</span>,<span class="built_in">source</span>=/src/webapp,target=/opt/webapp \</span><br><span class="line">    training/webapp \</span><br><span class="line">    python app.py</span><br></pre></td></tr></table></figure><p>上面的命令加载主机的 <code>/src/webapp</code> 目录到容器的 <code>/opt/webapp</code>目录。这个功能在进行测试的时候十分方便，比如用户可以放置一些程序到本地目录中，来查看容器是否正常工作。本地目录的路径必须是绝对路径，以前使用 <code>-v</code> 参数时如果本地目录不存在 Docker 会自动为你创建一个文件夹，现在使用 <code>--mount</code> 参数时如果本地目录不存在，Docker 会报错。</p><p>Docker 挂载主机目录的默认权限是 <code>读写</code>，用户也可以通过增加 <code>readonly</code> 指定为 <code>只读</code>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -d -P \</span><br><span class="line">    --name web \</span><br><span class="line">    <span class="comment"># -v /src/webapp:/opt/webapp:ro \</span></span><br><span class="line">    --mount <span class="built_in">type</span>=<span class="built_in">bind</span>,<span class="built_in">source</span>=/src/webapp,target=/opt/webapp,<span class="built_in">readonly</span> \</span><br><span class="line">    training/webapp \</span><br><span class="line">    python app.py</span><br></pre></td></tr></table></figure><p>加了 <code>readonly</code> 之后，就挂载为 <code>只读</code> 了。如果你在容器内 <code>/opt/webapp</code> 目录新建文件，会显示如下错误</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/opt/webapp <span class="comment"># touch new.txt</span></span><br><span class="line">touch: new.txt: Read-only file system</span><br></pre></td></tr></table></figure><h3 id="查看数据卷的具体信息-1"><a href="#查看数据卷的具体信息-1" class="headerlink" title="查看数据卷的具体信息"></a>查看数据卷的具体信息</h3><p>在主机里使用以下命令可以查看 <code>web</code> 容器的信息</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker inspect web</span><br></pre></td></tr></table></figure><p><code>挂载主机目录</code> 的配置信息在 “Mounts” Key 下面</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">"Mounts": [</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">"Type"</span>: <span class="string">"bind"</span>,</span><br><span class="line">        <span class="attr">"Source"</span>: <span class="string">"/src/webapp"</span>,</span><br><span class="line">        <span class="attr">"Destination"</span>: <span class="string">"/opt/webapp"</span>,</span><br><span class="line">        <span class="attr">"Mode"</span>: <span class="string">""</span>,</span><br><span class="line">        <span class="attr">"RW"</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="attr">"Propagation"</span>: <span class="string">"rprivate"</span></span><br><span class="line">    &#125;</span><br><span class="line">],</span><br></pre></td></tr></table></figure><h3 id="挂载一个本地主机文件作为数据卷"><a href="#挂载一个本地主机文件作为数据卷" class="headerlink" title="挂载一个本地主机文件作为数据卷"></a>挂载一个本地主机文件作为数据卷</h3><p><code>--mount</code> 标记也可以从主机挂载单个文件到容器中</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ docker run --rm -it \</span><br><span class="line">   <span class="comment"># -v $HOME/.bash_history:/root/.bash_history \</span></span><br><span class="line">   --mount <span class="built_in">type</span>=<span class="built_in">bind</span>,<span class="built_in">source</span>=<span class="variable">$HOME</span>/.bash_history,target=/root/.bash_history \</span><br><span class="line">   ubuntu:18.04 \</span><br><span class="line">   bash</span><br><span class="line"></span><br><span class="line">root@2affd44b4667:/<span class="comment"># history</span></span><br><span class="line">1  ls</span><br><span class="line">2  diskutil list</span><br></pre></td></tr></table></figure><p>这样就可以记录在容器输入过的命令了。</p><h2 id="选择-v-or-–mount-标志"><a href="#选择-v-or-–mount-标志" class="headerlink" title="选择 -v or –mount 标志"></a>选择 -v or –mount 标志</h2><p>最初，<code>-v</code>或<code>--volume</code>标志用于独立容器，而<code>--mount</code>标志用于群集服务。但是，从Docker 17.06开始，您也可以使用<code>--mount</code>独立的容器。一般来说，<code>--mount</code>更明确和详细。最大的区别在于-v语法将所有选项组合在一个字段中，而<code>--mount</code>语法将它们分开。建议新学者使用。</p><p><strong><code>v</code>或<code>- volume</code>:由三个字段组成，由冒号分隔(:)。字段必须按照正确的顺序书写，并且每个字段的含义都不是立刻确定。</strong></p><ul><li>在命名卷的情况下，第一个字段是卷的名称，在给定的主机上是惟一的。对于匿名卷，省略了第一个字段。</li><li>第二个字段是在容器中安装文件或目录的路径。</li><li>第三个字段是可选的，并且是一个逗号分隔的选项列表，如ro。下面讨论这些选项。</li></ul><p><strong><code>--mount</code>:由多个键-值对组成，由逗号分隔，每一对由<code>&lt; key&gt;= &lt;value&gt; tuple(元组）</code>组成。<code>--mount</code> 语法比<code>- v</code>或<code>—volume</code> 更详细，其中键对的顺序并不重要，而且标记的值更容易理解。</strong></p><ul><li>挂载的类型(type)，可以是绑定(bind)、卷(volume)或tmpfs。本主题讨论卷，因此类型将始终是卷。</li><li>挂载源（source)。对于命名卷，是卷的名称。对于匿名卷，该字段被省略。可以指定为source 或src。</li><li>挂在目标(destination)的值是将文件或目录安装在容器中的路径。可以指定为destination、dst或target。</li><li>如果存在readonly选项，则将绑定挂载安装到容器中作为只读。</li><li>可以使用键值对多次指定的volume-opt选项.</li></ul><p>与绑定挂载相反，所有的卷的选项对于<code>--mount</code> 和<code>-v</code>标志 都可以使用。当卷(volume)作为服务时，只支持<code>--mount</code>。</p><h1 id="容器网络"><a href="#容器网络" class="headerlink" title="容器网络"></a>容器网络</h1><p>Docker 允许通过外部访问容器或容器互联的方式来提供网络服务。</p><h2 id="外部访问容器"><a href="#外部访问容器" class="headerlink" title="外部访问容器"></a>外部访问容器</h2><p>容器中可以运行一些网络应用，要让外部也可以访问这些应用，可以通过 <code>-P</code> 或 <code>-p</code> 参数来指定端口映射。</p><p>当使用 <code>-P</code> 标记时，Docker 会随机映射一个 <code>49000~49900</code> 的端口到内部容器开放的网络端口。</p><p>使用 <code>docker container ls</code> 可以看到，本地主机的 49155 被映射到了容器的 5000 端口。此时访问本机的 49155 端口即可访问容器内 web 应用提供的界面。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -d -P training/webapp python app.py</span><br><span class="line">ea7fb3aa1ca874847d7469f62f7cdfcd557438453ad08c283416b5d229468db2</span><br><span class="line">$ docker container ls</span><br><span class="line">CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS                     NAMES</span><br><span class="line">ea7fb3aa1ca8        training/webapp     <span class="string">"python app.py"</span>     About an hour ago   Up About an hour    0.0.0.0:32768-&gt;5000/tcp   serene_buck</span><br></pre></td></tr></table></figure><p>同样的，可以通过 <code>docker logs</code> 命令来查看应用的信息。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ docker logs -f serene_buck</span><br><span class="line"> * Running on http://0.0.0.0:5000/ (Press CTRL+C to quit)</span><br><span class="line">172.17.0.1 - - [02/Dec/2019 06:27:22] <span class="string">"GET / HTTP/1.1"</span> 200 -</span><br><span class="line">172.17.0.1 - - [02/Dec/2019 06:27:23] <span class="string">"GET /favicon.ico HTTP/1.1"</span> 404 -</span><br></pre></td></tr></table></figure><p><code>-p</code> 则可以指定要映射的端口，并且，在一个指定端口上只可以绑定一个容器。支持的格式有 <code>ip:hostPort:containerPort | ip::containerPort | hostPort:containerPort</code>。</p><h3 id="映射所有接口地址"><a href="#映射所有接口地址" class="headerlink" title="映射所有接口地址"></a>映射所有接口地址</h3><p>使用 <code>hostPort:containerPort</code> 格式本地的 8000 端口映射到容器的 5000 端口，可以执行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -d -p 8000:5000 training/webapp python app.py</span><br></pre></td></tr></table></figure><p>此时默认会绑定本地所有接口上的所有地址。</p><h3 id="映射到指定地址的指定端口"><a href="#映射到指定地址的指定端口" class="headerlink" title="映射到指定地址的指定端口"></a>映射到指定地址的指定端口</h3><p>可以使用 <code>ip:hostPort:containerPort</code> 格式指定映射使用一个特定地址，比如 localhost 地址 127.0.0.1</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -d -p 127.0.0.1:5000:5000 training/webapp python app.py</span><br></pre></td></tr></table></figure><h3 id="映射到指定地址的任意端口"><a href="#映射到指定地址的任意端口" class="headerlink" title="映射到指定地址的任意端口"></a>映射到指定地址的任意端口</h3><p>使用 <code>ip::containerPort</code> 绑定 localhost 的任意端口到容器的 5000 端口，本地主机会自动分配一个端口。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -d -p 127.0.0.1::5000 training/webapp python app.py</span><br></pre></td></tr></table></figure><p>还可以使用 <code>udp</code> 标记来指定 <code>udp</code> 端口</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -d -p 127.0.0.1:5000:5000/udp training/webapp python app.py</span><br></pre></td></tr></table></figure><h3 id="查看映射端口配置"><a href="#查看映射端口配置" class="headerlink" title="查看映射端口配置"></a>查看映射端口配置</h3><p>使用 <code>docker port</code> 来查看当前映射的端口配置，也可以查看到绑定的地址</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker port 5f2b 5000</span><br><span class="line">0.0.0.0:8000</span><br></pre></td></tr></table></figure><blockquote><p>注意：</p><ul><li>容器有自己的内部网络和 ip 地址（使用 <code>docker inspect</code> 可以获取所有的变量，Docker 还可以有一个可变的网络配置。）</li><li><code>-p</code> 标记可以多次使用来绑定多个端口</li></ul><p>例如</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -d \</span><br><span class="line">    -p 5000:5000 \</span><br><span class="line">    -p 3000:80 \</span><br><span class="line">    training/webapp \</span><br><span class="line">    python app.py</span><br></pre></td></tr></table></figure><h2 id="容器互联"><a href="#容器互联" class="headerlink" title="容器互联"></a>容器互联</h2><h3 id="新建网络"><a href="#新建网络" class="headerlink" title="新建网络"></a>新建网络</h3><p>下面先创建一个新的 Docker 网络。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker network create -d bridge my-net</span><br><span class="line">cea6b6e901d97a319c537895587df6a1256ccc18fc1e6faccfa911ec843e2e64</span><br></pre></td></tr></table></figure><p><code>-d</code> 参数指定 Docker 网络类型，有 <code>bridge</code> <code>overlay</code>。其中 <code>overlay</code> 网络类型用于 Swarm mode，属于高级用法了。入门章节则不介绍了。</p><h3 id="连接容器"><a href="#连接容器" class="headerlink" title="连接容器"></a>连接容器</h3><p>运行一个容器并连接到新建的 <code>my-net</code> 网络</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -i -t --rm --name busybox1 --network my-net busybox sh</span><br></pre></td></tr></table></figure><p>打开新的终端，再运行一个容器并加入到 <code>my-net</code> 网络</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -i -t --rm --name busybox2 --network my-net busybox sh</span><br></pre></td></tr></table></figure><blockquote><p>Clean up (–rm) 指在容器运行完之后自动清除，<em>注意：–rm 和 -d不能共用！</em></p></blockquote><p>再打开一个新的终端查看容器信息。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ docker container ls       </span><br><span class="line">CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES</span><br><span class="line">4f37d2e62181        busybox             <span class="string">"sh"</span>                48 seconds ago      Up 47 seconds                           busybox2</span><br><span class="line">98b27738599c        busybox             <span class="string">"sh"</span>                2 minutes ago       Up About a minute                       busybox1</span><br></pre></td></tr></table></figure><p>下面通过 <code>ping</code> 来证明 <code>busybox1</code> 容器和 <code>busybox2</code> 容器建立了互联关系。</p><p>在 <code>busybox1</code> 容器输入以下命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/ <span class="comment"># ping busybox2</span></span><br><span class="line">PING busybox2 (172.18.0.3): 56 data bytes</span><br><span class="line">64 bytes from 172.18.0.3: seq=0 ttl=64 time=0.115 ms</span><br><span class="line">64 bytes from 172.18.0.3: seq=1 ttl=64 time=0.138 ms</span><br><span class="line">64 bytes from 172.18.0.3: seq=2 ttl=64 time=0.139 ms</span><br><span class="line">64 bytes from 172.18.0.3: seq=3 ttl=64 time=0.137 ms</span><br><span class="line">64 bytes from 172.18.0.3: seq=4 ttl=64 time=0.138 ms</span><br><span class="line">64 bytes from 172.18.0.3: seq=5 ttl=64 time=0.138 ms</span><br><span class="line">64 bytes from 172.18.0.3: seq=6 ttl=64 time=0.133 ms</span><br></pre></td></tr></table></figure><p>用 ping 来测试连接 <code>busybox2</code> 容器，它会解析成 <code>172.18.0.3</code>。</p><p>同理在 <code>busybox2</code> 容器执行 <code>ping busybox1</code>，也会成功连接到。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/ <span class="comment"># ping busybox1</span></span><br><span class="line">PING busybox1 (172.18.0.2): 56 data bytes</span><br><span class="line">64 bytes from 172.18.0.2: seq=0 ttl=64 time=0.091 ms</span><br><span class="line">64 bytes from 172.18.0.2: seq=1 ttl=64 time=0.137 ms</span><br></pre></td></tr></table></figure><p>这样，<code>busybox1</code> 容器和 <code>busybox2</code> 容器建立了互联关系。</p><blockquote><p>如果有多个容器需要互相连接，推荐使用Docker Compose。</p></blockquote><blockquote><p><code>BusyBox</code> 是一个集成了一百多个最常用 Linux 命令和工具（如 <code>cat</code>、<code>echo</code>、<code>grep</code>、<code>mount</code>、<code>telnet</code> 等）的精简工具箱，它只需要几 MB 的大小，很方便进行各种快速验证，被誉为“Linux 系统的瑞士军刀”。</p><p><code>BusyBox</code> 可运行于多款 <code>POSIX</code> 环境的操作系统中，如 <code>Linux</code>（包括 <code>Android</code>）、<code>Hurd</code>、<code>FreeBSD</code> 等。</p></blockquote><h2 id="配置DNS"><a href="#配置DNS" class="headerlink" title="配置DNS"></a>配置DNS</h2><p>Docker 利用虚拟文件来挂载容器的 3 个相关配置文件。</p><p>在容器中使用 <code>mount</code> 命令可以看到挂载信息：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ mount</span><br><span class="line">/dev/disk/by-uuid/1fec...ebdf on /etc/hostname <span class="built_in">type</span> ext4 ...</span><br><span class="line">/dev/disk/by-uuid/1fec...ebdf on /etc/hosts <span class="built_in">type</span> ext4 ...</span><br><span class="line">tmpfs on /etc/resolv.conf <span class="built_in">type</span> tmpfs ...</span><br></pre></td></tr></table></figure><p>这种机制可以让宿主主机 DNS 信息发生更新后，所有 Docker 容器的 DNS 配置通过 <code>/etc/resolv.conf</code> 文件立刻得到更新。</p><p>配置全部容器的 DNS ，也可以在 <code>/etc/docker/daemon.json</code> 文件中增加以下内容来设置。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"dns"</span> : [</span><br><span class="line">    <span class="string">"114.114.114.114"</span>,</span><br><span class="line">    <span class="string">"8.8.8.8"</span></span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样每次启动的容器 DNS 自动配置为 <code>114.114.114.114</code> 和 <code>8.8.8.8</code>。使用以下命令来证明其已经生效。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -it --rm ubuntu:18.04  cat etc/resolv.conf</span><br><span class="line">nameserver 114.114.114.114</span><br><span class="line">nameserver 8.8.8.8</span><br></pre></td></tr></table></figure><p>如果用户想要手动指定容器的配置，可以在使用 <code>docker run</code> 命令启动容器时加入如下参数：</p><blockquote><p><code>-h HOSTNAME</code> 或者 <code>--hostname=HOSTNAME</code> 设定容器的主机名，它会被写到容器内的 <code>/etc/hostname</code> 和 <code>/etc/hosts</code>。但它在容器外部看不到，既不会在 <code>docker container ls</code> 中显示，也不会在其他的容器的 <code>/etc/hosts</code> 看到。</p><p><code>--dns=IP_ADDRESS</code> 添加 DNS 服务器到容器的 <code>/etc/resolv.conf</code> 中，让容器用这个服务器来解析所有不在 <code>/etc/hosts</code> 中的主机名。</p><p><code>--dns-search=DOMAIN</code> 设定容器的搜索域，当设定搜索域为 <code>.example.com</code> 时，在搜索一个名为 host 的主机时，DNS 不仅搜索 host，还会搜索 <code>host.example.com</code>。</p><p>注意：如果在容器启动时没有指定最后两个参数，Docker 会默认用主机上的<code>/etc/resolv.conf</code> 来配置容器。</p></blockquote><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p>Docker 官网：<a href="https://www.docker.com/" target="_blank" rel="noopener">https://www.docker.com</a></p><p>Github Docker 源码：<a href="https://github.com/docker/docker-ce" target="_blank" rel="noopener">https://github.com/docker/docker-ce</a></p><p>Docker命令大全：<a href="https://www.runoob.com/docker/docker-command-manual.html" target="_blank" rel="noopener">https://www.runoob.com/docker/docker-command-manual.html</a></p><p>本文章摘抄于：<a href="https://yeasy.gitbooks.io/docker_practice/content/" target="_blank" rel="noopener">https://yeasy.gitbooks.io/docker_practice/content/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Docker容器简介&quot;&gt;&lt;a href=&quot;#Docker容器简介&quot; class=&quot;headerlink&quot; title=&quot;Docker容器简介&quot;&gt;&lt;/a&gt;Docker容器简介&lt;/h1&gt;&lt;p&gt;容器是 Docker 是一核心概念。&lt;/p&gt;
&lt;p&gt;简单的说，容器是独立运行的一个或一组应用，以及它们的运行态环境。对应的，虚拟机可以理解为模拟运行的一整套操作系统（提供了运行态环境和其他系统环境）和跑在上面的应用。&lt;/p&gt;
    
    </summary>
    
      <category term="Docker" scheme="http://hackycy.github.io/categories/Docker/"/>
    
    
      <category term="Docker" scheme="http://hackycy.github.io/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>Docker入门（一）——基本概念与安装</title>
    <link href="http://hackycy.github.io/2019/11/27/Docker%E5%85%A5%E9%97%A8%EF%BC%88%E4%B8%80%EF%BC%89%E2%80%94%E2%80%94%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E4%B8%8E%E5%AE%89%E8%A3%85/"/>
    <id>http://hackycy.github.io/2019/11/27/Docker入门（一）——基本概念与安装/</id>
    <published>2019-11-27T09:35:51.000Z</published>
    <updated>2019-12-15T08:59:36.010Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Docker简介"><a href="#Docker简介" class="headerlink" title="Docker简介"></a>Docker简介</h1><p>Docker 是一个开源的应用容器引擎，基于 <a href="https://www.runoob.com/go/go-tutorial.html" target="_blank" rel="noopener">Go 语言</a> 并遵从 Apache2.0 协议开源。</p><p>Docker 可以让开发者打包他们的应用以及依赖包到一个轻量级、可移植的容器中，然后发布到任何流行的 Linux 机器上，也可以实现虚拟化。</p><p>容器是完全使用沙箱机制，相互之间不会有任何接口（类似 iPhone 的 app）,更重要的是容器性能开销极低。</p><p>Docker 从 17.03 版本之后分为 CE（Community Edition: 社区版） 和 EE（Enterprise Edition: 企业版）</p><a id="more"></a><p>Docker 使用 <code>Google</code> 公司推出的 <a href="https://golang.org/" target="_blank" rel="noopener">Go 语言</a> 进行开发实现，基于 <code>Linux</code> 内核的 <a href="https://zh.wikipedia.org/wiki/Cgroups" target="_blank" rel="noopener">cgroup</a>，<a href="https://en.wikipedia.org/wiki/Linux_namespaces" target="_blank" rel="noopener">namespace</a>，以及 <a href="https://en.wikipedia.org/wiki/Aufs" target="_blank" rel="noopener">AUFS</a> 类的 <a href="https://en.wikipedia.org/wiki/Union_mount" target="_blank" rel="noopener">Union FS</a> 等技术，对进程进行封装隔离，属于 <a href="https://en.wikipedia.org/wiki/Operating-system-level_virtualization" target="_blank" rel="noopener">操作系统层面的虚拟化技术</a>。由于隔离的进程独立于宿主和其它的隔离的进程，因此也称其为容器。最初实现是基于 <a href="https://linuxcontainers.org/lxc/introduction/" target="_blank" rel="noopener">LXC</a>，从 0.7 版本以后开始去除 <code>LXC</code>，转而使用自行开发的 <a href="https://github.com/docker/libcontainer" target="_blank" rel="noopener">libcontainer</a>，从 1.11 开始，则进一步演进为使用 <a href="https://github.com/opencontainers/runc" target="_blank" rel="noopener">runC</a> 和 <a href="https://github.com/containerd/containerd" target="_blank" rel="noopener">containerd</a>。</p><p><img src="docker-on-linux.png" alt></p><blockquote><p><code>runc</code> 是一个 Linux 命令行工具，用于根据 <a href="https://github.com/opencontainers/runtime-spec" target="_blank" rel="noopener">OCI容器运行时规范</a> 创建和运行容器。</p><p><code>containerd</code> 是一个守护程序，它管理容器生命周期，提供了在一个节点上执行容器和管理镜像的最小功能集。</p></blockquote><p>Docker在容器的基础上，进行了进一步的封装，从文件系统、网络互联到进程隔离等等，极大的简化了容器的创建和维护。使得 <code>Docker</code> 技术比虚拟机技术更为轻便、快捷。</p><p>下面的图片比较了 <strong>Docker</strong> 和传统虚拟化方式的不同之处。传统虚拟机技术是虚拟出一套硬件后，在其上运行一个完整操作系统，在该系统上再运行所需应用进程；而容器内的应用进程直接运行于宿主的内核，容器内没有自己的内核，而且也没有进行硬件虚拟。因此容器要比传统虚拟机更为轻便。</p><p><img src="virtualization.png" alt></p><p><img src="docker.png" alt></p><h1 id="Docker优点"><a href="#Docker优点" class="headerlink" title="Docker优点"></a>Docker优点</h1><p> Docker 是一个用于开发，交付和运行应用程序的开放平台。Docker 使您能够将应用程序与基础架构分开，从而可以快速交付软件。借助 Docker，您可以与管理应用程序相同的方式来管理基础架构。通过利用 Docker 的方法来快速交付，测试和部署代码，您可以大大减少编写代码和在生产环境中运行代码之间的延迟。 </p><h2 id="快速，一致地交付您的应用程序"><a href="#快速，一致地交付您的应用程序" class="headerlink" title="快速，一致地交付您的应用程序"></a>快速，一致地交付您的应用程序</h2><p>Docker 允许开发人员使用您提供的应用程序或服务的本地容器在标准化环境中工作，从而简化了开发的生命周期。</p><p>容器非常适合持续集成和持续交付（CI / CD）工作流程，请考虑以下示例方案：</p><ul><li>您的开发人员在本地编写代码，并使用 Docker 容器与同事共享他们的工作。</li><li>他们使用 Docker 将其应用程序推送到测试环境中，并执行自动或手动测试。</li><li>当开发人员发现错误时，他们可以在开发环境中对其进行修复，然后将其重新部署到测试环境中，以进行测试和验证。</li><li>测试完成后，将修补程序推送给生产环境，就像将更新的镜像推送到生产环境一样简单。</li></ul><h2 id="响应式部署和扩展"><a href="#响应式部署和扩展" class="headerlink" title="响应式部署和扩展"></a>响应式部署和扩展</h2><p>Docker 是基于容器的平台，允许高度可移植的工作负载。Docker 容器可以在开发人员的本机上，数据中心的物理或虚拟机上，云服务上或混合环境中运行。</p><p>Docker 的可移植性和轻量级的特性，还可以使您轻松地完成动态管理的工作负担，并根据业务需求指示，实时扩展或拆除应用程序和服务。</p><h2 id="更轻松的维护和扩展"><a href="#更轻松的维护和扩展" class="headerlink" title="更轻松的维护和扩展"></a>更轻松的维护和扩展</h2><p> Docker 使用的分层存储以及镜像的技术，使得应用重复部分的复用更为容易，也使得应用的维护更新更加简单，基于基础镜像进一步扩展镜像也变得非常简单。此外，<code>Docker</code> 团队同各个开源项目团队一起维护了一大批高质量的 <a href="https://hub.docker.com/search/?type=image&amp;image_filter=official" target="_blank" rel="noopener">官方镜像</a>，既可以直接在生产环境使用，又可以作为基础进一步定制，大大的降低了应用服务的镜像制作成本。 </p><h2 id="在同一硬件上运行更多工作负载"><a href="#在同一硬件上运行更多工作负载" class="headerlink" title="在同一硬件上运行更多工作负载"></a>在同一硬件上运行更多工作负载</h2><p> Docker 轻巧快速。它为基于虚拟机管理程序的虚拟机提供了可行、经济、高效的替代方案，因此您可以利用更多的计算能力来实现业务目标。Docker 非常适合于高密度环境以及中小型部署，而您可以用更少的资源做更多的事情。 </p><h2 id="对比传统虚拟机总结"><a href="#对比传统虚拟机总结" class="headerlink" title="对比传统虚拟机总结"></a>对比传统虚拟机总结</h2><table><thead><tr><th style="text-align:left">特性</th><th style="text-align:left">容器</th><th style="text-align:left">虚拟机</th></tr></thead><tbody><tr><td style="text-align:left">启动</td><td style="text-align:left">秒级</td><td style="text-align:left">分钟级</td></tr><tr><td style="text-align:left">硬盘使用</td><td style="text-align:left">一般为 <code>MB</code></td><td style="text-align:left">一般为 <code>GB</code></td></tr><tr><td style="text-align:left">性能</td><td style="text-align:left">接近原生</td><td style="text-align:left">弱于</td></tr><tr><td style="text-align:left">系统支持量</td><td style="text-align:left">单机支持上千个容器</td><td style="text-align:left">一般几十个</td></tr></tbody></table><h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><p>Docker 包括三个基本概念</p><ul><li>镜像（<code>Image</code>）</li><li>容器（<code>Container</code>）</li><li>仓库（<code>Repository</code>）</li></ul><h2 id="镜像"><a href="#镜像" class="headerlink" title="镜像"></a>镜像</h2><p>我们都知道，操作系统分为内核和用户空间。对于 Linux 而言，内核启动后，会挂载 <code>root</code> 文件系统为其提供用户空间支持。而 Docker 镜像（Image），就相当于是一个 <code>root</code> 文件系统。比如官方镜像 <code>ubuntu:18.04</code> 就包含了完整的一套 Ubuntu 18.04 最小系统的 <code>root</code> 文件系统。</p><p>Docker 镜像是一个特殊的文件系统，除了提供容器运行时所需的程序、库、资源、配置等文件外，还包含了一些为运行时准备的一些配置参数（如匿名卷、环境变量、用户等）。镜像不包含任何动态数据，其内容在构建之后也不会被改变。</p><h3 id="分层存储"><a href="#分层存储" class="headerlink" title="分层存储"></a>分层存储</h3><p>因为镜像包含操作系统完整的 <code>root</code> 文件系统，其体积往往是庞大的，因此在 Docker 设计时，就充分利用 <a href="https://en.wikipedia.org/wiki/Union_mount" target="_blank" rel="noopener">Union FS</a> 的技术，将其设计为分层存储的架构。所以严格来说，镜像并非是像一个 ISO 那样的打包文件，镜像只是一个虚拟的概念，其实际体现并非由一个文件组成，而是由一组文件系统组成，或者说，由多层文件系统联合组成。</p><p>镜像构建时，会一层层构建，前一层是后一层的基础。每一层构建完就不会再发生改变，后一层上的任何改变只发生在自己这一层。比如，删除前一层文件的操作，实际不是真的删除前一层的文件，而是仅在当前层标记为该文件已删除。在最终容器运行的时候，虽然不会看到这个文件，但是实际上该文件会一直跟随镜像。因此，在构建镜像的时候，需要额外小心，每一层尽量只包含该层需要添加的东西，任何额外的东西应该在该层构建结束前清理掉。</p><p>分层存储的特征还使得镜像的复用、定制变的更为容易。甚至可以用之前构建好的镜像作为基础层，然后进一步添加新的层，以定制自己所需的内容，构建新的镜像。</p><p>关于镜像构建，将会在后续相关章节中做进一步的讲解。</p><h2 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h2><p>镜像（<code>Image</code>）和容器（<code>Container</code>）的关系，就像是面向对象程序设计中的 <code>类</code> 和 <code>实例</code> 一样，镜像是静态的定义，容器是镜像运行时的实体。容器可以被创建、启动、停止、删除、暂停等。</p><p>容器的实质是进程，但与直接在宿主执行的进程不同，容器进程运行于属于自己的独立的 <a href="https://en.wikipedia.org/wiki/Linux_namespaces" target="_blank" rel="noopener">命名空间</a>。因此容器可以拥有自己的 <code>root</code> 文件系统、自己的网络配置、自己的进程空间，甚至自己的用户 ID 空间。容器内的进程是运行在一个隔离的环境里，使用起来，就好像是在一个独立于宿主的系统下操作一样。这种特性使得容器封装的应用比直接在宿主运行更加安全。也因为这种隔离的特性，很多人初学 Docker 时常常会混淆容器和虚拟机。</p><p>前面讲过镜像使用的是分层存储，容器也是如此。每一个容器运行时，是以镜像为基础层，在其上创建一个当前容器的存储层，我们可以称这个为容器运行时读写而准备的存储层为 <strong>容器存储层</strong>。</p><p>容器存储层的生存周期和容器一样，容器消亡时，容器存储层也随之消亡。因此，任何保存于容器存储层的信息都会随容器删除而丢失。</p><p>按照 Docker 最佳实践的要求，容器不应该向其存储层内写入任何数据，容器存储层要保持无状态化。所有的文件写入操作，都应该使用 <strong>数据卷（Volume）</strong>、或者绑定宿主目录，在这些位置的读写会跳过容器存储层，直接对宿主（或网络存储）发生读写，其性能和稳定性更高。</p><p>数据卷的生存周期独立于容器，容器消亡，数据卷不会消亡。因此，使用数据卷后，容器删除或者重新运行之后，数据却不会丢失。</p><h2 id="仓库"><a href="#仓库" class="headerlink" title="仓库"></a>仓库</h2><h3 id="Docker-Registry"><a href="#Docker-Registry" class="headerlink" title="Docker Registry"></a>Docker Registry</h3><p>镜像构建完成后，可以很容易的在当前宿主机上运行，但是，如果需要在其它服务器上使用这个镜像，我们就需要一个集中的存储、分发镜像的服务，<a href="https://yeasy.gitbooks.io/docker_practice/content/repository/registry.html" target="_blank" rel="noopener">Docker Registry</a> 就是这样的服务。</p><p>一个 <strong>Docker Registry</strong> 中可以包含多个 <strong>仓库</strong>（<code>Repository</code>）；每个仓库可以包含多个 <strong>标签</strong>（<code>Tag</code>）；每个标签对应一个镜像。</p><p>通常，一个仓库会包含同一个软件不同版本的镜像，而标签就常用于对应该软件的各个版本。我们可以通过 <code>&lt;仓库名&gt;:&lt;标签&gt;</code> 的格式来指定具体是这个软件哪个版本的镜像。如果不给出标签，将以 <code>latest</code> 作为默认标签。</p><p>以 <a href="https://hub.docker.com/_/ubuntu" target="_blank" rel="noopener">Ubuntu 镜像</a> 为例，<code>ubuntu</code> 是仓库的名字，其内包含有不同的版本标签，如，<code>16.04</code>, <code>18.04</code>。我们可以通过 <code>ubuntu:16.04</code>，或者 <code>ubuntu:18.04</code> 来具体指定所需哪个版本的镜像。如果忽略了标签，比如 <code>ubuntu</code>，那将视为 <code>ubuntu:latest</code>。</p><p>仓库名经常以 <em>两段式路径</em> 形式出现，比如 <code>jwilder/nginx-proxy</code>，前者往往意味着 Docker Registry 多用户环境下的用户名，后者则往往是对应的软件名。但这并非绝对，取决于所使用的具体 Docker Registry 的软件或服务。</p><h3 id="Docker-Registry-公开服务"><a href="#Docker-Registry-公开服务" class="headerlink" title="Docker Registry 公开服务"></a>Docker Registry 公开服务</h3><p>Docker Registry 公开服务是开放给用户使用、允许用户管理镜像的 Registry 服务。一般这类公开服务允许用户免费上传、下载公开的镜像，并可能提供收费服务供用户管理私有镜像。</p><p>最常使用的 Registry 公开服务是官方的 <a href="https://hub.docker.com/" target="_blank" rel="noopener">Docker Hub</a>，这也是默认的 Registry，并拥有大量的高质量的官方镜像。除此以外，还有 <a href="https://coreos.com/" target="_blank" rel="noopener">CoreOS</a> 的 <a href="https://quay.io/repository/" target="_blank" rel="noopener">Quay.io</a>，CoreOS 相关的镜像存储在这里；Google 的 <a href="https://cloud.google.com/container-registry/" target="_blank" rel="noopener">Google Container Registry</a>，<a href="https://kubernetes.io/" target="_blank" rel="noopener">Kubernetes</a> 的镜像使用的就是这个服务。</p><p>由于某些原因，在国内访问这些服务可能会比较慢。国内的一些云服务商提供了针对 Docker Hub 的镜像服务（<code>Registry Mirror</code>），这些镜像服务被称为<strong>加速器</strong>。常见的有 <a href="https://cr.console.aliyun.com/#/accelerator" target="_blank" rel="noopener">阿里云加速器</a>、<a href="https://www.daocloud.io/mirror#accelerator-doc" target="_blank" rel="noopener">DaoCloud 加速器</a> 等。使用加速器会直接从国内的地址下载 Docker Hub 的镜像，比直接从 Docker Hub 下载速度会提高很多。</p><p>国内也有一些云服务商提供类似于 Docker Hub 的公开服务。比如 <a href="https://hub.tenxcloud.com/" target="_blank" rel="noopener">时速云镜像仓库</a>、<a href="https://c.163.com/hub#/m/library/" target="_blank" rel="noopener">网易云镜像服务</a>、<a href="https://hub.daocloud.io/" target="_blank" rel="noopener">DaoCloud 镜像市场</a>、<a href="https://cr.console.aliyun.com/" target="_blank" rel="noopener">阿里云镜像库</a> 等。</p><h3 id="私有-Docker-Registry"><a href="#私有-Docker-Registry" class="headerlink" title="私有 Docker Registry"></a>私有 Docker Registry</h3><p>除了使用公开服务外，用户还可以在本地搭建私有 Docker Registry。Docker 官方提供了 <a href="https://hub.docker.com/_/registry/" target="_blank" rel="noopener">Docker Registry</a> 镜像，可以直接使用做为私有 Registry 服务。在 <a href="https://yeasy.gitbooks.io/docker_practice/content/repository/registry.html" target="_blank" rel="noopener">私有仓库</a> 一节中，会有进一步的搭建私有 Registry 服务的讲解。</p><p>开源的 Docker Registry 镜像只提供了 <a href="https://docs.docker.com/registry/spec/api/" target="_blank" rel="noopener">Docker Registry API</a> 的服务端实现，足以支持 <code>docker</code> 命令，不影响使用。但不包含图形界面，以及镜像维护、用户管理、访问控制等高级功能。在官方的商业化版本 <a href="https://docs.docker.com/datacenter/dtr/2.0/" target="_blank" rel="noopener">Docker Trusted Registry</a> 中，提供了这些高级功能。</p><p>除了官方的 Docker Registry 外，还有第三方软件实现了 Docker Registry API，甚至提供了用户界面以及一些高级功能。比如，<a href="https://github.com/goharbor/harbor" target="_blank" rel="noopener">Harbor</a> 和 <a href="https://yeasy.gitbooks.io/docker_practice/content/repository/nexus3_registry.html" target="_blank" rel="noopener">Sonatype Nexus</a>。</p><h1 id="Docker安装"><a href="#Docker安装" class="headerlink" title="Docker安装"></a>Docker安装</h1><p>Docker 分为 CE 和 EE 两大版本。CE 即社区版（免费，支持周期 7 个月），EE 即企业版，强调安全，付费使用，支持周期 24 个月。</p><p>Docker CE 分为 <code>stable</code> <code>test</code> 和 <code>nightly</code> 三个更新频道。每六个月发布一个 <code>stable</code> 版本 (<code>18.09</code>, <code>19.03</code>, <code>19.09</code>…)。</p><p>官方网站上有各种环境下的 <a href="https://docs.docker.com/install/" target="_blank" rel="noopener">安装指南</a>，这里主要介绍 Docker CE 在 <code>Linux</code> 、 <code>macOS</code> 上的安装。</p><h2 id="Linux—CentOS"><a href="#Linux—CentOS" class="headerlink" title="Linux—CentOS"></a>Linux—CentOS</h2><h3 id="系统要求"><a href="#系统要求" class="headerlink" title="系统要求"></a>系统要求</h3><p> Docker CE 支持 64 位版本 CentOS 7，并且要求内核版本不低于 3.10。 CentOS 7 满足最低内核的要求，但由于内核版本比较低，部分功能（如 <code>overlay2</code> 存储层驱动）无法使用，并且部分功能可能不太稳定。 </p><h3 id="卸载旧版本"><a href="#卸载旧版本" class="headerlink" title="卸载旧版本"></a>卸载旧版本</h3><p> 旧版本的 Docker 称为 <code>docker</code> 或者 <code>docker-engine</code>，使用以下命令卸载旧版本： </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ sudo yum remove docker \</span><br><span class="line">                  docker-client \</span><br><span class="line">                  docker-client-latest \</span><br><span class="line">                  docker-common \</span><br><span class="line">                  docker-latest \</span><br><span class="line">                  docker-latest-logrotate \</span><br><span class="line">                  docker-logrotate \</span><br><span class="line">                  docker-selinux \</span><br><span class="line">                  docker-engine-selinux \</span><br><span class="line">                  docker-engine</span><br></pre></td></tr></table></figure><h3 id="使用yum安装"><a href="#使用yum安装" class="headerlink" title="使用yum安装"></a>使用yum安装</h3><p> 执行以下命令安装依赖包： </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ sudo yum install -y yum-utils \</span><br><span class="line">           device-mapper-persistent-data \</span><br><span class="line">           lvm2</span><br></pre></td></tr></table></figure><p>鉴于国内网络问题，强烈建议使用国内源，官方源请在注释中查看。</p><p>执行下面的命令添加 <code>yum</code> 软件源：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ sudo yum-config-manager \</span><br><span class="line">    --add-repo \</span><br><span class="line">    https://mirrors.ustc.edu.cn/docker-ce/linux/centos/docker-ce.repo</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 官方源</span></span><br><span class="line"><span class="comment"># $ sudo yum-config-manager \</span></span><br><span class="line"><span class="comment">#     --add-repo \</span></span><br><span class="line"><span class="comment">#     https://download.docker.com/linux/centos/docker-ce.repo</span></span><br></pre></td></tr></table></figure><blockquote><p> 如果需要测试版本的 Docker CE 请使用以下命令： </p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo yum-config-manager --<span class="built_in">enable</span> docker-ce-test</span><br></pre></td></tr></table></figure><blockquote><p> 如果需要每日构建版本的 Docker CE 请使用以下命令： </p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo yum-config-manager --<span class="built_in">enable</span> docker-ce-nightly</span><br></pre></td></tr></table></figure><h3 id="安装Docker-CE"><a href="#安装Docker-CE" class="headerlink" title="安装Docker CE"></a>安装Docker CE</h3><p> 更新 <code>yum</code> 软件源缓存，并安装 <code>docker-ce</code>。 </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo yum makecache fast</span><br><span class="line">$ sudo yum install docker-ce</span><br></pre></td></tr></table></figure><h3 id="使用脚本自动安装"><a href="#使用脚本自动安装" class="headerlink" title="使用脚本自动安装"></a>使用脚本自动安装</h3><p> 在测试或开发环境中 Docker 官方为了简化安装流程，提供了一套便捷的安装脚本，CentOS 系统上可以使用这套脚本安装，另外可以通过 <code>--mirror</code> 选项使用国内源进行安装： </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ curl -fsSL get.docker.com -o get-docker.sh</span><br><span class="line">$ sudo sh get-docker.sh --mirror Aliyun</span><br><span class="line"><span class="comment"># $ sudo sh get-docker.sh --mirror AzureChinaCloud</span></span><br></pre></td></tr></table></figure><p> 执行这个命令后，脚本就会自动的将一切准备工作做好，并且把 Docker CE 的稳定(stable)版本安装在系统中。 </p><h3 id="启动Docker"><a href="#启动Docker" class="headerlink" title="启动Docker"></a>启动Docker</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo systemctl <span class="built_in">enable</span> docker</span><br><span class="line">$ sudo systemctl start docker</span><br></pre></td></tr></table></figure><h3 id="建立-docker-用户组"><a href="#建立-docker-用户组" class="headerlink" title="建立 docker 用户组"></a>建立 docker 用户组</h3><p>默认情况下，<code>docker</code> 命令会使用 <a href="https://en.wikipedia.org/wiki/Unix_domain_socket" target="_blank" rel="noopener">Unix socket</a> 与 Docker 引擎通讯。而只有 <code>root</code> 用户和 <code>docker</code> 组的用户才可以访问 Docker 引擎的 Unix socket。出于安全考虑，一般 Linux 系统上不会直接使用 <code>root</code> 用户。因此，更好地做法是将需要使用 <code>docker</code> 的用户加入 <code>docker</code> 用户组。</p><p>建立 <code>docker</code> 组：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo groupadd docker</span><br></pre></td></tr></table></figure><p> 将当前用户加入 <code>docker</code> 组： </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo usermod -aG docker <span class="variable">$USER</span></span><br></pre></td></tr></table></figure><p> 退出当前终端并重新登录，进行如下测试。 </p><h3 id="测试-Docker-是否安装正确"><a href="#测试-Docker-是否安装正确" class="headerlink" title="测试 Docker 是否安装正确"></a>测试 Docker 是否安装正确</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">$ docker run hello-world</span><br><span class="line"></span><br><span class="line">Unable to find image <span class="string">'hello-world:latest'</span> locally</span><br><span class="line">latest: Pulling from library/hello-world</span><br><span class="line">d1725b59e92d: Pull complete</span><br><span class="line">Digest: sha256:0add3ace90ecb4adbf7777e9aacf18357296e799f81cabc9fde470971e499788</span><br><span class="line">Status: Downloaded newer image <span class="keyword">for</span> hello-world:latest</span><br><span class="line"></span><br><span class="line">Hello from Docker!</span><br><span class="line">This message shows that your installation appears to be working correctly.</span><br><span class="line"></span><br><span class="line">To generate this message, Docker took the following steps:</span><br><span class="line"> 1. The Docker client contacted the Docker daemon.</span><br><span class="line"> 2. The Docker daemon pulled the <span class="string">"hello-world"</span> image from the Docker Hub.</span><br><span class="line">    (amd64)</span><br><span class="line"> 3. The Docker daemon created a new container from that image <span class="built_in">which</span> runs the</span><br><span class="line">    executable that produces the output you are currently reading.</span><br><span class="line"> 4. The Docker daemon streamed that output to the Docker client, <span class="built_in">which</span> sent it</span><br><span class="line">    to your terminal.</span><br><span class="line"></span><br><span class="line">To try something more ambitious, you can run an Ubuntu container with:</span><br><span class="line"> $ docker run -it ubuntu bash</span><br><span class="line"></span><br><span class="line">Share images, automate workflows, and more with a free Docker ID:</span><br><span class="line"> https://hub.docker.com/</span><br><span class="line"></span><br><span class="line">For more examples and ideas, visit:</span><br><span class="line"> https://docs.docker.com/get-started/</span><br></pre></td></tr></table></figure><p> 若能正常输出以上信息，则说明安装成功。 </p><blockquote><p>个人作为开发者，建议直接使用宝塔进行安装，bt.cn安装后可以查看软件商店找到docker直接进行安装。对于开发者而言更加方便使用。</p></blockquote><h2 id="macOS"><a href="#macOS" class="headerlink" title="macOS"></a>macOS</h2><h3 id="系统要求-1"><a href="#系统要求-1" class="headerlink" title="系统要求"></a>系统要求</h3><p> <a href="https://docs.docker.com/docker-for-mac/" target="_blank" rel="noopener">Docker Desktop for Mac</a> 要求系统最低为 macOS Sierra 10.12。 </p><h3 id="Homebrew-安装"><a href="#Homebrew-安装" class="headerlink" title="Homebrew 安装"></a>Homebrew 安装</h3><p> <a href="https://brew.sh/" target="_blank" rel="noopener">Homebrew</a> 的 <a href="https://caskroom.github.io/" target="_blank" rel="noopener">Cask</a> 已经支持 Docker Desktop for Mac，因此可以很方便的使用 Homebrew Cask 来进行安装： </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ brew cask install docker</span><br></pre></td></tr></table></figure><h3 id="手动下载安装"><a href="#手动下载安装" class="headerlink" title="手动下载安装"></a>手动下载安装</h3><p> <a href="https://hub.docker.com/editions/community/docker-ce-desktop-mac" target="_blank" rel="noopener">https://hub.docker.com/editions/community/docker-ce-desktop-mac</a> </p><p><a href="https://docs.docker.com/toolbox/overview/" target="_blank" rel="noopener">https://docs.docker.com/toolbox/overview/</a></p><p>也可以点击以下链接直接下载 <a href="https://download.docker.com/mac/stable/Docker.dmg" target="_blank" rel="noopener">Stable</a> 或 <a href="https://download.docker.com/mac/edge/Docker.dmg" target="_blank" rel="noopener">Edge</a> 版本的 Docker Desktop for Mac。</p><blockquote><p>点击链接注册Docker ID即可下载。傻瓜式安装。安装后点击图标运行即可。</p><p>可关掉开机自启。preference -&gt; general -&gt; start Docker Desktop when you log in</p></blockquote><p>启动终端后，通过命令可以检查安装后的 Docker 版本。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ docker --version</span><br><span class="line">Docker version 19.03.5, build 633a0ea</span><br><span class="line">$ docker-compose --version</span><br><span class="line">docker-compose version 1.24.1, build 4667896b</span><br><span class="line">$ docker-machine --version</span><br><span class="line">docker-machine version 0.16.2, build bd45ab13</span><br></pre></td></tr></table></figure><h2 id="镜像加速器"><a href="#镜像加速器" class="headerlink" title="镜像加速器"></a>镜像加速器</h2><p>国内从 Docker Hub 拉取镜像有时会遇到困难，此时可以配置镜像加速器。国内很多云服务商都提供了国内加速器服务，例如：</p><ul><li><a href="https://github.com/Azure/container-service-for-azure-china/blob/master/aks/README.md#22-container-registry-proxy" target="_blank" rel="noopener">Azure 中国镜像 <code>https://dockerhub.azk8s.cn</code></a></li><li><a href="https://cr.console.aliyun.com/cn-hangzhou/mirrors" target="_blank" rel="noopener">阿里云加速器(需登录账号获取)</a></li><li><a href="https://kirk-enterprise.github.io/hub-docs/#/user-guide/mirror" target="_blank" rel="noopener">七牛云加速器 <code>https://reg-mirror.qiniu.com</code></a></li></ul><blockquote><p>由于镜像服务可能出现宕机，建议同时配置多个镜像。</p><p>国内各大云服务商均提供了 Docker 镜像加速服务，建议根据运行 Docker 的云平台选择对应的镜像加速服务，具体请参考官方文档。</p></blockquote><p>这里以 Azure 中国镜像 <code>https://dockerhub.azk8s.cn</code> 为例进行介绍。</p><h3 id="Ubuntu-16-04-、Debian-8-、CentOS-7"><a href="#Ubuntu-16-04-、Debian-8-、CentOS-7" class="headerlink" title="Ubuntu 16.04+、Debian 8+、CentOS 7"></a>Ubuntu 16.04+、Debian 8+、CentOS 7</h3><p> 对于使用 <a href="https://www.freedesktop.org/wiki/Software/systemd/" target="_blank" rel="noopener">systemd</a> 的系统，请在 <code>/etc/docker/daemon.json</code> 中写入如下内容（如果文件不存在请新建该文件） </p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"registry-mirrors"</span>: [</span><br><span class="line">    <span class="string">"https://dockerhub.azk8s.cn"</span>,</span><br><span class="line">    <span class="string">"https://reg-mirror.qiniu.com"</span></span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p> 注意，一定要保证该文件符合 json 规范，否则 Docker 将不能启动。 </p></blockquote><p> 之后重新启动服务。 </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo systemctl daemon-reload</span><br><span class="line">$ sudo systemctl restart docker</span><br></pre></td></tr></table></figure><blockquote><p> 注意：如果您之前查看旧教程，修改了 <code>docker.service</code> 文件内容，请去掉您添加的内容（<code>--registry-mirror=https://dockerhub.azk8s.cn</code>）。 </p></blockquote><h3 id="macOS-1"><a href="#macOS-1" class="headerlink" title="macOS"></a>macOS</h3><p> 对于使用 macOS 的用户，在任务栏点击 Docker Desktop 应用图标 -&gt; <code>Perferences</code>，在左侧导航菜单选择 <code>Docker Engine</code>，在右侧像下边一样编辑 json 文件。修改完成之后，点击 <code>Apply &amp; Restart</code> 按钮，Docker 就会重启并应用配置的镜像地址了。 </p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"registry-mirrors"</span>: [</span><br><span class="line">    <span class="string">"https://dockerhub.azk8s.cn"</span>,</span><br><span class="line">    <span class="string">"https://reg-mirror.qiniu.com"</span></span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="检查加速器是否生效"><a href="#检查加速器是否生效" class="headerlink" title="检查加速器是否生效"></a>检查加速器是否生效</h3><p> 执行 <code>$ docker info</code>，如果从结果中看到了如下内容，说明配置成功。 </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Registry Mirrors:</span><br><span class="line"> https://dockerhub.azk8s.cn/</span><br></pre></td></tr></table></figure><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p>Docker 官网：<a href="https://www.docker.com/" target="_blank" rel="noopener">https://www.docker.com</a></p><p>Github Docker 源码：<a href="https://github.com/docker/docker-ce" target="_blank" rel="noopener">https://github.com/docker/docker-ce</a></p><p>Docker命令大全：<a href="https://www.runoob.com/docker/docker-command-manual.html" target="_blank" rel="noopener">https://www.runoob.com/docker/docker-command-manual.html</a></p><p>本文章摘抄于：<a href="https://yeasy.gitbooks.io/docker_practice/content/" target="_blank" rel="noopener">https://yeasy.gitbooks.io/docker_practice/content/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Docker简介&quot;&gt;&lt;a href=&quot;#Docker简介&quot; class=&quot;headerlink&quot; title=&quot;Docker简介&quot;&gt;&lt;/a&gt;Docker简介&lt;/h1&gt;&lt;p&gt;Docker 是一个开源的应用容器引擎，基于 &lt;a href=&quot;https://www.runoob.com/go/go-tutorial.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Go 语言&lt;/a&gt; 并遵从 Apache2.0 协议开源。&lt;/p&gt;
&lt;p&gt;Docker 可以让开发者打包他们的应用以及依赖包到一个轻量级、可移植的容器中，然后发布到任何流行的 Linux 机器上，也可以实现虚拟化。&lt;/p&gt;
&lt;p&gt;容器是完全使用沙箱机制，相互之间不会有任何接口（类似 iPhone 的 app）,更重要的是容器性能开销极低。&lt;/p&gt;
&lt;p&gt;Docker 从 17.03 版本之后分为 CE（Community Edition: 社区版） 和 EE（Enterprise Edition: 企业版）&lt;/p&gt;
    
    </summary>
    
      <category term="Docker" scheme="http://hackycy.github.io/categories/Docker/"/>
    
    
      <category term="Docker" scheme="http://hackycy.github.io/tags/Docker/"/>
    
  </entry>
  
</feed>
