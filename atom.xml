<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>思忆技术</title>
  
  <subtitle>思忆，分享技术</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://hackycy.github.io/"/>
  <updated>2020-02-03T06:17:34.219Z</updated>
  <id>http://hackycy.github.io/</id>
  
  <author>
    <name>hackycy</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>重学Android之Handler</title>
    <link href="http://hackycy.github.io/2020/02/02/%E9%87%8D%E5%AD%A6Android%E4%B9%8BHandler/"/>
    <id>http://hackycy.github.io/2020/02/02/重学Android之Handler/</id>
    <published>2020-02-02T06:09:03.000Z</published>
    <updated>2020-02-03T06:17:34.219Z</updated>
    
    <content type="html"><![CDATA[<p><code>Handler</code> 是 <code>Android</code> 开发过程中非常非常常见的东西。它通常被我们用来做主线程与子线程之间的通信工具，而 Handler 作为 Android 中消息机制的重要一员也确实给我们的开发带来了极大的便利。</p><a id="more"></a><h1 id="重识Handler"><a href="#重识Handler" class="headerlink" title="重识Handler"></a>重识Handler</h1><p>我们可以使用 Handler <strong>发送并处理</strong>与一个线程关联的 Message 和 Runnable 。（注意：<strong>Runnable 会被封装进一个 Message，所以它本质上还是一个 Message</strong> ）</p><p>每个 Handler 都会跟一个线程绑定，并与该线程的 MessageQueue 关联在一起，从而实现消息的管理以及线程间通信。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">android.os.Handler handler = <span class="keyword">new</span> Handler()&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(<span class="keyword">final</span> Message msg)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//这里接受并处理消息</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//发送消息</span></span><br><span class="line">handler.sendMessage(message);</span><br><span class="line">handler.post(runnable);</span><br></pre></td></tr></table></figure><p>实例化一个 Handler 重写 <code>handleMessage</code> 方法 ，然后在需要的时候调用它的 <code>send</code> 以及 <code>post</code> <strong>系列方法</strong>就可以了，非常简单易用，并且支持延时消息。</p><p><strong>一些常用的方法如下</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">sendMessage(Message msg)</span><br><span class="line">sendMessageDelayed(Message msg, <span class="keyword">long</span> uptimeMillis)</span><br><span class="line">post(Runnable r)</span><br><span class="line">postDelayed(Runnable r, <span class="keyword">long</span> uptimeMillis)</span><br><span class="line">sendMessageAtTime(Message msg,<span class="keyword">long</span> when)</span><br><span class="line">  </span><br><span class="line">sendEmptyMessage(<span class="keyword">int</span> what)</span><br><span class="line">sendEmptyMessageDelayed(<span class="keyword">int</span> what, <span class="keyword">long</span> uptimeMillis)</span><br><span class="line">sendEmptyMessageAtTime(<span class="keyword">int</span> what, <span class="keyword">long</span> when)</span><br></pre></td></tr></table></figure><h1 id="Looper、Handler、MessageQueue与Message的关系与相关概念"><a href="#Looper、Handler、MessageQueue与Message的关系与相关概念" class="headerlink" title="Looper、Handler、MessageQueue与Message的关系与相关概念"></a>Looper、Handler、MessageQueue与Message的关系与相关概念</h1><h2 id="Android消息处理机制"><a href="#Android消息处理机制" class="headerlink" title="Android消息处理机制"></a>Android消息处理机制</h2><p>什么是Android消息处理机制？</p><p><strong>“消息”</strong>是windows运行机制中一个基本而又重要的概念。<strong>消息</strong>是一个<strong>报告事件发生的通知</strong>，<strong>消息驱动</strong>是围绕消息的产生与处理展开的，并依靠<strong>消息循环机制</strong>来实现（百度百科）。与Windows系统一样，Android也是<strong>消息驱动型</strong>的系统。引用一下消息驱动机制的四要素：</p><ul><li><p>接收消息的“消息队列”</p></li><li><p>阻塞式地从消息队列中接收消息并进行处理的“线程”</p></li><li><p>可发送的“消息的格式”</p></li><li><p>“消息发送函数”</p></li></ul><p>与之对应，Android系统中对应实现了：</p><ul><li>接收消息的“消息队列” ——　<strong>MessageQueue</strong></li><li>阻塞式地从消息队列中接收消息并进行处理的“线程” ——　<strong>Thread+Looper</strong></li><li>可发送的“消息的格式” ——　<strong>Message</strong></li><li>“消息发送函数”——　<strong>Handler的post()和sendMessage()</strong></li></ul><p>Android有大量的消息驱动方式来进行交互，比如Android的四大组件——<strong>Activity, Service, Broadcast, ContentProvider</strong>的启动过程的交互，都离不开消息机制。</p><h2 id="Handler"><a href="#Handler" class="headerlink" title="Handler"></a>Handler</h2><p>Handler是Android消息机制的上层接口。<strong>Handler并不是专门用来更新UI的，只是开发者常常用它来更新UI</strong>。Handler的主要用于<strong>同一个进程间的线程通信</strong>，Handler用于更新UI的时候是<strong>“子线程与主线程通信”；当然，Handler也可以用于子线程之间通信。</strong></p><p>Handler的消息机制主要是就指“Handler的运行机制”，Handler的运行机制时需要底层的<strong>MessageQueue和Looper</strong>支持的。</p><h2 id="MessageQueue"><a href="#MessageQueue" class="headerlink" title="MessageQueue"></a>MessageQueue</h2><p>MessageQueue翻译过来是”消息队列”的意思，实际上它内部的数据结构不是队列，而是<strong>单向链表</strong>；MessageQueue中储存了大量的<strong>消息</strong>，由于<strong>一个线程同一时间只能处理一条消息，所以我们建了一个链表，将我们需要处理的消息按顺序储存起来，然后一项一项的交给需要的线程处理</strong>，这就是MessageQueue存在的价值。</p><h2 id="Looper"><a href="#Looper" class="headerlink" title="Looper"></a>Looper</h2><p>Looper和MessageQueue的消息就像水泵和井(里边装的是水)的关系一样，我们有了消息(水)，但是为了把水从井中抽取出来(循环起来)，我们得有一个水泵作为<strong>动力</strong>，这个动力就是Looper。</p><p>如果我们在一个线程中调用<code>Looper.prepare()...Looper.loop()</code>，那么你的线程就成功升级为了一个<strong>Looper线程</strong>，这意味着<strong>你的线程有了一个消息泵(Looper)和一个消息队列(MessageQueue),此时你就可以调用Handler来进行线程间的通信了。</strong></p><p>我们应用的UI线程也就是主线程，在应用启动的时候，系统会自动初始化一个Looper，也就是说，我们的UI线程默认是Looper线程。这也就是为什么主线程中直接调用Handler没什么事，但是再子线程中创建Handler需要手动调用<code>Looper.prepare()...Looper.loop()</code>的和原因。</p><h2 id="Message"><a href="#Message" class="headerlink" title="Message"></a>Message</h2><p>Message也就是消息，井中的水。一个Message包括了消息类型(what),消息内容(arg1,arg2),发送它的Handler(target),Runnable回调接口等：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span> what;        <span class="comment">//数据类型</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span> arg1;        <span class="comment">//简单的整数值</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span> arg2;        <span class="comment">//简单的整数值可以直接发送，是一种替代setData（Bundle）的低成本方案，更加省资源</span></span><br><span class="line"><span class="keyword">public</span> Object obj;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*package*/</span> <span class="keyword">int</span> flags;</span><br><span class="line"><span class="comment">/*package*/</span> <span class="keyword">long</span> when;          <span class="comment">//Handler发送一个消息之后，返回此消息的目标交付时间（以毫秒为单位）。</span></span><br><span class="line"><span class="comment">/*package*/</span> Bundle data;        <span class="comment">//Bundle可以携带更复杂的数据类型</span></span><br><span class="line"><span class="comment">/*package*/</span> Handler target;     <span class="comment">//哪个Handler发送的消息</span></span><br><span class="line"><span class="comment">/*package*/</span> Runnable callback;  <span class="comment">//回调方法</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//可以看到，Message带了一个指向一下个节点的链，也就是说，MessageQueue内部维护的实际上是一个链表</span></span><br><span class="line"><span class="comment">/*package*/</span> Message next;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object sPoolSync = <span class="keyword">new</span> Object();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Message sPool;       <span class="comment">//消息池</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> sPoolSize = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_POOL_SIZE = <span class="number">50</span>;    <span class="comment">//消息池的最大容量</span></span><br></pre></td></tr></table></figure><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>Handler 的背后有着 Looper 以及 MessageQueue 的协助，三者通力合作，分工明确。</p><ul><li><strong>Message</strong>：消息分为硬件产生的消息(如按钮、触摸)和软件生成的消息；</li><li><strong>MessageQueue</strong>：消息队列的主要功能向消息池投递消息(<code>MessageQueue.enqueueMessage</code>)和取走消息池的消息(<code>MessageQueue.next</code>)；</li><li><strong>Handler</strong>：消息辅助类，主要功能向消息池发送各种消息事件(<code>Handler.sendMessage</code>)和处理相应消息事件(<code>Handler.handleMessage</code>)；</li><li><strong>Looper</strong>：不断循环执行(<code>Looper.loop</code>)，按分发机制将消息分发给目标处理者。</li></ul><p>一张图来了解一下它们之间的关系：</p><p><img src="messagequene.png" alt></p><h1 id="Handler原理解析（Java层）"><a href="#Handler原理解析（Java层）" class="headerlink" title="Handler原理解析（Java层）"></a>Handler原理解析（Java层）</h1><p>来分析原理前，先明确一下问题：</p><ol><li><strong>Handler 是如何与线程关联的？</strong></li><li><strong>Handler 发出去的消息是谁管理的？</strong></li><li><strong>消息又是怎么回到 handleMessage() 方法的？</strong></li><li><strong>线程的切换是怎么回事？</strong></li></ol><p>带着问题去寻找答案。</p><h2 id="Handler与Looper的关联"><a href="#Handler与Looper的关联" class="headerlink" title="Handler与Looper的关联"></a>Handler与Looper的关联</h2><p>实例化 Handler 的时候 Handler 会去检查当前线程的 Looper 是否存在，如果不存在则会报异常，也就是说<strong>在创建 Handler 之前一定需要先创建 Looper</strong> 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Handler</span><span class="params">(@Nullable Callback callback, <span class="keyword">boolean</span> async)</span> </span>&#123;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">//检查当前的线程是否有 Looper</span></span><br><span class="line">mLooper = Looper.myLooper();</span><br><span class="line"><span class="keyword">if</span> (mLooper == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(</span><br><span class="line">                <span class="string">"Can't create handler inside thread "</span> + Thread.currentThread()</span><br><span class="line">                        + <span class="string">" that has not called Looper.prepare()"</span>);</span><br><span class="line">&#125;</span><br><span class="line">  <span class="comment">//Looper 持有一个 MessageQueue</span></span><br><span class="line">mQueue = mLooper.mQueue;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>这个异常可能有的不熟悉，因为平时直接使用感受不到这个异常是因为主线程已经为我们创建好了 Looper</p></blockquote><p>一个完整的 Handler 使用例子其实是这样的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LooperThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> Handler mHandler;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Looper.prepare();</span><br><span class="line">        mHandler = <span class="keyword">new</span> Handler() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">                <span class="comment">// process incoming messages here</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        Looper.loop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Looper.prepare()</strong></p><p>对于无参的情况，默认调用<code>prepare(true)</code>，表示的是这个Looper允许退出，而对于false的情况则表示当前Looper不允许退出。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">prepare</span><span class="params">()</span> </span>&#123;</span><br><span class="line">prepare(<span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">prepare</span><span class="params">(<span class="keyword">boolean</span> quitAllowed)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (sThreadLocal.get() != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Only one Looper may be created per thread"</span>);</span><br><span class="line">&#125;</span><br><span class="line">sThreadLocal.set(<span class="keyword">new</span> Looper(quitAllowed));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的<code>sThreadLocal</code>是ThreadLocal类型，下面，先说说ThreadLocal。</p><p><strong>ThreadLocal</strong>： 线程本地存储区（Thread Local Storage，简称为TLS），每个线程都有自己的私有的本地存储区域，不同线程之间彼此不能访问对方的TLS区域。</p><p>Looper类中其定义如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;Looper&gt; sThreadLocal = <span class="keyword">new</span> ThreadLocal&lt;Looper&gt;();</span><br></pre></td></tr></table></figure><p>可见<code>sThreadLocal</code>的get()和set()操作的类型都是<code>Looper</code>类型。</p><blockquote><p>另外，与prepare()相近功能的，还有一个<code>prepareMainLooper()</code>方法，该方法主要在ActivityThread类中使用。</p></blockquote><p>Looper 提供了 <code>Looper.prepare()</code> 方法来创建 Looper ，并且会<strong>借助 ThreadLocal 来实现与当前线程的绑定</strong>功能。<strong>Looper.loop() 则会开始不断尝试从 MessageQueue 中获取 Message , 并分发给对应的 Handler</strong></p><p><strong>也就是说 Handler 跟线程的关联是靠 Looper 来实现的。</strong></p><h2 id="Message-的发送"><a href="#Message-的发送" class="headerlink" title="Message 的发送"></a>Message 的发送</h2><p>发送消息调用链：</p><p><img src="java_sendmessage.png" alt></p><p>不管我们调用什么方法，最终都会走到 <code>MessageQueue.enqueueMessage(Message,long)</code> 方法。</p><p>例如<code>sendEmptyMessage</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">sendEmptyMessage</span><span class="params">(<span class="keyword">int</span> what)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> sendEmptyMessageDelayed(what, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// -&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">sendEmptyMessageDelayed</span><span class="params">(<span class="keyword">int</span> what, <span class="keyword">long</span> delayMillis)</span> </span>&#123;</span><br><span class="line">Message msg = Message.obtain();</span><br><span class="line">msg.what = what;</span><br><span class="line"><span class="keyword">return</span> sendMessageDelayed(msg, delayMillis);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// -&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">sendMessageDelayed</span><span class="params">(@NonNull Message msg, <span class="keyword">long</span> delayMillis)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (delayMillis &lt; <span class="number">0</span>) &#123;</span><br><span class="line">delayMillis = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> sendMessageAtTime(msg, SystemClock.uptimeMillis() + delayMillis);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// -&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">sendMessageAtTime</span><span class="params">(@NonNull Message msg, <span class="keyword">long</span> uptimeMillis)</span> </span>&#123;</span><br><span class="line">MessageQueue queue = mQueue;</span><br><span class="line"><span class="keyword">if</span> (queue == <span class="keyword">null</span>) &#123;</span><br><span class="line">RuntimeException e = <span class="keyword">new</span> RuntimeException(</span><br><span class="line">   <span class="keyword">this</span> + <span class="string">" sendMessageAtTime() called with no mQueue"</span>);</span><br><span class="line">Log.w(<span class="string">"Looper"</span>, e.getMessage(), e);</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> enqueueMessage(queue, msg, uptimeMillis);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Handler.sendEmptyMessage()</code>等系列方法最终调用<code>MessageQueue.enqueueMessage(msg, uptimeMillis)</code>，将消息添加到消息队列中，其中uptimeMillis为系统当前的运行时间，不包括休眠时间。</p><p><strong>enqueueMessage</strong></p><p>添加一条消息到消息队列</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">enqueueMessage</span><span class="params">(Message msg, <span class="keyword">long</span> when)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 每一个普通Message必须有一个target</span></span><br><span class="line">    <span class="keyword">if</span> (msg.target == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Message must have a target."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (msg.isInUse()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(msg + <span class="string">" This message is already in use."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mQuitting) &#123;  <span class="comment">//正在退出时，回收msg，加入到消息池</span></span><br><span class="line">            msg.recycle();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        msg.markInUse();</span><br><span class="line">        msg.when = when;</span><br><span class="line">        Message p = mMessages;</span><br><span class="line">        <span class="keyword">boolean</span> needWake;</span><br><span class="line">        <span class="keyword">if</span> (p == <span class="keyword">null</span> || when == <span class="number">0</span> || when &lt; p.when) &#123;</span><br><span class="line">            <span class="comment">//p为null(代表MessageQueue没有消息） 或者msg的触发时间是队列中最早的， 则进入该该分支</span></span><br><span class="line">            msg.next = p;</span><br><span class="line">            mMessages = msg;</span><br><span class="line">            needWake = mBlocked; <span class="comment">//当阻塞时需要唤醒</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//将消息按时间顺序插入到MessageQueue。一般地，不需要唤醒事件队列，除非</span></span><br><span class="line">            <span class="comment">//消息队头存在barrier，并且同时Message是队列中最早的异步消息。</span></span><br><span class="line">            needWake = mBlocked &amp;&amp; p.target == <span class="keyword">null</span> &amp;&amp; msg.isAsynchronous();</span><br><span class="line">            Message prev;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                prev = p;</span><br><span class="line">                p = p.next;</span><br><span class="line">                <span class="keyword">if</span> (p == <span class="keyword">null</span> || when &lt; p.when) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (needWake &amp;&amp; p.isAsynchronous()) &#123;</span><br><span class="line">                    needWake = <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            msg.next = p;</span><br><span class="line">            prev.next = msg;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//消息没有退出，我们认为此时mPtr != 0</span></span><br><span class="line">        <span class="keyword">if</span> (needWake) &#123;</span><br><span class="line">            nativeWake(mPtr);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>MessageQueue</code>是按照Message触发时间的先后顺序排列的，队头的消息是将要最早触发的消息。当有消息需要加入消息队列时，会从队列头开始遍历，直到找到消息应该插入的合适位置，以保证所有消息的时间顺序。</p><h2 id="Message的分发"><a href="#Message的分发" class="headerlink" title="Message的分发"></a>Message的分发</h2><p><code>Looper.loop()</code>方法来进行消息的分发：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Looper</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">loop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Looper me = myLooper(); <span class="comment">//获取TLS存储的Looper对象</span></span><br><span class="line">    <span class="keyword">if</span> (me == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"No Looper; Looper.prepare() wasn't called on this thread."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">final</span> MessageQueue queue = me.mQueue; <span class="comment">//获取Looper对象中的消息队列</span></span><br><span class="line">  </span><br><span class="line">  Binder.clearCallingIdentity();</span><br><span class="line">    <span class="comment">//确保在权限检查时基于本地进程，而不是调用进程。</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> ident = Binder.clearCallingIdentity();</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">       <span class="comment">// 不断从 MessageQueue 获取 消息</span></span><br><span class="line">        Message msg = queue.next(); <span class="comment">// might block</span></span><br><span class="line">        <span class="comment">//退出 Looper </span></span><br><span class="line">        <span class="keyword">if</span> (msg == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// No message indicates that the message queue is quitting.</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            msg.target.dispatchMessage(msg);</span><br><span class="line">            end = (slowDispatchThresholdMs == <span class="number">0</span>) ? <span class="number">0</span> : SystemClock.uptimeMillis();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//...</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">      <span class="comment">//恢复调用者信息</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> newIdent = Binder.clearCallingIdentity();</span><br><span class="line"><span class="comment">//回收 message</span></span><br><span class="line">        msg.recycleUnchecked();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>loop()进入循环模式，不断重复下面的操作，直到没有消息时退出循环</p><ul><li>读取MessageQueue的下一条Message；</li><li>把Message分发给相应的target；</li><li>再把分发后的Message回收到消息池，以便重复利用。</li></ul><p>这是这个消息处理的核心部分。另外，上面代码中可以看到有logging方法，这是用于debug的，默认情况下<code>logging == null</code>，通过设置setMessageLogging()用来开启debug工作。</p><p><code>loop()</code> 里调用了 <code>MessageQueue.next()</code> :</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Message <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> ptr = mPtr;</span><br><span class="line">    <span class="keyword">if</span> (ptr == <span class="number">0</span>) &#123; <span class="comment">//当消息循环已经退出，则直接返回</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> pendingIdleHandlerCount = -<span class="number">1</span>; <span class="comment">// 循环迭代的首次为-1</span></span><br><span class="line">    <span class="keyword">int</span> nextPollTimeoutMillis = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nextPollTimeoutMillis != <span class="number">0</span>) &#123;</span><br><span class="line">            Binder.flushPendingCommands();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//阻塞操作，当等待nextPollTimeoutMillis时长，或者消息队列被唤醒，都会返回</span></span><br><span class="line">        nativePollOnce(ptr, nextPollTimeoutMillis);</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">long</span> now = SystemClock.uptimeMillis();</span><br><span class="line">            Message prevMsg = <span class="keyword">null</span>;</span><br><span class="line">            Message msg = mMessages;</span><br><span class="line">            <span class="comment">//当消息的Handler为空时，则查询异步消息</span></span><br><span class="line">            <span class="keyword">if</span> (msg != <span class="keyword">null</span> &amp;&amp; msg.target == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">//当查询到异步消息，则立刻退出循环</span></span><br><span class="line">                <span class="keyword">do</span> &#123;</span><br><span class="line">                    prevMsg = msg;</span><br><span class="line">                    msg = msg.next;</span><br><span class="line">                &#125; <span class="keyword">while</span> (msg != <span class="keyword">null</span> &amp;&amp; !msg.isAsynchronous());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (msg != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (now &lt; msg.when) &#123;</span><br><span class="line">                    <span class="comment">//当异步消息触发时间大于当前时间，则设置下一次轮询的超时时长</span></span><br><span class="line">                    nextPollTimeoutMillis = (<span class="keyword">int</span>) Math.min(msg.when - now, Integer.MAX_VALUE);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 获取一条消息，并返回</span></span><br><span class="line">                    mBlocked = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">if</span> (prevMsg != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        prevMsg.next = msg.next;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        mMessages = msg.next;</span><br><span class="line">                    &#125;</span><br><span class="line">                    msg.next = <span class="keyword">null</span>;</span><br><span class="line">                    <span class="comment">//设置消息的使用状态，即flags |= FLAG_IN_USE</span></span><br><span class="line">                    msg.markInUse();</span><br><span class="line">                    <span class="keyword">return</span> msg;   <span class="comment">//成功地获取MessageQueue中的下一条即将要执行的消息</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//没有消息</span></span><br><span class="line">                nextPollTimeoutMillis = -<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//消息正在退出，返回null</span></span><br><span class="line">            <span class="keyword">if</span> (mQuitting) &#123;</span><br><span class="line">                dispose();</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//当消息队列为空，或者是消息队列的第一个消息时</span></span><br><span class="line">            <span class="keyword">if</span> (pendingIdleHandlerCount &lt; <span class="number">0</span> &amp;&amp; (mMessages == <span class="keyword">null</span> || now &lt; mMessages.when)) &#123;</span><br><span class="line">                pendingIdleHandlerCount = mIdleHandlers.size();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (pendingIdleHandlerCount &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">//没有idle handlers 需要运行，则循环并等待。</span></span><br><span class="line">                mBlocked = <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (mPendingIdleHandlers == <span class="keyword">null</span>) &#123;</span><br><span class="line">                mPendingIdleHandlers = <span class="keyword">new</span> IdleHandler[Math.max(pendingIdleHandlerCount, <span class="number">4</span>)];</span><br><span class="line">            &#125;</span><br><span class="line">            mPendingIdleHandlers = mIdleHandlers.toArray(mPendingIdleHandlers);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//只有第一次循环时，会运行idle handlers，执行完成后，重置pendingIdleHandlerCount为0.</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pendingIdleHandlerCount; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> IdleHandler idler = mPendingIdleHandlers[i];</span><br><span class="line">            mPendingIdleHandlers[i] = <span class="keyword">null</span>; <span class="comment">//去掉handler的引用</span></span><br><span class="line">            <span class="keyword">boolean</span> keep = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                keep = idler.queueIdle();  <span class="comment">//idle时执行的方法</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                Log.wtf(TAG, <span class="string">"IdleHandler threw exception"</span>, t);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!keep) &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">                    mIdleHandlers.remove(idler);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//重置idle handler个数为0，以保证不会再次重复运行</span></span><br><span class="line">        pendingIdleHandlerCount = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//当调用一个空闲handler时，一个新message能够被分发，因此无需等待可以直接查询pending message.</span></span><br><span class="line">        nextPollTimeoutMillis = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><code>nativePollOnce</code>是阻塞操作，其中<code>nextPollTimeoutMillis</code>代表下一个消息到来前，还需要等待的时长；当nextPollTimeoutMillis = -1时，表示消息队列中无消息，会一直等待下去。</p><p>当处于空闲时，往往会执行<code>IdleHandler</code>中的方法。当nativePollOnce()返回后，next()从<code>mMessages</code>中提取一个消息。</p></blockquote><p>并且loop方法调用了 <code>msg.target.dispatchMessage(msg)</code> ，msg.target 就是发送该消息的 Handler</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Handler</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dispatchMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//msg.callback 是 Runnable ，如果是 post方法则会走这个 if</span></span><br><span class="line">  <span class="keyword">if</span> (msg.callback != <span class="keyword">null</span>) &#123;</span><br><span class="line">    handleCallback(msg);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//callback </span></span><br><span class="line">    <span class="keyword">if</span> (mCallback != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (mCallback.handleMessage(msg)) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//回调到 Handler 的 handleMessage 方法</span></span><br><span class="line">    handleMessage(msg);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>dispatchMessage() 方法针对 Runnable 的方法做了特殊处理，如果是 ，则会直接执行 <code>Runnable.run()</code> 。</strong></p></blockquote><p><strong>Looper.loop() 是个死循环，会不断调用 MessageQueue.next() 获取 Message ，并调用 <code>msg.target.dispatchMessage(msg)</code> 回到了 Handler 来分发消息，以此来完成消息的回调</strong>。</p><p><img src="yuanli.webp" alt></p><h2 id="线程的切换"><a href="#线程的切换" class="headerlink" title="线程的切换"></a>线程的切换</h2><p>先将所涉及的方法调用栈画出来，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Thread.foo()&#123;</span><br><span class="line">Looper.loop()</span><br><span class="line"> -&gt; MessageQueue.next()</span><br><span class="line">   -&gt; Message.target.dispatchMessage()</span><br><span class="line">    -&gt; Handler.handleMessage()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>显而易见，Handler.handleMessage() 所在的线程最终由调用 Looper.loop() 的线程所决定。</strong></p><p>平时我们用的时候从异步线程发送消息到 Handler，这个 Handler 的 <code>handleMessage()</code> 方法是在主线程调用的，所以消息就从异步线程切换到了主线程。</p><h1 id="Handler的正确使用姿势"><a href="#Handler的正确使用姿势" class="headerlink" title="Handler的正确使用姿势"></a>Handler的正确使用姿势</h1><p>Handler很常用，但是也有很多需要注意的。</p><h2 id="为什么主线程可以直接使用-Handler，不需要创建-Looper"><a href="#为什么主线程可以直接使用-Handler，不需要创建-Looper" class="headerlink" title="为什么主线程可以直接使用 Handler，不需要创建 Looper"></a>为什么主线程可以直接使用 Handler，不需要创建 Looper</h2><p>前面我们提到了每个Handler 的线程都有一个 Looper ，主线程当然也不例外，但是我们不曾准备过主线程的 Looper 而可以直接使用，这是为何？</p><p><strong>注意：通常我们认为 ActivityThread 就是主线程。事实上它并不是一个线程，而是主线程操作的管理者，所以吧，我觉得把 ActivityThread 认为就是主线程无可厚非，另外主线程也可以说成 UI 线程。</strong></p><p>在 ActivityThread.main() 方法中有如下代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">//android.app.ActivityThread</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">  //...</span><br><span class="line">  Looper.prepareMainLooper();</span><br><span class="line"></span><br><span class="line">  ActivityThread thread = new ActivityThread();</span><br><span class="line">  thread.attach(false);</span><br><span class="line"></span><br><span class="line">  if (sMainThreadHandler == null) &#123;</span><br><span class="line">    sMainThreadHandler = thread.getHandler();</span><br><span class="line">  &#125;</span><br><span class="line">  //...</span><br><span class="line">  Looper.loop();</span><br><span class="line"></span><br><span class="line">  throw new RuntimeException(&quot;Main thread loop unexpectedly exited&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Looper.prepareMainLooper(); 代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Initialize the current thread as a looper, marking it as an</span><br><span class="line"> * application&apos;s main looper. The main looper for your application</span><br><span class="line"> * is created by the Android environment, so you should never need</span><br><span class="line"> * to call this function yourself.  See also: &#123;@link #prepare()&#125;</span><br><span class="line"> */</span><br><span class="line">public static void prepareMainLooper() &#123;</span><br><span class="line">    prepare(false);</span><br><span class="line">    synchronized (Looper.class) &#123;</span><br><span class="line">        if (sMainLooper != null) &#123;</span><br><span class="line">            throw new IllegalStateException(&quot;The main Looper has already been prepared.&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        sMainLooper = myLooper();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到<strong>在 ActivityThread 里 调用了 Looper.prepareMainLooper() 方法创建了 主线程的 Looper ,并且调用了 loop() 方法</strong>，所以我们就可以直接使用 Handler 了。</p><p><strong>注意：<code>Looper.loop()</code> 是个死循环，后面的代码正常情况不会执行。</strong></p><h2 id="主线程的-Looper-不允许退出"><a href="#主线程的-Looper-不允许退出" class="headerlink" title="主线程的 Looper 不允许退出"></a>主线程的 Looper 不允许退出</h2><p>如果你尝试退出 Looper ，你会得到以下错误信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Caused by: java.lang.IllegalStateException: Main thread not allowed to quit.</span><br><span class="line">  at android.os.MessageQueue.quit(MessageQueue.java:415)</span><br><span class="line">  at android.os.Looper.quit(Looper.java:240)</span><br></pre></td></tr></table></figure><p> 其实原因很简单，<strong>主线程不允许退出</strong>，退出就意味 APP 要挂。</p><h2 id="为什么Looper-loop方法不会卡死主线程"><a href="#为什么Looper-loop方法不会卡死主线程" class="headerlink" title="为什么Looper.loop方法不会卡死主线程"></a>为什么Looper.loop方法不会卡死主线程</h2><p>参考：<a href="https://www.zhihu.com/question/34652589/answer/90344494" target="_blank" rel="noopener">https://www.zhihu.com/question/34652589/answer/90344494</a></p><h2 id="Handler-里藏着的-Callback-能干什么"><a href="#Handler-里藏着的-Callback-能干什么" class="headerlink" title="Handler 里藏着的 Callback 能干什么"></a>Handler 里藏着的 Callback 能干什么</h2><p>在 Handler 的构造方法中有几个 要求传入 Callback ，那它是什么，又能做什么呢？</p><p>来看看 <code>Handler.dispatchMessage(msg)</code> 方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public void dispatchMessage(Message msg) &#123;</span><br><span class="line">  //这里的 callback 是 Runnable</span><br><span class="line">  if (msg.callback != null) &#123;</span><br><span class="line">    handleCallback(msg);</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    //如果 callback 处理了该 msg 并且返回 true， 就不会再回调 handleMessage</span><br><span class="line">    if (mCallback != null) &#123;</span><br><span class="line">      if (mCallback.handleMessage(msg)) &#123;</span><br><span class="line">        return;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    handleMessage(msg);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到 Handler.Callback 有<strong>优先处理消息的权利</strong> ，当一条消息被 Callback 处理<strong>并拦截（返回 true）</strong>，那么 Handler 的 <code>handleMessage(msg)</code> 方法就不会被调用了；如果 Callback 处理了消息，但是并没有拦截，那么就意味着<strong>一个消息可以同时被 Callback 以及 Handler 处理</strong>。</p><p><strong>我们可以利用 Callback 这个拦截机制来拦截 Handler 的消息！</strong></p><blockquote><p> 场景：Hook <code>ActivityThread.mH</code>， 在 ActivityThread 中有个成员变量 <code>mH</code> ，它是个 Handler，又是个极其重要的类，几乎所有的插件化框架都使用了这个方法。</p></blockquote><h2 id="创建-Message-实例的方式"><a href="#创建-Message-实例的方式" class="headerlink" title="创建 Message 实例的方式"></a>创建 Message 实例的方式</h2><p>先来看看消息池：</p><p>在代码中，可能经常看到recycle()方法，咋一看，可能是在做虚拟机的gc()相关的工作，其实不然，这是用于把消息加入到消息池的作用。这样的好处是，当消息池不为空时，可以直接从消息池中获取Message对象，而不是直接创建，提高效率。</p><p>静态变量<code>sPool</code>的数据类型为Message，通过next成员变量，维护一个消息池；静态变量<code>MAX_POOL_SIZE</code>代表消息池的可用大小；消息池的默认大小为50。</p><p>消息池常用的操作方法是obtain()和recycle()。</p><p><strong>obtain</strong></p><p>从消息池中获取消息</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Message <span class="title">obtain</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (sPoolSync) &#123;</span><br><span class="line">        <span class="keyword">if</span> (sPool != <span class="keyword">null</span>) &#123;</span><br><span class="line">            Message m = sPool;</span><br><span class="line">            sPool = m.next;</span><br><span class="line">            m.next = <span class="keyword">null</span>; <span class="comment">//从sPool中取出一个Message对象，并消息链表断开</span></span><br><span class="line">            m.flags = <span class="number">0</span>; <span class="comment">// 清除in-use flag</span></span><br><span class="line">            sPoolSize--; <span class="comment">//消息池的可用大小进行减1操作</span></span><br><span class="line">            <span class="keyword">return</span> m;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Message(); <span class="comment">// 当消息池为空时，直接创建Message对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>obtain()，从消息池取Message，都是把消息池表头的Message取走，再把表头指向next;</p><p><strong>recycle</strong></p><p>把不再使用的消息加入消息池</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">recycle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (isInUse()) &#123; <span class="comment">//判断消息是否正在使用</span></span><br><span class="line">        <span class="keyword">if</span> (gCheckRecycle) &#123; <span class="comment">//Android 5.0以后的版本默认为true,之前的版本默认为false.</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"This message cannot be recycled because it is still in use."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    recycleUnchecked();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//对于不再使用的消息，加入到消息池</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">recycleUnchecked</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//将消息标示位置为IN_USE，并清空消息所有的参数。</span></span><br><span class="line">    flags = FLAG_IN_USE;</span><br><span class="line">    what = <span class="number">0</span>;</span><br><span class="line">    arg1 = <span class="number">0</span>;</span><br><span class="line">    arg2 = <span class="number">0</span>;</span><br><span class="line">    obj = <span class="keyword">null</span>;</span><br><span class="line">    replyTo = <span class="keyword">null</span>;</span><br><span class="line">    sendingUid = -<span class="number">1</span>;</span><br><span class="line">    when = <span class="number">0</span>;</span><br><span class="line">    target = <span class="keyword">null</span>;</span><br><span class="line">    callback = <span class="keyword">null</span>;</span><br><span class="line">    data = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">synchronized</span> (sPoolSync) &#123;</span><br><span class="line">        <span class="keyword">if</span> (sPoolSize &lt; MAX_POOL_SIZE) &#123; <span class="comment">//当消息池没有满时，将Message对象加入消息池</span></span><br><span class="line">            next = sPool;</span><br><span class="line">            sPool = <span class="keyword">this</span>;</span><br><span class="line">            sPoolSize++; <span class="comment">//消息池的可用大小进行加1操作</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>recycle()，将Message加入到消息池的过程，都是把Message加到链表的表头；</p><p><strong>所以由于 Handler 极为常用，所以为了节省开销，Android 给 Message 设计了回收机制，所以我们在使用的时候尽量复用 Message ，减少内存消耗。</strong></p><ul><li><p>1、通过 Message 的静态方法 <code>Message.obtain();</code>  获取；</p></li><li><p>2、通过 Handler 的公有方法 <code>handler.obtainMessage();</code> 。</p></li></ul><h2 id="Handler-引起的内存泄露原因以及解决方案"><a href="#Handler-引起的内存泄露原因以及解决方案" class="headerlink" title="Handler 引起的内存泄露原因以及解决方案"></a>Handler 引起的内存泄露原因以及解决方案</h2><p>Handler 允许我们发送<strong>延时消息</strong>，如果在延时期间用户关闭了 Activity，那么该 Activity 会泄露。</p><p>这个泄露是因为 Message 会持有 Handler，而又因为 <strong>Java 的特性，内部类会持有外部类</strong>，使得 Activity 会被 Handler 持有，这样最终就导致 Activity 泄露。</p><p>解决该问题的最有效的方法是：<strong>将 Handler 定义成静态的内部类，在内部持有 Activity 的弱引用，并及时移除所有消息</strong>。</p><p>示例代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> DemoActivity extends Activity &#123;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SafeHandler</span> <span class="keyword">extends</span> <span class="title">Handler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> WeakReference&lt;DemoActivity&gt; ref;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SafeHandler</span><span class="params">(DemoActivity activity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.ref = <span class="keyword">new</span> WeakReference(activity);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(<span class="keyword">final</span> Message msg)</span> </span>&#123;</span><br><span class="line">        DemoActivity activity = ref.get();</span><br><span class="line">        <span class="keyword">if</span> (activity != <span class="keyword">null</span>) &#123;</span><br><span class="line">            activity.handleMessage(msg);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">private</span> SafeHandler mSafeHandler = <span class="keyword">new</span> SafeHandler(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// .... do somthing</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//移除消息，加一层保障：</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDestroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  mSafeHandler.removeCallbacksAndMessages(<span class="keyword">null</span>);</span><br><span class="line">  <span class="keyword">super</span>.onDestroy();</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>注意：单纯的在 <code>onDestroy</code> 移除消息并不保险，因为 <code>onDestroy</code> 并不一定执行。</strong></p></blockquote><h2 id="子线程里弹-Toast"><a href="#子线程里弹-Toast" class="headerlink" title="子线程里弹 Toast"></a>子线程里弹 Toast</h2><p>当我们尝试在子线程里直接去弹 Toast 的时候，会 crash ：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java.lang.RuntimeException: Can&apos;t create handler inside thread that has not called Looper.prepare()</span><br></pre></td></tr></table></figure><p><strong>本质上是因为 Toast 的实现依赖于 Handler</strong>，同理的还有 Dialog。</p><p>正确使用代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Looper.prepare();</span><br><span class="line">    Toast.makeText(HandlerActivity.<span class="keyword">this</span>, <span class="string">"子线程下测试不会崩溃啦！"</span>, Toast.LENGTH_SHORT).show();</span><br><span class="line">    Looper.loop();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;).start();</span><br></pre></td></tr></table></figure><h2 id="巧妙利用-Looper-机制"><a href="#巧妙利用-Looper-机制" class="headerlink" title="巧妙利用 Looper 机制"></a>巧妙利用 Looper 机制</h2><p>我们可以利用 Looper 的机制来帮助我们做一些事情：</p><ol><li>将 Runnable post 到主线程执行；</li><li>利用 Looper 判断当前线程是否是主线程。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">MainThread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">MainThread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Handler HANDLER = <span class="keyword">new</span> Handler(Looper.getMainLooper());</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(@NonNull Runnable runnable)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isMainThread()) &#123;</span><br><span class="line">            runnable.run();</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            HANDLER.post(runnable);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isMainThread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Looper.myLooper() == Looper.getMainLooper();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://www.jianshu.com/p/f70ee1765a61" target="_blank" rel="noopener">https://www.jianshu.com/p/f70ee1765a61</a></p><p><a href="http://gityuan.com/2015/12/26/handler-message-framework/" target="_blank" rel="noopener">http://gityuan.com/2015/12/26/handler-message-framework/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;Handler&lt;/code&gt; 是 &lt;code&gt;Android&lt;/code&gt; 开发过程中非常非常常见的东西。它通常被我们用来做主线程与子线程之间的通信工具，而 Handler 作为 Android 中消息机制的重要一员也确实给我们的开发带来了极大的便利。&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="http://hackycy.github.io/categories/Android/"/>
    
    
      <category term="Handler" scheme="http://hackycy.github.io/tags/Handler/"/>
    
  </entry>
  
  <entry>
    <title>解决Android Studio——Configuration on demand is not supported by the current version of the Android Gradle</title>
    <link href="http://hackycy.github.io/2020/01/17/%E8%A7%A3%E5%86%B3Android-Studio%E2%80%94%E2%80%94Configuration-on-demand-is-not-supported-by-the-current-version-of-the-Android-Gradle/"/>
    <id>http://hackycy.github.io/2020/01/17/解决Android-Studio——Configuration-on-demand-is-not-supported-by-the-current-version-of-the-Android-Gradle/</id>
    <published>2020-01-17T06:45:50.000Z</published>
    <updated>2020-01-17T06:57:04.136Z</updated>
    
    <content type="html"><![CDATA[<p>【错误】<br>Configuration on demand is not supported by the current version of the Android Gradle plugin since you are using Gradle version 4.6 or above. </p><p>Suggestion: disable configuration on demand by setting org.gradle.configureondemand=false in your gradle.properties file or use a Gradle version less than 4.6.</p><p>【翻译】<br>由于使用你正在使用 Gradle 版本4.6或以上，当前版本的Android的 Gradle 插件不支持按需配置。</p><p>建议：通过在你的 gradle.properties 文件中设置 org.gradle.configureondemand=false 禁用按需配置，或者使用一个低于4.6版本的 Gradle。</p><a id="more"></a><p><strong>解决方案1：降级</strong></p><p>打开 <strong>gradle-wrapper.properties</strong> 文件，修改 <strong>distributionUrl</strong> 参数，将其后面修改为低于4.6版本的 Gradle。如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">distributionUrl=https\://services.gradle.org/distributions/gradle-4.1-all.zip</span><br></pre></td></tr></table></figure><p><img src="properties.png" alt></p><p><strong>解决方法2：禁用按需配置</strong></p><p>1、打开 <strong>gradle.properties</strong> 文件，共有两个：<strong>Global Properties</strong> 和 <strong>Project Properties</strong>，将其中的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">org.gradle.configureondemand=true</span><br></pre></td></tr></table></figure><p>修改为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">org.gradle.configureondemand=false</span><br></pre></td></tr></table></figure><blockquote><p>或删除该语句，或注释掉该语句。</p></blockquote><p>2、或者通过 <strong>Preferences</strong> 菜单，找到 <strong>Build, Execution, Deployment</strong> 里面的 <strong>Compiler</strong>，将右面的 <strong>Configure on demand</strong> 取消勾选。</p><p><img src="panel.png" alt></p><p><strong>参考链接</strong></p><p><a href="https://stackoverflow.com/questions/49990933/configuration-on-demand-is-not-supported-by-the-current-version-of-the-android-g" target="_blank" rel="noopener">https://stackoverflow.com/questions/49990933/configuration-on-demand-is-not-supported-by-the-current-version-of-the-android-g</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;【错误】&lt;br&gt;Configuration on demand is not supported by the current version of the Android Gradle plugin since you are using Gradle version 4.6 or above. &lt;/p&gt;
&lt;p&gt;Suggestion: disable configuration on demand by setting org.gradle.configureondemand=false in your gradle.properties file or use a Gradle version less than 4.6.&lt;/p&gt;
&lt;p&gt;【翻译】&lt;br&gt;由于使用你正在使用 Gradle 版本4.6或以上，当前版本的Android的 Gradle 插件不支持按需配置。&lt;/p&gt;
&lt;p&gt;建议：通过在你的 gradle.properties 文件中设置 org.gradle.configureondemand=false 禁用按需配置，或者使用一个低于4.6版本的 Gradle。&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="http://hackycy.github.io/categories/Android/"/>
    
    
      <category term="Android" scheme="http://hackycy.github.io/tags/Android/"/>
    
      <category term="Android Studio" scheme="http://hackycy.github.io/tags/Android-Studio/"/>
    
  </entry>
  
  <entry>
    <title>Java 8 新特性一览</title>
    <link href="http://hackycy.github.io/2020/01/04/Java-8-%E6%96%B0%E7%89%B9%E6%80%A7%E4%B8%80%E8%A7%88/"/>
    <id>http://hackycy.github.io/2020/01/04/Java-8-新特性一览/</id>
    <published>2020-01-04T02:13:58.000Z</published>
    <updated>2020-01-04T04:10:31.097Z</updated>
    
    <content type="html"><![CDATA[<p>Java 8 (又称为 jdk 1.8) 是 Java 语言开发的一个主要版本。 Oracle 公司于 2014 年 3 月 18 日发布 Java 8 ，它支持函数式编程，新的 JavaScript 引擎，新的日期 API，新的Stream API 等。</p><a id="more"></a><h1 id="新特性"><a href="#新特性" class="headerlink" title="新特性"></a>新特性</h1><p>Java8 新增了非常多的特性，我们主要讨论以下几个：</p><ul><li><strong>Lambda 表达式</strong> − Lambda 允许把函数作为一个方法的参数（函数作为参数传递到方法中）。</li><li><strong>方法引用</strong> − 方法引用提供了非常有用的语法，可以直接引用已有Java类或对象（实例）的方法或构造器。与lambda联合使用，方法引用可以使语言的构造更紧凑简洁，减少冗余代码。</li><li><strong>默认方法</strong> − 默认方法就是一个在接口里面有了一个实现的方法。</li><li><strong>Stream API</strong> −新添加的Stream API（java.util.stream） 把真正的函数式编程风格引入到Java中。</li><li><strong>Date Time API</strong> − 加强对日期与时间的处理。</li><li><strong>Optional 类</strong> − Optional 类已经成为 Java 8 类库的一部分，用来解决空指针异常。</li></ul><blockquote><p>更多相关请浏览-&gt;<a href="https://www.oracle.com/technetwork/java/javase/8-whats-new-2157071.html" target="_blank" rel="noopener">https://www.oracle.com/technetwork/java/javase/8-whats-new-2157071.html</a></p></blockquote><h1 id="Lambda-表达式"><a href="#Lambda-表达式" class="headerlink" title="Lambda 表达式"></a>Lambda 表达式</h1><p>Lambda 表达式，也可称为闭包，它是推动 Java 8 发布的最重要新特性。</p><p>Lambda 允许把函数作为一个方法的参数（函数作为参数传递进方法中）。</p><p>使用 Lambda 表达式可以使代码变的更加简洁紧凑。</p><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><p>lambda 表达式的语法格式如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(parameters) -&gt; expression </span><br><span class="line"><span class="comment">// or</span></span><br><span class="line">(parameters) -&gt;&#123; statements; &#125;</span><br></pre></td></tr></table></figure><ul><li><strong>可选类型声明：</strong>不需要声明参数类型，编译器可以统一识别参数值。</li><li><strong>可选的参数圆括号：</strong>一个参数无需定义圆括号，但多个参数需要定义圆括号。</li><li><strong>可选的大括号：</strong>如果主体包含了一个语句，就不需要使用大括号。</li><li><strong>可选的返回关键字：</strong>如果主体只有一个表达式返回值则编译器会自动返回值，大括号需要指定明表达式返回了一个数值。</li></ul><p>来看一下最简单的使用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Lambda</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"匿名内部类实现"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">"Lambda实现"</span>);</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        Lambda lambda = <span class="keyword">new</span> Lambda();</span><br><span class="line">        lambda.printFunc(() -&gt; System.out.println(<span class="string">"hello, lambda"</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printFunc</span><span class="params">(Functional func)</span> </span>&#123;</span><br><span class="line">        func.accept();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">interface</span> <span class="title">Functional</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">accept</span><span class="params">()</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">匿名内部类实现</span><br><span class="line">Lambda实现</span><br><span class="line">hello, lambda</span><br></pre></td></tr></table></figure><p><strong>更多实例</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 不需要参数,返回值为 5  </span></span><br><span class="line">() -&gt; <span class="number">5</span>  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// 2. 接收一个参数(数字类型),返回其2倍的值  </span></span><br><span class="line">x -&gt; <span class="number">2</span> * x  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// 3. 接受2个参数(数字),并返回他们的差值  </span></span><br><span class="line">(x, y) -&gt; x – y  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// 4. 接收2个int型整数,返回他们的和  </span></span><br><span class="line">(<span class="keyword">int</span> x, <span class="keyword">int</span> y) -&gt; x + y  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// 5. 接受一个 string 对象,并在控制台打印,不返回任何值(看起来像是返回void)  </span></span><br><span class="line">(String s) -&gt; System.out.print(s)</span><br></pre></td></tr></table></figure><h2 id="前提条件"><a href="#前提条件" class="headerlink" title="前提条件"></a>前提条件</h2><p>Lambda的语法非常简洁，但并不是可以随便使用的，使用时有几个条件需要特别注意：</p><ul><li><strong>方法的参数</strong>或者<strong>局部变量类型</strong>必须为<strong>接口</strong>才能使用Lambda</li><li>接口中有且仅有一个抽象方法</li></ul><h2 id="函数式接口"><a href="#函数式接口" class="headerlink" title="函数式接口"></a>函数式接口</h2><p>函数式接口在Java中指的是：<strong>有且仅有一个抽象方法的接口</strong>。</p><p>函数式接口，即适用于函数式变成场景的接口，而Java中的函数式编程体现就是Lambda，所以函数式接口就是可以适用于Lambda使用的接口。只有确保接口中有且仅有一个抽象方法，Java中的Lambda才能顺利进行推导。</p><p><code>@FunctionalInterface</code>注解</p><p>与<code>@Override</code>注解的作用类似，Java 8中专门为函数式接口引入了一个新的注解：<code>@FunctionalInterface</code>。该注解可以用于一个接口的定义上。</p><blockquote><p>默认方法和静态方法不会破坏函数式接口的定义，因此如下的代码是合法的。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">FunctionalDefaultMethods</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">defaultMethod</span><span class="params">()</span> </span>&#123;&#125;        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Lambda与匿名内部类对比"><a href="#Lambda与匿名内部类对比" class="headerlink" title="Lambda与匿名内部类对比"></a>Lambda与匿名内部类对比</h2><ul><li>所需要的类型不一样：匿名内部类需要的类型可以是类、抽象类、接口。Lambda表达式需要的类型必须是接口。</li><li>抽象方法的数量不一样：匿名内部类所需的接口中抽象方法数量随意，Lambda表达式所需的接口有且只能有一个抽象方法。</li><li>实现原理不同：匿名内部类是在编译后形成class，Lambda表达式是在程序运行时动态生成class。</li></ul><h2 id="常用的内置函数式接口"><a href="#常用的内置函数式接口" class="headerlink" title="常用的内置函数式接口"></a>常用的内置函数式接口</h2><p>Lambda表达式的前提是需要有函数式接口。而Lambda使用时不需要关心接口名、抽象方法名。只关心抽象方法的参数列表和返回值类型。因此为了让我们使用Lambda方便，JDK提供了大量的函数式接口。都在<code>java.util.function</code>包下可以查看。</p><p>常用的几个接口：</p><h3 id="Supplier"><a href="#Supplier" class="headerlink" title="Supplier"></a>Supplier</h3><p>该接口意味着“供给”，对应的Lambda表达式需要对外提供一个符合泛型类型的对象数据。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Supplier</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function">T <span class="title">get</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Consumer"><a href="#Consumer" class="headerlink" title="Consumer"></a>Consumer</h3><p>该接口与Supplier正好相反，它不是生产一个数据，而是消费一个数据，其数据类型由泛型参数决定。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Consumer</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">accept</span><span class="params">(T t)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Function"><a href="#Function" class="headerlink" title="Function"></a>Function</h3><p>该接口用来提供一个类型的数据得到另一个类型的数据，前者称为前置条件，后者称为后置条件，有参数有返回值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Function</span>&lt;<span class="title">T</span>, <span class="title">R</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function">R <span class="title">apply</span><span class="params">(T t)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Predicate"><a href="#Predicate" class="headerlink" title="Predicate"></a>Predicate</h3><p>有时候需要对某种类型数据进行判断，从而得到一个布尔值的接口，这时可以使用该接口。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Predicate</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">test</span><span class="params">(T t)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="接口默认方法"><a href="#接口默认方法" class="headerlink" title="接口默认方法"></a>接口默认方法</h1><p>Java 8 新增了接口的默认方法。</p><p>简单说，默认方法就是接口可以有实现方法，而且不需要实现类去实现其方法。</p><p>我们只需在方法名前面加个 default 关键字即可实现默认方法。</p><blockquote><p><strong>为什么要有这个特性？</strong></p><p>首先，之前的接口是个双刃剑，好处是面向抽象而不是面向具体编程，缺陷是，当需要修改接口时候，需要修改全部实现该接口的类，目前的 java 8 之前的集合框架没有 foreach 方法，通常能想到的解决办法是在JDK里给相关的接口添加新的方法及实现。然而，对于已经发布的版本，是没法在给接口添加新方法的同时不影响已有的实现。所以引进的默认方法。他们的目的是为了解决接口的修改与现有的实现不兼容的问题。</p></blockquote><h2 id="语法-1"><a href="#语法-1" class="headerlink" title="语法"></a>语法</h2><h3 id="默认方法语法："><a href="#默认方法语法：" class="headerlink" title="默认方法语法："></a>默认方法语法：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Vehicle</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;</span><br><span class="line">      System.out.println(<span class="string">"我是一辆车!"</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="多个默认方法"><a href="#多个默认方法" class="headerlink" title="多个默认方法"></a>多个默认方法</h3><p>一个接口有默认方法，考虑这样的情况，一个类实现了多个接口，且这些接口有相同的默认方法，以下实例说明了这种情况的解决方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Vehicle</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;</span><br><span class="line">      System.out.println(<span class="string">"我是一辆车!"</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">FourWheeler</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;</span><br><span class="line">      System.out.println(<span class="string">"我是一辆四轮车!"</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="静态默认方法"><a href="#静态默认方法" class="headerlink" title="静态默认方法"></a>静态默认方法</h2><p>Java 8 的另一个特性是接口可以声明（并且可以提供实现）静态方法。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Vehicle</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;</span><br><span class="line">      System.out.println(<span class="string">"我是一辆车!"</span>);</span><br><span class="line">   &#125;</span><br><span class="line">    <span class="comment">// 静态方法</span></span><br><span class="line">   <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">blowHorn</span><span class="params">()</span></span>&#123;</span><br><span class="line">      System.out.println(<span class="string">"按喇叭!!!"</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>尽管默认方法有这么多好处，但在实际开发中应该谨慎使用：在复杂的继承体系中，默认方法可能引起歧义和编译错误。</p></blockquote><h1 id="方法引用"><a href="#方法引用" class="headerlink" title="方法引用"></a>方法引用</h1><p>方法引用使得开发者可以直接引用现存的方法、Java类的构造方法或者实例对象。方法引用和Lambda表达式配合使用，使得java类的构造方法看起来紧凑而简洁，没有很多复杂的模板代码。</p><p>方法引用使用一对冒号 <strong>::</strong> </p><ul><li><strong>构造器引用：</strong>它的语法是<code>Class::new</code>，或者更一般的<code>Class&lt; T &gt;::new</code>实例如下：</li><li><strong>静态方法引用：</strong>它的语法是<code>Class::static_method</code>，实例如下：</li><li><strong>特定类的任意对象的方法引用：</strong>它的语法是<code>Class::method</code>实例如下：</li><li><strong>特定对象的方法引用：</strong>它的语法是<code>instance::method</code>实例如下：</li></ul><p>我们来用一个案例来理解一下为什么需要方法引用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MethodRef</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">getMax</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> n : arr) &#123;</span><br><span class="line">            sum += n;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(sum);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      <span class="comment">// 直接重复拷贝代码</span></span><br><span class="line">        printMax((arr) -&gt; &#123;</span><br><span class="line">            <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> n : arr) &#123;</span><br><span class="line">                sum += n;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(sum);</span><br><span class="line">        &#125;);</span><br><span class="line"><span class="comment">// 在Lambda中调用另一个函数</span></span><br><span class="line">        printMax((arr) -&gt; &#123;</span><br><span class="line">            getMax(arr);</span><br><span class="line">        &#125;);</span><br><span class="line"><span class="comment">// 直接使用方法引用</span></span><br><span class="line">        printMax(MethodRef::getMax);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printMax</span><span class="params">(Consumer&lt;<span class="keyword">int</span>[]&gt; consumer)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span>, <span class="number">14</span>, <span class="number">15</span>&#125;;</span><br><span class="line">        consumer.accept(arr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在main函数中的使用的三个对比，这就是减少了代码的冗余。</p><h1 id="Stream流"><a href="#Stream流" class="headerlink" title="Stream流"></a>Stream流</h1><p>Java 8 API添加了一个新的抽象称为流Stream，可以让你以一种声明的方式处理数据。</p><p>Stream 使用一种类似用 SQL 语句从数据库查询数据的直观方式来提供一种对 Java 集合运算和表达的高阶抽象。</p><p>Stream API可以极大提高Java程序员的生产力，让程序员写出高效率、干净、简洁的代码。</p><p>这种风格将要处理的元素集合看作一种流， 流在管道中传输， 并且可以在管道的节点上进行处理， 比如筛选， 排序，聚合等。</p><p>元素流在管道中经过中间操作（intermediate operation）的处理，最后由最终操作(terminal operation)得到前面处理的结果。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">+--------------------+       +------+   +------+   +---+   +-------+</span><br><span class="line">| stream of elements +-----&gt; |filter+-&gt; |sorted+-&gt; |map+-&gt; |collect|</span><br><span class="line">+--------------------+       +------+   +------+   +---+   +-------+</span><br></pre></td></tr></table></figure><p>以上的流程转换为 Java 代码为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; transactionsIds = </span><br><span class="line">widgets.stream()</span><br><span class="line">             .filter(b -&gt; b.getColor() == RED)</span><br><span class="line">             .sorted((x,y) -&gt; x.getWeight() - y.getWeight())</span><br><span class="line">             .mapToInt(Widget::getWeight)</span><br><span class="line">             .sum();</span><br></pre></td></tr></table></figure><h2 id="什么是-Stream"><a href="#什么是-Stream" class="headerlink" title="什么是 Stream"></a>什么是 Stream</h2><p>Stream（流）是一个来自数据源的元素队列并支持聚合操作</p><ul><li>元素是特定类型的对象，形成一个队列。 Java中的Stream并不会存储元素，而是按需计算。</li><li><strong>数据源</strong> 流的来源。 可以是集合，数组，I/O channel， 产生器generator 等。</li><li><strong>聚合操作</strong> 类似SQL语句一样的操作， 比如filter, map, reduce, find, match, sorted等。</li></ul><p>和以前的Collection操作不同， Stream操作还有两个基础的特征：</p><ul><li><strong>Pipelining</strong>: 中间操作都会返回流对象本身。 这样多个操作可以串联成一个管道， 如同流式风格（fluent style）。 这样做可以对操作进行优化， 比如延迟执行(laziness)和短路( short-circuiting)。</li><li><strong>内部迭代</strong>： 以前对集合遍历都是通过Iterator或者For-Each的方式, 显式的在集合外部进行迭代， 这叫做外部迭代。 Stream提供了内部迭代的方式， 通过访问者模式(Visitor)实现。</li></ul><h2 id="生成流"><a href="#生成流" class="headerlink" title="生成流"></a>生成流</h2><p>在 Java 8 中, 集合接口有两个方法来生成流：</p><ul><li><strong>stream()</strong> − 为集合创建串行流。</li><li><strong>parallelStream()</strong> − 为集合创建并行流。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; strings = Arrays.asList(<span class="string">"abc"</span>, <span class="string">""</span>, <span class="string">"bc"</span>, <span class="string">"efg"</span>, <span class="string">"abcd"</span>,<span class="string">""</span>, <span class="string">"jkl"</span>);</span><br><span class="line">List&lt;String&gt; filtered = strings.stream().filter(string -&gt; !string.isEmpty()).collect(Collectors.toList());</span><br></pre></td></tr></table></figure><h2 id="forEach"><a href="#forEach" class="headerlink" title="forEach"></a>forEach</h2><p>Stream 提供了新的方法 ‘forEach’ 来迭代流中的每个数据。以下代码片段使用 forEach 输出了10个随机数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Random random = <span class="keyword">new</span> Random();</span><br><span class="line">random.ints().limit(<span class="number">10</span>).forEach(System.out::println);</span><br></pre></td></tr></table></figure><h2 id="map"><a href="#map" class="headerlink" title="map"></a>map</h2><p>map 方法用于映射每个元素到对应的结果，以下代码片段使用 map 输出了元素对应的平方数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; numbers = Arrays.asList(<span class="number">3</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">7</span>, <span class="number">3</span>, <span class="number">5</span>);</span><br><span class="line"><span class="comment">// 获取对应的平方数</span></span><br><span class="line">List&lt;Integer&gt; squaresList = numbers.stream().map( i -&gt; i*i).distinct().collect(Collectors.toList());</span><br></pre></td></tr></table></figure><h2 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h2><p>filter 方法用于通过设置的条件过滤出元素。以下代码片段使用 filter 方法过滤出空字符串：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt;strings = Arrays.asList(<span class="string">"abc"</span>, <span class="string">""</span>, <span class="string">"bc"</span>, <span class="string">"efg"</span>, <span class="string">"abcd"</span>,<span class="string">""</span>, <span class="string">"jkl"</span>);</span><br><span class="line"><span class="comment">// 获取空字符串的数量</span></span><br><span class="line"><span class="keyword">long</span> count = strings.stream().filter(string -&gt; string.isEmpty()).count();</span><br></pre></td></tr></table></figure><h2 id="limit"><a href="#limit" class="headerlink" title="limit"></a>limit</h2><p>limit 方法用于获取指定数量的流。 以下代码片段使用 limit 方法打印出 10 条数据：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Random random = <span class="keyword">new</span> Random();</span><br><span class="line">random.ints().limit(<span class="number">10</span>).forEach(System.out::println);</span><br></pre></td></tr></table></figure><h2 id="sorted"><a href="#sorted" class="headerlink" title="sorted"></a>sorted</h2><p>sorted 方法用于对流进行排序。以下代码片段使用 sorted 方法对输出的 10 个随机数进行排序：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Random random = <span class="keyword">new</span> Random();</span><br><span class="line">random.ints().limit(<span class="number">10</span>).sorted().forEach(System.out::println);</span><br></pre></td></tr></table></figure><h2 id="并行（parallel）程序"><a href="#并行（parallel）程序" class="headerlink" title="并行（parallel）程序"></a>并行（parallel）程序</h2><p>parallelStream 是流并行处理程序的代替方法。以下实例我们使用 parallelStream 来输出空字符串的数量：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; strings = Arrays.asList(<span class="string">"abc"</span>, <span class="string">""</span>, <span class="string">"bc"</span>, <span class="string">"efg"</span>, <span class="string">"abcd"</span>,<span class="string">""</span>, <span class="string">"jkl"</span>);</span><br><span class="line"><span class="comment">// 获取空字符串的数量</span></span><br><span class="line"><span class="keyword">int</span> count = strings.parallelStream().filter(string -&gt; string.isEmpty()).count();</span><br></pre></td></tr></table></figure><p>我们可以很容易的在顺序运行和并行直接切换。</p><h2 id="Collectors"><a href="#Collectors" class="headerlink" title="Collectors"></a>Collectors</h2><p>Collectors 类实现了很多归约操作，例如将流转换成集合和聚合元素。Collectors 可用于返回列表或字符串：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt;strings = Arrays.asList(<span class="string">"abc"</span>, <span class="string">""</span>, <span class="string">"bc"</span>, <span class="string">"efg"</span>, <span class="string">"abcd"</span>,<span class="string">""</span>, <span class="string">"jkl"</span>);</span><br><span class="line">List&lt;String&gt; filtered = strings.stream().filter(string -&gt; !string.isEmpty()).collect(Collectors.toList());</span><br><span class="line"> </span><br><span class="line">System.out.println(<span class="string">"筛选列表: "</span> + filtered);</span><br><span class="line">String mergedString = strings.stream().filter(string -&gt; !string.isEmpty()).collect(Collectors.joining(<span class="string">", "</span>));</span><br><span class="line">System.out.println(<span class="string">"合并字符串: "</span> + mergedString);</span><br></pre></td></tr></table></figure><h2 id="统计"><a href="#统计" class="headerlink" title="统计"></a>统计</h2><p>另外，一些产生统计结果的收集器也非常有用。它们主要用于int、double、long等基本类型上，它们可以用来产生类似如下的统计结果。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; numbers = Arrays.asList(<span class="number">3</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">7</span>, <span class="number">3</span>, <span class="number">5</span>);</span><br><span class="line"> </span><br><span class="line">IntSummaryStatistics stats = numbers.stream().mapToInt((x) -&gt; x).summaryStatistics();</span><br><span class="line"> </span><br><span class="line">System.out.println(<span class="string">"列表中最大的数 : "</span> + stats.getMax());</span><br><span class="line">System.out.println(<span class="string">"列表中最小的数 : "</span> + stats.getMin());</span><br><span class="line">System.out.println(<span class="string">"所有数之和 : "</span> + stats.getSum());</span><br><span class="line">System.out.println(<span class="string">"平均数 : "</span> + stats.getAverage());</span><br></pre></td></tr></table></figure><blockquote><p>更多Api请翻阅文档：<a href="https://docs.oracle.com/javase/8/docs/api/java/util/stream/package-summary.html" target="_blank" rel="noopener">https://docs.oracle.com/javase/8/docs/api/java/util/stream/package-summary.html</a></p></blockquote><h1 id="Date-Time-API"><a href="#Date-Time-API" class="headerlink" title="Date/Time API"></a>Date/Time API</h1><p>Java 8通过发布新的Date-Time API (JSR 310)来进一步加强对日期与时间的处理。</p><p>在旧版的 Java 中，日期时间 API 存在诸多问题，其中有：</p><ul><li><strong>非线程安全</strong> − java.util.Date 是非线程安全的，所有的日期类都是可变的，这是Java日期类最大的问题之一。</li><li><strong>设计很差</strong> − Java的日期/时间类的定义并不一致，在java.util和java.sql的包中都有日期类，此外用于格式化和解析的类在java.text包中定义。java.util.Date同时包含日期和时间，而java.sql.Date仅包含日期，将其纳入java.sql包并不合理。另外这两个类都有相同的名字，这本身就是一个非常糟糕的设计。</li><li><strong>时区处理麻烦</strong> − 日期类并不提供国际化，没有时区支持，因此Java引入了java.util.Calendar和java.util.TimeZone类，但他们同样存在上述所有的问题。</li></ul><p>Java 8 在 <strong>java.time</strong> 包下提供了很多新的 API。以下为两个比较重要的 API：</p><ul><li><strong>Local(本地)</strong> − 简化了日期时间的处理，没有时区的问题。</li><li><strong>Zoned(时区)</strong> − 通过制定的时区处理日期时间。</li></ul><p>新的java.time包涵盖了所有处理日期，时间，日期/时间，时区，时刻（instants），过程（during）与时钟（clock）的操作。</p><blockquote><p><a href="https://docs.oracle.com/javase/8/docs/technotes/guides/datetime/index.html" target="_blank" rel="noopener">https://docs.oracle.com/javase/8/docs/technotes/guides/datetime/index.html</a></p></blockquote><h2 id="本地化日期时间-API"><a href="#本地化日期时间-API" class="headerlink" title="本地化日期时间 API"></a>本地化日期时间 API</h2><p><code>LocalDate/LocalTime</code> 和 <code>LocalDateTime</code> 类可以在处理时区不是必须的情况。代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取当前的日期时间</span></span><br><span class="line">LocalDateTime currentTime = LocalDateTime.now();</span><br><span class="line">System.out.println(<span class="string">"当前时间: "</span> + currentTime);</span><br><span class="line">        </span><br><span class="line">LocalDate date1 = currentTime.toLocalDate();</span><br><span class="line">System.out.println(<span class="string">"date1: "</span> + date1);</span><br><span class="line">        </span><br><span class="line">Month month = currentTime.getMonth();</span><br><span class="line"><span class="keyword">int</span> day = currentTime.getDayOfMonth();</span><br><span class="line"><span class="keyword">int</span> seconds = currentTime.getSecond();</span><br><span class="line">        </span><br><span class="line">System.out.println(<span class="string">"月: "</span> + month +<span class="string">", 日: "</span> + day +<span class="string">", 秒: "</span> + seconds);</span><br><span class="line">        </span><br><span class="line">LocalDateTime date2 = currentTime.withDayOfMonth(<span class="number">10</span>).withYear(<span class="number">2012</span>);</span><br><span class="line">System.out.println(<span class="string">"date2: "</span> + date2);</span><br><span class="line">        </span><br><span class="line"><span class="comment">// 12 december 2014</span></span><br><span class="line">LocalDate date3 = LocalDate.of(<span class="number">2014</span>, Month.DECEMBER, <span class="number">12</span>);</span><br><span class="line">System.out.println(<span class="string">"date3: "</span> + date3);</span><br><span class="line">        </span><br><span class="line"><span class="comment">// 22 小时 15 分钟</span></span><br><span class="line">LocalTime date4 = LocalTime.of(<span class="number">22</span>, <span class="number">15</span>);</span><br><span class="line">System.out.println(<span class="string">"date4: "</span> + date4);</span><br><span class="line">        </span><br><span class="line"><span class="comment">// 解析字符串</span></span><br><span class="line">LocalTime date5 = LocalTime.parse(<span class="string">"20:15:30"</span>);</span><br><span class="line">System.out.println(<span class="string">"date5: "</span> + date5);</span><br></pre></td></tr></table></figure><blockquote><p> output</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt; 当前时间: 2016-04-15T16:55:48.668</span><br><span class="line">&gt; date1: 2016-04-15</span><br><span class="line">&gt; 月: APRIL, 日: 15, 秒: 48</span><br><span class="line">&gt; date2: 2012-04-10T16:55:48.668</span><br><span class="line">&gt; date3: 2014-12-12</span><br><span class="line">&gt; date4: 22:15</span><br><span class="line">&gt; date5: 20:15:30</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><h2 id="使用时区的日期时间API"><a href="#使用时区的日期时间API" class="headerlink" title="使用时区的日期时间API"></a>使用时区的日期时间API</h2><p>如果我们需要考虑到时区，就可以使用时区<code>ZonedDateTime</code>的日期时间API：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取当前时间日期</span></span><br><span class="line">ZonedDateTime date1 = ZonedDateTime.parse(<span class="string">"2015-12-03T10:15:30+05:30[Asia/Shanghai]"</span>);</span><br><span class="line">System.out.println(<span class="string">"date1: "</span> + date1);</span><br><span class="line">        </span><br><span class="line">ZoneId id = ZoneId.of(<span class="string">"Europe/Paris"</span>);</span><br><span class="line">System.out.println(<span class="string">"ZoneId: "</span> + id);</span><br><span class="line">        </span><br><span class="line">ZoneId currentZone = ZoneId.systemDefault();</span><br><span class="line">System.out.println(<span class="string">"当期时区: "</span> + currentZone);</span><br></pre></td></tr></table></figure><blockquote><p>output</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; date1: 2015-12-03T10:15:30+08:00[Asia/Shanghai]</span><br><span class="line">&gt; ZoneId: Europe/Paris</span><br><span class="line">&gt; 当期时区: Asia/Shanghai</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>更多示例<a href="https://www.javacodegeeks.com/2014/04/java-8-date-time-api-tutorial-localdatetime.html" target="_blank" rel="noopener">https://www.javacodegeeks.com/2014/04/java-8-date-time-api-tutorial-localdatetime.html</a></p></blockquote><h1 id="Optional-类"><a href="#Optional-类" class="headerlink" title="Optional 类"></a>Optional 类</h1><p>Optional 类是一个可以为null的容器对象。如果值存在则isPresent()方法会返回true，调用get()方法会返回该对象。</p><p>Optional 是个容器：它可以保存类型T的值，或者仅仅保存null。Optional提供很多有用的方法，这样我们就不用显式进行空值检测。</p><p>Optional 类的引入很好的解决空指针异常。</p><h2 id="类声明"><a href="#类声明" class="headerlink" title="类声明"></a>类声明</h2><p>以下是一个 <strong>java.util.Optional</strong> 类的声明：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Optional</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">Object</span></span></span><br></pre></td></tr></table></figure><h2 id="类方法"><a href="#类方法" class="headerlink" title="类方法"></a>类方法</h2><table><thead><tr><th style="text-align:left">序号</th><th style="text-align:left">方法 &amp; 描述</th></tr></thead><tbody><tr><td style="text-align:left">1</td><td style="text-align:left"><strong>static  Optional empty()</strong>返回空的 Optional 实例。</td></tr><tr><td style="text-align:left">2</td><td style="text-align:left"><strong>boolean equals(Object obj)</strong>判断其他对象是否等于 Optional。</td></tr><tr><td style="text-align:left">3</td><td style="text-align:left"><strong>Optional filter(Predicate predicate)</strong>如果值存在，并且这个值匹配给定的 predicate，返回一个Optional用以描述这个值，否则返回一个空的Optional。</td></tr><tr><td style="text-align:left">4</td><td style="text-align:left"><strong> Optional flatMap(Function&gt; mapper)</strong>如果值存在，返回基于Optional包含的映射方法的值，否则返回一个空的Optional</td></tr><tr><td style="text-align:left">5</td><td style="text-align:left"><strong>T get()</strong>如果在这个Optional中包含这个值，返回值，否则抛出异常：NoSuchElementException</td></tr><tr><td style="text-align:left">6</td><td style="text-align:left"><strong>int hashCode()</strong>返回存在值的哈希码，如果值不存在 返回 0。</td></tr><tr><td style="text-align:left">7</td><td style="text-align:left"><strong>void ifPresent(Consumer consumer)</strong>如果值存在则使用该值调用 consumer , 否则不做任何事情。</td></tr><tr><td style="text-align:left">8</td><td style="text-align:left"><strong>boolean isPresent()</strong>如果值存在则方法会返回true，否则返回 false。</td></tr><tr><td style="text-align:left">9</td><td style="text-align:left"><strong>Optional map(Function mapper)</strong>如果有值，则对其执行调用映射函数得到返回值。如果返回值不为 null，则创建包含映射返回值的Optional作为map方法返回值，否则返回空Optional。</td></tr><tr><td style="text-align:left">10</td><td style="text-align:left"><strong>static  Optional of(T value)</strong>返回一个指定非null值的Optional。</td></tr><tr><td style="text-align:left">11</td><td style="text-align:left"><strong>static  Optional ofNullable(T value)</strong>如果为非空，返回 Optional 描述的指定值，否则返回空的 Optional。</td></tr><tr><td style="text-align:left">12</td><td style="text-align:left"><strong>T orElse(T other)</strong>如果存在该值，返回值， 否则返回 other。</td></tr><tr><td style="text-align:left">13</td><td style="text-align:left"><strong>T orElseGet(Supplier other)</strong>如果存在该值，返回值， 否则触发 other，并返回 other 调用的结果。</td></tr><tr><td style="text-align:left">14</td><td style="text-align:left"><strong> T orElseThrow(Supplier exceptionSupplier)</strong>如果存在该值，返回包含的值，否则抛出由 Supplier 继承的异常</td></tr><tr><td style="text-align:left">15</td><td style="text-align:left"><strong>String toString()</strong>返回一个Optional的非空字符串，用来调试</td></tr></tbody></table><p><strong>注意：</strong> 这些方法是从 <strong>java.lang.Object</strong> 类继承来的。</p><h2 id="Optional实例"><a href="#Optional实例" class="headerlink" title="Optional实例"></a>Optional实例</h2><p>通过以下实例来更好的了解 Optional 类的使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OptionalDemo</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</span><br><span class="line">   </span><br><span class="line">      OptionalDemo optionalDemo = <span class="keyword">new</span> OptionalDemo();</span><br><span class="line">      Integer value1 = <span class="keyword">null</span>;</span><br><span class="line">      Integer value2 = <span class="keyword">new</span> Integer(<span class="number">10</span>);</span><br><span class="line">        </span><br><span class="line">      <span class="comment">// Optional.ofNullable - 允许传递为 null 参数</span></span><br><span class="line">      Optional&lt;Integer&gt; a = Optional.ofNullable(value1);</span><br><span class="line">        </span><br><span class="line">      <span class="comment">// Optional.of - 如果传递的参数是 null，抛出异常 NullPointerException</span></span><br><span class="line">      Optional&lt;Integer&gt; b = Optional.of(value2);</span><br><span class="line">      System.out.println(optionalDemo.sum(a,b));</span><br><span class="line">   &#125;</span><br><span class="line">    </span><br><span class="line">   <span class="function"><span class="keyword">public</span> Integer <span class="title">sum</span><span class="params">(Optional&lt;Integer&gt; a, Optional&lt;Integer&gt; b)</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">      <span class="comment">// Optional.isPresent - 判断值是否存在</span></span><br><span class="line">      System.out.println(<span class="string">"第一个参数值存在: "</span> + a.isPresent());</span><br><span class="line">      System.out.println(<span class="string">"第二个参数值存在: "</span> + b.isPresent());</span><br><span class="line">        </span><br><span class="line">      <span class="comment">// Optional.orElse - 如果值存在，返回它，否则返回默认值</span></span><br><span class="line">      Integer value1 = a.orElse(<span class="keyword">new</span> Integer(<span class="number">0</span>));</span><br><span class="line">        </span><br><span class="line">      <span class="comment">//Optional.get - 获取值，值需要存在</span></span><br><span class="line">      Integer value2 = b.get();</span><br><span class="line">      <span class="keyword">return</span> value1 + value2;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>output</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; 第一个参数值存在: false</span><br><span class="line">&gt; 第二个参数值存在: true</span><br><span class="line">&gt; 10</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://www.jianshu.com/p/5b800057f2d8" target="_blank" rel="noopener">https://www.jianshu.com/p/5b800057f2d8</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Java 8 (又称为 jdk 1.8) 是 Java 语言开发的一个主要版本。 Oracle 公司于 2014 年 3 月 18 日发布 Java 8 ，它支持函数式编程，新的 JavaScript 引擎，新的日期 API，新的Stream API 等。&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="http://hackycy.github.io/categories/Java/"/>
    
    
      <category term="Java" scheme="http://hackycy.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>i18n（国际化）地域标识码</title>
    <link href="http://hackycy.github.io/2019/12/16/i18n%EF%BC%88%E5%9B%BD%E9%99%85%E5%8C%96%EF%BC%89%E5%9C%B0%E5%9F%9F%E6%A0%87%E8%AF%86%E7%A0%81/"/>
    <id>http://hackycy.github.io/2019/12/16/i18n（国际化）地域标识码/</id>
    <published>2019-12-16T09:00:27.000Z</published>
    <updated>2020-01-18T08:13:02.376Z</updated>
    
    <content type="html"><![CDATA[<p>i18n(国际化) 和l18n(本地化)时的地域标识代码 格式如 zh-CN(语言-国家)</p><a id="more"></a><table><thead><tr><th style="text-align:left">国家</th><th style="text-align:left">语言</th><th style="text-align:left">语言编码</th><th style="text-align:left">国家编码</th></tr></thead><tbody><tr><td style="text-align:left">中国</td><td style="text-align:left">汉语</td><td style="text-align:left">zh</td><td style="text-align:left">CN</td></tr><tr><td style="text-align:left">中国香港</td><td style="text-align:left"></td><td style="text-align:left">zh</td><td style="text-align:left">HK</td></tr><tr><td style="text-align:left">中国澳门</td><td style="text-align:left"></td><td style="text-align:left">zh</td><td style="text-align:left">MO</td></tr><tr><td style="text-align:left">中国台湾</td><td style="text-align:left"></td><td style="text-align:left">zh</td><td style="text-align:left">TW</td></tr><tr><td style="text-align:left">新加坡</td><td style="text-align:left">汉语</td><td style="text-align:left">zh</td><td style="text-align:left">SG</td></tr><tr><td style="text-align:left">中国简体中文</td><td style="text-align:left">zh-CHS</td><td style="text-align:left"></td><td style="text-align:left"></td></tr><tr><td style="text-align:left">中国繁体中文</td><td style="text-align:left">zh-CHT</td><td style="text-align:left"></td><td style="text-align:left"></td></tr><tr><td style="text-align:left">英国</td><td style="text-align:left">英语</td><td style="text-align:left">en</td><td style="text-align:left">GB</td></tr><tr><td style="text-align:left">美国</td><td style="text-align:left">英语</td><td style="text-align:left">en</td><td style="text-align:left">US</td></tr><tr><td style="text-align:left">俄罗斯</td><td style="text-align:left">俄罗斯 Tatar 语</td><td style="text-align:left">tt</td><td style="text-align:left">RU</td></tr><tr><td style="text-align:left">俄罗斯</td><td style="text-align:left">俄罗斯语</td><td style="text-align:left">ru</td><td style="text-align:left">RU</td></tr><tr><td style="text-align:left">德国</td><td style="text-align:left">德语</td><td style="text-align:left">de</td><td style="text-align:left">DE</td></tr><tr><td style="text-align:left">瑞士</td><td style="text-align:left">德语</td><td style="text-align:left">de</td><td style="text-align:left">CH</td></tr><tr><td style="text-align:left">卢森堡</td><td style="text-align:left">德语</td><td style="text-align:left">de</td><td style="text-align:left">LU</td></tr><tr><td style="text-align:left">奥地利</td><td style="text-align:left">德语</td><td style="text-align:left">de</td><td style="text-align:left">AT</td></tr><tr><td style="text-align:left">列支敦士登</td><td style="text-align:left">德语</td><td style="text-align:left">de</td><td style="text-align:left">LI</td></tr><tr><td style="text-align:left">加拿大</td><td style="text-align:left">法语</td><td style="text-align:left">fr</td><td style="text-align:left">CA</td></tr><tr><td style="text-align:left">法国</td><td style="text-align:left">法语</td><td style="text-align:left">fr</td><td style="text-align:left">FR</td></tr><tr><td style="text-align:left">卢森堡</td><td style="text-align:left">法语</td><td style="text-align:left">fr</td><td style="text-align:left">LU</td></tr><tr><td style="text-align:left">比利时</td><td style="text-align:left">法语</td><td style="text-align:left">fr</td><td style="text-align:left">BE</td></tr><tr><td style="text-align:left">摩纳哥</td><td style="text-align:left">法语</td><td style="text-align:left">fr</td><td style="text-align:left">MC</td></tr><tr><td style="text-align:left">瑞士</td><td style="text-align:left">法语</td><td style="text-align:left">fr</td><td style="text-align:left">CH</td></tr><tr><td style="text-align:left">意大利</td><td style="text-align:left">意大利</td><td style="text-align:left">it</td><td style="text-align:left">IT</td></tr><tr><td style="text-align:left">日本</td><td style="text-align:left">日语</td><td style="text-align:left">ja</td><td style="text-align:left">JP</td></tr><tr><td style="text-align:left">韩国</td><td style="text-align:left">韩国</td><td style="text-align:left">ko</td><td style="text-align:left">KR</td></tr><tr><td style="text-align:left">哈萨克</td><td style="text-align:left">哈萨克(Kazakh)</td><td style="text-align:left">kk</td><td style="text-align:left">KZ</td></tr><tr><td style="text-align:left">芬兰</td><td style="text-align:left">芬兰语</td><td style="text-align:left">fi</td><td style="text-align:left">FI</td></tr><tr><td style="text-align:left">瑞典</td><td style="text-align:left">芬兰语</td><td style="text-align:left">sv</td><td style="text-align:left">FI</td></tr><tr><td style="text-align:left">瑞典</td><td style="text-align:left">瑞典语</td><td style="text-align:left">sv</td><td style="text-align:left">SE</td></tr><tr><td style="text-align:left">匈牙利</td><td style="text-align:left">匈牙利</td><td style="text-align:left">hu</td><td style="text-align:left">HU</td></tr><tr><td style="text-align:left">冰岛</td><td style="text-align:left">冰岛</td><td style="text-align:left">is</td><td style="text-align:left">IS</td></tr><tr><td style="text-align:left">印尼</td><td style="text-align:left">印尼</td><td style="text-align:left">id</td><td style="text-align:left">ID</td></tr><tr><td style="text-align:left">瑞士</td><td style="text-align:left">意大利</td><td style="text-align:left">it</td><td style="text-align:left">CH</td></tr><tr><td style="text-align:left">土耳其</td><td style="text-align:left">土耳其语</td><td style="text-align:left">tr</td><td style="text-align:left">TR</td></tr><tr><td style="text-align:left">乌克兰</td><td style="text-align:left">乌克兰语</td><td style="text-align:left">uk</td><td style="text-align:left">UA</td></tr><tr><td style="text-align:left">巴基斯坦</td><td style="text-align:left">巴基斯坦 Urdu 语</td><td style="text-align:left">ur</td><td style="text-align:left">PK</td></tr><tr><td style="text-align:left">加拿大</td><td style="text-align:left">英语</td><td style="text-align:left">en</td><td style="text-align:left">CA</td></tr><tr><td style="text-align:left">爱尔兰</td><td style="text-align:left">英语</td><td style="text-align:left">en</td><td style="text-align:left">IE</td></tr><tr><td style="text-align:left">捷克</td><td style="text-align:left">捷克</td><td style="text-align:left">cs</td><td style="text-align:left">CZ</td></tr><tr><td style="text-align:left">瑞士</td><td style="text-align:left">法语</td><td style="text-align:left">fr</td><td style="text-align:left">CH</td></tr><tr><td style="text-align:left">加勒比海</td><td style="text-align:left">英语</td><td style="text-align:left">en</td><td style="text-align:left">CB</td></tr><tr><td style="text-align:left">澳洲</td><td style="text-align:left">英语</td><td style="text-align:left">en</td><td style="text-align:left">AU</td></tr><tr><td style="text-align:left">新西兰</td><td style="text-align:left">英语</td><td style="text-align:left">en</td><td style="text-align:left">NZ</td></tr><tr><td style="text-align:left">比利时</td><td style="text-align:left">法语</td><td style="text-align:left">fr</td><td style="text-align:left">BE</td></tr><tr><td style="text-align:left">菲律宾</td><td style="text-align:left">英语</td><td style="text-align:left">en</td><td style="text-align:left">PH</td></tr><tr><td style="text-align:left">牙买加</td><td style="text-align:left">英语</td><td style="text-align:left">en</td><td style="text-align:left">JM</td></tr><tr><td style="text-align:left">伯利兹</td><td style="text-align:left">英语</td><td style="text-align:left">en</td><td style="text-align:left">BZ</td></tr><tr><td style="text-align:left">千里达托贝哥共和国英语</td><td style="text-align:left"></td><td style="text-align:left">en</td><td style="text-align:left">TT</td></tr><tr><td style="text-align:left">津巴布韦</td><td style="text-align:left">英语</td><td style="text-align:left">en</td><td style="text-align:left">ZW</td></tr><tr><td style="text-align:left">爱沙尼亚</td><td style="text-align:left">爱沙尼亚</td><td style="text-align:left">et</td><td style="text-align:left">EE</td></tr><tr><td style="text-align:left">法罗群岛</td><td style="text-align:left">法罗语(Faroese)</td><td style="text-align:left">fo</td><td style="text-align:left">FO</td></tr><tr><td style="text-align:left">摩纳哥</td><td style="text-align:left">法语</td><td style="text-align:left">fr</td><td style="text-align:left">MC</td></tr><tr><td style="text-align:left">西班牙</td><td style="text-align:left">西班牙语</td><td style="text-align:left">es</td><td style="text-align:left">ES</td></tr><tr><td style="text-align:left">阿根廷</td><td style="text-align:left">西班牙语</td><td style="text-align:left">es</td><td style="text-align:left">AR</td></tr><tr><td style="text-align:left">墨西哥</td><td style="text-align:left">西班牙语</td><td style="text-align:left">es</td><td style="text-align:left">MX</td></tr><tr><td style="text-align:left">玻利维亚</td><td style="text-align:left">西班牙语</td><td style="text-align:left">es</td><td style="text-align:left">BO</td></tr><tr><td style="text-align:left">智利</td><td style="text-align:left">西班牙语</td><td style="text-align:left">es</td><td style="text-align:left">CL</td></tr><tr><td style="text-align:left">巴拿马</td><td style="text-align:left">西班牙语</td><td style="text-align:left">es</td><td style="text-align:left">PA</td></tr><tr><td style="text-align:left">委内瑞拉</td><td style="text-align:left">西班牙语</td><td style="text-align:left">es</td><td style="text-align:left">VE</td></tr><tr><td style="text-align:left">哥伦比亚</td><td style="text-align:left">西班牙语</td><td style="text-align:left">es</td><td style="text-align:left">CO</td></tr><tr><td style="text-align:left">秘鲁</td><td style="text-align:left">西班牙语</td><td style="text-align:left">es</td><td style="text-align:left">PE</td></tr><tr><td style="text-align:left">哥斯达黎加</td><td style="text-align:left">西班牙语</td><td style="text-align:left">es</td><td style="text-align:left">CR</td></tr><tr><td style="text-align:left">多米尼加共和国</td><td style="text-align:left">西班牙语</td><td style="text-align:left">es</td><td style="text-align:left">DO</td></tr><tr><td style="text-align:left">厄瓜多尔</td><td style="text-align:left">西班牙语</td><td style="text-align:left">es</td><td style="text-align:left">EC</td></tr><tr><td style="text-align:left">萨尔瓦多</td><td style="text-align:left">西班牙语</td><td style="text-align:left">es</td><td style="text-align:left">SV</td></tr><tr><td style="text-align:left">危地马拉</td><td style="text-align:left">西班牙语</td><td style="text-align:left">es</td><td style="text-align:left">GT</td></tr><tr><td style="text-align:left">洪都拉斯</td><td style="text-align:left">西班牙语</td><td style="text-align:left">es</td><td style="text-align:left">HN</td></tr><tr><td style="text-align:left">尼加拉瓜</td><td style="text-align:left">西班牙语</td><td style="text-align:left">es</td><td style="text-align:left">NI</td></tr><tr><td style="text-align:left">巴拉圭</td><td style="text-align:left">西班牙语</td><td style="text-align:left">es</td><td style="text-align:left">PY</td></tr><tr><td style="text-align:left">波多黎各</td><td style="text-align:left">西班牙语</td><td style="text-align:left">es</td><td style="text-align:left">PR</td></tr><tr><td style="text-align:left">乌拉圭</td><td style="text-align:left">西班牙语</td><td style="text-align:left">es</td><td style="text-align:left">UY</td></tr><tr><td style="text-align:left">印度</td><td style="text-align:left">坦米尔语</td><td style="text-align:left">ta</td><td style="text-align:left">IN</td></tr><tr><td style="text-align:left">印度</td><td style="text-align:left">印度语(Gujarati)</td><td style="text-align:left">gu</td><td style="text-align:left">IN</td></tr><tr><td style="text-align:left">印度</td><td style="text-align:left">北印度语</td><td style="text-align:left">hi</td><td style="text-align:left">IN</td></tr><tr><td style="text-align:left">印度</td><td style="text-align:left">卡纳达语</td><td style="text-align:left">kn</td><td style="text-align:left">IN</td></tr><tr><td style="text-align:left">印度</td><td style="text-align:left">Konkani</td><td style="text-align:left">kok</td><td style="text-align:left">IN</td></tr><tr><td style="text-align:left">印度</td><td style="text-align:left">马拉地语</td><td style="text-align:left">mr</td><td style="text-align:left">IN</td></tr><tr><td style="text-align:left">印度</td><td style="text-align:left">Punjab 语</td><td style="text-align:left">pa</td><td style="text-align:left">IN</td></tr><tr><td style="text-align:left">印度</td><td style="text-align:left">梵文</td><td style="text-align:left">sa</td><td style="text-align:left">IN</td></tr><tr><td style="text-align:left">印度</td><td style="text-align:left">印度 Telugu 语</td><td style="text-align:left">te</td><td style="text-align:left">IN</td></tr><tr><td style="text-align:left">挪威</td><td style="text-align:left">挪威</td><td style="text-align:left">nb</td><td style="text-align:left">NO</td></tr><tr><td style="text-align:left">挪威</td><td style="text-align:left">挪威(Nynorsk)</td><td style="text-align:left">nn</td><td style="text-align:left">NO</td></tr><tr><td style="text-align:left">波兰</td><td style="text-align:left">波兰</td><td style="text-align:left">pl</td><td style="text-align:left">PL</td></tr><tr><td style="text-align:left">巴西</td><td style="text-align:left">葡萄牙语</td><td style="text-align:left">pt</td><td style="text-align:left">BR</td></tr><tr><td style="text-align:left">葡萄牙</td><td style="text-align:left">葡萄牙语</td><td style="text-align:left">pt</td><td style="text-align:left">PT</td></tr><tr><td style="text-align:left">越南</td><td style="text-align:left">越南语</td><td style="text-align:left">vi</td><td style="text-align:left">VN</td></tr><tr><td style="text-align:left">泰国</td><td style="text-align:left">泰语</td><td style="text-align:left">th</td><td style="text-align:left">TH</td></tr><tr><td style="text-align:left">南非</td><td style="text-align:left">英语</td><td style="text-align:left">en</td><td style="text-align:left">ZA</td></tr><tr><td style="text-align:left">南非</td><td style="text-align:left">公用荷兰语</td><td style="text-align:left">af</td><td style="text-align:left">ZA</td></tr><tr><td style="text-align:left">白俄罗斯</td><td style="text-align:left">白俄罗斯语(Belarusian)</td><td style="text-align:left">be</td><td style="text-align:left">BY</td></tr><tr><td style="text-align:left">伊朗王国</td><td style="text-align:left">波斯语</td><td style="text-align:left">fa</td><td style="text-align:left">IR</td></tr><tr><td style="text-align:left">以色列</td><td style="text-align:left">希伯来文</td><td style="text-align:left">he</td><td style="text-align:left">IL</td></tr><tr><td style="text-align:left">丹麦</td><td style="text-align:left">丹麦</td><td style="text-align:left">da</td><td style="text-align:left">DK</td></tr><tr><td style="text-align:left">马尔代夫</td><td style="text-align:left">马尔代夫(Dhivehi)</td><td style="text-align:left">div</td><td style="text-align:left">MV</td></tr><tr><td style="text-align:left">比利时</td><td style="text-align:left">荷兰语</td><td style="text-align:left">nl</td><td style="text-align:left">BE</td></tr><tr><td style="text-align:left">荷兰</td><td style="text-align:left">荷兰语</td><td style="text-align:left">nl</td><td style="text-align:left">NL</td></tr><tr><td style="text-align:left">希腊</td><td style="text-align:left">希腊</td><td style="text-align:left">el</td><td style="text-align:left">GR</td></tr><tr><td style="text-align:left">沙特阿拉伯</td><td style="text-align:left">阿拉伯语</td><td style="text-align:left">ar</td><td style="text-align:left">SA</td></tr><tr><td style="text-align:left">埃及</td><td style="text-align:left">阿拉伯语</td><td style="text-align:left">ar</td><td style="text-align:left">EG</td></tr><tr><td style="text-align:left">伊拉克</td><td style="text-align:left">阿拉伯语</td><td style="text-align:left">ar</td><td style="text-align:left">IQ</td></tr><tr><td style="text-align:left">约旦</td><td style="text-align:left">阿拉伯语</td><td style="text-align:left">ar</td><td style="text-align:left">JO</td></tr><tr><td style="text-align:left">科威特</td><td style="text-align:left">阿拉伯语</td><td style="text-align:left">ar</td><td style="text-align:left">KW</td></tr><tr><td style="text-align:left">黎巴嫩</td><td style="text-align:left">阿拉伯语</td><td style="text-align:left">ar</td><td style="text-align:left">LB</td></tr><tr><td style="text-align:left">利比亚</td><td style="text-align:left">阿拉伯语</td><td style="text-align:left">ar</td><td style="text-align:left">LY</td></tr><tr><td style="text-align:left">卡塔尔</td><td style="text-align:left">阿拉伯语</td><td style="text-align:left">ar</td><td style="text-align:left">QA</td></tr><tr><td style="text-align:left">叙利亚共和国</td><td style="text-align:left">阿拉伯语</td><td style="text-align:left">ar</td><td style="text-align:left">SY</td></tr><tr><td style="text-align:left">叙利亚共和国</td><td style="text-align:left">叙利亚语(Syriac)</td><td style="text-align:left">syr</td><td style="text-align:left">SY</td></tr><tr><td style="text-align:left">保加利亚</td><td style="text-align:left">保加利亚</td><td style="text-align:left">bg</td><td style="text-align:left">BG</td></tr><tr><td style="text-align:left">阿尔巴尼亚</td><td style="text-align:left">阿尔巴尼亚</td><td style="text-align:left">sq</td><td style="text-align:left">AL</td></tr><tr><td style="text-align:left">阿尔及利亚</td><td style="text-align:left">阿拉伯语</td><td style="text-align:left">ar</td><td style="text-align:left">DZ</td></tr><tr><td style="text-align:left">巴林</td><td style="text-align:left">阿拉伯语</td><td style="text-align:left">ar</td><td style="text-align:left">BH</td></tr><tr><td style="text-align:left">摩洛哥</td><td style="text-align:left">阿拉伯语</td><td style="text-align:left">ar</td><td style="text-align:left">MA</td></tr><tr><td style="text-align:left">阿曼</td><td style="text-align:left">阿拉伯语</td><td style="text-align:left">ar</td><td style="text-align:left">OM</td></tr><tr><td style="text-align:left">北非的共和国</td><td style="text-align:left">阿拉伯语</td><td style="text-align:left">ar</td><td style="text-align:left">TN</td></tr><tr><td style="text-align:left">阿拉伯联合酋长国</td><td style="text-align:left">阿拉伯语</td><td style="text-align:left">ar</td><td style="text-align:left">AE</td></tr><tr><td style="text-align:left">也门</td><td style="text-align:left">阿拉伯语</td><td style="text-align:left">ar</td><td style="text-align:left">YE</td></tr><tr><td style="text-align:left">亚美尼亚</td><td style="text-align:left">亚美尼亚语</td><td style="text-align:left">hy</td><td style="text-align:left">AM</td></tr><tr><td style="text-align:left">巴斯克</td><td style="text-align:left">巴斯克</td><td style="text-align:left">eu</td><td style="text-align:left">ES</td></tr><tr><td style="text-align:left">嘉泰罗尼亚</td><td style="text-align:left">嘉泰罗尼亚</td><td style="text-align:left">ca</td><td style="text-align:left">ES</td></tr><tr><td style="text-align:left">肯尼亚</td><td style="text-align:left">肯尼亚(Swahili)语</td><td style="text-align:left">sw</td><td style="text-align:left">KE</td></tr><tr><td style="text-align:left">克罗埃西亚</td><td style="text-align:left">克罗埃西亚</td><td style="text-align:left">hr</td><td style="text-align:left">HR</td></tr><tr><td style="text-align:left">加利西亚</td><td style="text-align:left">加利西亚</td><td style="text-align:left">gl</td><td style="text-align:left">ES</td></tr><tr><td style="text-align:left">格鲁吉亚州</td><td style="text-align:left">格鲁吉亚州</td><td style="text-align:left">ka</td><td style="text-align:left">GE</td></tr><tr><td style="text-align:left">哈萨克</td><td style="text-align:left">Kyrgyz</td><td style="text-align:left">ky</td><td style="text-align:left">KZ</td></tr><tr><td style="text-align:left">拉脱维亚</td><td style="text-align:left">拉脱维亚</td><td style="text-align:left">lv</td><td style="text-align:left">LV</td></tr><tr><td style="text-align:left">立陶宛</td><td style="text-align:left">立陶宛</td><td style="text-align:left">lt</td><td style="text-align:left">LT</td></tr><tr><td style="text-align:left">马其顿</td><td style="text-align:left">马其顿</td><td style="text-align:left">mk</td><td style="text-align:left">MK</td></tr><tr><td style="text-align:left">汶莱</td><td style="text-align:left">马来语</td><td style="text-align:left">ms</td><td style="text-align:left">BN</td></tr><tr><td style="text-align:left">马来西亚</td><td style="text-align:left">马来西亚语</td><td style="text-align:left">ms</td><td style="text-align:left">MY</td></tr><tr><td style="text-align:left">蒙古</td><td style="text-align:left">蒙古</td><td style="text-align:left">mn</td><td style="text-align:left">MN</td></tr><tr><td style="text-align:left">罗马尼亚</td><td style="text-align:left">罗马尼亚语</td><td style="text-align:left">ro</td><td style="text-align:left">RO</td></tr><tr><td style="text-align:left">塞尔维亚(西里尔字母的)</td><td style="text-align:left">sr-SP-Cyrl</td><td style="text-align:left"></td><td style="text-align:left"></td></tr><tr><td style="text-align:left">塞尔(拉丁文)</td><td style="text-align:left">sr-SP-Latn</td><td style="text-align:left"></td><td style="text-align:left"></td></tr><tr><td style="text-align:left">斯洛伐克</td><td style="text-align:left">斯洛伐克</td><td style="text-align:left">sk</td><td style="text-align:left">SK</td></tr><tr><td style="text-align:left">斯洛文尼亚</td><td style="text-align:left">斯洛文尼亚</td><td style="text-align:left">sl</td><td style="text-align:left">SI</td></tr><tr><td style="text-align:left">乌兹别克</td><td style="text-align:left">乌兹别克(西里尔字母的)</td><td style="text-align:left">uz</td><td style="text-align:left">uz-UZ-Cyrl</td></tr><tr><td style="text-align:left">乌兹别克</td><td style="text-align:left">乌兹别克(拉丁文的)</td><td style="text-align:left">uz</td><td style="text-align:left">UZ-Latn</td></tr><tr><td style="text-align:left">塞浦路斯</td><td style="text-align:left">希腊文</td><td style="text-align:left">el</td><td style="text-align:left">CY</td></tr><tr><td style="text-align:left">英语(全球)</td><td style="text-align:left">en-WW</td><td style="text-align:left"></td></tr></tbody></table><blockquote><p>内容转载于<a href="https://www.cnblogs.com/isdom/p/webclips009.html" target="_blank" rel="noopener">https://www.cnblogs.com/isdom/p/webclips009.html</a></p></blockquote><p>更为详细的一个表格：</p><table><thead><tr><th>Language</th><th>English Name</th><th>Chinese Name</th><th>Code</th><th>GB</th><th>ICS</th><th>JB</th><th>KK</th></tr></thead><tbody><tr><td>العربية</td><td>Arabic(Israel)</td><td>阿拉伯语(以色列)</td><td>ar_IL</td><td>Y</td><td>Y</td><td>Y</td><td>Y</td></tr><tr><td></td><td>Arabic(Egypt)</td><td>阿拉伯语(埃及)</td><td>ar_EG</td><td>GD_MN</td><td>GD_MN</td><td>GD_MN</td><td>GD_MN</td></tr><tr><td>中文</td><td>Chinese Simplified</td><td>中文简体</td><td>zh_TW</td><td>Y</td><td>Y</td><td>Y</td><td>Y</td></tr><tr><td></td><td>Chinese Tradition</td><td>中文繁体</td><td>zh_CN</td><td>Y</td><td>Y</td><td>Y</td><td>Y</td></tr><tr><td></td><td>Chinese</td><td>中文(香港)</td><td>zh_HK</td><td>N</td><td>N</td><td>P</td><td>P</td></tr><tr><td>Nederlands</td><td>Dutch (Netherlands)</td><td>荷兰语</td><td>nl_NL</td><td>Y</td><td>Y</td><td>Y</td><td>Y</td></tr><tr><td></td><td>Dutch (Netherlands)</td><td>荷兰语(比利时)</td><td>nl_BE</td><td>GD_MN</td><td>GD_MN</td><td>GD_MN</td><td>GD_MN</td></tr><tr><td>English</td><td>English(United States)</td><td>英语(美国)</td><td>en_US</td><td>Y</td><td>Y</td><td>Y</td><td>Y</td></tr><tr><td></td><td>English(Australia)</td><td>英语(澳大利亚)</td><td>en_AU</td><td>GD_MN</td><td>GD_MN</td><td>GD_MN</td><td>GD_MN</td></tr><tr><td></td><td>English(Canada)</td><td>英语(加拿大)</td><td>en_CA</td><td>GD_MN</td><td>GD_MN</td><td>GD_MN</td><td>GD_MN</td></tr><tr><td></td><td>English(India)</td><td>英语(印度)</td><td>en_IN</td><td>GD_MN</td><td>GD_MN</td><td>GD_MN</td><td>GD_MN</td></tr><tr><td></td><td>English(Ireland)</td><td>英语(爱尔兰)</td><td>en_IE</td><td>GD_MN</td><td>GD_MN</td><td>GD_MN</td><td>GD_MN</td></tr><tr><td></td><td>English(New Zealand)</td><td>英语(新西兰)</td><td>en_NZ</td><td>GD_MN</td><td>GD_MN</td><td>GD_MN</td><td>GD_MN</td></tr><tr><td></td><td>English(Singapore)</td><td>英语(新加波)</td><td>en_SG</td><td>GD_MN</td><td>GD_MN</td><td>GD_MN</td><td>GD_MN</td></tr><tr><td></td><td>English(South Africa)</td><td>英语(南非)</td><td>en_ZA</td><td>GD_MN</td><td>GD_MN</td><td>GD_MN</td><td>GD_MN</td></tr><tr><td></td><td>English(United Kingdom)</td><td>英语(英国)</td><td>en_GB</td><td>GD_MN</td><td>GD_MN</td><td>GD_MN</td><td>Y</td></tr><tr><td>Français</td><td>French</td><td>法语</td><td>fr_FR</td><td>Y</td><td>Y</td><td>Y</td><td>Y</td></tr><tr><td></td><td>French</td><td>法语(比利时)</td><td>fr_BE</td><td>GD_MN</td><td>GD_MN</td><td>GD_MN</td><td>GD_MN</td></tr><tr><td></td><td>French</td><td>法语(加拿大)</td><td>fr_CA</td><td>GD_MN</td><td>GD_MN</td><td>GD_MN</td><td>GD_MN</td></tr><tr><td></td><td>French</td><td>法语(瑞士)</td><td>fr_CH</td><td>GD_MN</td><td>GD_MN</td><td>GD_MN</td><td>GD_MN</td></tr><tr><td>Deutsch</td><td>German</td><td>德语</td><td>de_DE</td><td>Y</td><td>Y</td><td>Y</td><td>Y</td></tr><tr><td></td><td>German</td><td>德语(列支敦斯登)</td><td>de_LI</td><td>GD_MN</td><td>GD_MN</td><td>GD_MN</td><td>GD_MN</td></tr><tr><td></td><td>German</td><td>德语(奥地利)</td><td>de_AT</td><td>GD_MN</td><td>GD_MN</td><td>GD_MN</td><td>Y</td></tr><tr><td></td><td>German</td><td>德语(瑞士)</td><td>de_CH</td><td>GD_MN</td><td>GD_MN</td><td>GD_MN</td><td>GD_MN</td></tr><tr><td>Italiano</td><td>Italian</td><td>意大利语</td><td>it_IT</td><td>Y</td><td>Y</td><td>Y</td><td>Y</td></tr><tr><td></td><td>Italian</td><td>意大利语(瑞士)</td><td>it_CH</td><td>GD_MN</td><td>GD_MN</td><td>GD_MN</td><td>GD_MN</td></tr><tr><td>Protuguês</td><td>Portuguese</td><td>葡萄牙语（巴西）</td><td>pt_BR</td><td>Y</td><td>Y</td><td>Y</td><td>Y</td></tr><tr><td></td><td>Portuguese</td><td>葡萄牙语</td><td>pt_PT</td><td>Y</td><td>Y</td><td>Y</td><td>Y</td></tr><tr><td>Español</td><td>Spanish</td><td>西班牙语</td><td>es_ES</td><td>Y</td><td>Y</td><td>Y</td><td>Y</td></tr><tr><td></td><td>Spanish</td><td>西班牙语(美国)</td><td>es_US</td><td>GD_MN</td><td>GD_MN</td><td>P</td><td>Y</td></tr><tr><td>বাংলা</td><td>Bengali</td><td>孟加拉语</td><td>bn_BD</td><td>Y</td><td>N</td><td>N</td><td>N</td></tr><tr><td></td><td>Bengali</td><td>孟加拉语(印度)</td><td>bn_IN</td><td>Y</td><td>Y</td><td>Y</td><td>Y</td></tr><tr><td>hrvatski</td><td>Croatian</td><td>克罗地亚语</td><td>hr_HR</td><td>GD_MN</td><td>GD_MN</td><td>P</td><td>Y</td></tr><tr><td>čeština</td><td>Czech</td><td>捷克语</td><td>cs_CZ</td><td>Y</td><td>Y</td><td>Y</td><td>Y</td></tr><tr><td>Dansk</td><td>Danish</td><td>丹麦语</td><td>da_DK</td><td>GD_MN</td><td>GD_MN</td><td>P</td><td>Y</td></tr><tr><td>ελληνικά</td><td>Greek</td><td>希腊语</td><td>el_GR</td><td>GD_MN</td><td>Y</td><td>Y</td><td>Y</td></tr><tr><td>עברית</td><td>Hebrew</td><td>希伯来语(以色列)</td><td>he_IL</td><td>GD_MN</td><td>GD_MN</td><td>GD_MN</td><td>GD_MN</td></tr><tr><td></td><td>Hebrew</td><td>希伯来语(以色列)</td><td>iw_IL</td><td>GD_MN</td><td>GD_MN</td><td>Y</td><td>Y</td></tr><tr><td>हिंदी</td><td>Hindi</td><td>印度语</td><td>hi_IN</td><td>Y</td><td>Y</td><td>Y</td><td>Y</td></tr><tr><td>Magyar</td><td>Hungarian</td><td>匈牙利语</td><td>hu_HU</td><td>GD_MN</td><td>Y</td><td>Y</td><td>Y</td></tr><tr><td></td><td>Indonesian</td><td>印度尼西亚语</td><td>in_ID</td><td>Y</td><td>Y</td><td>Y</td><td>Y</td></tr><tr><td>日本語の言語</td><td>Japanese</td><td>日语</td><td>ja_JP</td><td>GD_MN</td><td>GD_MN</td><td>P</td><td>P</td></tr><tr><td>한국의</td><td>Korean</td><td>韩语（朝鲜语）</td><td>ko_KR</td><td>GD_MN</td><td>GD_MN</td><td>Y</td><td>Y</td></tr><tr><td>Bahasa Melayu</td><td>Malay</td><td>马来语</td><td>ms_MY</td><td>Y</td><td>Y</td><td>Y</td><td>Y</td></tr><tr><td>فارسی</td><td>Perisan</td><td>波斯语</td><td>fa_IR</td><td>Y</td><td>Y</td><td>Y</td><td>Y</td></tr><tr><td>Polski</td><td>Polish</td><td>波兰语</td><td>pl_PL</td><td>GD_MN</td><td>GD_MN</td><td>P</td><td>Y</td></tr><tr><td>româna</td><td>Romanian</td><td>罗马尼亚语</td><td>ro_RO</td><td>GD_MN</td><td>Y</td><td>Y</td><td>Y</td></tr><tr><td>Русский</td><td>Russian</td><td>俄罗斯语</td><td>ru_RU</td><td>Y</td><td>Y</td><td>Y</td><td>Y</td></tr><tr><td>српски</td><td>Serbian</td><td>塞尔维亚语</td><td>sr_RS</td><td>GD_MN</td><td>GD_MN</td><td>P</td><td>P</td></tr><tr><td>Svenska</td><td>Swedish</td><td>瑞典语</td><td>sv_SE</td><td>GD_MN</td><td>GD_MN</td><td>P</td><td>Y</td></tr><tr><td>ไทย</td><td>Thai</td><td>泰语</td><td>th_TH</td><td>Y</td><td>Y</td><td>Y</td><td>Y</td></tr><tr><td>Türkçe</td><td>Turkey</td><td>土耳其语</td><td>tr_TR</td><td>Y</td><td>Y</td><td>Y</td><td>Y</td></tr><tr><td>اردو</td><td>Urdu</td><td>乌尔都语</td><td>ur_PK</td><td>Y</td><td>Y</td><td>Y</td><td>Y</td></tr><tr><td>tiếng việt</td><td>Vietnamese</td><td>越南语</td><td>vi_VN</td><td>Y</td><td>Y</td><td>Y</td><td>Y</td></tr><tr><td>catalá</td><td>Catalan</td><td>加泰隆语(西班牙)</td><td>ca_ES</td><td>GD_MN</td><td>GD_MN</td><td>P</td><td>P</td></tr><tr><td>latviešu</td><td>Latviesu</td><td>拉脱维亚语</td><td>lv_LV</td><td>GD_MN</td><td>GD_MN</td><td>P</td><td>Y</td></tr><tr><td>Lietuvių</td><td>Lithuanian</td><td>立陶宛语</td><td>lt_LT</td><td>GD_MN</td><td>GD_MN</td><td>P</td><td>Y</td></tr><tr><td>Norsk bokmal</td><td>Norwegian</td><td>挪威语</td><td>nb_NO</td><td>GD_MN</td><td>GD_MN</td><td>P</td><td>Y</td></tr><tr><td>Slovenčina</td><td>slovencina</td><td>斯洛伐克语</td><td>sk_SK</td><td>GD_MN</td><td>GD_MN</td><td>P</td><td>Y</td></tr><tr><td>Slovenščina</td><td>Slovenian</td><td>斯洛文尼亚语</td><td>sl_SI</td><td>GD_MN</td><td>GD_MN</td><td>P</td><td>P</td></tr><tr><td>български</td><td>bulgarian</td><td>保加利亚语</td><td>bg_BG</td><td>GD_MN</td><td>GD_MN</td><td>P</td><td>Y</td></tr><tr><td>українська</td><td>Ukrainian</td><td>乌克兰语</td><td>uk_UA</td><td>GD_MN</td><td>GD_MN</td><td>P</td><td>Y</td></tr><tr><td>Tagalog</td><td>Filipino</td><td>菲律宾语</td><td>tl_PH</td><td>GD_MN</td><td>Y</td><td>Y</td><td>Y</td></tr><tr><td>Suomi</td><td>Finnish</td><td>芬兰语</td><td>fi_FI</td><td>GD_MN</td><td>GD_MN</td><td>P</td><td>Y</td></tr><tr><td>Afrikaans</td><td>Afrikaans</td><td>南非语</td><td>af_ZA</td><td>N</td><td>GD_MN</td><td>GD_MN</td><td>GD_MN</td></tr><tr><td>Rumantsch</td><td>Romansh</td><td>罗曼什语(瑞士)</td><td>rm_CH</td><td>GD_MN</td><td>GD_MN</td><td>GD_MN</td><td>GD_MN</td></tr><tr><td>ဗမာ</td><td>Burmese(Zawgyi)</td><td>缅甸语(民间)</td><td>my_ZG</td><td>N</td><td>N</td><td>P</td><td>P</td></tr><tr><td></td><td>Burmese(Paduak)</td><td>缅甸语(官方)</td><td>my_MM</td><td>N</td><td>N</td><td>Y</td><td>Y</td></tr><tr><td>មែរ</td><td>Khmer</td><td>柬埔寨语</td><td>km_KH</td><td>N</td><td>N</td><td>Y</td><td>Y</td></tr><tr><td>አማርኛ</td><td>Amharic</td><td>阿姆哈拉语(埃塞俄比亚)</td><td>am_ET</td><td>N</td><td>GD_MN</td><td>GD_MN</td><td>GD_MN</td></tr><tr><td>беларуская</td><td>Belarusian</td><td>白俄罗斯语</td><td>be_BY</td><td>N</td><td>GD_MN</td><td>GD_MN</td><td>GD_MN</td></tr><tr><td>eesti</td><td>Estonian</td><td>爱沙尼亚语</td><td>et_EE</td><td>N</td><td>GD_MN</td><td>P</td><td>P</td></tr><tr><td>Kiswahili</td><td>Swahili</td><td>斯瓦希里语(坦桑尼亚)</td><td>sw_TZ</td><td>N</td><td>GD_MN</td><td>GD_MN</td><td>GD_MN</td></tr><tr><td>isiZulu</td><td>Zulu</td><td>祖鲁语(南非)</td><td>zu_ZA</td><td>N</td><td>GD_MN</td><td>GD_MN</td><td>GD_MN</td></tr><tr><td>azərbaycanca</td><td>Azerbaijani</td><td>阿塞拜疆语</td><td>az_AZ</td><td>N</td><td>N</td><td>N</td><td>GD_MN</td></tr><tr><td>Հայերէն</td><td>Armenian</td><td>亚美尼亚语(亚美尼亚)</td><td>hy_AM</td><td>N</td><td>N</td><td>P</td><td>P</td></tr><tr><td>ქართული</td><td>Georgian</td><td>格鲁吉亚语(格鲁吉亚)</td><td>ka_GE</td><td>N</td><td>N</td><td>N</td><td>GD_MN</td></tr><tr><td>ລາວ</td><td>Laotian</td><td>老挝语(老挝)</td><td>lo_LA</td><td>N</td><td>N</td><td>N</td><td>GD_MN</td></tr><tr><td>Монгол</td><td>Mongolian</td><td>蒙古语</td><td>mn_MN</td><td>N</td><td>N</td><td>N</td><td>GD_MN</td></tr><tr><td>नेपाली</td><td>Nepali</td><td>尼泊尔语</td><td>ne_NP</td><td>N</td><td>N</td><td>N</td><td>GD_MN</td></tr><tr><td>қазақ тілі</td><td>Kazakh</td><td>哈萨克语</td><td>kk_KZ</td><td>N</td><td>N</td><td>P</td><td>P</td></tr><tr><td>සිංහල</td><td>Sinhala</td><td>僧加罗语(斯里兰卡)</td><td>si_LK</td><td>N</td><td>N</td><td>N</td><td>GD_MN</td></tr></tbody></table><blockquote><p>1、标记“N”表示当前版本不支持；标记“Y”表示mtk、google均支持；标记“GD_MN”表示Google默认支持，MTK不支持。<br>2、对于GD_MN，如果要支持的话，只需翻译mtk新增的部分字串就行。<br>3、如若打开或者添加语言，可以参考如下FAQ，<br>   如何打开一种语言：FAQ04326<br>4、标记“P”是mtk后面新支持的一些语言,如果要支持，可以通过PMS系统直接申请Patch，ALPS01686452  支持除民间缅甸语以外所有版本的多国语言（这个PATCH的民间缅甸语只支持KK.MP1 , KK.MP6 , KK.MP7）<br>5、关于民间缅甸语的情况<br>目前MTK JB3.MP,JB5.MP,JB9.MP,KK.MP1,KK.MP6已经可以支持Zawgyi。如果需要的话可以通过PMS系统申请patch,请按以下操作：<br>1).申请strings patch 和字库PATCH<br>   JBX:<br>      ALPS01561463<br>      ALPS01400558<br>      ALPS01444813<br>      ALPS01444868<br>KK.MP1 , KK.MP6 , KK.MP7<br>ALPS01686452<br>3).需要注意的是padauk(my_MM)和zawgyi(my_ZG)不能同时开,只能打开一个.<br>4)如果遇到访问一些缅甸语语网站时出现大量圈圈，可能是该网站是民间缅甸语网站，可以申请这些patch</p></blockquote><p>摘抄自：<a href="https://blog.csdn.net/ouyang_peng/article/details/50209789" target="_blank" rel="noopener">https://blog.csdn.net/ouyang_peng/article/details/50209789</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;i18n(国际化) 和l18n(本地化)时的地域标识代码 格式如 zh-CN(语言-国家)&lt;/p&gt;
    
    </summary>
    
      <category term="程序人生" scheme="http://hackycy.github.io/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/"/>
    
    
      <category term="i18n" scheme="http://hackycy.github.io/tags/i18n/"/>
    
  </entry>
  
  <entry>
    <title>网页布局之Flex布局</title>
    <link href="http://hackycy.github.io/2019/12/14/%E7%BD%91%E9%A1%B5%E5%B8%83%E5%B1%80%E4%B9%8BFlex%E5%B8%83%E5%B1%80/"/>
    <id>http://hackycy.github.io/2019/12/14/网页布局之Flex布局/</id>
    <published>2019-12-14T03:24:47.000Z</published>
    <updated>2019-12-15T09:03:57.121Z</updated>
    
    <content type="html"><![CDATA[<p>网页布局（layout）是 CSS 的一个重点应用。布局的传统解决方案，基于<a href="https://developer.mozilla.org/en-US/docs/Web/CSS/box_model" target="_blank" rel="noopener">盒状模型</a>，依赖 <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/display" target="_blank" rel="noopener"><code>display</code></a> 属性 + <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/position" target="_blank" rel="noopener"><code>position</code></a>属性 + <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/float" target="_blank" rel="noopener"><code>float</code></a>属性。它对于那些特殊布局非常不方便，比如，<a href="https://css-tricks.com/centering-css-complete-guide/" target="_blank" rel="noopener">垂直居中</a>就不容易实现。</p><a id="more"></a><p><img src="flexbg.png" alt></p><p>2009年，W3C 提出了一种新的方案—-Flex 布局，可以简便、完整、响应式地实现各种页面布局。目前，它已经得到了所有浏览器的支持，这意味着，现在就能很安全地使用这项功能。</p><p><img src="caniuseflex.png" alt></p><h1 id="Flex布局是什么"><a href="#Flex布局是什么" class="headerlink" title="Flex布局是什么"></a>Flex布局是什么</h1><p>Flex是Flexible Box的缩写。译为“弹性布局”，用来作为盒状模型提供最大的灵活性。</p><p>任何一个容器都可以指定为Flex布局。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span>&#123;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>行内元素也可以使用Flex布局。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span>&#123;</span><br><span class="line">  <span class="attribute">display</span>: inline-flex;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Webkit内核的浏览器，必须加上<code>-webkit</code>前缀。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span>&#123;</span><br><span class="line">  <span class="attribute">display</span>: -webkit-flex;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意，设为 Flex 布局以后，子元素的<code>float</code>、<code>clear</code>和<code>vertical-align</code>属性将失效。</p></blockquote><h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><p>采用 Flex 布局的元素，称为 Flex 容器（flex container），简称”容器”。它的所有子元素自动成为容器成员，称为 Flex 项目（flex item），简称”项目”。</p><p>我们把一个容器的 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/display" target="_blank" rel="noopener"><code>display</code></a> 属性值改为 <code>flex</code> 或者 <code>inline-flex</code> 完成这一步之后，容器中的直系子元素就会变为 <strong>flex 元素</strong>。所有CSS属性都会有一个初始值，所以 flex 容器中的所有 flex 元素都会有下列行为：</p><ul><li>元素排列为一行 (<code>flex-direction</code> 属性的初始值是 <code>row</code>)。</li><li>元素从主轴的起始线开始。</li><li>元素不会在主维度方向拉伸，但是可以缩小。</li><li>元素被拉伸来填充交叉轴大小。</li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/flex-basis" target="_blank" rel="noopener"><code>flex-basis</code></a> 属性为 <code>auto。</code></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/flex-wrap" target="_blank" rel="noopener"><code>flex-wrap</code></a> 属性为 <code>nowrap。</code></li></ul><p>容器默认存在两根轴：主轴和交叉轴。主轴由 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/flex-direction" target="_blank" rel="noopener"><code>flex-direction</code></a> 定义，另一根轴垂直于它。而Flexbox的所有属性都与这两根主轴有关。</p><h2 id="主轴"><a href="#主轴" class="headerlink" title="主轴"></a>主轴</h2><p>主轴（main axis）由<code>flex-direction</code>定义，可以取四个值。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flex-direction: column | column-reverse | row | row-reverse;</span><br></pre></td></tr></table></figure><blockquote><p>选择了 <code>row</code> 或者 <code>row-reverse</code>，你的主轴将沿着 <strong>inline</strong> 方向延伸。</p><p>选择 <code>column</code> 或者 <code>column-reverse</code> 时，你的主轴会沿着上下方向延伸 — 也就是 <strong>block 排列的方向。</strong></p></blockquote><h2 id="交叉轴"><a href="#交叉轴" class="headerlink" title="交叉轴"></a>交叉轴</h2><p>交叉轴（cross axis）垂直于主轴</p><blockquote><p><code>flex-direction</code> (主轴) 设成了 <code>row</code> 或者 <code>row-reverse</code> 的话，交叉轴的方向就是沿着列向下的。</p><p>主轴方向设成了 <code>column</code> 或者 <code>column-reverse</code>，交叉轴就是水平方向。</p></blockquote><h2 id="起始线和终止线"><a href="#起始线和终止线" class="headerlink" title="起始线和终止线"></a>起始线和终止线</h2><p>主轴的开始位置（与边框的交叉点）叫做<code>main start</code>，结束位置叫做<code>main end</code>；交叉轴的开始位置叫做<code>cross start</code>，结束位置叫做<code>cross end</code>。</p><p>项目默认沿主轴排列。单个项目占据的主轴空间叫做<code>main size</code>，占据的交叉轴空间叫做<code>cross size</code>。</p><p><img src="axis.png" alt></p><h1 id="容器的属性"><a href="#容器的属性" class="headerlink" title="容器的属性"></a>容器的属性</h1><p>以下6个属性设置在容器上。</p><ul><li>flex-direction</li><li>flex-wrap</li><li>flex-flow</li><li>justify-content</li><li>align-items</li><li>align-content</li></ul><h2 id="flex-direction属性"><a href="#flex-direction属性" class="headerlink" title="flex-direction属性"></a>flex-direction属性</h2><p><code>flex-direction</code>属性决定主轴的方向（即项目的排列方向）。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flex-direction: row | row-reverse | column | column-reverse;</span><br></pre></td></tr></table></figure><p>它可能取四个值：</p><ul><li><code>row</code>（默认值）：主轴为水平方向，起点在左端。</li><li><code>row-reverse</code>：主轴为水平方向，起点在右端。</li><li><code>column</code>：主轴为垂直方向，起点在上沿。</li><li><code>column-reverse</code>：主轴为垂直方向，起点在下沿。</li></ul><p><img src="flexdirection.png" alt></p><h2 id="flex-wrap属性"><a href="#flex-wrap属性" class="headerlink" title="flex-wrap属性"></a>flex-wrap属性</h2><p>默认情况下，项目都排在一条线（又称”轴线”）上。<code>flex-wrap</code>属性定义，如果一条轴线排不下，如何换行。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flex-wrap: nowrap | wrap | wrap-reverse;</span><br></pre></td></tr></table></figure><p>它可能取三个值：</p><ul><li><code>nowrap</code>（默认）：不换行。</li><li><code>wrap</code>：换行，第一行在上方。</li><li><code>wrap-reverse</code>：换行，第一行在下方。</li></ul><p><img src="flexwrap.png" alt></p><h2 id="flex-flow属性"><a href="#flex-flow属性" class="headerlink" title="flex-flow属性"></a>flex-flow属性</h2><p><code>flex-flow</code>属性是<code>flex-direction</code>属性和<code>flex-wrap</code>属性的简写形式，默认值为<code>row nowrap</code>。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flex-flow: &lt;flex-direction&gt; || &lt;flex-wrap&gt;;</span><br></pre></td></tr></table></figure><h2 id="justify-content属性"><a href="#justify-content属性" class="headerlink" title="justify-content属性"></a>justify-content属性</h2><p><code>justify-content</code>属性定义了项目在主轴上的对齐方式。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">justify-content: flex-start | flex-end | center | space-between | space-around;</span><br></pre></td></tr></table></figure><p>它可能取5个值，具体对齐方式与轴的方向有关。</p><ul><li><code>flex-start</code>（默认值）：主轴的起点对齐</li><li><code>flex-end</code>：主轴的终点对齐</li><li><code>center</code>： 主轴的中点对齐</li><li><code>space-between</code>：主轴两端对齐，项目之间的间隔都相等。</li><li><code>space-around</code>：每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍。</li></ul><p><img src="justifycontent.png" alt></p><h2 id="align-items属性"><a href="#align-items属性" class="headerlink" title="align-items属性"></a>align-items属性</h2><p><code>align-items</code>属性定义项目在交叉轴上如何对齐。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">align-items: flex-start | flex-end | center | baseline | stretch;</span><br></pre></td></tr></table></figure><p>它可能取5个值。具体的对齐方式与交叉轴的方向有关，下面假设交叉轴从上到下。</p><ul><li><code>flex-start</code>：交叉轴的起点对齐。</li><li><code>flex-end</code>：交叉轴的终点对齐。</li><li><code>center</code>：交叉轴的中点对齐。</li><li><code>baseline</code>: 项目的第一行文字的基线对齐。</li><li><code>stretch</code>（默认值）：如果项目未设置高度或设为auto，将占满整个容器的高度。</li></ul><p><img src="alignitems.png" alt></p><h2 id="align-content属性"><a href="#align-content属性" class="headerlink" title="align-content属性"></a>align-content属性</h2><p><code>align-content</code>属性定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。</p><p>即该属性对单行弹性盒子模型无效。（即：带有 <code>flex-wrap: nowrap</code>）。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">align-content: flex-start | flex-end | center | space-between | space-around | stretch;</span><br></pre></td></tr></table></figure><p>该属性可能取6个值。</p><ul><li><code>flex-start</code>：与交叉轴的起点对齐。</li><li><code>flex-end</code>：与交叉轴的终点对齐。</li><li><code>center</code>：与交叉轴的中点对齐。</li><li><code>space-between</code>：与交叉轴两端对齐，轴线之间的间隔平均分布。</li><li><code>space-around</code>：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍。</li><li><code>stretch</code>（默认值）：轴线占满整个交叉轴。</li></ul><p><img src="aligncontent.png" alt></p><h1 id="项目的属性"><a href="#项目的属性" class="headerlink" title="项目的属性"></a>项目的属性</h1><p>以下6个属性设置在项目上。</p><ul><li><code>order</code></li><li><code>flex-grow</code></li><li><code>flex-shrink</code></li><li><code>flex-basis</code></li><li><code>flex</code></li><li><code>align-self</code></li></ul><h2 id="order属性"><a href="#order属性" class="headerlink" title="order属性"></a>order属性</h2><p><code>order</code>属性定义项目的排列顺序。数值越小，排列越靠前，默认为0。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">order</span>: &lt;<span class="selector-tag">integer</span>&gt;; <span class="comment">/* default 0 */</span></span><br></pre></td></tr></table></figure><p><img src="order.png" alt></p><h2 id="flex-grow属性"><a href="#flex-grow属性" class="headerlink" title="flex-grow属性"></a>flex-grow属性</h2><p><code>flex-grow</code>属性定义项目的放大比例，默认为<code>0</code>，即如果存在剩余空间，也不放大。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">flex-grow</span>: &lt;<span class="selector-tag">number</span>&gt;; <span class="comment">/* default 0 */</span></span><br></pre></td></tr></table></figure><p><img src="flexgrow.png" alt></p><p>如果所有项目的<code>flex-grow</code>属性都为1，则它们将等分剩余空间（如果有的话）。如果一个项目的<code>flex-grow</code>属性为2，其他项目都为1，则前者占据的剩余空间将比其他项多一倍。</p><h2 id="flex-shrink属性"><a href="#flex-shrink属性" class="headerlink" title="flex-shrink属性"></a>flex-shrink属性</h2><p><code>flex-shrink</code>属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">flex-shrink</span>: &lt;<span class="selector-tag">number</span>&gt;; <span class="comment">/* default 1 */</span></span><br></pre></td></tr></table></figure><p><img src="flexshrink.png" alt></p><p>如果所有项目的<code>flex-shrink</code>属性都为1，当空间不足时，都将等比例缩小。如果一个项目的<code>flex-shrink</code>属性为0，其他项目都为1，则空间不足时，前者不缩小。</p><p>负值对该属性无效。</p><h2 id="flex-basis属性"><a href="#flex-basis属性" class="headerlink" title="flex-basis属性"></a>flex-basis属性</h2><p><code>flex-basis</code>属性定义了在分配多余空间之前，项目占据的主轴空间（main size）。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值是<code>auto</code>，即项目的本来大小。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flex-basis: &lt;length&gt; | auto; /* default auto */</span><br></pre></td></tr></table></figure><p>它可以设为跟<code>width</code>或<code>height</code>属性一样的值（比如350px），则项目将占据固定空间。</p><h2 id="flex属性"><a href="#flex属性" class="headerlink" title="flex属性"></a>flex属性</h2><p><code>flex</code>属性是<code>flex-grow</code>, <code>flex-shrink</code> 和 <code>flex-basis</code>的简写，默认值为<code>0 1 auto</code>。后两个属性可选。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flex: none | [ &lt;'flex-grow'&gt; &lt;'flex-shrink'&gt;? || &lt;'flex-basis'&gt; ]</span><br></pre></td></tr></table></figure><p>该属性有两个快捷值：<code>auto</code> (<code>1 1 auto</code>) 和 none (<code>0 0 auto</code>)。</p><p>建议优先使用这个属性，而不是单独写三个分离的属性，因为浏览器会推算相关值。</p><h2 id="align-self属性"><a href="#align-self属性" class="headerlink" title="align-self属性"></a>align-self属性</h2><p><code>align-self</code>属性允许单个项目有与其他项目不一样的对齐方式，可覆盖<code>align-items</code>属性。默认值为<code>auto</code>，表示继承父元素的<code>align-items</code>属性，如果没有父元素，则等同于<code>stretch</code>。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">align-self: auto | flex-start | flex-end | center | baseline | stretch;</span><br></pre></td></tr></table></figure><p>该属性可能取6个值，除了auto，其他都与align-items属性完全一致。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_Flexible_Box_Layout/Basic_Concepts_of_Flexbox" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_Flexible_Box_Layout/Basic_Concepts_of_Flexbox</a></p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_Box_Alignment/Box_Alignment_in_Flexbox" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_Box_Alignment/Box_Alignment_in_Flexbox</a></p><p><a href="http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;网页布局（layout）是 CSS 的一个重点应用。布局的传统解决方案，基于&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/CSS/box_model&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;盒状模型&lt;/a&gt;，依赖 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/CSS/display&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;&lt;code&gt;display&lt;/code&gt;&lt;/a&gt; 属性 + &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/CSS/position&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;&lt;code&gt;position&lt;/code&gt;&lt;/a&gt;属性 + &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/CSS/float&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;&lt;code&gt;float&lt;/code&gt;&lt;/a&gt;属性。它对于那些特殊布局非常不方便，比如，&lt;a href=&quot;https://css-tricks.com/centering-css-complete-guide/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;垂直居中&lt;/a&gt;就不容易实现。&lt;/p&gt;
    
    </summary>
    
      <category term="CSS" scheme="http://hackycy.github.io/categories/CSS/"/>
    
    
      <category term="CSS" scheme="http://hackycy.github.io/tags/CSS/"/>
    
      <category term="Flex布局" scheme="http://hackycy.github.io/tags/Flex%E5%B8%83%E5%B1%80/"/>
    
  </entry>
  
  <entry>
    <title>Docker入门（六）——Docker Compose</title>
    <link href="http://hackycy.github.io/2019/12/11/Docker%E5%85%A5%E9%97%A8%EF%BC%88%E5%85%AD%EF%BC%89%E2%80%94%E2%80%94Docker-Compose/"/>
    <id>http://hackycy.github.io/2019/12/11/Docker入门（六）——Docker-Compose/</id>
    <published>2019-12-11T03:43:25.000Z</published>
    <updated>2019-12-15T09:01:12.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Docker-Compose简介"><a href="#Docker-Compose简介" class="headerlink" title="Docker Compose简介"></a>Docker Compose简介</h1><p><code>Compose</code> 项目是 Docker 官方的开源项目，负责实现对 Docker 容器集群的快速编排。其代码目前在 <a href="https://github.com/docker/compose" target="_blank" rel="noopener">https://github.com/docker/compose</a> 上开源。</p><p><code>Compose</code> 定位是 「定义和运行多个 Docker 容器的应用（Defining and running multi-container Docker applications）」，其前身是开源项目 Fig。</p><a id="more"></a><p><code>Dockerfile</code> 模板文件可以让用户很方便的定义一个单独的应用容器。但是在平常使用中，经常会碰到需要多个容器相互配合来完成某项任务的情况。例如要实现一个 Web 项目，除了 Web 服务容器本身，往往还需要再加上后端的数据库服务容器，甚至还包括负载均衡容器等。</p><p><code>Compose</code> 恰好满足了这样的需求。它允许用户通过一个单独的 <code>docker-compose.yml</code> 模板文件（YAML 格式）来定义一组相关联的应用容器为一个项目（project）。</p><p><strong><code>Compose</code> 中有两个重要的概念：</strong></p><ul><li>服务 (<code>service</code>)：一个应用的容器，实际上可以包括若干运行相同镜像的容器实例。</li><li>项目 (<code>project</code>)：由一组关联的应用容器组成的一个完整业务单元，在 <code>docker-compose.yml</code> 文件中定义。</li></ul><p><code>Compose</code> 的默认管理对象是项目，通过子命令对项目中的一组容器进行便捷地生命周期管理。</p><p><code>Compose</code> 项目由 Python 编写，实现上调用了 Docker 服务提供的 API 来对容器进行管理。因此，只要所操作的平台支持 Docker API，就可以在其上利用 <code>Compose</code> 来进行编排管理。</p><h1 id="安装与卸载"><a href="#安装与卸载" class="headerlink" title="安装与卸载"></a>安装与卸载</h1><p><code>Compose</code> 支持 Linux、macOS、Windows 10 三大平台。</p><p><code>Compose</code> 可以通过 Python 的包管理工具 <code>pip</code> 进行安装，也可以直接下载编译好的二进制文件使用，甚至能够直接在 Docker 容器中运行。</p><p><code>Docker Desktop for Mac/Windows</code> 自带 <code>docker-compose</code> 二进制文件，安装 Docker 之后可以直接使用。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ docker-compose --version</span><br><span class="line"></span><br><span class="line">docker-compose version 1.24.1, build 4667896b</span><br></pre></td></tr></table></figure><p>Linux 系统请使用以下介绍的方法安装。</p><h2 id="二进制包"><a href="#二进制包" class="headerlink" title="二进制包"></a>二进制包</h2><p>在 Linux 上的也安装十分简单，从 <a href="https://github.com/docker/compose/releases" target="_blank" rel="noopener">官方 GitHub Release</a> 处直接下载编译好的二进制文件即可。</p><p>例如，在 Linux 64 位系统上直接下载对应的二进制包。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ sudo curl -L https://github.com/docker/compose/releases/download/1.24.1/docker-compose-`uname -s`-`uname -m` &gt; /usr/<span class="built_in">local</span>/bin/docker-compose</span><br><span class="line"></span><br><span class="line">$ sudo chmod +x /usr/<span class="built_in">local</span>/bin/docker-compose</span><br></pre></td></tr></table></figure><h2 id="PIP-安装"><a href="#PIP-安装" class="headerlink" title="PIP 安装"></a>PIP 安装</h2><p><em>注：</em> <code>x86_64</code> 架构的 Linux 建议按照上边的方法下载二进制包进行安装，如果您计算机的架构是 <code>ARM</code> (例如，树莓派)，再使用 <code>pip</code> 安装。</p><p>这种方式是将 Compose 当作一个 Python 应用来从 pip 源中安装。</p><p>执行安装命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo pip install -U docker-compose</span><br></pre></td></tr></table></figure><p>可以看到类似如下输出，说明安装成功。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Collecting docker-compose</span><br><span class="line">  Downloading docker-compose-1.24.1.tar.gz (149kB): 149kB downloaded</span><br><span class="line">...</span><br><span class="line">Successfully installed docker-compose cached-property requests texttable websocket-client docker-py dockerpty six enum34 backports.ssl-match-hostname ipaddress</span><br></pre></td></tr></table></figure><h2 id="bash-补全命令"><a href="#bash-补全命令" class="headerlink" title="bash 补全命令"></a>bash 补全命令</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ curl -L https://raw.githubusercontent.com/docker/compose/1.24.1/contrib/completion/bash/docker-compose &gt; /etc/bash_completion.d/docker-compose</span><br></pre></td></tr></table></figure><h2 id="卸载"><a href="#卸载" class="headerlink" title="卸载"></a>卸载</h2><p>如果是二进制包方式安装的，删除二进制文件即可。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo rm /usr/<span class="built_in">local</span>/bin/docker-compose</span><br></pre></td></tr></table></figure><p>如果是通过 <code>pip</code> 安装的，则执行如下命令即可删除。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo pip uninstall docker-compose</span><br></pre></td></tr></table></figure><h1 id="Compose使用"><a href="#Compose使用" class="headerlink" title="Compose使用"></a>Compose使用</h1><h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><p>最常见的项目是 web 网站，该项目应该包含 web 应用和缓存。</p><h2 id="Web应用"><a href="#Web应用" class="headerlink" title="Web应用"></a>Web应用</h2><p>新建文件夹，在该目录中编写 <code>app.py</code> 文件</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask</span><br><span class="line"><span class="keyword">from</span> redis <span class="keyword">import</span> Redis</span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line">redis = Redis(host=<span class="string">'redis'</span>, port=<span class="number">6379</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route('/')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello</span><span class="params">()</span>:</span></span><br><span class="line">    count = redis.incr(<span class="string">'hits'</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'Hello World! 该页面已被访问 &#123;&#125; 次。\n'</span>.format(count)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    app.run(host=<span class="string">"0.0.0.0"</span>, debug=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure><h2 id="Dockerfile"><a href="#Dockerfile" class="headerlink" title="Dockerfile"></a>Dockerfile</h2><p>编写 <code>Dockerfile</code> 文件，内容为</p><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> python:<span class="number">3.6</span>-alpine</span><br><span class="line"><span class="keyword">ADD</span><span class="bash"> . /code</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> /code</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> pip install redis flask</span></span><br><span class="line"><span class="keyword">CMD</span><span class="bash"> [<span class="string">"python"</span>, <span class="string">"app.py"</span>]</span></span><br></pre></td></tr></table></figure><h2 id="docker-compose-yml"><a href="#docker-compose-yml" class="headerlink" title="docker-compose.yml"></a>docker-compose.yml</h2><p>编写 <code>docker-compose.yml</code> 文件，这个是 Compose 使用的主模板文件。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">'3'</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">web:</span></span><br><span class="line">    <span class="attr">build:</span> <span class="string">.</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">     <span class="bullet">-</span> <span class="string">"5000:5000"</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">redis:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">"redis:alpine"</span></span><br></pre></td></tr></table></figure><h2 id="运行compose项目"><a href="#运行compose项目" class="headerlink" title="运行compose项目"></a>运行compose项目</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker-compose up</span><br></pre></td></tr></table></figure><p>此时访问本地 <code>5000</code> 端口，每次刷新页面，计数就会加 1。</p><h1 id="命令说明"><a href="#命令说明" class="headerlink" title="命令说明"></a>命令说明</h1><h2 id="命令对象与格式"><a href="#命令对象与格式" class="headerlink" title="命令对象与格式"></a>命令对象与格式</h2><p>对于 Compose 来说，大部分命令的对象既可以是项目本身，也可以指定为项目中的服务或者容器。如果没有特别的说明，命令对象将是项目，这意味着项目中所有的服务都会受到命令影响。</p><p>执行 <code>docker-compose [COMMAND] --help</code> 或者 <code>docker-compose help [COMMAND]</code> 可以查看具体某个命令的使用格式。</p><p><code>docker-compose</code> 命令的基本的使用格式是</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose [-f=&lt;arg&gt;...] [options] [COMMAND] [ARGS...]</span><br></pre></td></tr></table></figure><h2 id="命令选项"><a href="#命令选项" class="headerlink" title="命令选项"></a>命令选项</h2><ul><li><code>-f, --file FILE</code> 指定使用的 Compose 模板文件，默认为 <code>docker-compose.yml</code>，可以多次指定。</li><li><code>-p, --project-name NAME</code> 指定项目名称，默认将使用所在目录名称作为项目名。</li><li><code>--x-networking</code> 使用 Docker 的可拔插网络后端特性</li><li><code>--x-network-driver DRIVER</code> 指定网络后端的驱动，默认为 <code>bridge</code></li><li><code>--verbose</code> 输出更多调试信息。</li><li><code>-v, --version</code> 打印版本并退出。</li></ul><h2 id="命令使用说明"><a href="#命令使用说明" class="headerlink" title="命令使用说明"></a>命令使用说明</h2><h3 id="build"><a href="#build" class="headerlink" title="build"></a><code>build</code></h3><p>格式为 <code>docker-compose build [options] [SERVICE...]</code>。</p><p>构建（重新构建）项目中的服务容器。</p><p>服务容器一旦构建后，将会带上一个标记名，例如对于 web 项目中的一个 db 容器，可能是 web_db。</p><p>可以随时在项目目录下运行 <code>docker-compose build</code> 来重新构建服务。</p><p>选项包括：</p><ul><li><code>--force-rm</code> 删除构建过程中的临时容器。</li><li><code>--no-cache</code> 构建镜像过程中不使用 cache（这将加长构建过程）。</li><li><code>--pull</code> 始终尝试通过 pull 来获取更新版本的镜像。</li></ul><h3 id="config"><a href="#config" class="headerlink" title="config"></a><code>config</code></h3><p>验证 Compose 文件格式是否正确，若正确则显示配置，若格式错误显示错误原因。</p><h3 id="down"><a href="#down" class="headerlink" title="down"></a><code>down</code></h3><p>此命令将会停止 <code>up</code> 命令所启动的容器，并移除网络</p><h3 id="exec"><a href="#exec" class="headerlink" title="exec"></a><code>exec</code></h3><p>进入指定的容器。</p><h3 id="help"><a href="#help" class="headerlink" title="help"></a><code>help</code></h3><p>获得一个命令的帮助。</p><h3 id="images"><a href="#images" class="headerlink" title="images"></a><code>images</code></h3><p>列出 Compose 文件中包含的镜像。</p><h3 id="kill"><a href="#kill" class="headerlink" title="kill"></a><code>kill</code></h3><p>格式为 <code>docker-compose kill [options] [SERVICE...]</code>。</p><p>通过发送 <code>SIGKILL</code> 信号来强制停止服务容器。</p><p>支持通过 <code>-s</code> 参数来指定发送的信号，例如通过如下指令发送 <code>SIGINT</code> 信号。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker-compose <span class="built_in">kill</span> -s SIGINT</span><br></pre></td></tr></table></figure><h3 id="logs"><a href="#logs" class="headerlink" title="logs"></a><code>logs</code></h3><p>格式为 <code>docker-compose logs [options] [SERVICE...]</code>。</p><p>查看服务容器的输出。默认情况下，docker-compose 将对不同的服务输出使用不同的颜色来区分。可以通过 <code>--no-color</code> 来关闭颜色。</p><p>该命令在调试问题的时候十分有用。</p><h3 id="pause"><a href="#pause" class="headerlink" title="pause"></a><code>pause</code></h3><p>格式为 <code>docker-compose pause [SERVICE...]</code>。</p><p>暂停一个服务容器。</p><h3 id="port"><a href="#port" class="headerlink" title="port"></a><code>port</code></h3><p>格式为 <code>docker-compose port [options] SERVICE PRIVATE_PORT</code>。</p><p>打印某个容器端口所映射的公共端口。</p><p>选项：</p><ul><li><code>--protocol=proto</code> 指定端口协议，tcp（默认值）或者 udp。</li><li><code>--index=index</code> 如果同一服务存在多个容器，指定命令对象容器的序号（默认为 1）。</li></ul><h3 id="ps"><a href="#ps" class="headerlink" title="ps"></a><code>ps</code></h3><p>格式为 <code>docker-compose ps [options] [SERVICE...]</code>。</p><p>列出项目中目前的所有容器。</p><p>选项：</p><ul><li><code>-q</code> 只打印容器的 ID 信息。</li></ul><h3 id="pull"><a href="#pull" class="headerlink" title="pull"></a><code>pull</code></h3><p>格式为 <code>docker-compose pull [options] [SERVICE...]</code>。</p><p>拉取服务依赖的镜像。</p><p>选项：</p><ul><li><code>--ignore-pull-failures</code> 忽略拉取镜像过程中的错误。</li></ul><h3 id="push"><a href="#push" class="headerlink" title="push"></a><code>push</code></h3><p>推送服务依赖的镜像到 Docker 镜像仓库。</p><h3 id="restart"><a href="#restart" class="headerlink" title="restart"></a><code>restart</code></h3><p>格式为 <code>docker-compose restart [options] [SERVICE...]</code>。</p><p>重启项目中的服务。</p><p>选项：</p><ul><li><code>-t, --timeout TIMEOUT</code> 指定重启前停止容器的超时（默认为 10 秒）。</li></ul><h3 id="rm"><a href="#rm" class="headerlink" title="rm"></a><code>rm</code></h3><p>格式为 <code>docker-compose rm [options] [SERVICE...]</code>。</p><p>删除所有（停止状态的）服务容器。推荐先执行 <code>docker-compose stop</code> 命令来停止容器。</p><p>选项：</p><ul><li><code>-f, --force</code> 强制直接删除，包括非停止状态的容器。一般尽量不要使用该选项。</li><li><code>-v</code> 删除容器所挂载的数据卷。</li></ul><h3 id="run"><a href="#run" class="headerlink" title="run"></a><code>run</code></h3><p>格式为 <code>docker-compose run [options] [-p PORT...] [-e KEY=VAL...] SERVICE [COMMAND] [ARGS...]</code>。</p><p>在指定服务上执行一个命令。</p><p>例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker-compose run ubuntu ping docker.com</span><br></pre></td></tr></table></figure><p>将会启动一个 ubuntu 服务容器，并执行 <code>ping docker.com</code> 命令。</p><p>默认情况下，如果存在关联，则所有关联的服务将会自动被启动，除非这些服务已经在运行中。</p><p>该命令类似启动容器后运行指定的命令，相关卷、链接等等都将会按照配置自动创建。</p><p>两个不同点：</p><ul><li>给定命令将会覆盖原有的自动运行命令；</li><li>不会自动创建端口，以避免冲突。</li></ul><p>如果不希望自动启动关联的容器，可以使用 <code>--no-deps</code> 选项，例如</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker-compose run --no-deps web python manage.py shell</span><br></pre></td></tr></table></figure><p>将不会启动 web 容器所关联的其它容器。</p><p>选项：</p><ul><li><code>-d</code> 后台运行容器。</li><li><code>--name NAME</code> 为容器指定一个名字。</li><li><code>--entrypoint CMD</code> 覆盖默认的容器启动指令。</li><li><code>-e KEY=VAL</code> 设置环境变量值，可多次使用选项来设置多个环境变量。</li><li><code>-u, --user=&quot;&quot;</code> 指定运行容器的用户名或者 uid。</li><li><code>--no-deps</code> 不自动启动关联的服务容器。</li><li><code>--rm</code> 运行命令后自动删除容器，<code>d</code> 模式下将忽略。</li><li><code>-p, --publish=[]</code> 映射容器端口到本地主机。</li><li><code>--service-ports</code> 配置服务端口并映射到本地主机。</li><li><code>-T</code> 不分配伪 tty，意味着依赖 tty 的指令将无法运行。</li></ul><h3 id="scale"><a href="#scale" class="headerlink" title="scale"></a><code>scale</code></h3><p>格式为 <code>docker-compose scale [options] [SERVICE=NUM...]</code>。</p><p>设置指定服务运行的容器个数。</p><p>通过 <code>service=num</code> 的参数来设置数量。例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker-compose scale web=3 db=2</span><br></pre></td></tr></table></figure><p>将启动 3 个容器运行 web 服务，2 个容器运行 db 服务。</p><p>一般的，当指定数目多于该服务当前实际运行容器，将新创建并启动容器；反之，将停止容器。</p><p>选项：</p><ul><li><code>-t, --timeout TIMEOUT</code> 停止容器时候的超时（默认为 10 秒）。</li></ul><h3 id="start"><a href="#start" class="headerlink" title="start"></a><code>start</code></h3><p>格式为 <code>docker-compose start [SERVICE...]</code>。</p><p>启动已经存在的服务容器。</p><h3 id="stop"><a href="#stop" class="headerlink" title="stop"></a><code>stop</code></h3><p>格式为 <code>docker-compose stop [options] [SERVICE...]</code>。</p><p>停止已经处于运行状态的容器，但不删除它。通过 <code>docker-compose start</code> 可以再次启动这些容器。</p><p>选项：</p><ul><li><code>-t, --timeout TIMEOUT</code> 停止容器时候的超时（默认为 10 秒）。</li></ul><h3 id="top"><a href="#top" class="headerlink" title="top"></a><code>top</code></h3><p>查看各个服务容器内运行的进程。</p><h3 id="unpause"><a href="#unpause" class="headerlink" title="unpause"></a><code>unpause</code></h3><p>格式为 <code>docker-compose unpause [SERVICE...]</code>。</p><p>恢复处于暂停状态中的服务。</p><h3 id="up"><a href="#up" class="headerlink" title="up"></a><code>up</code></h3><p>格式为 <code>docker-compose up [options] [SERVICE...]</code>。</p><p>该命令十分强大，它将尝试自动完成包括构建镜像，（重新）创建服务，启动服务，并关联服务相关容器的一系列操作。</p><p>链接的服务都将会被自动启动，除非已经处于运行状态。</p><p>可以说，大部分时候都可以直接通过该命令来启动一个项目。</p><p>默认情况，<code>docker-compose up</code> 启动的容器都在前台，控制台将会同时打印所有容器的输出信息，可以很方便进行调试。</p><p>当通过 <code>Ctrl-C</code> 停止命令时，所有容器将会停止。</p><p>如果使用 <code>docker-compose up -d</code>，将会在后台启动并运行所有的容器。一般推荐生产环境下使用该选项。</p><p>默认情况，如果服务容器已经存在，<code>docker-compose up</code> 将会尝试停止容器，然后重新创建（保持使用 <code>volumes-from</code> 挂载的卷），以保证新启动的服务匹配 <code>docker-compose.yml</code> 文件的最新内容。如果用户不希望容器被停止并重新创建，可以使用 <code>docker-compose up --no-recreate</code>。这样将只会启动处于停止状态的容器，而忽略已经运行的服务。如果用户只想重新部署某个服务，可以使用 <code>docker-compose up --no-deps -d</code> 来重新创建服务并后台停止旧服务，启动新服务，并不会影响到其所依赖的服务。</p><p>选项：</p><ul><li><code>-d</code> 在后台运行服务容器。</li><li><code>--no-color</code> 不使用颜色来区分不同的服务的控制台输出。</li><li><code>--no-deps</code> 不启动服务所链接的容器。</li><li><code>--force-recreate</code> 强制重新创建容器，不能与 <code>--no-recreate</code> 同时使用。</li><li><code>--no-recreate</code> 如果容器已经存在了，则不重新创建，不能与 <code>--force-recreate</code> 同时使用。</li><li><code>--no-build</code> 不自动构建缺失的服务镜像。</li><li><code>-t, --timeout TIMEOUT</code> 停止容器时候的超时（默认为 10 秒）。</li></ul><h3 id="version"><a href="#version" class="headerlink" title="version"></a><code>version</code></h3><p>格式为 <code>docker-compose version</code>。</p><p>打印版本信息。</p><h1 id="Compose模版文件"><a href="#Compose模版文件" class="headerlink" title="Compose模版文件"></a>Compose模版文件</h1><p>模板文件是使用 <code>Compose</code> 的核心，涉及到的指令关键字也比较多。但大家不用担心，这里面大部分指令跟 <code>docker run</code> 相关参数的含义都是类似的。</p><p>默认的模板文件名称为 <code>docker-compose.yml</code>，格式为 YAML 格式。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">"3"</span></span><br><span class="line"></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">webapp:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">examples/web</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">"80:80"</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">"/data"</span></span><br></pre></td></tr></table></figure><p>注意每个服务都必须通过 <code>image</code> 指令指定镜像或 <code>build</code> 指令（需要 Dockerfile）等来自动构建生成镜像。</p><p>如果使用 <code>build</code> 指令，在 <code>Dockerfile</code> 中设置的选项(例如：<code>CMD</code>, <code>EXPOSE</code>, <code>VOLUME</code>, <code>ENV</code> 等) 将会自动被获取，无需在 <code>docker-compose.yml</code> 中重复设置。</p><p>下面分别介绍各个指令的用法。</p><h2 id="build-1"><a href="#build-1" class="headerlink" title="build"></a><code>build</code></h2><p>指定 <code>Dockerfile</code> 所在文件夹的路径（可以是绝对路径，或者相对 docker-compose.yml 文件的路径）。 <code>Compose</code> 将会利用它自动构建这个镜像，然后使用这个镜像。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">'3'</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">webapp:</span></span><br><span class="line">    <span class="attr">build:</span> <span class="string">./dir</span></span><br></pre></td></tr></table></figure><p>你也可以使用 <code>context</code> 指令指定 <code>Dockerfile</code> 所在文件夹的路径。</p><p>使用 <code>dockerfile</code> 指令指定 <code>Dockerfile</code> 文件名。</p><p>使用 <code>arg</code> 指令指定构建镜像时的变量。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">'3'</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">webapp:</span></span><br><span class="line">    <span class="attr">build:</span></span><br><span class="line">      <span class="attr">context:</span> <span class="string">./dir</span></span><br><span class="line">      <span class="attr">dockerfile:</span> <span class="string">Dockerfile-alternate</span></span><br><span class="line">      <span class="attr">args:</span></span><br><span class="line">        <span class="attr">buildno:</span> <span class="number">1</span></span><br></pre></td></tr></table></figure><p>使用 <code>cache_from</code> 指定构建镜像的缓存</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">build:</span></span><br><span class="line">  <span class="attr">context:</span> <span class="string">.</span></span><br><span class="line">  <span class="attr">cache_from:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">alpine:latest</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">corp/web_app:3.14</span></span><br></pre></td></tr></table></figure><h2 id="cap-add-cap-drop"><a href="#cap-add-cap-drop" class="headerlink" title="cap_add, cap_drop"></a><code>cap_add, cap_drop</code></h2><p>指定容器的内核能力（capacity）分配。</p><p>例如，让容器拥有所有能力可以指定为：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">cap_add:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">ALL</span></span><br></pre></td></tr></table></figure><p>去掉 NET_ADMIN 能力可以指定为：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">cap_drop:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">NET_ADMIN</span></span><br></pre></td></tr></table></figure><h2 id="command"><a href="#command" class="headerlink" title="command"></a><code>command</code></h2><p>覆盖容器启动后默认执行的命令。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">command:</span> <span class="string">echo</span> <span class="string">"hello world"</span></span><br></pre></td></tr></table></figure><h2 id="configs"><a href="#configs" class="headerlink" title="configs"></a><code>configs</code></h2><p>仅用于 <code>Swarm mode</code>，详细内容请查看 <a href="https://yeasy.gitbooks.io/docker_practice/content/swarm_mode" target="_blank" rel="noopener"><code>Swarm mode</code></a> 一节。</p><h2 id="cgroup-parent"><a href="#cgroup-parent" class="headerlink" title="cgroup_parent"></a><code>cgroup_parent</code></h2><p>指定父 <code>cgroup</code> 组，意味着将继承该组的资源限制。</p><p>例如，创建了一个 cgroup 组名称为 <code>cgroups_1</code>。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">cgroup_parent:</span> <span class="string">cgroups_1</span></span><br></pre></td></tr></table></figure><h2 id="container-name"><a href="#container-name" class="headerlink" title="container_name"></a><code>container_name</code></h2><p>指定容器名称。默认将会使用 <code>项目名称_服务名称_序号</code> 这样的格式。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">container_name:</span> <span class="string">docker-web-container</span></span><br></pre></td></tr></table></figure><blockquote><p>注意: 指定容器名称后，该服务将无法进行扩展（scale），因为 Docker 不允许多个容器具有相同的名称。</p></blockquote><h2 id="deploy"><a href="#deploy" class="headerlink" title="deploy"></a><code>deploy</code></h2><p>仅用于 <code>Swarm mode</code>，详细内容请查看 <a href="https://yeasy.gitbooks.io/docker_practice/content/swarm_mode" target="_blank" rel="noopener"><code>Swarm mode</code></a> 一节</p><h2 id="devices"><a href="#devices" class="headerlink" title="devices"></a><code>devices</code></h2><p>指定设备映射关系。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">devices:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">"/dev/ttyUSB1:/dev/ttyUSB0"</span></span><br></pre></td></tr></table></figure><h2 id="depends-on"><a href="#depends-on" class="headerlink" title="depends_on"></a><code>depends_on</code></h2><p>解决容器的依赖、启动先后的问题。以下例子中会先启动 <code>redis</code> <code>db</code> 再启动 <code>web</code></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">'3'</span></span><br><span class="line"></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">web:</span></span><br><span class="line">    <span class="attr">build:</span> <span class="string">.</span></span><br><span class="line">    <span class="attr">depends_on:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">db</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">redis</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">redis:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">redis</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">db:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">postgres</span></span><br></pre></td></tr></table></figure><blockquote><p>注意：<code>web</code> 服务不会等待 <code>redis</code> <code>db</code> 「完全启动」之后才启动。</p></blockquote><h2 id="dns"><a href="#dns" class="headerlink" title="dns"></a><code>dns</code></h2><p>自定义 <code>DNS</code> 服务器。可以是一个值，也可以是一个列表。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">dns:</span> <span class="number">8.8</span><span class="number">.8</span><span class="number">.8</span></span><br><span class="line"></span><br><span class="line"><span class="attr">dns:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="number">8.8</span><span class="number">.8</span><span class="number">.8</span></span><br><span class="line">  <span class="bullet">-</span> <span class="number">114.114</span><span class="number">.114</span><span class="number">.114</span></span><br></pre></td></tr></table></figure><h2 id="dns-search"><a href="#dns-search" class="headerlink" title="dns_search"></a><code>dns_search</code></h2><p>配置 <code>DNS</code> 搜索域。可以是一个值，也可以是一个列表。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">dns_search:</span> <span class="string">example.com</span></span><br><span class="line"></span><br><span class="line"><span class="attr">dns_search:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">domain1.example.com</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">domain2.example.com</span></span><br></pre></td></tr></table></figure><h2 id="tmpfs"><a href="#tmpfs" class="headerlink" title="tmpfs"></a><code>tmpfs</code></h2><p>挂载一个 tmpfs 文件系统到容器。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">tmpfs:</span> <span class="string">/run</span></span><br><span class="line"><span class="attr">tmpfs:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">/run</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">/tmp</span></span><br></pre></td></tr></table></figure><h2 id="env-file"><a href="#env-file" class="headerlink" title="env_file"></a><code>env_file</code></h2><p>从文件中获取环境变量，可以为单独的文件路径或列表。</p><p>如果通过 <code>docker-compose -f FILE</code> 方式来指定 Compose 模板文件，则 <code>env_file</code> 中变量的路径会基于模板文件路径。</p><p>如果有变量名称与 <code>environment</code> 指令冲突，则按照惯例，以后者为准。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">env_file: .env</span><br><span class="line"></span><br><span class="line">env_file:</span><br><span class="line">  - ./common.env</span><br><span class="line">  - ./apps/web.env</span><br><span class="line">  - /opt/secrets.env</span><br></pre></td></tr></table></figure><p>环境变量文件中每一行必须符合格式，支持 <code>#</code> 开头的注释行。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># common.env: Set development environment</span></span><br><span class="line">PROG_ENV=development</span><br></pre></td></tr></table></figure><h2 id="environment"><a href="#environment" class="headerlink" title="environment"></a><code>environment</code></h2><p>设置环境变量。你可以使用数组或字典两种格式。</p><p>只给定名称的变量会自动获取运行 Compose 主机上对应变量的值，可以用来防止泄露不必要的数据。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">environment:</span></span><br><span class="line">  <span class="attr">RACK_ENV:</span> <span class="string">development</span></span><br><span class="line">  <span class="attr">SESSION_SECRET:</span></span><br><span class="line"></span><br><span class="line"><span class="attr">environment:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">RACK_ENV=development</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">SESSION_SECRET</span></span><br></pre></td></tr></table></figure><p>如果变量名称或者值中用到 <code>true|false，yes|no</code> 等表达 <a href="https://yaml.org/type/bool.html" target="_blank" rel="noopener">布尔</a> 含义的词汇，最好放到引号里，避免 YAML 自动解析某些内容为对应的布尔语义。这些特定词汇，包括</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">y|Y|yes|Yes|YES|n|N|no|No|NO|<span class="literal">true</span>|True|TRUE|<span class="literal">false</span>|False|FALSE|on|On|ON|off|Off|OFF</span><br></pre></td></tr></table></figure><h2 id="expose"><a href="#expose" class="headerlink" title="expose"></a><code>expose</code></h2><p>暴露端口，但不映射到宿主机，只被连接的服务访问。</p><p>仅可以指定内部端口为参数</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">expose:</span></span><br><span class="line"> <span class="bullet">-</span> <span class="string">"3000"</span></span><br><span class="line"> <span class="bullet">-</span> <span class="string">"8000"</span></span><br></pre></td></tr></table></figure><h2 id="external-links"><a href="#external-links" class="headerlink" title="external_links"></a><code>external_links</code></h2><blockquote><p>注意：不建议使用该指令。</p></blockquote><p>链接到 <code>docker-compose.yml</code> 外部的容器，甚至并非 <code>Compose</code> 管理的外部容器。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">external_links:</span></span><br><span class="line"> <span class="bullet">-</span> <span class="string">redis_1</span></span><br><span class="line"> <span class="bullet">-</span> <span class="string">project_db_1:mysql</span></span><br><span class="line"> <span class="bullet">-</span> <span class="string">project_db_1:postgresql</span></span><br></pre></td></tr></table></figure><h2 id="extra-hosts"><a href="#extra-hosts" class="headerlink" title="extra_hosts"></a><code>extra_hosts</code></h2><p>类似 Docker 中的 <code>--add-host</code> 参数，指定额外的 host 名称映射信息。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">extra_hosts:</span></span><br><span class="line"> <span class="bullet">-</span> <span class="string">"googledns:8.8.8.8"</span></span><br><span class="line"> <span class="bullet">-</span> <span class="string">"dockerhub:52.1.157.61"</span></span><br></pre></td></tr></table></figure><p>会在启动后的服务容器中 <code>/etc/hosts</code> 文件中添加如下两条条目。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">8.8.8.8 googledns</span><br><span class="line">52.1.157.61 dockerhub</span><br></pre></td></tr></table></figure><h2 id="healthcheck"><a href="#healthcheck" class="headerlink" title="healthcheck"></a><code>healthcheck</code></h2><p>通过命令检查容器是否健康运行。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">healthcheck:</span></span><br><span class="line">  <span class="attr">test:</span> <span class="string">["CMD",</span> <span class="string">"curl"</span><span class="string">,</span> <span class="string">"-f"</span><span class="string">,</span> <span class="string">"http://localhost"</span><span class="string">]</span></span><br><span class="line">  <span class="attr">interval:</span> <span class="string">1m30s</span></span><br><span class="line">  <span class="attr">timeout:</span> <span class="string">10s</span></span><br><span class="line">  <span class="attr">retries:</span> <span class="number">3</span></span><br></pre></td></tr></table></figure><h2 id="image"><a href="#image" class="headerlink" title="image"></a><code>image</code></h2><p>指定为镜像名称或镜像 ID。如果镜像在本地不存在，<code>Compose</code> 将会尝试拉取这个镜像。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">image:</span> <span class="string">ubuntu</span></span><br><span class="line"><span class="attr">image:</span> <span class="string">orchardup/postgresql</span></span><br><span class="line"><span class="attr">image:</span> <span class="string">a4bc65fd</span></span><br></pre></td></tr></table></figure><h2 id="labels"><a href="#labels" class="headerlink" title="labels"></a><code>labels</code></h2><p>为容器添加 Docker 元数据（metadata）信息。例如可以为容器添加辅助说明信息。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">labels:</span></span><br><span class="line">  <span class="attr">com.startupteam.description:</span> <span class="string">"webapp for a startup team"</span></span><br><span class="line">  <span class="attr">com.startupteam.department:</span> <span class="string">"devops department"</span></span><br><span class="line">  <span class="attr">com.startupteam.release:</span> <span class="string">"rc3 for v1.0"</span></span><br></pre></td></tr></table></figure><h2 id="links"><a href="#links" class="headerlink" title="links"></a><code>links</code></h2><blockquote><p>注意：不推荐使用该指令。</p></blockquote><h2 id="logging"><a href="#logging" class="headerlink" title="logging"></a><code>logging</code></h2><p>配置日志选项。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">logging:</span></span><br><span class="line">  <span class="attr">driver:</span> <span class="string">syslog</span></span><br><span class="line">  <span class="attr">options:</span></span><br><span class="line">    <span class="attr">syslog-address:</span> <span class="string">"tcp://192.168.0.42:123"</span></span><br></pre></td></tr></table></figure><p>目前支持三种日志驱动类型。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">driver:</span> <span class="string">"json-file"</span></span><br><span class="line"><span class="attr">driver:</span> <span class="string">"syslog"</span></span><br><span class="line"><span class="attr">driver:</span> <span class="string">"none"</span></span><br></pre></td></tr></table></figure><p><code>options</code> 配置日志驱动的相关参数。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">options:</span></span><br><span class="line">  <span class="attr">max-size:</span> <span class="string">"200k"</span></span><br><span class="line">  <span class="attr">max-file:</span> <span class="string">"10"</span></span><br></pre></td></tr></table></figure><h2 id="network-mode"><a href="#network-mode" class="headerlink" title="network_mode"></a><code>network_mode</code></h2><p>设置网络模式。使用和 <code>docker run</code> 的 <code>--network</code> 参数一样的值。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">network_mode:</span> <span class="string">"bridge"</span></span><br><span class="line"><span class="attr">network_mode:</span> <span class="string">"host"</span></span><br><span class="line"><span class="attr">network_mode:</span> <span class="string">"none"</span></span><br><span class="line"><span class="attr">network_mode:</span> <span class="string">"service:[service name]"</span></span><br><span class="line"><span class="attr">network_mode:</span> <span class="string">"container:[container name/id]"</span></span><br></pre></td></tr></table></figure><h2 id="networks"><a href="#networks" class="headerlink" title="networks"></a><code>networks</code></h2><p>配置容器连接的网络。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">"3"</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">some-service:</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">     <span class="bullet">-</span> <span class="string">some-network</span></span><br><span class="line">     <span class="bullet">-</span> <span class="string">other-network</span></span><br><span class="line"></span><br><span class="line"><span class="attr">networks:</span></span><br><span class="line">  <span class="attr">some-network:</span></span><br><span class="line">  <span class="attr">other-network:</span></span><br></pre></td></tr></table></figure><h2 id="pid"><a href="#pid" class="headerlink" title="pid"></a><code>pid</code></h2><p>跟主机系统共享进程命名空间。打开该选项的容器之间，以及容器和宿主机系统之间可以通过进程 ID 来相互访问和操作。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">pid:</span> <span class="string">"host"</span></span><br></pre></td></tr></table></figure><h2 id="ports"><a href="#ports" class="headerlink" title="ports"></a><code>ports</code></h2><p>暴露端口信息。</p><p>使用宿主端口：容器端口 <code>(HOST:CONTAINER)</code> 格式，或者仅仅指定容器的端口（宿主将会随机选择端口）都可以。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">ports:</span></span><br><span class="line"> <span class="bullet">-</span> <span class="string">"3000"</span></span><br><span class="line"> <span class="bullet">-</span> <span class="string">"8000:8000"</span></span><br><span class="line"> <span class="bullet">-</span> <span class="string">"49100:22"</span></span><br><span class="line"> <span class="bullet">-</span> <span class="string">"127.0.0.1:8001:8001"</span></span><br></pre></td></tr></table></figure><p><em>注意：当使用 <code>HOST:CONTAINER</code> 格式来映射端口时，如果你使用的容器端口小于 60 并且没放到引号里，可能会得到错误结果，因为 <code>YAML</code> 会自动解析 <code>xx:yy</code> 这种数字格式为 60 进制。为避免出现这种问题，建议数字串都采用引号包括起来的字符串格式。</em></p><h2 id="secrets"><a href="#secrets" class="headerlink" title="secrets"></a><code>secrets</code></h2><p>存储敏感数据，例如 <code>mysql</code> 服务密码。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">"3.1"</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line"></span><br><span class="line"><span class="attr">mysql:</span></span><br><span class="line">  <span class="attr">image:</span> <span class="string">mysql</span></span><br><span class="line">  <span class="attr">environment:</span></span><br><span class="line">    <span class="attr">MYSQL_ROOT_PASSWORD_FILE:</span> <span class="string">/run/secrets/db_root_password</span></span><br><span class="line">  <span class="attr">secrets:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">db_root_password</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">my_other_secret</span></span><br><span class="line"></span><br><span class="line"><span class="attr">secrets:</span></span><br><span class="line">  <span class="attr">my_secret:</span></span><br><span class="line">    <span class="attr">file:</span> <span class="string">./my_secret.txt</span></span><br><span class="line">  <span class="attr">my_other_secret:</span></span><br><span class="line">    <span class="attr">external:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><h2 id="security-opt"><a href="#security-opt" class="headerlink" title="security_opt"></a><code>security_opt</code></h2><p>指定容器模板标签（label）机制的默认属性（用户、角色、类型、级别等）。例如配置标签的用户名和角色名。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">security_opt:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">label:user:USER</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">label:role:ROLE</span></span><br></pre></td></tr></table></figure><h2 id="stop-signal"><a href="#stop-signal" class="headerlink" title="stop_signal"></a><code>stop_signal</code></h2><p>设置另一个信号来停止容器。在默认情况下使用的是 SIGTERM 停止容器。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">stop_signal:</span> <span class="string">SIGUSR1</span></span><br></pre></td></tr></table></figure><h2 id="sysctls"><a href="#sysctls" class="headerlink" title="sysctls"></a><code>sysctls</code></h2><p>配置容器内核参数。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">sysctls:</span></span><br><span class="line">  <span class="attr">net.core.somaxconn:</span> <span class="number">1024</span></span><br><span class="line">  <span class="attr">net.ipv4.tcp_syncookies:</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="attr">sysctls:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">net.core.somaxconn=1024</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">net.ipv4.tcp_syncookies=0</span></span><br></pre></td></tr></table></figure><h2 id="ulimits"><a href="#ulimits" class="headerlink" title="ulimits"></a><code>ulimits</code></h2><p>指定容器的 ulimits 限制值。</p><p>例如，指定最大进程数为 65535，指定文件句柄数为 20000（软限制，应用可以随时修改，不能超过硬限制） 和 40000（系统硬限制，只能 root 用户提高）。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">ulimits:</span></span><br><span class="line">  <span class="attr">nproc:</span> <span class="number">65535</span></span><br><span class="line">  <span class="attr">nofile:</span></span><br><span class="line">    <span class="attr">soft:</span> <span class="number">20000</span></span><br><span class="line">    <span class="attr">hard:</span> <span class="number">40000</span></span><br></pre></td></tr></table></figure><h2 id="volumes"><a href="#volumes" class="headerlink" title="volumes"></a><code>volumes</code></h2><p>数据卷所挂载路径设置。可以设置为宿主机路径(<code>HOST:CONTAINER</code>)或者数据卷名称(<code>VOLUME:CONTAINER</code>)，并且可以设置访问模式 （<code>HOST:CONTAINER:ro</code>）。</p><p>该指令中路径支持相对路径。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">volumes:</span></span><br><span class="line"> <span class="bullet">-</span> <span class="string">/var/lib/mysql</span></span><br><span class="line"> <span class="bullet">-</span> <span class="string">cache/:/tmp/cache</span></span><br><span class="line"> <span class="bullet">-</span> <span class="string">~/configs:/etc/configs/:ro</span></span><br></pre></td></tr></table></figure><p>如果路径为数据卷名称，必须在文件中配置数据卷。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">"3"</span></span><br><span class="line"></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">my_src:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">mysql:8.0</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">mysql_data:/var/lib/mysql</span></span><br><span class="line"></span><br><span class="line"><span class="attr">volumes:</span></span><br><span class="line">  <span class="attr">mysql_data:</span></span><br></pre></td></tr></table></figure><h2 id="其它指令"><a href="#其它指令" class="headerlink" title="其它指令"></a>其它指令</h2><p>此外，还有包括 <code>domainname, entrypoint, hostname, ipc, mac_address, privileged, read_only, shm_size, restart, stdin_open, tty, user, working_dir</code> 等指令，基本跟 <code>docker run</code> 中对应参数的功能一致。</p><p>指定服务容器启动后执行的入口文件。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">entrypoint:</span> <span class="string">/code/entrypoint.sh</span></span><br></pre></td></tr></table></figure><p>指定容器中运行应用的用户名。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">user:</span> <span class="string">nginx</span></span><br></pre></td></tr></table></figure><p>指定容器中工作目录。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">working_dir:</span> <span class="string">/code</span></span><br></pre></td></tr></table></figure><p>指定容器中搜索域名、主机名、mac 地址等。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">domainname:</span> <span class="string">your_website.com</span></span><br><span class="line"><span class="attr">hostname:</span> <span class="string">test</span></span><br><span class="line"><span class="attr">mac_address:</span> <span class="number">08</span><span class="number">-00</span><span class="number">-27</span><span class="number">-00</span><span class="string">-0C-0A</span></span><br></pre></td></tr></table></figure><p>允许容器中运行一些特权命令。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">privileged:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>指定容器退出后的重启策略为始终重启。该命令对保持服务始终运行十分有效，在生产环境中推荐配置为 <code>always</code> 或者 <code>unless-stopped</code>。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">restart:</span> <span class="string">always</span></span><br></pre></td></tr></table></figure><p>以只读模式挂载容器的 root 文件系统，意味着不能对容器内容进行修改。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">read_only:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>打开标准输入，可以接受外部输入。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">stdin_open:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>模拟一个伪终端。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">tty:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><h2 id="读取变量"><a href="#读取变量" class="headerlink" title="读取变量"></a>读取变量</h2><p>Compose 模板文件支持动态读取主机的系统环境变量和当前目录下的 <code>.env</code> 文件中的变量。</p><p>例如，下面的 Compose 文件将从运行它的环境中读取变量 <code>${MONGO_VERSION}</code> 的值，并写入执行的指令中。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">"3"</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line"></span><br><span class="line"><span class="attr">db:</span></span><br><span class="line">  <span class="attr">image:</span> <span class="string">"mongo:$&#123;MONGO_VERSION&#125;"</span></span><br></pre></td></tr></table></figure><p>如果执行 <code>MONGO_VERSION=3.2 docker-compose up</code> 则会启动一个 <code>mongo:3.2</code> 镜像的容器；如果执行 <code>MONGO_VERSION=2.8 docker-compose up</code> 则会启动一个 <code>mongo:2.8</code> 镜像的容器。</p><p>若当前目录存在 <code>.env</code> 文件，执行 <code>docker-compose</code> 命令时将从该文件中读取变量。</p><p>在当前目录新建 <code>.env</code> 文件并写入以下内容。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 支持 # 号注释</span></span><br><span class="line">MONGO_VERSION=3.6</span><br></pre></td></tr></table></figure><p>执行 <code>docker-compose up</code> 则会启动一个 <code>mongo:3.6</code> 镜像的容器。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://docs.docker.com/compose/compose-file/" target="_blank" rel="noopener">https://docs.docker.com/compose/compose-file/</a></p><p>本文章摘抄于：<a href="https://yeasy.gitbooks.io/docker_practice/content/" target="_blank" rel="noopener">https://yeasy.gitbooks.io/docker_practice/content/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Docker-Compose简介&quot;&gt;&lt;a href=&quot;#Docker-Compose简介&quot; class=&quot;headerlink&quot; title=&quot;Docker Compose简介&quot;&gt;&lt;/a&gt;Docker Compose简介&lt;/h1&gt;&lt;p&gt;&lt;code&gt;Compose&lt;/code&gt; 项目是 Docker 官方的开源项目，负责实现对 Docker 容器集群的快速编排。其代码目前在 &lt;a href=&quot;https://github.com/docker/compose&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/docker/compose&lt;/a&gt; 上开源。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Compose&lt;/code&gt; 定位是 「定义和运行多个 Docker 容器的应用（Defining and running multi-container Docker applications）」，其前身是开源项目 Fig。&lt;/p&gt;
    
    </summary>
    
      <category term="Docker" scheme="http://hackycy.github.io/categories/Docker/"/>
    
    
      <category term="Docker" scheme="http://hackycy.github.io/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>Docker入门（五）——Dockerfile</title>
    <link href="http://hackycy.github.io/2019/12/05/Docker%E5%85%A5%E9%97%A8%EF%BC%88%E4%BA%94%EF%BC%89%E2%80%94%E2%80%94Dockerfile/"/>
    <id>http://hackycy.github.io/2019/12/05/Docker入门（五）——Dockerfile/</id>
    <published>2019-12-05T07:23:52.000Z</published>
    <updated>2019-12-15T09:00:50.011Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Dockerfile简介"><a href="#Dockerfile简介" class="headerlink" title="Dockerfile简介"></a>Dockerfile简介</h1><p>Dockerfile 是一个用来构建镜像的文本文件，文本内容包含了一条条构建镜像所需的指令和说明。</p><a id="more"></a><h1 id="利用-commit-理解镜像构成"><a href="#利用-commit-理解镜像构成" class="headerlink" title="利用 commit 理解镜像构成"></a>利用 commit 理解镜像构成</h1><p>理解Dockerfile定制镜像前先来了解一下<code>docker commit</code>。</p><p>镜像是容器的基础，每次执行 <code>docker run</code> 的时候都会指定哪个镜像作为容器运行的基础。在之前的例子中，我们所使用的都是来自于 Docker Hub 的镜像。直接使用这些镜像是可以满足一定的需求，而当这些镜像无法直接满足需求时，我们就需要定制这些镜像。</p><p>镜像是多层存储，每一层是在前一层的基础上进行的修改；而容器同样也是多层存储，是在以镜像为基础层，在其基础上加一层作为容器运行时的存储层。</p><p>现在让我们以定制一个 Web 服务器为例子，来讲解镜像是如何构建的。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker run --name webserver -d -p 80:80 nginx</span><br></pre></td></tr></table></figure><p>这条命令会用 <code>nginx</code> 镜像启动一个容器，命名为 <code>webserver</code>，并且映射了 80 端口，这样我们可以用浏览器去访问这个 <code>nginx</code> 服务器。</p><p>如果是在 Linux 本机运行的 Docker，或者如果使用的是 Docker Desktop for Mac/Windows，那么可以直接访问：<a href="http://localhost/" target="_blank" rel="noopener">http://localhost</a>；如果使用的是 Docker Toolbox，或者是在虚拟机、云服务器上安装的 Docker，则需要将 <code>localhost</code> 换为虚拟机地址或者实际云服务器地址。</p><p>直接用浏览器访问的话，我们会看到默认的 Nginx 欢迎页面。</p><p><img src="commit_hello_nginx.png" alt></p><p>现在，假设我们非常不喜欢这个欢迎页面，我们希望改成欢迎 Docker 的文字，我们可以使用 <code>docker exec</code> 命令进入容器，修改其内容。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ docker <span class="built_in">exec</span> -it webserver bash</span><br><span class="line">root@3e3b6840ce9a:/<span class="comment"># echo '&lt;h1&gt;Hello, Docker!&lt;/h1&gt;' &gt; /usr/share/nginx/html/index.html</span></span><br><span class="line">root@3e3b6840ce9a:/<span class="comment"># exit</span></span><br><span class="line"><span class="built_in">exit</span></span><br></pre></td></tr></table></figure><p>我们以交互式终端方式进入 <code>webserver</code> 容器，并执行了 <code>bash</code> 命令，也就是获得一个可操作的 Shell。</p><p>然后，我们用 <code>Hello, Docker!</code> 覆盖了 <code>/usr/share/nginx/html/index.html</code> 的内容。</p><p>现在我们再刷新浏览器的话，会发现内容被改变了。</p><p><img src="commit_hello_nginx2.png" alt></p><p>现在我们定制好了变化，我们希望能将其保存下来形成镜像。</p><p>要知道，当我们运行一个容器的时候（如果不使用卷的话），我们做的任何文件修改都会被记录于容器存储层里。而 Docker 提供了一个 <code>docker commit</code> 命令，可以将容器的存储层保存下来成为镜像。换句话说，就是在原有镜像的基础上，再叠加上容器的存储层，并构成新的镜像。以后我们运行这个新镜像的时候，就会拥有原有容器最后的文件变化。</p><p><code>docker commit</code> 的语法格式为：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker commit [选项] &lt;容器ID或容器名&gt; [&lt;仓库名&gt;[:&lt;标签&gt;]]</span><br></pre></td></tr></table></figure><p>我们可以用下面的命令将容器保存为镜像：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ docker commit \</span><br><span class="line">    --author <span class="string">"Tao Wang &lt;twang2218@gmail.com&gt;"</span> \</span><br><span class="line">    --message <span class="string">"修改了默认网页"</span> \</span><br><span class="line">    webserver \</span><br><span class="line">    nginx:v2</span><br><span class="line">sha256:07e33465974800ce65751acc279adc6ed2dc5ed4e0838f8b86f0c87aa1795214</span><br></pre></td></tr></table></figure><p>其中 <code>--author</code> 是指定修改的作者，而 <code>--message</code> 则是记录本次修改的内容。这点和 <code>git</code> 版本控制相似，不过这里这些信息可以省略留空。</p><p>我们可以在 <code>docker image ls</code> 中看到这个新定制的镜像：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ docker image ls nginx</span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">nginx               v2                  07e334659748        9 seconds ago       181.5 MB</span><br><span class="line">nginx               1.11                05a60462f8ba        12 days ago         181.5 MB</span><br><span class="line">nginx               latest              e43d811ce2f4        4 weeks ago         181.5 MB</span><br></pre></td></tr></table></figure><p>我们还可以用 <code>docker history</code> 具体查看镜像内的历史记录，如果比较 <code>nginx:latest</code> 的历史记录，我们会发现新增了我们刚刚提交的这一层。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ docker <span class="built_in">history</span> nginx:v2</span><br><span class="line">IMAGE               CREATED             CREATED BY                                      SIZE                COMMENT</span><br><span class="line">07e334659748        54 seconds ago      nginx -g daemon off;                            95 B                修改了默认网页</span><br><span class="line">e43d811ce2f4        4 weeks ago         /bin/sh -c <span class="comment">#(nop)  CMD ["nginx" "-g" "daemon    0 B</span></span><br><span class="line">&lt;missing&gt;           4 weeks ago         /bin/sh -c <span class="comment">#(nop)  EXPOSE 443/tcp 80/tcp        0 B</span></span><br><span class="line">&lt;missing&gt;           4 weeks ago         /bin/sh -c ln -sf /dev/stdout /var/<span class="built_in">log</span>/nginx/   22 B</span><br><span class="line">&lt;missing&gt;           4 weeks ago         /bin/sh -c apt-key adv --keyserver hkp://pgp.   58.46 MB</span><br><span class="line">&lt;missing&gt;           4 weeks ago         /bin/sh -c <span class="comment">#(nop)  ENV NGINX_VERSION=1.11.5-1   0 B</span></span><br><span class="line">&lt;missing&gt;           4 weeks ago         /bin/sh -c <span class="comment">#(nop)  MAINTAINER NGINX Docker Ma   0 B</span></span><br><span class="line">&lt;missing&gt;           4 weeks ago         /bin/sh -c <span class="comment">#(nop)  CMD ["/bin/bash"]            0 B</span></span><br><span class="line">&lt;missing&gt;           4 weeks ago         /bin/sh -c <span class="comment">#(nop) ADD file:23aa4f893e3288698c   123 MB</span></span><br></pre></td></tr></table></figure><p>新的镜像定制好后，我们可以来运行这个镜像。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --name web2 -d -p 81:80 nginx:v2</span><br></pre></td></tr></table></figure><p>这里我们命名为新的服务为 <code>web2</code>，并且映射到 <code>81</code> 端口。如果是 Docker Desktop for Mac/Windows 或 Linux 桌面的话，我们就可以直接访问 <a href="http://localhost:81/" target="_blank" rel="noopener">http://localhost:81</a> 看到结果，其内容应该和之前修改后的 <code>webserver</code> 一样。</p><p>至此，我们第一次完成了定制镜像，使用的是 <code>docker commit</code> 命令，手动操作给旧的镜像添加了新的一层，形成新的镜像，对镜像多层存储应该有了更直观的感觉。</p><blockquote><p>注意： <code>docker commit</code> 命令除了学习之外，还有一些特殊的应用场合，比如被入侵后保存现场等。但是，不要使用 <code>docker commit</code> 定制镜像，使用 <code>docker commit</code> 命令虽然可以比较直观的帮助理解镜像分层存储的概念，但是实际环境中并不会这样使用。</p><p>定制镜像应该使用 <code>Dockerfile</code> 来完成。如果你想要定制镜像请查看下一小节。</p></blockquote><h1 id="Dockerfile定制镜像"><a href="#Dockerfile定制镜像" class="headerlink" title="Dockerfile定制镜像"></a>Dockerfile定制镜像</h1><p>从<code>docker commit</code>中了解到镜像的定制实际上就是定制每一层所添加的配置、文件。</p><p>如果可以把每一层修改、安装、构建、操作的命令都写入一个脚本，用这个脚本来构建、定制镜像，那么之前提及的无法重复的问题、镜像构建透明性的问题、体积的问题就都会解决。这个脚本就是 Dockerfile。</p><p>Dockerfile 是一个文本文件，其内包含了一条条的 <strong>指令(Instruction)</strong>，每一条指令构建一层，因此每一条指令的内容，就是描述该层应当如何构建。</p><p>还以之前定制 <code>nginx</code> 镜像为例，这次我们使用 Dockerfile 来定制。</p><p>在一个空白目录中，建立一个文本文件，并命名为 <code>Dockerfile</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ mkdir mynginx</span><br><span class="line">$ <span class="built_in">cd</span> mynginx</span><br><span class="line">$ touch Dockerfile</span><br></pre></td></tr></table></figure><p>其内容为：</p><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> nginx</span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> <span class="built_in">echo</span> <span class="string">'&lt;h1&gt;Hello, Docker!&lt;/h1&gt;'</span> &gt; /usr/share/nginx/html/index.html</span></span><br></pre></td></tr></table></figure><p>这个 Dockerfile 很简单，一共就两行。涉及到了两条指令，<code>FROM</code> 和 <code>RUN</code>。</p><h2 id="FROM-指定基础镜像"><a href="#FROM-指定基础镜像" class="headerlink" title="FROM 指定基础镜像"></a>FROM 指定基础镜像</h2><p>所谓定制镜像，那一定是以一个镜像为基础，在其上进行定制。就像我们之前运行了一个 <code>nginx</code> 镜像的容器，再进行修改一样，基础镜像是必须指定的。而 <code>FROM</code> 就是指定 <strong>基础镜像</strong>，因此一个 <code>Dockerfile</code> 中 <code>FROM</code> 是必备的指令，并且必须是第一条指令。</p><p>在 <a href="https://hub.docker.com/search?q=&amp;type=image&amp;image_filter=official" target="_blank" rel="noopener">Docker Hub</a> 上有非常多的高质量的官方镜像，有可以直接拿来使用的服务类的镜像，如 <a href="https://hub.docker.com/_/nginx/" target="_blank" rel="noopener"><code>nginx</code></a>、<a href="https://hub.docker.com/_/redis/" target="_blank" rel="noopener"><code>redis</code></a>、<a href="https://hub.docker.com/_/mongo/" target="_blank" rel="noopener"><code>mongo</code></a>、<a href="https://hub.docker.com/_/mysql/" target="_blank" rel="noopener"><code>mysql</code></a>、<a href="https://hub.docker.com/_/httpd/" target="_blank" rel="noopener"><code>httpd</code></a>、<a href="https://hub.docker.com/_/php/" target="_blank" rel="noopener"><code>php</code></a>、<a href="https://hub.docker.com/_/tomcat/" target="_blank" rel="noopener"><code>tomcat</code></a> 等；也有一些方便开发、构建、运行各种语言应用的镜像，如 <a href="https://hub.docker.com/_/node" target="_blank" rel="noopener"><code>node</code></a>、<a href="https://hub.docker.com/_/openjdk/" target="_blank" rel="noopener"><code>openjdk</code></a>、<a href="https://hub.docker.com/_/python/" target="_blank" rel="noopener"><code>python</code></a>、<a href="https://hub.docker.com/_/ruby/" target="_blank" rel="noopener"><code>ruby</code></a>、<a href="https://hub.docker.com/_/golang/" target="_blank" rel="noopener"><code>golang</code></a> 等。可以在其中寻找一个最符合我们最终目标的镜像为基础镜像进行定制。</p><p>如果没有找到对应服务的镜像，官方镜像中还提供了一些更为基础的操作系统镜像，如 <a href="https://hub.docker.com/_/ubuntu/" target="_blank" rel="noopener"><code>ubuntu</code></a>、<a href="https://hub.docker.com/_/debian/" target="_blank" rel="noopener"><code>debian</code></a>、<a href="https://hub.docker.com/_/centos/" target="_blank" rel="noopener"><code>centos</code></a>、<a href="https://hub.docker.com/_/fedora/" target="_blank" rel="noopener"><code>fedora</code></a>、<a href="https://hub.docker.com/_/alpine/" target="_blank" rel="noopener"><code>alpine</code></a> 等，这些操作系统的软件库为我们提供了更广阔的扩展空间。</p><p>除了选择现有镜像为基础镜像外，Docker 还存在一个特殊的镜像，名为 <code>scratch</code>。这个镜像是虚拟的概念，并不实际存在，它表示一个空白的镜像。</p><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> scratch</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>如果你以 <code>scratch</code> 为基础镜像的话，意味着你不以任何镜像为基础，接下来所写的指令将作为镜像第一层开始存在。</p><p>不以任何系统为基础，直接将可执行文件复制进镜像的做法并不罕见，比如 <a href="https://hub.docker.com/_/swarm/" target="_blank" rel="noopener"><code>swarm</code></a>、<a href="https://quay.io/repository/coreos/etcd" target="_blank" rel="noopener"><code>etcd</code></a>。对于 Linux 下静态编译的程序来说，并不需要有操作系统提供运行时支持，所需的一切库都已经在可执行文件里了，因此直接 <code>FROM scratch</code> 会让镜像体积更加小巧。使用 <a href="https://golang.org/" target="_blank" rel="noopener">Go 语言</a> 开发的应用很多会使用这种方式来制作镜像，这也是为什么有人认为 Go 是特别适合容器微服务架构的语言的原因之一。</p><h2 id="RUN-执行命令"><a href="#RUN-执行命令" class="headerlink" title="RUN 执行命令"></a>RUN 执行命令</h2><p><code>RUN</code> 指令是用来执行命令行命令的。由于命令行的强大能力，<code>RUN</code> 指令在定制镜像时是最常用的指令之一。其格式有两种：</p><ul><li><em>shell</em> 格式：<code>RUN &lt;命令&gt;</code>，就像直接在命令行中输入的命令一样。刚才写的 Dockerfile 中的 <code>RUN</code> 指令就是这种格式。</li></ul><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">RUN</span><span class="bash"> <span class="built_in">echo</span> <span class="string">'&lt;h1&gt;Hello, Docker!&lt;/h1&gt;'</span> &gt; /usr/share/nginx/html/index.html</span></span><br></pre></td></tr></table></figure><ul><li><em>exec</em> 格式：<code>RUN [&quot;可执行文件&quot;, &quot;参数1&quot;, &quot;参数2&quot;]</code>，这更像是函数调用中的格式。</li></ul><p>既然 <code>RUN</code> 就像 Shell 脚本一样可以执行命令，那么我们是否就可以像 Shell 脚本一样把每个命令对应一个 RUN 呢？比如这样：</p><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> debian:stretch</span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> apt-get update</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> apt-get install -y gcc libc6-dev make wget</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> wget -O redis.tar.gz <span class="string">"http://download.redis.io/releases/redis-5.0.3.tar.gz"</span></span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> mkdir -p /usr/src/redis</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> tar -xzf redis.tar.gz -C /usr/src/redis --strip-components=1</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> make -C /usr/src/redis</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> make -C /usr/src/redis install</span></span><br></pre></td></tr></table></figure><p>之前说过，Dockerfile 中每一个指令都会建立一层，<code>RUN</code> 也不例外。每一个 <code>RUN</code> 的行为，就和刚才我们手工建立镜像的过程一样：新建立一层，在其上执行这些命令，执行结束后，<code>commit</code> 这一层的修改，构成新的镜像。</p><p>而上面的这种写法，创建了 7 层镜像。这是完全没有意义的，而且很多运行时不需要的东西，都被装进了镜像里，比如编译环境、更新的软件包等等。结果就是产生非常臃肿、非常多层的镜像，不仅仅增加了构建部署的时间，也很容易出错。 这是很多初学 Docker 的人常犯的一个错误。</p><p><em>Union FS 是有最大层数限制的，比如 AUFS，曾经是最大不得超过 42 层，现在是不得超过 127 层。</em></p><p>上面的 <code>Dockerfile</code> 正确的写法应该是这样：</p><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> debian:stretch</span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> buildDeps=<span class="string">'gcc libc6-dev make wget'</span> \</span></span><br><span class="line"><span class="bash">    &amp;&amp; apt-get update \</span></span><br><span class="line"><span class="bash">    &amp;&amp; apt-get install -y <span class="variable">$buildDeps</span> \</span></span><br><span class="line"><span class="bash">    &amp;&amp; wget -O redis.tar.gz <span class="string">"http://download.redis.io/releases/redis-5.0.3.tar.gz"</span> \</span></span><br><span class="line"><span class="bash">    &amp;&amp; mkdir -p /usr/src/redis \</span></span><br><span class="line"><span class="bash">    &amp;&amp; tar -xzf redis.tar.gz -C /usr/src/redis --strip-components=1 \</span></span><br><span class="line"><span class="bash">    &amp;&amp; make -C /usr/src/redis \</span></span><br><span class="line"><span class="bash">    &amp;&amp; make -C /usr/src/redis install \</span></span><br><span class="line"><span class="bash">    &amp;&amp; rm -rf /var/lib/apt/lists/* \</span></span><br><span class="line"><span class="bash">    &amp;&amp; rm redis.tar.gz \</span></span><br><span class="line"><span class="bash">    &amp;&amp; rm -r /usr/src/redis \</span></span><br><span class="line"><span class="bash">    &amp;&amp; apt-get purge -y --auto-remove <span class="variable">$buildDeps</span></span></span><br></pre></td></tr></table></figure><p>首先，之前所有的命令只有一个目的，就是编译、安装 redis 可执行文件。因此没有必要建立很多层，这只是一层的事情。因此，这里没有使用很多个 <code>RUN</code> 对一一对应不同的命令，而是仅仅使用一个 <code>RUN</code> 指令，并使用 <code>&amp;&amp;</code> 将各个所需命令串联起来。将之前的 7 层，简化为了 1 层。在撰写 Dockerfile 的时候，要经常提醒自己，这并不是在写 Shell 脚本，而是在定义每一层该如何构建。</p><p>并且，这里为了格式化还进行了换行。Dockerfile 支持 Shell 类的行尾添加 <code>\</code> 的命令换行方式，以及行首 <code>#</code> 进行注释的格式。良好的格式，比如换行、缩进、注释等，会让维护、排障更为容易，这是一个比较好的习惯。</p><p>此外，还可以看到这一组命令的最后添加了清理工作的命令，删除了为了编译构建所需要的软件，清理了所有下载、展开的文件，并且还清理了 <code>apt</code> 缓存文件。这是很重要的一步，我们之前说过，镜像是多层存储，每一层的东西并不会在下一层被删除，会一直跟随着镜像。因此镜像构建时，一定要确保每一层只添加真正需要添加的东西，任何无关的东西都应该清理掉。</p><p>很多人初学 Docker 制作出了很臃肿的镜像的原因之一，就是忘记了每一层构建的最后一定要清理掉无关文件。</p><h2 id="构建镜像"><a href="#构建镜像" class="headerlink" title="构建镜像"></a>构建镜像</h2><p>好了，让我们再回到之前定制的 nginx 镜像的 Dockerfile 来。现在我们明白了这个 Dockerfile 的内容，那么让我们来构建这个镜像吧。</p><p>在 <code>Dockerfile</code> 文件所在目录执行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ docker build -t nginx:v3 .</span><br><span class="line">Sending build context to Docker daemon 2.048 kB</span><br><span class="line">Step 1 : FROM nginx</span><br><span class="line"> ---&gt; e43d811ce2f4</span><br><span class="line">Step 2 : RUN <span class="built_in">echo</span> <span class="string">'&lt;h1&gt;Hello, Docker!&lt;/h1&gt;'</span> &gt; /usr/share/nginx/html/index.html</span><br><span class="line"> ---&gt; Running <span class="keyword">in</span> 9cdc27646c7b</span><br><span class="line"> ---&gt; 44aa4490ce2c</span><br><span class="line">Removing intermediate container 9cdc27646c7b</span><br><span class="line">Successfully built 44aa4490ce2c</span><br></pre></td></tr></table></figure><p>从命令的输出结果中，我们可以清晰的看到镜像的构建过程。在 <code>Step 2</code> 中，如同我们之前所说的那样，<code>RUN</code> 指令启动了一个容器 <code>9cdc27646c7b</code>，执行了所要求的命令，并最后提交了这一层 <code>44aa4490ce2c</code>，随后删除了所用到的这个容器 <code>9cdc27646c7b</code>。</p><p>这里我们使用了 <code>docker build</code> 命令进行镜像构建。其格式为：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build [选项] &lt;上下文路径/URL/-&gt;</span><br></pre></td></tr></table></figure><p>在这里我们指定了最终镜像的名称 <code>-t nginx:v3</code>，构建成功后，我们可以像之前运行 <code>nginx:v2</code> 那样来运行这个镜像，其结果会和 <code>nginx:v2</code> 一样。</p><h2 id="镜像构建上下文（Context）"><a href="#镜像构建上下文（Context）" class="headerlink" title="镜像构建上下文（Context）"></a>镜像构建上下文（Context）</h2><p>如果注意，会看到 <code>docker build</code> 命令最后有一个 <code>.</code>。<code>.</code> 表示当前目录，而 <code>Dockerfile</code> 就在当前目录，因此不少初学者以为这个路径是在指定 <code>Dockerfile</code> 所在路径，这么理解其实是不准确的。如果对应上面的命令格式，你可能会发现，这是在指定 <strong>上下文路径</strong>。那么什么是上下文呢？</p><p>首先我们要理解 <code>docker build</code> 的工作原理。Docker 在运行时分为 Docker 引擎（也就是服务端守护进程）和客户端工具。Docker 的引擎提供了一组 REST API，被称为 <a href="https://docs.docker.com/develop/sdk/" target="_blank" rel="noopener">Docker Remote API</a>，而如 <code>docker</code> 命令这样的客户端工具，则是通过这组 API 与 Docker 引擎交互，从而完成各种功能。因此，虽然表面上我们好像是在本机执行各种 <code>docker</code> 功能，但实际上，一切都是使用的远程调用形式在服务端（Docker 引擎）完成。也因为这种 C/S 设计，让我们操作远程服务器的 Docker 引擎变得轻而易举。</p><p>当我们进行镜像构建的时候，并非所有定制都会通过 <code>RUN</code> 指令完成，经常会需要将一些本地文件复制进镜像，比如通过 <code>COPY</code> 指令、<code>ADD</code> 指令等。而 <code>docker build</code> 命令构建镜像，其实并非在本地构建，而是在服务端，也就是 Docker 引擎中构建的。那么在这种客户端/服务端的架构中，如何才能让服务端获得本地文件呢？</p><p>这就引入了上下文的概念。当构建的时候，用户会指定构建镜像上下文的路径，<code>docker build</code> 命令得知这个路径后，会将路径下的所有内容打包，然后上传给 Docker 引擎。这样 Docker 引擎收到这个上下文包后，展开就会获得构建镜像所需的一切文件。</p><p>如果在 <code>Dockerfile</code> 中这么写：</p><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">COPY</span><span class="bash"> ./package.json /app/</span></span><br></pre></td></tr></table></figure><p>这并不是要复制执行 <code>docker build</code> 命令所在的目录下的 <code>package.json</code>，也不是复制 <code>Dockerfile</code> 所在目录下的 <code>package.json</code>，而是复制 <strong>上下文（context）</strong> 目录下的 <code>package.json</code>。</p><p>因此，<code>COPY</code> 这类指令中的源文件的路径都是<em>相对路径</em>。这也是初学者经常会问的为什么 <code>COPY ../package.json /app</code> 或者 <code>COPY /opt/xxxx /app</code> 无法工作的原因，因为这些路径已经超出了上下文的范围，Docker 引擎无法获得这些位置的文件。如果真的需要那些文件，应该将它们复制到上下文目录中去。</p><p>现在就可以理解刚才的命令 <code>docker build -t nginx:v3 .</code> 中的这个 <code>.</code>，实际上是在指定上下文的目录，<code>docker build</code> 命令会将该目录下的内容打包交给 Docker 引擎以帮助构建镜像。</p><p>如果观察 <code>docker build</code> 输出，我们其实已经看到了这个发送上下文的过程：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ docker build -t nginx:v3 .</span><br><span class="line">Sending build context to Docker daemon 2.048 kB</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>理解构建上下文对于镜像构建是很重要的，避免犯一些不应该的错误。比如有些初学者在发现 <code>COPY /opt/xxxx /app</code> 不工作后，于是干脆将 <code>Dockerfile</code> 放到了硬盘根目录去构建，结果发现 <code>docker build</code> 执行后，在发送一个几十 GB 的东西，极为缓慢而且很容易构建失败。那是因为这种做法是在让 <code>docker build</code> 打包整个硬盘，这显然是使用错误。</p><p>一般来说，应该会将 <code>Dockerfile</code> 置于一个空目录下，或者项目根目录下。如果该目录下没有所需文件，那么应该把所需文件复制一份过来。如果目录下有些东西确实不希望构建时传给 Docker 引擎，那么可以用 <code>.gitignore</code> 一样的语法写一个 <code>.dockerignore</code>，该文件是用于剔除不需要作为上下文传递给 Docker 引擎的。</p><p>那么为什么会有人误以为 <code>.</code> 是指定 <code>Dockerfile</code> 所在目录呢？这是因为在默认情况下，如果不额外指定 <code>Dockerfile</code> 的话，会将上下文目录下的名为 <code>Dockerfile</code> 的文件作为 Dockerfile。</p><p>这只是默认行为，实际上 <code>Dockerfile</code> 的文件名并不要求必须为 <code>Dockerfile</code>，而且并不要求必须位于上下文目录中，比如可以用 <code>-f ../Dockerfile.php</code> 参数指定某个文件作为 <code>Dockerfile</code>。</p><p>一般使用默认的文件名 <code>Dockerfile</code>，以及会将其置于镜像构建上下文目录中。</p><h2 id="其它-docker-build-的用法"><a href="#其它-docker-build-的用法" class="headerlink" title="其它 docker build 的用法"></a>其它 <code>docker build</code> 的用法</h2><h3 id="直接用-Git-repo-进行构建"><a href="#直接用-Git-repo-进行构建" class="headerlink" title="直接用 Git repo 进行构建"></a>直接用 Git repo 进行构建</h3><p>或许你已经注意到了，<code>docker build</code> 还支持从 URL 构建，比如可以直接从 Git repo 中构建：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ docker build https://github.com/twang2218/gitlab-ce-zh.git<span class="comment">#:11.1</span></span><br><span class="line"></span><br><span class="line">Sending build context to Docker daemon 2.048 kB</span><br><span class="line">Step 1 : FROM gitlab/gitlab-ce:11.1.0-ce.0</span><br><span class="line">11.1.0-ce.0: Pulling from gitlab/gitlab-ce</span><br><span class="line">aed15891ba52: Already exists</span><br><span class="line">773ae8583d14: Already exists</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>这行命令指定了构建所需的 Git repo，并且指定默认的 <code>master</code> 分支，构建目录为 <code>/11.1/</code>，然后 Docker 就会自己去 <code>git clone</code> 这个项目、切换到指定分支、并进入到指定目录后开始构建。</p><h3 id="用给定的-tar-压缩包构建"><a href="#用给定的-tar-压缩包构建" class="headerlink" title="用给定的 tar 压缩包构建"></a>用给定的 tar 压缩包构建</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker build http://server/context.tar.gz</span><br></pre></td></tr></table></figure><p>如果所给出的 URL 不是个 Git repo，而是个 <code>tar</code> 压缩包，那么 Docker 引擎会下载这个包，并自动解压缩，以其作为上下文，开始构建。</p><h3 id="从标准输入中读取-Dockerfile-进行构建"><a href="#从标准输入中读取-Dockerfile-进行构建" class="headerlink" title="从标准输入中读取 Dockerfile 进行构建"></a>从标准输入中读取 Dockerfile 进行构建</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build - &lt; Dockerfile</span><br></pre></td></tr></table></figure><p>或</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat Dockerfile | docker build -</span><br></pre></td></tr></table></figure><p>如果标准输入传入的是文本文件，则将其视为 <code>Dockerfile</code>，并开始构建。这种形式由于直接从标准输入中读取 Dockerfile 的内容，它没有上下文，因此不可以像其他方法那样可以将本地文件 <code>COPY</code> 进镜像之类的事情。</p><h3 id="从标准输入中读取上下文压缩包进行构建"><a href="#从标准输入中读取上下文压缩包进行构建" class="headerlink" title="从标准输入中读取上下文压缩包进行构建"></a>从标准输入中读取上下文压缩包进行构建</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker build - &lt; context.tar.gz</span><br></pre></td></tr></table></figure><p>如果发现标准输入的文件格式是 <code>gzip</code>、<code>bzip2</code> 以及 <code>xz</code> 的话，将会使其为上下文压缩包，直接将其展开，将里面视为上下文，并开始构建。</p><h1 id="Dockerfile指令"><a href="#Dockerfile指令" class="headerlink" title="Dockerfile指令"></a>Dockerfile指令</h1><p>一张图来大概了解一下</p><p><img src="command.webp" alt></p><h2 id="COPY-复制文件"><a href="#COPY-复制文件" class="headerlink" title="COPY 复制文件"></a>COPY 复制文件</h2><p>格式：</p><ul><li><code>COPY [--chown=:] &lt;源路径&gt;... &lt;目标路径&gt;</code></li><li><code>COPY [--chown=:] [&quot;&lt;源路径1&gt;&quot;,... &quot;&lt;目标路径&gt;&quot;]</code></li></ul><p>和 <code>RUN</code> 指令一样，也有两种格式，一种类似于命令行，一种类似于函数调用。</p><p><code>COPY</code> 指令将从构建上下文目录中 <code>&lt;源路径&gt;</code> 的文件/目录复制到新的一层的镜像内的 <code>&lt;目标路径&gt;</code> 位置。比如：</p><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">COPY</span><span class="bash"> package.json /usr/src/app/</span></span><br></pre></td></tr></table></figure><p><code>&lt;源路径&gt;</code> 可以是多个，甚至可以是通配符，其通配符规则要满足 Go 的 <a href="https://golang.org/pkg/path/filepath/#Match" target="_blank" rel="noopener"><code>filepath.Match</code></a> 规则，如：</p><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">COPY</span><span class="bash"> hom* /mydir/</span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> hom?.txt /mydir/</span></span><br></pre></td></tr></table></figure><p><code>&lt;目标路径&gt;</code> 可以是容器内的绝对路径，也可以是相对于工作目录的相对路径（工作目录可以用 <code>WORKDIR</code> 指令来指定）。目标路径不需要事先创建，如果目录不存在会在复制文件前先行创建缺失目录。</p><p>此外，还需要注意一点，使用 <code>COPY</code> 指令，源文件的各种元数据都会保留。比如读、写、执行权限、文件变更时间等。这个特性对于镜像定制很有用。特别是构建相关文件都在使用 Git 进行管理的时候。</p><p>在使用该指令的时候还可以加上 <code>--chown=:</code> 选项来改变文件的所属用户及所属组。</p><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">COPY</span><span class="bash"> --chown=55:mygroup files* /mydir/</span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> --chown=bin files* /mydir/</span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> --chown=1 files* /mydir/</span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> --chown=10:11 files* /mydir/</span></span><br></pre></td></tr></table></figure><h2 id="ADD-更高级的复制文件"><a href="#ADD-更高级的复制文件" class="headerlink" title="ADD 更高级的复制文件"></a>ADD 更高级的复制文件</h2><p><code>ADD</code> 指令和 <code>COPY</code> 的格式和性质基本一致。但是在 <code>COPY</code> 基础上增加了一些功能。</p><p>比如 <code>&lt;源路径&gt;</code> 可以是一个 <code>URL</code>，这种情况下，Docker 引擎会试图去下载这个链接的文件放到 <code>&lt;目标路径&gt;</code> 去。下载后的文件权限自动设置为 <code>600</code>，如果这并不是想要的权限，那么还需要增加额外的一层 <code>RUN</code> 进行权限调整，另外，如果下载的是个压缩包，需要解压缩，也一样还需要额外的一层 <code>RUN</code> 指令进行解压缩。所以不如直接使用 <code>RUN</code> 指令，然后使用 <code>wget</code> 或者 <code>curl</code> 工具下载，处理权限、解压缩、然后清理无用文件更合理。因此，这个功能其实并不实用，而且不推荐使用。</p><p>如果 <code>&lt;源路径&gt;</code> 为一个 <code>tar</code> 压缩文件的话，压缩格式为 <code>gzip</code>, <code>bzip2</code> 以及 <code>xz</code> 的情况下，<code>ADD</code> 指令将会自动解压缩这个压缩文件到 <code>&lt;目标路径&gt;</code> 去。</p><p>在某些情况下，这个自动解压缩的功能非常有用，比如官方镜像 <code>ubuntu</code> 中：</p><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> scratch</span><br><span class="line"><span class="keyword">ADD</span><span class="bash"> ubuntu-xenial-core-cloudimg-amd64-root.tar.gz /</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>但在某些情况下，如果我们真的是希望复制个压缩文件进去，而不解压缩，这时就不可以使用 <code>ADD</code> 命令了。</p><p>在 Docker 官方的 <a href="https://yeasy.gitbooks.io/docker_practice/content/appendix/best_practices.html" target="_blank" rel="noopener">Dockerfile 最佳实践文档</a> 中要求，尽可能的使用 <code>COPY</code>，因为 <code>COPY</code> 的语义很明确，就是复制文件而已，而 <code>ADD</code> 则包含了更复杂的功能，其行为也不一定很清晰。最适合使用 <code>ADD</code> 的场合，就是所提及的需要自动解压缩的场合。</p><p>另外需要注意的是，<code>ADD</code> 指令会令镜像构建缓存失效，从而可能会令镜像构建变得比较缓慢。</p><p>因此在 <code>COPY</code> 和 <code>ADD</code> 指令中选择的时候，可以遵循这样的原则，所有的文件复制均使用 <code>COPY</code> 指令，仅在需要自动解压缩的场合使用 <code>ADD</code>。</p><p>在使用该指令的时候还可以加上 <code>--chown=:</code> 选项来改变文件的所属用户及所属组。</p><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ADD</span><span class="bash"> --chown=55:mygroup files* /mydir/</span></span><br><span class="line"><span class="keyword">ADD</span><span class="bash"> --chown=bin files* /mydir/</span></span><br><span class="line"><span class="keyword">ADD</span><span class="bash"> --chown=1 files* /mydir/</span></span><br><span class="line"><span class="keyword">ADD</span><span class="bash"> --chown=10:11 files* /mydir/</span></span><br></pre></td></tr></table></figure><h2 id="CMD-容器启动命令"><a href="#CMD-容器启动命令" class="headerlink" title="CMD 容器启动命令"></a>CMD 容器启动命令</h2><p><code>CMD</code> 指令的格式和 <code>RUN</code> 相似，也是两种格式：</p><ul><li><code>shell</code> 格式：<code>CMD &lt;命令&gt;</code></li><li><code>exec</code> 格式：<code>CMD [&quot;可执行文件&quot;, &quot;参数1&quot;, &quot;参数2&quot;...]</code></li><li>参数列表格式：<code>CMD [&quot;参数1&quot;, &quot;参数2&quot;...]</code>。在指定了 <code>ENTRYPOINT</code> 指令后，用 <code>CMD</code> 指定具体的参数。</li></ul><p>之前介绍容器的时候曾经说过，Docker 不是虚拟机，容器就是进程。既然是进程，那么在启动容器的时候，需要指定所运行的程序及参数。<code>CMD</code> 指令就是用于指定默认的容器主进程的启动命令的。</p><p>在运行时可以指定新的命令来替代镜像设置中的这个默认命令，比如，<code>ubuntu</code> 镜像默认的 <code>CMD</code> 是 <code>/bin/bash</code>，如果我们直接 <code>docker run -it ubuntu</code> 的话，会直接进入 <code>bash</code>。我们也可以在运行时指定运行别的命令，如 <code>docker run -it ubuntu cat /etc/os-release</code>。这就是用 <code>cat /etc/os-release</code> 命令替换了默认的 <code>/bin/bash</code> 命令了，输出了系统版本信息。</p><p>在指令格式上，一般推荐使用 <code>exec</code> 格式，这类格式在解析时会被解析为 JSON 数组，因此一定要使用双引号 <code>&quot;</code>，而不要使用单引号。</p><p>如果使用 <code>shell</code> 格式的话，实际的命令会被包装为 <code>sh -c</code> 的参数的形式进行执行。比如：</p><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CMD</span><span class="bash"> <span class="built_in">echo</span> <span class="variable">$HOME</span></span></span><br></pre></td></tr></table></figure><p>在实际执行中，会将其变更为：</p><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CMD</span><span class="bash"> [ <span class="string">"sh"</span>, <span class="string">"-c"</span>, <span class="string">"echo <span class="variable">$HOME</span>"</span> ]</span></span><br></pre></td></tr></table></figure><p>这就是为什么我们可以使用环境变量的原因，因为这些环境变量会被 shell 进行解析处理。</p><p>提到 <code>CMD</code> 就不得不提容器中应用在前台执行和后台执行的问题。这是初学者常出现的一个混淆。</p><p>Docker 不是虚拟机，容器中的应用都应该以前台执行，而不是像虚拟机、物理机里面那样，用 <code>systemd</code> 去启动后台服务，容器内没有后台服务的概念。</p><p>一些初学者将 <code>CMD</code> 写为：</p><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CMD</span><span class="bash"> service nginx start</span></span><br></pre></td></tr></table></figure><p>然后发现容器执行后就立即退出了。甚至在容器内去使用 <code>systemctl</code> 命令结果却发现根本执行不了。这就是因为没有搞明白前台、后台的概念，没有区分容器和虚拟机的差异，依旧在以传统虚拟机的角度去理解容器。</p><p><strong>对于容器而言，其启动程序就是容器应用进程，容器就是为了主进程而存在的，主进程退出，容器就失去了存在的意义，从而退出，其它辅助进程不是它需要关心的东西。</strong></p><p>而使用 <code>service nginx start</code> 命令，则是希望 upstart 来以后台守护进程形式启动 <code>nginx</code> 服务。而刚才说了 <code>CMD service nginx start</code> 会被理解为 <code>CMD [ &quot;sh&quot;, &quot;-c&quot;, &quot;service nginx start&quot;]</code>，因此主进程实际上是 <code>sh</code>。那么当 <code>service nginx start</code> 命令结束后，<code>sh</code> 也就结束了，<code>sh</code> 作为主进程退出了，自然就会令容器退出。</p><p>正确的做法是直接执行 <code>nginx</code> 可执行文件，并且要求以前台形式运行。比如：</p><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CMD</span><span class="bash"> [<span class="string">"nginx"</span>, <span class="string">"-g"</span>, <span class="string">"daemon off;"</span>]</span></span><br></pre></td></tr></table></figure><h2 id="ENTRYPOINT-入口点"><a href="#ENTRYPOINT-入口点" class="headerlink" title="ENTRYPOINT 入口点"></a>ENTRYPOINT 入口点</h2><p><code>ENTRYPOINT</code> 的格式和 <code>RUN</code> 指令格式一样，分为 <code>exec</code> 格式和 <code>shell</code> 格式。</p><p><code>ENTRYPOINT</code> 的目的和 <code>CMD</code> 一样，都是在指定容器启动程序及参数。<code>ENTRYPOINT</code> 在运行时也可以替代，不过比 <code>CMD</code> 要略显繁琐，需要通过 <code>docker run</code> 的参数 <code>--entrypoint</code> 来指定。</p><p>当指定了 <code>ENTRYPOINT</code> 后，<code>CMD</code> 的含义就发生了改变，不再是直接的运行其命令，而是将 <code>CMD</code> 的内容作为参数传给 <code>ENTRYPOINT</code> 指令，换句话说实际执行时，将变为：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;ENTRYPOINT&gt; <span class="string">"&lt;CMD&gt;"</span></span><br></pre></td></tr></table></figure><p>那么有了 <code>CMD</code> 后，为什么还要有 <code>ENTRYPOINT</code> 呢？这种 <code>&quot;&quot;</code> 有什么好处么？让我们来看几个场景。</p><h3 id="场景一：让镜像变成像命令一样使用"><a href="#场景一：让镜像变成像命令一样使用" class="headerlink" title="场景一：让镜像变成像命令一样使用"></a>场景一：让镜像变成像命令一样使用</h3><p>假设我们需要一个得知自己当前公网 IP 的镜像，那么可以先用 <code>CMD</code> 来实现：</p><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> ubuntu:<span class="number">18.04</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> apt-get update \</span></span><br><span class="line"><span class="bash">    &amp;&amp; apt-get install -y curl \</span></span><br><span class="line"><span class="bash">    &amp;&amp; rm -rf /var/lib/apt/lists/*</span></span><br><span class="line"><span class="keyword">CMD</span><span class="bash"> [ <span class="string">"curl"</span>, <span class="string">"-s"</span>, <span class="string">"https://ip.cn"</span> ]</span></span><br></pre></td></tr></table></figure><p>假如我们使用 <code>docker build -t myip .</code> 来构建镜像的话，如果我们需要查询当前公网 IP，只需要执行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker run myip</span><br><span class="line">当前 IP：61.148.226.66 来自：北京市 联通</span><br></pre></td></tr></table></figure><p>嗯，这么看起来好像可以直接把镜像当做命令使用了，不过命令总有参数，如果我们希望加参数呢？比如从上面的 <code>CMD</code> 中可以看到实质的命令是 <code>curl</code>，那么如果我们希望显示 HTTP 头信息，就需要加上 <code>-i</code> 参数。那么我们可以直接加 <code>-i</code> 参数给 <code>docker run myip</code> 么？</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker run myip -i</span><br><span class="line">docker: Error response from daemon: invalid header field value <span class="string">"oci runtime error: container_linux.go:247: starting container process caused \"exec: \\\"-i\\\": executable file not found in <span class="variable">$PATH</span>\"\n"</span>.</span><br></pre></td></tr></table></figure><p>我们可以看到可执行文件找不到的报错，<code>executable file not found</code>。之前我们说过，跟在镜像名后面的是 <code>command</code>，运行时会替换 <code>CMD</code> 的默认值。因此这里的 <code>-i</code> 替换了原来的 <code>CMD</code>，而不是添加在原来的 <code>curl -s https://ip.cn</code> 后面。而 <code>-i</code> 根本不是命令，所以自然找不到。</p><p>那么如果我们希望加入 <code>-i</code> 这参数，我们就必须重新完整的输入这个命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker run myip curl -s https://ip.cn -i</span><br></pre></td></tr></table></figure><p>这显然不是很好的解决方案，而使用 <code>ENTRYPOINT</code> 就可以解决这个问题。现在我们重新用 <code>ENTRYPOINT</code> 来实现这个镜像：</p><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> ubuntu:<span class="number">18.04</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> apt-get update \</span></span><br><span class="line"><span class="bash">    &amp;&amp; apt-get install -y curl \</span></span><br><span class="line"><span class="bash">    &amp;&amp; rm -rf /var/lib/apt/lists/*</span></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="bash"> [ <span class="string">"curl"</span>, <span class="string">"-s"</span>, <span class="string">"https://ip.cn"</span> ]</span></span><br></pre></td></tr></table></figure><p>这次我们再来尝试直接使用 <code>docker run myip -i</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">$ docker run myip</span><br><span class="line">当前 IP：61.148.226.66 来自：北京市 联通</span><br><span class="line"></span><br><span class="line">$ docker run myip -i</span><br><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Server: nginx/1.8.0</span><br><span class="line">Date: Tue, 22 Nov 2016 05:12:40 GMT</span><br><span class="line">Content-Type: text/html; charset=UTF-8</span><br><span class="line">Vary: Accept-Encoding</span><br><span class="line">X-Powered-By: PHP/5.6.24-1~dotdeb+7.1</span><br><span class="line">X-Cache: MISS from cache-2</span><br><span class="line">X-Cache-Lookup: MISS from cache-2:80</span><br><span class="line">X-Cache: MISS from proxy-2_6</span><br><span class="line">Transfer-Encoding: chunked</span><br><span class="line">Via: 1.1 cache-2:80, 1.1 proxy-2_6:8006</span><br><span class="line">Connection: keep-alive</span><br><span class="line"></span><br><span class="line">当前 IP：61.148.226.66 来自：北京市 联通</span><br></pre></td></tr></table></figure><p>可以看到，这次成功了。这是因为当存在 <code>ENTRYPOINT</code> 后，<code>CMD</code> 的内容将会作为参数传给 <code>ENTRYPOINT</code>，而这里 <code>-i</code> 就是新的 <code>CMD</code>，因此会作为参数传给 <code>curl</code>，从而达到了我们预期的效果。</p><h3 id="场景二：应用运行前的准备工作"><a href="#场景二：应用运行前的准备工作" class="headerlink" title="场景二：应用运行前的准备工作"></a>场景二：应用运行前的准备工作</h3><p>启动容器就是启动主进程，但有些时候，启动主进程前，需要一些准备工作。</p><p>比如 <code>mysql</code> 类的数据库，可能需要一些数据库配置、初始化的工作，这些工作要在最终的 mysql 服务器运行之前解决。</p><p>此外，可能希望避免使用 <code>root</code> 用户去启动服务，从而提高安全性，而在启动服务前还需要以 <code>root</code> 身份执行一些必要的准备工作，最后切换到服务用户身份启动服务。或者除了服务外，其它命令依旧可以使用 <code>root</code> 身份执行，方便调试等。</p><p>这些准备工作是和容器 <code>CMD</code> 无关的，无论 <code>CMD</code> 为什么，都需要事先进行一个预处理的工作。这种情况下，可以写一个脚本，然后放入 <code>ENTRYPOINT</code> 中去执行，而这个脚本会将接到的参数（也就是 <code></code>）作为命令，在脚本最后执行。比如官方镜像 <code>redis</code> 中就是这么做的：</p><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> alpine:<span class="number">3.4</span></span><br><span class="line">...</span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> addgroup -S redis &amp;&amp; adduser -S -G redis redis</span></span><br><span class="line">...</span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="bash"> [<span class="string">"docker-entrypoint.sh"</span>]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">6379</span></span><br><span class="line"><span class="keyword">CMD</span><span class="bash"> [ <span class="string">"redis-server"</span> ]</span></span><br></pre></td></tr></table></figure><p>可以看到其中为了 redis 服务创建了 redis 用户，并在最后指定了 <code>ENTRYPOINT</code> 为 <code>docker-entrypoint.sh</code> 脚本。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line">...</span><br><span class="line"><span class="comment"># allow the container to be started with `--user`</span></span><br><span class="line"><span class="keyword">if</span> [ <span class="string">"<span class="variable">$1</span>"</span> = <span class="string">'redis-server'</span> -a <span class="string">"<span class="variable">$(id -u)</span>"</span> = <span class="string">'0'</span> ]; <span class="keyword">then</span></span><br><span class="line">    chown -R redis .</span><br><span class="line">    <span class="built_in">exec</span> su-exec redis <span class="string">"<span class="variable">$0</span>"</span> <span class="string">"<span class="variable">$@</span>"</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">exec</span> <span class="string">"<span class="variable">$@</span>"</span></span><br></pre></td></tr></table></figure><p>该脚本的内容就是根据 <code>CMD</code> 的内容来判断，如果是 <code>redis-server</code> 的话，则切换到 <code>redis</code> 用户身份启动服务器，否则依旧使用 <code>root</code> 身份执行。比如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -it redis id</span><br><span class="line">uid=0(root) gid=0(root) groups=0(root)</span><br></pre></td></tr></table></figure><h2 id="ENV-设置环境变量"><a href="#ENV-设置环境变量" class="headerlink" title="ENV 设置环境变量"></a>ENV 设置环境变量</h2><p>格式有两种：</p><ul><li><code>ENV</code></li><li><code>ENV = =...</code></li></ul><p>这个指令很简单，就是设置环境变量而已，无论是后面的其它指令，如 <code>RUN</code>，还是运行时的应用，都可以直接使用这里定义的环境变量。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ENV VERSION=1.0 DEBUG=on \</span><br><span class="line">    NAME=&quot;Happy Feet&quot;</span><br></pre></td></tr></table></figure><p>这个例子中演示了如何换行，以及对含有空格的值用双引号括起来的办法，这和 Shell 下的行为是一致的。</p><p>定义了环境变量，那么在后续的指令中，就可以使用这个环境变量。比如在官方 <code>node</code> 镜像 <code>Dockerfile</code> 中，就有类似这样的代码：</p><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ENV</span> NODE_VERSION <span class="number">7.2</span>.<span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> curl -SLO <span class="string">"https://nodejs.org/dist/v<span class="variable">$NODE_VERSION</span>/node-v<span class="variable">$NODE_VERSION</span>-linux-x64.tar.xz"</span> \</span></span><br><span class="line"><span class="bash">  &amp;&amp; curl -SLO <span class="string">"https://nodejs.org/dist/v<span class="variable">$NODE_VERSION</span>/SHASUMS256.txt.asc"</span> \</span></span><br><span class="line"><span class="bash">  &amp;&amp; gpg --batch --decrypt --output SHASUMS256.txt SHASUMS256.txt.asc \</span></span><br><span class="line"><span class="bash">  &amp;&amp; grep <span class="string">" node-v<span class="variable">$NODE_VERSION</span>-linux-x64.tar.xz\$"</span> SHASUMS256.txt | sha256sum -c - \</span></span><br><span class="line"><span class="bash">  &amp;&amp; tar -xJf <span class="string">"node-v<span class="variable">$NODE_VERSION</span>-linux-x64.tar.xz"</span> -C /usr/<span class="built_in">local</span> --strip-components=1 \</span></span><br><span class="line"><span class="bash">  &amp;&amp; rm <span class="string">"node-v<span class="variable">$NODE_VERSION</span>-linux-x64.tar.xz"</span> SHASUMS256.txt.asc SHASUMS256.txt \</span></span><br><span class="line"><span class="bash">  &amp;&amp; ln -s /usr/<span class="built_in">local</span>/bin/node /usr/<span class="built_in">local</span>/bin/nodejs</span></span><br></pre></td></tr></table></figure><p>在这里先定义了环境变量 <code>NODE_VERSION</code>，其后的 <code>RUN</code> 这层里，多次使用 <code>$NODE_VERSION</code> 来进行操作定制。可以看到，将来升级镜像构建版本的时候，只需要更新 <code>7.2.0</code> 即可，<code>Dockerfile</code> 构建维护变得更轻松了。</p><p>下列指令可以支持环境变量展开： <code>ADD</code>、<code>COPY</code>、<code>ENV</code>、<code>EXPOSE</code>、<code>FROM</code>、<code>LABEL</code>、<code>USER</code>、<code>WORKDIR</code>、<code>VOLUME</code>、<code>STOPSIGNAL</code>、<code>ONBUILD</code>、<code>RUN</code>。</p><p>可以从这个指令列表里感觉到，环境变量可以使用的地方很多，很强大。通过环境变量，我们可以让一份 <code>Dockerfile</code> 制作更多的镜像，只需使用不同的环境变量即可。</p><h2 id="ARG-构建参数"><a href="#ARG-构建参数" class="headerlink" title="ARG 构建参数"></a>ARG 构建参数</h2><p>格式：<code>ARG &lt;参数名&gt;[=&lt;默认值&gt;]</code></p><p>构建参数和 <code>ENV</code> 的效果一样，都是设置环境变量。所不同的是，<code>ARG</code> 所设置的构建环境的环境变量，在将来容器运行时是不会存在这些环境变量的。但是不要因此就使用 <code>ARG</code> 保存密码之类的信息，因为 <code>docker history</code> 还是可以看到所有值的。</p><p><code>Dockerfile</code> 中的 <code>ARG</code> 指令是定义参数名称，以及定义其默认值。该默认值可以在构建命令 <code>docker build</code> 中用 <code>--build-arg &lt;参数名&gt;=&lt;值&gt;</code> 来覆盖。</p><p>在 1.13 之前的版本，要求 <code>--build-arg</code> 中的参数名，必须在 <code>Dockerfile</code> 中用 <code>ARG</code> 定义过了，换句话说，就是 <code>--build-arg</code> 指定的参数，必须在 <code>Dockerfile</code> 中使用了。如果对应参数没有被使用，则会报错退出构建。从 1.13 开始，这种严格的限制被放开，不再报错退出，而是显示警告信息，并继续构建。这对于使用 CI 系统，用同样的构建流程构建不同的 <code>Dockerfile</code> 的时候比较有帮助，避免构建命令必须根据每个 Dockerfile 的内容修改。</p><h2 id="VOLUME-定义匿名卷"><a href="#VOLUME-定义匿名卷" class="headerlink" title="VOLUME 定义匿名卷"></a>VOLUME 定义匿名卷</h2><p>格式为：</p><ul><li><code>VOLUME [&quot;&lt;路径1&gt;&quot;, &quot;&lt;路径2&gt;&quot;...]</code></li><li><code>VOLUME &lt;路径&gt;</code></li></ul><p>之前我们说过，容器运行时应该尽量保持容器存储层不发生写操作，对于数据库类需要保存动态数据的应用，其数据库文件应该保存于卷(volume)中，后面的章节我们会进一步介绍 Docker 卷的概念。为了防止运行时用户忘记将动态文件所保存目录挂载为卷，在 <code>Dockerfile</code> 中，我们可以事先指定某些目录挂载为匿名卷，这样在运行时如果用户不指定挂载，其应用也可以正常运行，不会向容器存储层写入大量数据。</p><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">VOLUME</span><span class="bash"> /data</span></span><br></pre></td></tr></table></figure><p>这里的 <code>/data</code> 目录就会在运行时自动挂载为匿名卷，任何向 <code>/data</code> 中写入的信息都不会记录进容器存储层，从而保证了容器存储层的无状态化。当然，运行时可以覆盖这个挂载设置。比如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -v mydata:/data xxxx</span><br></pre></td></tr></table></figure><p>在这行命令中，就使用了 <code>mydata</code> 这个命名卷挂载到了 <code>/data</code> 这个位置，替代了 <code>Dockerfile</code> 中定义的匿名卷的挂载配置。</p><h2 id="EXPOSE-声明端口"><a href="#EXPOSE-声明端口" class="headerlink" title="EXPOSE 声明端口"></a>EXPOSE 声明端口</h2><p>格式为 <code>EXPOSE &lt;端口1&gt; [&lt;端口2&gt;...]</code>。</p><p><code>EXPOSE</code> 指令是声明运行时容器提供服务端口，这只是一个声明，在运行时并不会因为这个声明应用就会开启这个端口的服务。在 Dockerfile 中写入这样的声明有两个好处，一个是帮助镜像使用者理解这个镜像服务的守护端口，以方便配置映射；另一个用处则是在运行时使用随机端口映射时，也就是 <code>docker run -P</code> 时，会自动随机映射 <code>EXPOSE</code> 的端口。</p><p>要将 <code>EXPOSE</code> 和在运行时使用 <code>-p &lt;宿主端口&gt;:&lt;容器端口&gt;</code> 区分开来。<code>-p</code>，是映射宿主端口和容器端口，换句话说，就是将容器的对应端口服务公开给外界访问，而 <code>EXPOSE</code> 仅仅是声明容器打算使用什么端口而已，并不会自动在宿主进行端口映射。</p><h2 id="WORKDIR-指定工作目录"><a href="#WORKDIR-指定工作目录" class="headerlink" title="WORKDIR 指定工作目录"></a>WORKDIR 指定工作目录</h2><p>格式为 <code>WORKDIR &lt;工作目录路径&gt;</code>。</p><p>使用 <code>WORKDIR</code> 指令可以来指定工作目录（或者称为当前目录），以后各层的当前目录就被改为指定的目录，如该目录不存在，<code>WORKDIR</code> 会帮你建立目录。</p><p>之前提到一些初学者常犯的错误是把 <code>Dockerfile</code> 等同于 Shell 脚本来书写，这种错误的理解还可能会导致出现下面这样的错误：</p><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">RUN</span><span class="bash"> <span class="built_in">cd</span> /app</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> <span class="built_in">echo</span> <span class="string">"hello"</span> &gt; world.txt</span></span><br></pre></td></tr></table></figure><p>如果将这个 <code>Dockerfile</code> 进行构建镜像运行后，会发现找不到 <code>/app/world.txt</code> 文件，或者其内容不是 <code>hello</code>。原因其实很简单，在 Shell 中，连续两行是同一个进程执行环境，因此前一个命令修改的内存状态，会直接影响后一个命令；而在 <code>Dockerfile</code> 中，这两行 <code>RUN</code> 命令的执行环境根本不同，是两个完全不同的容器。这就是对 <code>Dockerfile</code> 构建分层存储的概念不了解所导致的错误。</p><p>之前说过每一个 <code>RUN</code> 都是启动一个容器、执行命令、然后提交存储层文件变更。第一层 <code>RUN cd /app</code> 的执行仅仅是当前进程的工作目录变更，一个内存上的变化而已，其结果不会造成任何文件变更。而到第二层的时候，启动的是一个全新的容器，跟第一层的容器更完全没关系，自然不可能继承前一层构建过程中的内存变化。</p><p>因此如果需要改变以后各层的工作目录的位置，那么应该使用 <code>WORKDIR</code> 指令。</p><h2 id="USER-指定当前用户"><a href="#USER-指定当前用户" class="headerlink" title="USER 指定当前用户"></a>USER 指定当前用户</h2><p>格式：<code>USER &lt;用户名&gt;[:&lt;用户组&gt;]</code></p><p><code>USER</code> 指令和 <code>WORKDIR</code> 相似，都是改变环境状态并影响以后的层。<code>WORKDIR</code> 是改变工作目录，<code>USER</code> 则是改变之后层的执行 <code>RUN</code>, <code>CMD</code> 以及 <code>ENTRYPOINT</code> 这类命令的身份。</p><p>当然，和 <code>WORKDIR</code> 一样，<code>USER</code> 只是帮助你切换到指定用户而已，这个用户必须是事先建立好的，否则无法切换。</p><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">RUN</span><span class="bash"> groupadd -r redis &amp;&amp; useradd -r -g redis redis</span></span><br><span class="line"><span class="keyword">USER</span> redis</span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> [ <span class="string">"redis-server"</span> ]</span></span><br></pre></td></tr></table></figure><p>如果以 <code>root</code> 执行的脚本，在执行期间希望改变身份，比如希望以某个已经建立好的用户来运行某个服务进程，不要使用 <code>su</code> 或者 <code>sudo</code>，这些都需要比较麻烦的配置，而且在 TTY 缺失的环境下经常出错。建议使用 <a href="https://github.com/tianon/gosu" target="_blank" rel="noopener"><code>gosu</code></a>。</p><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 建立 redis 用户，并使用 gosu 换另一个用户执行命令</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> groupadd -r redis &amp;&amp; useradd -r -g redis redis</span></span><br><span class="line"><span class="comment"># 下载 gosu</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> wget -O /usr/<span class="built_in">local</span>/bin/gosu <span class="string">"https://github.com/tianon/gosu/releases/download/1.7/gosu-amd64"</span> \</span></span><br><span class="line"><span class="bash">    &amp;&amp; chmod +x /usr/<span class="built_in">local</span>/bin/gosu \</span></span><br><span class="line"><span class="bash">    &amp;&amp; gosu nobody <span class="literal">true</span></span></span><br><span class="line"><span class="comment"># 设置 CMD，并以另外的用户执行</span></span><br><span class="line"><span class="keyword">CMD</span><span class="bash"> [ <span class="string">"exec"</span>, <span class="string">"gosu"</span>, <span class="string">"redis"</span>, <span class="string">"redis-server"</span> ]</span></span><br></pre></td></tr></table></figure><h2 id="HEALTHCHECK-健康检查"><a href="#HEALTHCHECK-健康检查" class="headerlink" title="HEALTHCHECK 健康检查"></a>HEALTHCHECK 健康检查</h2><p>格式：</p><ul><li><code>HEALTHCHECK [选项] CMD &lt;命令&gt;</code>：设置检查容器健康状况的命令</li><li><code>HEALTHCHECK NONE</code>：如果基础镜像有健康检查指令，使用这行可以屏蔽掉其健康检查指令</li></ul><p><code>HEALTHCHECK</code> 指令是告诉 Docker 应该如何进行判断容器的状态是否正常，这是 Docker 1.12 引入的新指令。</p><p>在没有 <code>HEALTHCHECK</code> 指令前，Docker 引擎只可以通过容器内主进程是否退出来判断容器是否状态异常。很多情况下这没问题，但是如果程序进入死锁状态，或者死循环状态，应用进程并不退出，但是该容器已经无法提供服务了。在 1.12 以前，Docker 不会检测到容器的这种状态，从而不会重新调度，导致可能会有部分容器已经无法提供服务了却还在接受用户请求。</p><p>而自 1.12 之后，Docker 提供了 <code>HEALTHCHECK</code> 指令，通过该指令指定一行命令，用这行命令来判断容器主进程的服务状态是否还正常，从而比较真实的反应容器实际状态。</p><p>当在一个镜像指定了 <code>HEALTHCHECK</code> 指令后，用其启动容器，初始状态会为 <code>starting</code>，在 <code>HEALTHCHECK</code> 指令检查成功后变为 <code>healthy</code>，如果连续一定次数失败，则会变为 <code>unhealthy</code>。</p><p><code>HEALTHCHECK</code> 支持下列选项：</p><ul><li><code>--interval=&lt;间隔&gt;</code>：两次健康检查的间隔，默认为 30 秒；</li><li><code>--timeout=&lt;时长&gt;</code>：健康检查命令运行超时时间，如果超过这个时间，本次健康检查就被视为失败，默认 30 秒；</li><li><code>--retries=&lt;次数&gt;</code>：当连续失败指定次数后，则将容器状态视为 <code>unhealthy</code>，默认 3 次。</li></ul><p>和 <code>CMD</code>, <code>ENTRYPOINT</code> 一样，<code>HEALTHCHECK</code> 只可以出现一次，如果写了多个，只有最后一个生效。</p><p>在 <code>HEALTHCHECK [选项] CMD</code> 后面的命令，格式和 <code>ENTRYPOINT</code> 一样，分为 <code>shell</code> 格式，和 <code>exec</code> 格式。命令的返回值决定了该次健康检查的成功与否：<code>0</code>：成功；<code>1</code>：失败；<code>2</code>：保留，不要使用这个值。</p><p>假设我们有个镜像是个最简单的 Web 服务，我们希望增加健康检查来判断其 Web 服务是否在正常工作，我们可以用 <code>curl</code> 来帮助判断，其 <code>Dockerfile</code> 的 <code>HEALTHCHECK</code> 可以这么写：</p><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> nginx</span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> apt-get update &amp;&amp; apt-get install -y curl &amp;&amp; rm -rf /var/lib/apt/lists/*</span></span><br><span class="line"><span class="keyword">HEALTHCHECK</span><span class="bash"> --interval=5s --timeout=3s \</span></span><br><span class="line"><span class="bash">  CMD curl -fs http://localhost/ || <span class="built_in">exit</span> 1</span></span><br></pre></td></tr></table></figure><p>这里我们设置了每 5 秒检查一次（这里为了试验所以间隔非常短，实际应该相对较长），如果健康检查命令超过 3 秒没响应就视为失败，并且使用 <code>curl -fs http://localhost/ || exit 1</code> 作为健康检查命令。</p><p>使用 <code>docker build</code> 来构建这个镜像：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker build -t myweb:v1 .</span><br></pre></td></tr></table></figure><p>构建好了后，我们启动一个容器：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -d --name web -p 80:80 myweb:v1</span><br></pre></td></tr></table></figure><p>当运行该镜像后，可以通过 <code>docker container ls</code> 看到最初的状态为 <code>(health: starting)</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ docker container ls</span><br><span class="line">CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS                            PORTS               NAMES</span><br><span class="line">03e28eb00bd0        myweb:v1            <span class="string">"nginx -g 'daemon off"</span>   3 seconds ago       Up 2 seconds (health: starting)   80/tcp, 443/tcp     web</span><br></pre></td></tr></table></figure><p>在等待几秒钟后，再次 <code>docker container ls</code>，就会看到健康状态变化为了 <code>(healthy)</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ docker container ls</span><br><span class="line">CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS                    PORTS               NAMES</span><br><span class="line">03e28eb00bd0        myweb:v1            <span class="string">"nginx -g 'daemon off"</span>   18 seconds ago      Up 16 seconds (healthy)   80/tcp, 443/tcp     web</span><br></pre></td></tr></table></figure><p>如果健康检查连续失败超过了重试次数，状态就会变为 <code>(unhealthy)</code>。</p><p>为了帮助排障，健康检查命令的输出（包括 <code>stdout</code> 以及 <code>stderr</code>）都会被存储于健康状态里，可以用 <code>docker inspect</code> 来查看。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ docker inspect --format <span class="string">'&#123;&#123;json .State.Health&#125;&#125;'</span> web | python -m json.tool</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">"FailingStreak"</span>: 0,</span><br><span class="line">    <span class="string">"Log"</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">"End"</span>: <span class="string">"2016-11-25T14:35:37.940957051Z"</span>,</span><br><span class="line">            <span class="string">"ExitCode"</span>: 0,</span><br><span class="line">            <span class="string">"Output"</span>: <span class="string">"&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;head&gt;\n&lt;title&gt;Welcome to nginx!&lt;/title&gt;\n&lt;style&gt;\n    body &#123;\n        width: 35em;\n        margin: 0 auto;\n        font-family: Tahoma, Verdana, Arial, sans-serif;\n    &#125;\n&lt;/style&gt;\n&lt;/head&gt;\n&lt;body&gt;\n&lt;h1&gt;Welcome to nginx!&lt;/h1&gt;\n&lt;p&gt;If you see this page, the nginx web server is successfully installed and\nworking. Further configuration is required.&lt;/p&gt;\n\n&lt;p&gt;For online documentation and support please refer to\n&lt;a href=\"http://nginx.org/\"&gt;nginx.org&lt;/a&gt;.&lt;br/&gt;\nCommercial support is available at\n&lt;a href=\"http://nginx.com/\"&gt;nginx.com&lt;/a&gt;.&lt;/p&gt;\n\n&lt;p&gt;&lt;em&gt;Thank you for using nginx.&lt;/em&gt;&lt;/p&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n"</span>,</span><br><span class="line">            <span class="string">"Start"</span>: <span class="string">"2016-11-25T14:35:37.780192565Z"</span></span><br><span class="line">        &#125;</span><br><span class="line">    ],</span><br><span class="line">    <span class="string">"Status"</span>: <span class="string">"healthy"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="ONBUILD-为他人做嫁衣裳"><a href="#ONBUILD-为他人做嫁衣裳" class="headerlink" title="ONBUILD 为他人做嫁衣裳"></a>ONBUILD 为他人做嫁衣裳</h2><p>格式：<code>ONBUILD &lt;其它指令&gt;</code>。</p><p><code>ONBUILD</code> 是一个特殊的指令，它后面跟的是其它指令，比如 <code>RUN</code>, <code>COPY</code> 等，而这些指令，在当前镜像构建时并不会被执行。只有当以当前镜像为基础镜像，去构建下一级镜像的时候才会被执行。</p><p><code>Dockerfile</code> 中的其它指令都是为了定制当前镜像而准备的，唯有 <code>ONBUILD</code> 是为了帮助别人定制自己而准备的。</p><p>假设我们要制作 Node.js 所写的应用的镜像。我们都知道 Node.js 使用 <code>npm</code> 进行包管理，所有依赖、配置、启动信息等会放到 <code>package.json</code> 文件里。在拿到程序代码后，需要先进行 <code>npm install</code> 才可以获得所有需要的依赖。然后就可以通过 <code>npm start</code> 来启动应用。因此，一般来说会这样写 <code>Dockerfile</code>：</p><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> node:slim</span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> mkdir /app</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> /app</span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> ./package.json /app</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> [ <span class="string">"npm"</span>, <span class="string">"install"</span> ]</span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> . /app/</span></span><br><span class="line"><span class="keyword">CMD</span><span class="bash"> [ <span class="string">"npm"</span>, <span class="string">"start"</span> ]</span></span><br></pre></td></tr></table></figure><p>把这个 <code>Dockerfile</code> 放到 Node.js 项目的根目录，构建好镜像后，就可以直接拿来启动容器运行。但是如果我们还有第二个 Node.js 项目也差不多呢？好吧，那就再把这个 <code>Dockerfile</code> 复制到第二个项目里。那如果有第三个项目呢？再复制么？文件的副本越多，版本控制就越困难，让我们继续看这样的场景维护的问题。</p><p>如果第一个 Node.js 项目在开发过程中，发现这个 <code>Dockerfile</code> 里存在问题，比如敲错字了、或者需要安装额外的包，然后开发人员修复了这个 <code>Dockerfile</code>，再次构建，问题解决。第一个项目没问题了，但是第二个项目呢？虽然最初 <code>Dockerfile</code> 是复制、粘贴自第一个项目的，但是并不会因为第一个项目修复了他们的 <code>Dockerfile</code>，而第二个项目的 <code>Dockerfile</code> 就会被自动修复。</p><p>那么我们可不可以做一个基础镜像，然后各个项目使用这个基础镜像呢？这样基础镜像更新，各个项目不用同步 <code>Dockerfile</code> 的变化，重新构建后就继承了基础镜像的更新？好吧，可以，让我们看看这样的结果。那么上面的这个 <code>Dockerfile</code> 就会变为：</p><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> node:slim</span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> mkdir /app</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> /app</span></span><br><span class="line"><span class="keyword">CMD</span><span class="bash"> [ <span class="string">"npm"</span>, <span class="string">"start"</span> ]</span></span><br></pre></td></tr></table></figure><p>这里我们把项目相关的构建指令拿出来，放到子项目里去。假设这个基础镜像的名字为 <code>my-node</code> 的话，各个项目内的自己的 <code>Dockerfile</code> 就变为：</p><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> my-node</span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> ./package.json /app</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> [ <span class="string">"npm"</span>, <span class="string">"install"</span> ]</span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> . /app/</span></span><br></pre></td></tr></table></figure><p>基础镜像变化后，各个项目都用这个 <code>Dockerfile</code> 重新构建镜像，会继承基础镜像的更新。</p><p>那么，问题解决了么？没有。准确说，只解决了一半。如果这个 <code>Dockerfile</code> 里面有些东西需要调整呢？比如 <code>npm install</code> 都需要加一些参数，那怎么办？这一行 <code>RUN</code> 是不可能放入基础镜像的，因为涉及到了当前项目的 <code>./package.json</code>，难道又要一个个修改么？所以说，这样制作基础镜像，只解决了原来的 <code>Dockerfile</code> 的前4条指令的变化问题，而后面三条指令的变化则完全没办法处理。</p><p><code>ONBUILD</code> 可以解决这个问题。让我们用 <code>ONBUILD</code> 重新写一下基础镜像的 <code>Dockerfile</code>:</p><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> node:slim</span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> mkdir /app</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> /app</span></span><br><span class="line"><span class="keyword">ONBUILD</span> <span class="keyword">COPY</span><span class="bash"> ./package.json /app</span></span><br><span class="line"><span class="keyword">ONBUILD</span> <span class="keyword">RUN</span><span class="bash"> [ <span class="string">"npm"</span>, <span class="string">"install"</span> ]</span></span><br><span class="line"><span class="keyword">ONBUILD</span> <span class="keyword">COPY</span><span class="bash"> . /app/</span></span><br><span class="line"><span class="keyword">CMD</span><span class="bash"> [ <span class="string">"npm"</span>, <span class="string">"start"</span> ]</span></span><br></pre></td></tr></table></figure><p>这次我们回到原始的 <code>Dockerfile</code>，但是这次将项目相关的指令加上 <code>ONBUILD</code>，这样在构建基础镜像的时候，这三行并不会被执行。然后各个项目的 <code>Dockerfile</code> 就变成了简单地：</p><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> my-node</span><br></pre></td></tr></table></figure><p>是的，只有这么一行。当在各个项目目录中，用这个只有一行的 <code>Dockerfile</code> 构建镜像时，之前基础镜像的那三行 <code>ONBUILD</code> 就会开始执行，成功的将当前项目的代码复制进镜像、并且针对本项目执行 <code>npm install</code>，生成应用镜像。</p><h1 id="Dockerfile多阶段构建"><a href="#Dockerfile多阶段构建" class="headerlink" title="Dockerfile多阶段构建"></a>Dockerfile多阶段构建</h1><h2 id="之前的做法"><a href="#之前的做法" class="headerlink" title="之前的做法"></a>之前的做法</h2><p>在 Docker 17.05 版本之前，我们构建 Docker 镜像时，通常会采用两种方式：</p><h3 id="全部放入一个-Dockerfile"><a href="#全部放入一个-Dockerfile" class="headerlink" title="全部放入一个 Dockerfile"></a>全部放入一个 Dockerfile</h3><p>一种方式是将所有的构建过程编包含在一个 <code>Dockerfile</code> 中，包括项目及其依赖库的编译、测试、打包等流程，这里可能会带来的一些问题：</p><ul><li>镜像层次多，镜像体积较大，部署时间变长</li><li>源代码存在泄露的风险</li></ul><p>例如，编写 <code>app.go</code> 文件，该程序输出 <code>Hello World!</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    fmt.Printf(<span class="string">"Hello World!"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编写 <code>Dockerfile.one</code> 文件</p><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> golang:<span class="number">1.9</span>-alpine</span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> apk --no-cache add git ca-certificates</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> /go/src/github.com/go/helloworld/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> app.go .</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> go get -d -v github.com/go-sql-driver/mysql \</span></span><br><span class="line"><span class="bash">  &amp;&amp; CGO_ENABLED=0 GOOS=linux go build -a -installsuffix cgo -o app . \</span></span><br><span class="line"><span class="bash">  &amp;&amp; cp /go/src/github.com/go/helloworld/app /root</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> /root/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">CMD</span><span class="bash"> [<span class="string">"./app"</span>]</span></span><br></pre></td></tr></table></figure><p>构建镜像</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker build -t go/helloworld:1 -f Dockerfile.one .</span><br></pre></td></tr></table></figure><h3 id="分散到多个-Dockerfile"><a href="#分散到多个-Dockerfile" class="headerlink" title="分散到多个 Dockerfile"></a>分散到多个 Dockerfile</h3><p>另一种方式，就是我们事先在一个 <code>Dockerfile</code> 将项目及其依赖库编译测试打包好后，再将其拷贝到运行环境中，这种方式需要我们编写两个 <code>Dockerfile</code> 和一些编译脚本才能将其两个阶段自动整合起来，这种方式虽然可以很好地规避第一种方式存在的风险，但明显部署过程较复杂。</p><p>例如，编写 <code>Dockerfile.build</code> 文件</p><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> golang:<span class="number">1.9</span>-alpine</span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> apk --no-cache add git</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> /go/src/github.com/go/helloworld</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> app.go .</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> go get -d -v github.com/go-sql-driver/mysql \</span></span><br><span class="line"><span class="bash">  &amp;&amp; CGO_ENABLED=0 GOOS=linux go build -a -installsuffix cgo -o app .</span></span><br></pre></td></tr></table></figure><p>编写 <code>Dockerfile.copy</code> 文件</p><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> alpine:latest</span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> apk --no-cache add ca-certificates</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> /root/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> app .</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">CMD</span><span class="bash"> [<span class="string">"./app"</span>]</span></span><br></pre></td></tr></table></figure><p>新建 <code>build.sh</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"><span class="built_in">echo</span> Building go/helloworld:build</span><br><span class="line"></span><br><span class="line">docker build -t go/helloworld:build . -f Dockerfile.build</span><br><span class="line"></span><br><span class="line">docker create --name extract go/helloworld:build</span><br><span class="line">docker cp extract:/go/src/github.com/go/helloworld/app ./app</span><br><span class="line">docker rm -f extract</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> Building go/helloworld:2</span><br><span class="line"></span><br><span class="line">docker build --no-cache -t go/helloworld:2 . -f Dockerfile.copy</span><br><span class="line">rm ./app</span><br></pre></td></tr></table></figure><p>现在运行脚本即可构建镜像</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ chmod +x build.sh</span><br><span class="line"></span><br><span class="line">$ ./build.sh</span><br></pre></td></tr></table></figure><p>对比两种方式生成的镜像大小</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ docker image ls</span><br><span class="line"></span><br><span class="line">REPOSITORY      TAG    IMAGE ID        CREATED         SIZE</span><br><span class="line">go/helloworld   2      f7cf3465432c    22 seconds ago  6.47MB</span><br><span class="line">go/helloworld   1      f55d3e16affc    2 minutes ago   295MB</span><br></pre></td></tr></table></figure><h2 id="使用多阶段构建"><a href="#使用多阶段构建" class="headerlink" title="使用多阶段构建"></a>使用多阶段构建</h2><p>为解决以上问题，Docker v17.05 开始支持多阶段构建 (<code>multistage builds</code>)。使用多阶段构建我们就可以很容易解决前面提到的问题，并且只需要编写一个 <code>Dockerfile</code>：</p><p>例如，编写 <code>Dockerfile</code> 文件</p><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> golang:<span class="number">1.9</span>-alpine as builder</span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> apk --no-cache add git</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> /go/src/github.com/go/helloworld/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> go get -d -v github.com/go-sql-driver/mysql</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> app.go .</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> CGO_ENABLED=0 GOOS=linux go build -a -installsuffix cgo -o app .</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">FROM</span> alpine:latest as prod</span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> apk --no-cache add ca-certificates</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> /root/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> --from=0 /go/src/github.com/go/helloworld/app .</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">CMD</span><span class="bash"> [<span class="string">"./app"</span>]</span></span><br></pre></td></tr></table></figure><p>构建镜像</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker build -t go/helloworld:3 .</span><br></pre></td></tr></table></figure><p>对比三个镜像大小</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ docker image ls</span><br><span class="line"></span><br><span class="line">REPOSITORY        TAG   IMAGE ID         CREATED            SIZE</span><br><span class="line">go/helloworld     3     d6911ed9c846     7 seconds ago      6.47MB</span><br><span class="line">go/helloworld     2     f7cf3465432c     22 seconds ago     6.47MB</span><br><span class="line">go/helloworld     1     f55d3e16affc     2 minutes ago      295MB</span><br></pre></td></tr></table></figure><p>很明显使用多阶段构建的镜像体积小，同时也完美解决了上边提到的问题。</p><h3 id="只构建某一阶段的镜像"><a href="#只构建某一阶段的镜像" class="headerlink" title="只构建某一阶段的镜像"></a>只构建某一阶段的镜像</h3><p>我们可以使用 <code>as</code> 来为某一阶段命名，例如</p><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> golang:<span class="number">1.9</span>-alpine as builder</span><br></pre></td></tr></table></figure><p>例如当我们只想构建 <code>builder</code> 阶段的镜像时，增加 <code>--target=builder</code> 参数即可</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker build --target builder -t username/imagename:tag .</span><br></pre></td></tr></table></figure><h3 id="构建时从其他镜像复制文件"><a href="#构建时从其他镜像复制文件" class="headerlink" title="构建时从其他镜像复制文件"></a>构建时从其他镜像复制文件</h3><p>上面例子中我们使用 <code>COPY --from=0 /go/src/github.com/go/helloworld/app .</code> 从上一阶段的镜像中复制文件，我们也可以复制任意镜像中的文件。</p><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="keyword">COPY</span><span class="bash"> --from=nginx:latest /etc/nginx/nginx.conf /nginx.conf</span></span><br></pre></td></tr></table></figure><h1 id="镜像的实现原理"><a href="#镜像的实现原理" class="headerlink" title="镜像的实现原理"></a>镜像的实现原理</h1><p>Docker 镜像是怎么实现增量的修改和维护的？</p><p>每个镜像都由很多层次构成，Docker 使用 <a href="https://en.wikipedia.org/wiki/UnionFS" target="_blank" rel="noopener">Union FS</a> 将这些不同的层结合到一个镜像中去。</p><p>通常 Union FS 有两个用途, 一方面可以实现不借助 LVM、RAID 将多个 disk 挂到同一个目录下,另一个更常用的就是将一个只读的分支和一个可写的分支联合在一起，Live CD 正是基于此方法可以允许在镜像不变的基础上允许用户在其上进行一些写操作。</p><p>Docker 在 AUFS 上构建的容器也是利用了类似的原理。</p><h1 id="实践指南"><a href="#实践指南" class="headerlink" title="实践指南"></a>实践指南</h1><h2 id="一般性的指南和建议"><a href="#一般性的指南和建议" class="headerlink" title="一般性的指南和建议"></a>一般性的指南和建议</h2><h3 id="容器应该是短暂的"><a href="#容器应该是短暂的" class="headerlink" title="容器应该是短暂的"></a>容器应该是短暂的</h3><p>通过 <code>Dockerfile</code> 构建的镜像所启动的容器应该尽可能短暂（生命周期短）。「短暂」意味着可以停止和销毁容器，并且创建一个新容器并部署好所需的设置和配置工作量应该是极小的。</p><h3 id="使用-dockerignore-文件"><a href="#使用-dockerignore-文件" class="headerlink" title="使用 .dockerignore 文件"></a>使用 <code>.dockerignore</code> 文件</h3><p>使用 <code>Dockerfile</code> 构建镜像时最好是将 <code>Dockerfile</code> 放置在一个新建的空目录下。然后将构建镜像所需要的文件添加到该目录中。为了提高构建镜像的效率，你可以在目录下新建一个 <code>.dockerignore</code> 文件来指定要忽略的文件和目录。<code>.dockerignore</code> 文件的排除模式语法和 Git 的 <code>.gitignore</code> 文件相似。</p><h3 id="使用多阶段构建-1"><a href="#使用多阶段构建-1" class="headerlink" title="使用多阶段构建"></a>使用多阶段构建</h3><p>在 <code>Docker 17.05</code> 以上版本中，你可以使用 <a href="https://yeasy.gitbooks.io/docker_practice/content/image/multistage-builds.md" target="_blank" rel="noopener">多阶段构建</a> 来减少所构建镜像的大小。</p><h3 id="避免安装不必要的包"><a href="#避免安装不必要的包" class="headerlink" title="避免安装不必要的包"></a>避免安装不必要的包</h3><p>为了降低复杂性、减少依赖、减小文件大小、节约构建时间，你应该避免安装任何不必要的包。例如，不要在数据库镜像中包含一个文本编辑器。</p><h3 id="一个容器只运行一个进程"><a href="#一个容器只运行一个进程" class="headerlink" title="一个容器只运行一个进程"></a>一个容器只运行一个进程</h3><p>应该保证在一个容器中只运行一个进程。将多个应用解耦到不同容器中，保证了容器的横向扩展和复用。例如 web 应用应该包含三个容器：web应用、数据库、缓存。</p><p>如果容器互相依赖，你可以使用 <a href="https://yeasy.gitbooks.io/docker_practice/content/network/linking.html" target="_blank" rel="noopener">Docker 自定义网络</a> 来把这些容器连接起来。</p><h3 id="镜像层数尽可能少"><a href="#镜像层数尽可能少" class="headerlink" title="镜像层数尽可能少"></a>镜像层数尽可能少</h3><p>你需要在 <code>Dockerfile</code> 可读性（也包括长期的可维护性）和减少层数之间做一个平衡。</p><h3 id="将多行参数排序"><a href="#将多行参数排序" class="headerlink" title="将多行参数排序"></a>将多行参数排序</h3><p>将多行参数按字母顺序排序（比如要安装多个包时）。这可以帮助你避免重复包含同一个包，更新包列表时也更容易。也便于 <code>PRs</code> 阅读和审查。建议在反斜杠符号 <code>\</code> 之前添加一个空格，以增加可读性。</p><p>下面是来自 <code>buildpack-deps</code> 镜像的例子：</p><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">RUN</span><span class="bash"> apt-get update &amp;&amp; apt-get install -y \</span></span><br><span class="line"><span class="bash">  bzr \</span></span><br><span class="line"><span class="bash">  cvs \</span></span><br><span class="line"><span class="bash">  git \</span></span><br><span class="line"><span class="bash">  mercurial \</span></span><br><span class="line"><span class="bash">  subversion</span></span><br></pre></td></tr></table></figure><h3 id="构建缓存"><a href="#构建缓存" class="headerlink" title="构建缓存"></a>构建缓存</h3><p>在镜像的构建过程中，Docker 会遍历 <code>Dockerfile</code> 文件中的指令，然后按顺序执行。在执行每条指令之前，Docker 都会在缓存中查找是否已经存在可重用的镜像，如果有就使用现存的镜像，不再重复创建。如果你不想在构建过程中使用缓存，你可以在 <code>docker build</code> 命令中使用 <code>--no-cache=true</code> 选项。</p><p>但是，如果你想在构建的过程中使用缓存，你得明白什么时候会，什么时候不会找到匹配的镜像，遵循的基本规则如下：</p><ul><li>从一个基础镜像开始（<code>FROM</code> 指令指定），下一条指令将和该基础镜像的所有子镜像进行匹配，检查这些子镜像被创建时使用的指令是否和被检查的指令完全一样。如果不是，则缓存失效。</li><li>在大多数情况下，只需要简单地对比 <code>Dockerfile</code> 中的指令和子镜像。然而，有些指令需要更多的检查和解释。</li><li>对于 <code>ADD</code> 和 <code>COPY</code> 指令，镜像中对应文件的内容也会被检查，每个文件都会计算出一个校验和。文件的最后修改时间和最后访问时间不会纳入校验。在缓存的查找过程中，会将这些校验和和已存在镜像中的文件校验和进行对比。如果文件有任何改变，比如内容和元数据，则缓存失效。</li><li>除了 <code>ADD</code> 和 <code>COPY</code> 指令，缓存匹配过程不会查看临时容器中的文件来决定缓存是否匹配。例如，当执行完 <code>RUN apt-get -y update</code> 指令后，容器中一些文件被更新，但 Docker 不会检查这些文件。这种情况下，只有指令字符串本身被用来匹配缓存。</li></ul><p>一旦缓存失效，所有后续的 <code>Dockerfile</code> 指令都将产生新的镜像，缓存不会被使用。</p><h2 id="Dockerfile-指令"><a href="#Dockerfile-指令" class="headerlink" title="Dockerfile 指令"></a>Dockerfile 指令</h2><p>下面针对 <code>Dockerfile</code> 中各种指令的最佳编写方式给出建议。</p><h3 id="FROM"><a href="#FROM" class="headerlink" title="FROM"></a>FROM</h3><p>尽可能使用当前官方仓库作为你构建镜像的基础。推荐使用 <a href="https://hub.docker.com/_/alpine/" target="_blank" rel="noopener">Alpine</a> 镜像，因为它被严格控制并保持最小尺寸（目前小于 5 MB），但它仍然是一个完整的发行版。</p><h3 id="LABEL"><a href="#LABEL" class="headerlink" title="LABEL"></a>LABEL</h3><p>你可以给镜像添加标签来帮助组织镜像、记录许可信息、辅助自动化构建等。每个标签一行，由 <code>LABEL</code> 开头加上一个或多个标签对。下面的示例展示了各种不同的可能格式。<code>#</code> 开头的行是注释内容。</p><blockquote><p>注意：如果你的字符串中包含空格，必须将字符串放入引号中或者对空格使用转义。如果字符串内容本身就包含引号，必须对引号使用转义。</p></blockquote><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Set one or more individual labels</span></span><br><span class="line"><span class="keyword">LABEL</span><span class="bash"> com.example.version=<span class="string">"0.0.1-beta"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">LABEL</span><span class="bash"> vendor=<span class="string">"ACME Incorporated"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">LABEL</span><span class="bash"> com.example.release-date=<span class="string">"2015-02-12"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">LABEL</span><span class="bash"> com.example.version.is-production=<span class="string">""</span></span></span><br></pre></td></tr></table></figure><p>一个镜像可以包含多个标签，但建议将多个标签放入到一个 <code>LABEL</code> 指令中。</p><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Set multiple labels at once, using line-continuation characters to break long lines</span></span><br><span class="line"><span class="keyword">LABEL</span><span class="bash"> vendor=ACME\ Incorporated \</span></span><br><span class="line"><span class="bash">      com.example.is-beta= \</span></span><br><span class="line"><span class="bash">      com.example.is-production=<span class="string">""</span> \</span></span><br><span class="line"><span class="bash">      com.example.version=<span class="string">"0.0.1-beta"</span> \</span></span><br><span class="line"><span class="bash">      com.example.release-date=<span class="string">"2015-02-12"</span></span></span><br></pre></td></tr></table></figure><p>关于标签可以接受的键值对，参考 <a href="https://docs.docker.com/config/labels-custom-metadata/" target="_blank" rel="noopener">Understanding object labels</a>。关于查询标签信息，参考 <a href="https://docs.docker.com/config/labels-custom-metadata/" target="_blank" rel="noopener">Managing labels on objects</a>。</p><h3 id="RUN"><a href="#RUN" class="headerlink" title="RUN"></a>RUN</h3><p>为了保持 <code>Dockerfile</code> 文件的可读性，可理解性，以及可维护性，建议将长的或复杂的 <code>RUN</code> 指令用反斜杠 <code>\</code> 分割成多行。</p><h4 id="apt-get"><a href="#apt-get" class="headerlink" title="apt-get"></a>apt-get</h4><p><code>RUN</code> 指令最常见的用法是安装包用的 <code>apt-get</code>。因为 <code>RUN apt-get</code> 指令会安装包，所以有几个问题需要注意。</p><p>不要使用 <code>RUN apt-get upgrade</code> 或 <code>dist-upgrade</code>，因为许多基础镜像中的「必须」包不会在一个非特权容器中升级。如果基础镜像中的某个包过时了，你应该联系它的维护者。如果你确定某个特定的包，比如 <code>foo</code>，需要升级，使用 <code>apt-get install -y foo</code> 就行，该指令会自动升级 <code>foo</code> 包。</p><p>永远将 <code>RUN apt-get update</code> 和 <code>apt-get install</code> 组合成一条 <code>RUN</code> 声明，例如：</p><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">RUN</span><span class="bash"> apt-get update &amp;&amp; apt-get install -y \</span></span><br><span class="line"><span class="bash">        package-bar \</span></span><br><span class="line"><span class="bash">        package-baz \</span></span><br><span class="line"><span class="bash">        package-foo</span></span><br></pre></td></tr></table></figure><p>将 <code>apt-get update</code> 放在一条单独的 <code>RUN</code> 声明中会导致缓存问题以及后续的 <code>apt-get install</code> 失败。比如，假设你有一个 <code>Dockerfile</code> 文件：</p><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> ubuntu:<span class="number">18.04</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> apt-get update</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> apt-get install -y curl</span></span><br></pre></td></tr></table></figure><p>构建镜像后，所有的层都在 Docker 的缓存中。假设你后来又修改了其中的 <code>apt-get install</code> 添加了一个包：</p><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> ubuntu:<span class="number">18.04</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> apt-get update</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> apt-get install -y curl nginx</span></span><br></pre></td></tr></table></figure><p>Docker 发现修改后的 <code>RUN apt-get update</code> 指令和之前的完全一样。所以，<code>apt-get update</code> 不会执行，而是使用之前的缓存镜像。因为 <code>apt-get update</code> 没有运行，后面的 <code>apt-get install</code> 可能安装的是过时的 <code>curl</code> 和 <code>nginx</code> 版本。</p><p>使用 <code>RUN apt-get update &amp;&amp; apt-get install -y</code> 可以确保你的 Dockerfiles 每次安装的都是包的最新的版本，而且这个过程不需要进一步的编码或额外干预。这项技术叫作 <code>cache busting</code>。你也可以显示指定一个包的版本号来达到 <code>cache-busting</code>，这就是所谓的固定版本，例如：</p><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">RUN</span><span class="bash"> apt-get update &amp;&amp; apt-get install -y \</span></span><br><span class="line"><span class="bash">    package-bar \</span></span><br><span class="line"><span class="bash">    package-baz \</span></span><br><span class="line"><span class="bash">    package-foo=1.3.*</span></span><br></pre></td></tr></table></figure><p>固定版本会迫使构建过程检索特定的版本，而不管缓存中有什么。这项技术也可以减少因所需包中未预料到的变化而导致的失败。</p><p>下面是一个 <code>RUN</code> 指令的示例模板，展示了所有关于 <code>apt-get</code> 的建议。</p><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">RUN</span><span class="bash"> apt-get update &amp;&amp; apt-get install -y \</span></span><br><span class="line"><span class="bash">    aufs-tools \</span></span><br><span class="line"><span class="bash">    automake \</span></span><br><span class="line"><span class="bash">    build-essential \</span></span><br><span class="line"><span class="bash">    curl \</span></span><br><span class="line"><span class="bash">    dpkg-sig \</span></span><br><span class="line"><span class="bash">    libcap-dev \</span></span><br><span class="line"><span class="bash">    libsqlite3-dev \</span></span><br><span class="line"><span class="bash">    mercurial \</span></span><br><span class="line"><span class="bash">    reprepro \</span></span><br><span class="line"><span class="bash">    ruby1.9.1 \</span></span><br><span class="line"><span class="bash">    ruby1.9.1-dev \</span></span><br><span class="line"><span class="bash">    s3cmd=1.1.* \</span></span><br><span class="line"><span class="bash"> &amp;&amp; rm -rf /var/lib/apt/lists/*</span></span><br></pre></td></tr></table></figure><p>其中 <code>s3cmd</code> 指令指定了一个版本号 <code>1.1.*</code>。如果之前的镜像使用的是更旧的版本，指定新的版本会导致 <code>apt-get udpate</code> 缓存失效并确保安装的是新版本。</p><p>另外，清理掉 apt 缓存 <code>var/lib/apt/lists</code> 可以减小镜像大小。因为 <code>RUN</code> 指令的开头为 <code>apt-get udpate</code>，包缓存总是会在 <code>apt-get install</code> 之前刷新。</p><blockquote><p>注意：官方的 Debian 和 Ubuntu 镜像会自动运行 apt-get clean，所以不需要显式的调用 apt-get clean。</p></blockquote><h3 id="CMD"><a href="#CMD" class="headerlink" title="CMD"></a>CMD</h3><p><code>CMD</code> 指令用于执行目标镜像中包含的软件，可以包含参数。<code>CMD</code> 大多数情况下都应该以 <code>CMD [&quot;executable&quot;, &quot;param1&quot;, &quot;param2&quot;...]</code> 的形式使用。因此，如果创建镜像的目的是为了部署某个服务(比如 <code>Apache</code>)，你可能会执行类似于 <code>CMD [&quot;apache2&quot;, &quot;-DFOREGROUND&quot;]</code> 形式的命令。我们建议任何服务镜像都使用这种形式的命令。</p><p>多数情况下，<code>CMD</code> 都需要一个交互式的 <code>shell</code> (bash, Python, perl 等)，例如 <code>CMD [&quot;perl&quot;, &quot;-de0&quot;]</code>，或者 <code>CMD [&quot;PHP&quot;, &quot;-a&quot;]</code>。使用这种形式意味着，当你执行类似 <code>docker run -it python</code> 时，你会进入一个准备好的 <code>shell</code> 中。<code>CMD</code> 应该在极少的情况下才能以 <code>CMD [&quot;param&quot;, &quot;param&quot;]</code> 的形式与 <code>ENTRYPOINT</code> 协同使用，除非你和你的镜像使用者都对 <code>ENTRYPOINT</code> 的工作方式十分熟悉。</p><h3 id="EXPOSE"><a href="#EXPOSE" class="headerlink" title="EXPOSE"></a>EXPOSE</h3><p><code>EXPOSE</code> 指令用于指定容器将要监听的端口。因此，你应该为你的应用程序使用常见的端口。例如，提供 <code>Apache</code> web 服务的镜像应该使用 <code>EXPOSE 80</code>，而提供 <code>MongoDB</code> 服务的镜像使用 <code>EXPOSE 27017</code>。</p><p>对于外部访问，用户可以在执行 <code>docker run</code> 时使用一个标志来指示如何将指定的端口映射到所选择的端口。</p><h3 id="ENV"><a href="#ENV" class="headerlink" title="ENV"></a>ENV</h3><p>为了方便新程序运行，你可以使用 <code>ENV</code> 来为容器中安装的程序更新 <code>PATH</code> 环境变量。例如使用 <code>ENV PATH /usr/local/nginx/bin:$PATH</code> 来确保 <code>CMD [&quot;nginx&quot;]</code> 能正确运行。</p><p><code>ENV</code> 指令也可用于为你想要容器化的服务提供必要的环境变量，比如 Postgres 需要的 <code>PGDATA</code>。</p><p>最后，<code>ENV</code> 也能用于设置常见的版本号，比如下面的示例：</p><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ENV</span> PG_MAJOR <span class="number">9.3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">ENV</span> PG_VERSION <span class="number">9.3</span>.<span class="number">4</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> curl -SL http://example.com/postgres-<span class="variable">$PG_VERSION</span>.tar.xz | tar -xJC /usr/src/postgress &amp;&amp; …</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">ENV</span> PATH /usr/local/postgres-$PG_MAJOR/bin:$PATH</span><br></pre></td></tr></table></figure><p>类似于程序中的常量，这种方法可以让你只需改变 <code>ENV</code> 指令来自动的改变容器中的软件版本。</p><h3 id="ADD-和-COPY"><a href="#ADD-和-COPY" class="headerlink" title="ADD 和 COPY"></a>ADD 和 COPY</h3><p>虽然 <code>ADD</code> 和 <code>COPY</code> 功能类似，但一般优先使用 <code>COPY</code>。因为它比 <code>ADD</code> 更透明。<code>COPY</code> 只支持简单将本地文件拷贝到容器中，而 <code>ADD</code> 有一些并不明显的功能（比如本地 tar 提取和远程 URL 支持）。因此，<code>ADD</code> 的最佳用例是将本地 tar 文件自动提取到镜像中，例如 <code>ADD rootfs.tar.xz</code>。</p><p>如果你的 <code>Dockerfile</code> 有多个步骤需要使用上下文中不同的文件。单独 <code>COPY</code> 每个文件，而不是一次性的 <code>COPY</code> 所有文件，这将保证每个步骤的构建缓存只在特定的文件变化时失效。例如：</p><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">COPY</span><span class="bash"> requirements.txt /tmp/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> pip install --requirement /tmp/requirements.txt</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> . /tmp/</span></span><br></pre></td></tr></table></figure><p>如果将 <code>COPY . /tmp/</code> 放置在 <code>RUN</code> 指令之前，只要 <code>.</code> 目录中任何一个文件变化，都会导致后续指令的缓存失效。</p><p>为了让镜像尽量小，最好不要使用 <code>ADD</code> 指令从远程 URL 获取包，而是使用 <code>curl</code> 和 <code>wget</code>。这样你可以在文件提取完之后删掉不再需要的文件来避免在镜像中额外添加一层。比如尽量避免下面的用法：</p><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ADD</span><span class="bash"> http://example.com/big.tar.xz /usr/src/things/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> tar -xJf /usr/src/things/big.tar.xz -C /usr/src/things</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> make -C /usr/src/things all</span></span><br></pre></td></tr></table></figure><p>而是应该使用下面这种方法：</p><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">RUN</span><span class="bash"> mkdir -p /usr/src/things \</span></span><br><span class="line"><span class="bash">    &amp;&amp; curl -SL http://example.com/big.tar.xz \</span></span><br><span class="line"><span class="bash">    | tar -xJC /usr/src/things \</span></span><br><span class="line"><span class="bash">    &amp;&amp; make -C /usr/src/things all</span></span><br></pre></td></tr></table></figure><p>上面使用的管道操作，所以没有中间文件需要删除。</p><p>对于其他不需要 <code>ADD</code> 的自动提取功能的文件或目录，你应该使用 <code>COPY</code>。</p><h3 id="ENTRYPOINT"><a href="#ENTRYPOINT" class="headerlink" title="ENTRYPOINT"></a>ENTRYPOINT</h3><p><code>ENTRYPOINT</code> 的最佳用处是设置镜像的主命令，允许将镜像当成命令本身来运行（用 <code>CMD</code> 提供默认选项）。</p><p>例如，下面的示例镜像提供了命令行工具 <code>s3cmd</code>:</p><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ENTRYPOINT</span><span class="bash"> [<span class="string">"s3cmd"</span>]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">CMD</span><span class="bash"> [<span class="string">"--help"</span>]</span></span><br></pre></td></tr></table></figure><p>现在直接运行该镜像创建的容器会显示命令帮助：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker run s3cmd</span><br></pre></td></tr></table></figure><p>或者提供正确的参数来执行某个命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker run s3cmd ls s3://mybucket</span><br></pre></td></tr></table></figure><p>这样镜像名可以当成命令行的参考。</p><p><code>ENTRYPOINT</code> 指令也可以结合一个辅助脚本使用，和前面命令行风格类似，即使启动工具需要不止一个步骤。</p><p>例如，<code>Postgres</code> 官方镜像使用下面的脚本作为 <code>ENTRYPOINT</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="built_in">set</span> -e</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [ <span class="string">"<span class="variable">$1</span>"</span> = <span class="string">'postgres'</span> ]; <span class="keyword">then</span></span><br><span class="line">    chown -R postgres <span class="string">"<span class="variable">$PGDATA</span>"</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> [ -z <span class="string">"<span class="variable">$(ls -A "$PGDATA")</span>"</span> ]; <span class="keyword">then</span></span><br><span class="line">        gosu postgres initdb</span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">exec</span> gosu postgres <span class="string">"<span class="variable">$@</span>"</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">exec</span> <span class="string">"<span class="variable">$@</span>"</span></span><br></pre></td></tr></table></figure><blockquote><p>注意：该脚本使用了 Bash 的内置命令 exec，所以最后运行的进程就是容器的 PID 为 1 的进程。这样，进程就可以接收到任何发送给容器的 Unix 信号了。</p></blockquote><p>该辅助脚本被拷贝到容器，并在容器启动时通过 <code>ENTRYPOINT</code> 执行：</p><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">COPY</span><span class="bash"> ./docker-entrypoint.sh /</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="bash"> [<span class="string">"/docker-entrypoint.sh"</span>]</span></span><br></pre></td></tr></table></figure><p>该脚本可以让用户用几种不同的方式和 <code>Postgres</code> 交互。</p><p>你可以很简单地启动 <code>Postgres</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker run postgres</span><br></pre></td></tr></table></figure><p>也可以执行 <code>Postgres</code> 并传递参数：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker run postgres postgres --<span class="built_in">help</span></span><br></pre></td></tr></table></figure><p>最后，你还可以启动另外一个完全不同的工具，比如 <code>Bash</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker run --rm -it postgres bash</span><br></pre></td></tr></table></figure><h3 id="VOLUME"><a href="#VOLUME" class="headerlink" title="VOLUME"></a>VOLUME</h3><p><code>VOLUME</code> 指令用于暴露任何数据库存储文件，配置文件，或容器创建的文件和目录。强烈建议使用 <code>VOLUME</code> 来管理镜像中的可变部分和用户可以改变的部分。</p><h3 id="USER"><a href="#USER" class="headerlink" title="USER"></a>USER</h3><p>如果某个服务不需要特权执行，建议使用 <code>USER</code> 指令切换到非 root 用户。先在 <code>Dockerfile</code> 中使用类似 <code>RUN groupadd -r postgres &amp;&amp; useradd -r -g postgres postgres</code> 的指令创建用户和用户组。</p><blockquote><p>注意：在镜像中，用户和用户组每次被分配的 UID/GID 都是不确定的，下次重新构建镜像时被分配到的 UID/GID 可能会不一样。如果要依赖确定的 UID/GID，你应该显示的指定一个 UID/GID。</p></blockquote><p>你应该避免使用 <code>sudo</code>，因为它不可预期的 TTY 和信号转发行为可能造成的问题比它能解决的问题还多。如果你真的需要和 <code>sudo</code> 类似的功能（例如，以 root 权限初始化某个守护进程，以非 root 权限执行它），你可以使用 <a href="https://github.com/tianon/gosu" target="_blank" rel="noopener">gosu</a>。</p><p>最后，为了减少层数和复杂度，避免频繁地使用 <code>USER</code> 来回切换用户。</p><h3 id="WORKDIR"><a href="#WORKDIR" class="headerlink" title="WORKDIR"></a>WORKDIR</h3><p>为了清晰性和可靠性，你应该总是在 <code>WORKDIR</code> 中使用绝对路径。另外，你应该使用 <code>WORKDIR</code> 来替代类似于 <code>RUN cd ... &amp;&amp; do-something</code> 的指令，后者难以阅读、排错和维护。</p><h2 id="官方镜像示例"><a href="#官方镜像示例" class="headerlink" title="官方镜像示例"></a>官方镜像示例</h2><p>这些官方镜像的 Dockerfile 都是参考典范：<a href="https://github.com/docker-library/docs" target="_blank" rel="noopener">https://github.com/docker-library/docs</a></p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>本文章摘抄于：<a href="https://yeasy.gitbooks.io/docker_practice/content/" target="_blank" rel="noopener">https://yeasy.gitbooks.io/docker_practice/content/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Dockerfile简介&quot;&gt;&lt;a href=&quot;#Dockerfile简介&quot; class=&quot;headerlink&quot; title=&quot;Dockerfile简介&quot;&gt;&lt;/a&gt;Dockerfile简介&lt;/h1&gt;&lt;p&gt;Dockerfile 是一个用来构建镜像的文本文件，文本内容包含了一条条构建镜像所需的指令和说明。&lt;/p&gt;
    
    </summary>
    
      <category term="Docker" scheme="http://hackycy.github.io/categories/Docker/"/>
    
    
      <category term="Docker" scheme="http://hackycy.github.io/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>Docker入门（四）——仓库</title>
    <link href="http://hackycy.github.io/2019/12/04/Docker%E5%85%A5%E9%97%A8%EF%BC%88%E5%9B%9B%EF%BC%89%E2%80%94%E2%80%94%E4%BB%93%E5%BA%93/"/>
    <id>http://hackycy.github.io/2019/12/04/Docker入门（四）——仓库/</id>
    <published>2019-12-04T08:28:56.000Z</published>
    <updated>2019-12-15T09:00:29.706Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Docker仓库简介"><a href="#Docker仓库简介" class="headerlink" title="Docker仓库简介"></a>Docker仓库简介</h1><p>仓库（<code>Repository</code>）是集中存放镜像的地方。</p><p>一个容易混淆的概念是注册服务器（<code>Registry</code>）。实际上注册服务器是管理仓库的具体服务器，每个服务器上可以有多个仓库，而每个仓库下面有多个镜像。从这方面来说，仓库可以被认为是一个具体的项目或目录。例如对于仓库地址 <code>dl.dockerpool.com/ubuntu</code> 来说，<code>dl.dockerpool.com</code> 是注册服务器地址，<code>ubuntu</code> 是仓库名。</p><p>大部分时候，并不需要严格区分这两者的概念。</p><a id="more"></a><h1 id="Docker-Hub"><a href="#Docker-Hub" class="headerlink" title="Docker Hub"></a>Docker Hub</h1><p>目前 Docker 官方维护了一个公共仓库 <a href="https://hub.docker.com/" target="_blank" rel="noopener">Docker Hub</a>，其中已经包括了数量超过 <a href="https://hub.docker.com/search/?type=image" target="_blank" rel="noopener">2,650,000</a> 的镜像。大部分需求都可以通过在 Docker Hub 中直接下载镜像来实现。</p><h2 id="注册"><a href="#注册" class="headerlink" title="注册"></a>注册</h2><p>你可以在 <a href="https://hub.docker.com/" target="_blank" rel="noopener">https://hub.docker.com</a> 免费注册一个 Docker 账号。</p><h2 id="登录"><a href="#登录" class="headerlink" title="登录"></a>登录</h2><p>可以通过执行 <code>docker login</code> 命令交互式的输入用户名及密码来完成在命令行界面登录 Docker Hub。</p><p>你可以通过 <code>docker logout</code> 退出登录。</p><h2 id="拉取镜像"><a href="#拉取镜像" class="headerlink" title="拉取镜像"></a>拉取镜像</h2><p>你可以通过 <code>docker search</code> 命令来查找官方仓库中的镜像，并利用 <code>docker pull</code> 命令来将它下载到本地。</p><p>例如以 <code>centos</code> 为关键词进行搜索：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ docker search centos</span><br><span class="line">NAME                                            DESCRIPTION                                     STARS     OFFICIAL   AUTOMATED</span><br><span class="line">centos                                          The official build of CentOS.                   465       [OK]</span><br><span class="line">tianon/centos                                   CentOS 5 and 6, created using rinse instea...   28</span><br><span class="line">blalor/centos                                   Bare-bones base CentOS 6.5 image                6                    [OK]</span><br><span class="line">saltstack/centos-6-minimal                                                                      6                    [OK]</span><br><span class="line">tutum/centos-6.4                                DEPRECATED. Use tutum/centos:6.4 instead. ...   5                    [OK]</span><br></pre></td></tr></table></figure><p>可以看到返回了很多包含关键字的镜像，其中包括镜像名字、描述、收藏数（表示该镜像的受关注程度）、是否官方创建（OFFICIAL）、是否自动构建 （AUTOMATED）。</p><p>根据是否是官方提供，可将镜像分为两类。</p><p>一种是类似 <code>centos</code> 这样的镜像，被称为基础镜像或根镜像。这些基础镜像由 Docker 公司创建、验证、支持、提供。这样的镜像往往使用单个单词作为名字。</p><p>还有一种类型，比如 <code>tianon/centos</code> 镜像，它是由 Docker Hub 的注册用户创建并维护的，往往带有用户名称前缀。可以通过前缀 <code>username/</code> 来指定使用某个用户提供的镜像，比如 tianon 用户。</p><p>另外，在查找的时候通过 <code>--filter=stars=N</code> 参数可以指定仅显示收藏数量为 <code>N</code> 以上的镜像。</p><p>下载官方 <code>centos</code> 镜像到本地。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ docker pull centos</span><br><span class="line">Pulling repository centos</span><br><span class="line">0b443ba03958: Download complete</span><br><span class="line">539c0211cd76: Download complete</span><br><span class="line">511136ea3c5a: Download complete</span><br><span class="line">7064731afe90: Download complete</span><br></pre></td></tr></table></figure><h2 id="推送镜像"><a href="#推送镜像" class="headerlink" title="推送镜像"></a>推送镜像</h2><p>用户也可以在登录后通过 <code>docker push</code> 命令来将自己的镜像推送到 Docker Hub。</p><p>以下命令中的 <code>username</code> 请替换为你的 Docker 账号用户名。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$ docker tag ubuntu:18.04 username/ubuntu:18.04</span><br><span class="line"></span><br><span class="line">$ docker image ls</span><br><span class="line"></span><br><span class="line">REPOSITORY                                               TAG                    IMAGE ID            CREATED             SIZE</span><br><span class="line">ubuntu                                                   18.04                  275d79972a86        6 days ago          94.6MB</span><br><span class="line">username/ubuntu                                          18.04                  275d79972a86        6 days ago          94.6MB</span><br><span class="line"></span><br><span class="line">$ docker push username/ubuntu:18.04</span><br><span class="line"></span><br><span class="line">$ docker search username</span><br><span class="line"></span><br><span class="line">NAME                      DESCRIPTION                                     STARS               OFFICIAL            AUTOMATED</span><br><span class="line">username/ubuntu</span><br></pre></td></tr></table></figure><h2 id="自动构建"><a href="#自动构建" class="headerlink" title="自动构建"></a>自动构建</h2><p>自动构建（Automated Builds）功能对于需要经常升级镜像内程序来说，十分方便。</p><p>有时候，用户构建了镜像，安装了某个软件，当软件发布新版本则需要手动更新镜像。</p><p>而自动构建允许用户通过 Docker Hub 指定跟踪一个目标网站（支持 <a href="https://github.com/" target="_blank" rel="noopener">GitHub</a> 或 <a href="https://bitbucket.org/" target="_blank" rel="noopener">BitBucket</a>）上的项目，一旦项目发生新的提交 （commit）或者创建了新的标签（tag），Docker Hub 会自动构建镜像并推送到 Docker Hub 中。</p><p>要配置自动构建，包括如下的步骤：</p><ul><li>登录 Docker Hub；</li><li>在 Docker Hub 点击右上角头像，在账号设置（Account Settings）中关联（Linked Accounts）目标网站；</li><li>在 Docker Hub 中新建或选择已有的仓库，在 <code>Builds</code> 选项卡中选择 <code>Configure Automated Builds</code>；</li><li>选取一个目标网站中的项目（需要含 <code>Dockerfile</code>）和分支；</li><li>指定 <code>Dockerfile</code> 的位置，并保存。</li></ul><p>之后，可以在 Docker Hub 的仓库页面的 <code>Timeline</code> 选项卡中查看每次构建的状态。</p><h1 id="私有仓库"><a href="#私有仓库" class="headerlink" title="私有仓库"></a>私有仓库</h1><p>有时候使用 Docker Hub 这样的公共仓库可能不方便，用户可以创建一个本地仓库供私人使用。</p><p>本节介绍如何使用本地仓库。</p><p><a href="https://docs.docker.com/registry/" target="_blank" rel="noopener"><code>docker-registry</code></a> 是官方提供的工具，可以用于构建私有的镜像仓库。本文内容基于 <a href="https://github.com/docker/distribution" target="_blank" rel="noopener"><code>docker-registry</code></a> v2.x 版本。</p><h2 id="安装运行-docker-registry"><a href="#安装运行-docker-registry" class="headerlink" title="安装运行 docker-registry"></a>安装运行 docker-registry</h2><h3 id="容器运行"><a href="#容器运行" class="headerlink" title="容器运行"></a>容器运行</h3><p>你可以通过获取官方 <code>registry</code> 镜像来运行。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -d -p 5000:5000 --restart=always --name registry registry</span><br></pre></td></tr></table></figure><p>这将使用官方的 <code>registry</code> 镜像来启动私有仓库。默认情况下，仓库会被创建在容器的 <code>/var/lib/registry</code> 目录下。你可以通过 <code>-v</code> 参数来将镜像文件存放在本地的指定路径。例如下面的例子将上传的镜像放到本地的 <code>/opt/data/registry</code> 目录。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -d \</span><br><span class="line">    -p 5000:5000 \</span><br><span class="line">    -v /opt/data/registry:/var/lib/registry \</span><br><span class="line">    registry</span><br></pre></td></tr></table></figure><h2 id="在私有仓库上传、搜索、下载镜像"><a href="#在私有仓库上传、搜索、下载镜像" class="headerlink" title="在私有仓库上传、搜索、下载镜像"></a>在私有仓库上传、搜索、下载镜像</h2><p>创建好私有仓库之后，就可以使用 <code>docker tag</code> 来标记一个镜像，然后推送它到仓库。例如私有仓库地址为 <code>127.0.0.1:5000</code>。</p><p>先在本机查看已有的镜像。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ docker image ls</span><br><span class="line">REPOSITORY                        TAG                 IMAGE ID            CREATED             VIRTUAL SIZE</span><br><span class="line">ubuntu                            latest              ba5877dc9bec        6 weeks ago         192.7 MB</span><br></pre></td></tr></table></figure><p>使用 <code>docker tag</code> 将 <code>ubuntu:latest</code> 这个镜像标记为 <code>127.0.0.1:5000/ubuntu:latest</code>。</p><p>格式为 <code>docker tag IMAGE[:TAG] [REGISTRY_HOST[:REGISTRY_PORT]/]REPOSITORY[:TAG]</code>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ docker tag ubuntu:latest 127.0.0.1:5000/ubuntu:latest</span><br><span class="line">$ docker image ls</span><br><span class="line">REPOSITORY                        TAG                 IMAGE ID            CREATED             VIRTUAL SIZE</span><br><span class="line">ubuntu                            latest              ba5877dc9bec        6 weeks ago         192.7 MB</span><br><span class="line">127.0.0.1:5000/ubuntu:latest      latest              ba5877dc9bec        6 weeks ago         192.7 MB</span><br></pre></td></tr></table></figure><p>使用 <code>docker push</code> 上传标记的镜像。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ docker push 127.0.0.1:5000/ubuntu:latest</span><br><span class="line">The push refers to repository [127.0.0.1:5000/ubuntu]</span><br><span class="line">373a30c24545: Pushed</span><br><span class="line">a9148f5200b0: Pushed</span><br><span class="line">cdd3de0940ab: Pushed</span><br><span class="line">fc56279bbb33: Pushed</span><br><span class="line">b38367233d37: Pushed</span><br><span class="line">2aebd096e0e2: Pushed</span><br><span class="line">latest: digest: sha256:fe4277621f10b5026266932ddf760f5a756d2facd505a94d2da12f4f52f71f5a size: 1568</span><br></pre></td></tr></table></figure><p>用 <code>curl</code> 查看仓库中的镜像。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ curl 127.0.0.1:5000/v2/_catalog</span><br><span class="line">&#123;<span class="string">"repositories"</span>:[<span class="string">"ubuntu"</span>]&#125;</span><br></pre></td></tr></table></figure><p>这里可以看到 <code>{&quot;repositories&quot;:[&quot;ubuntu&quot;]}</code>，表明镜像已经被成功上传了。</p><p>先删除已有镜像，再尝试从私有仓库中下载这个镜像。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$ docker image rm 127.0.0.1:5000/ubuntu:latest</span><br><span class="line"></span><br><span class="line">$ docker pull 127.0.0.1:5000/ubuntu:latest</span><br><span class="line">Pulling repository 127.0.0.1:5000/ubuntu:latest</span><br><span class="line">ba5877dc9bec: Download complete</span><br><span class="line">511136ea3c5a: Download complete</span><br><span class="line">9bad880da3d2: Download complete</span><br><span class="line">25f11f5fb0cb: Download complete</span><br><span class="line">ebc34468f71d: Download complete</span><br><span class="line">2318d26665ef: Download complete</span><br><span class="line"></span><br><span class="line">$ docker image ls</span><br><span class="line">REPOSITORY                         TAG                 IMAGE ID            CREATED             VIRTUAL SIZE</span><br><span class="line">127.0.0.1:5000/ubuntu:latest       latest              ba5877dc9bec        6 weeks ago         192.7 MB</span><br></pre></td></tr></table></figure><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><p>如果你不想使用 <code>127.0.0.1:5000</code> 作为仓库地址，比如想让本网段的其他主机也能把镜像推送到私有仓库。你就得把例如 <code>192.168.199.100:5000</code> 这样的内网地址作为私有仓库地址，这时你会发现无法成功推送镜像。</p><p>这是因为 Docker 默认不允许非 <code>HTTPS</code> 方式推送镜像。我们可以通过 Docker 的配置选项来取消这个限制，或者查看下一节配置能够通过 <code>HTTPS</code> 访问的私有仓库。</p><h3 id="Ubuntu-16-04-Debian-8-centos-7"><a href="#Ubuntu-16-04-Debian-8-centos-7" class="headerlink" title="Ubuntu 16.04+, Debian 8+, centos 7"></a>Ubuntu 16.04+, Debian 8+, centos 7</h3><p>对于使用 <code>systemd</code> 的系统，请在 <code>/etc/docker/daemon.json</code> 中写入如下内容（如果文件不存在请新建该文件）</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"registry-mirror"</span>: [</span><br><span class="line">    <span class="string">"https://dockerhub.azk8s.cn"</span></span><br><span class="line">  ],</span><br><span class="line">  <span class="attr">"insecure-registries"</span>: [</span><br><span class="line">    <span class="string">"192.168.199.100:5000"</span></span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意：该文件必须符合 <code>json</code> 规范，否则 Docker 将不能启动。</p></blockquote><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>对于 Docker Desktop for Windows 、 Docker Desktop for Mac 在设置中的 <code>Docker Engine</code> 中进行编辑 ，增加和上边一样的字符串即可。</p><h1 id="Nexus3-x-的私有仓库"><a href="#Nexus3-x-的私有仓库" class="headerlink" title="Nexus3.x 的私有仓库"></a>Nexus3.x 的私有仓库</h1><p>使用 Docker 官方的 Registry 创建的仓库面临一些维护问题。比如某些镜像删除以后空间默认是不会回收的，需要一些命令去回收空间然后重启 Registry 程序。在企业中把内部的一些工具包放入 Nexus 中是比较常见的做法，最新版本 <code>Nexus3.x</code> 全面支持 Docker 的私有镜像。所以使用 <a href="https://www.sonatype.com/download-oss-sonatype/" target="_blank" rel="noopener"><code>Nexus3.x</code></a> 一个软件来管理 <code>Docker</code> , <code>Maven</code> , <code>Yum</code> , <code>PyPI</code> 等是一个明智的选择。</p><h2 id="启动-Nexus-容器"><a href="#启动-Nexus-容器" class="headerlink" title="启动 Nexus 容器"></a>启动 Nexus 容器</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -d --name nexus3 --restart=always \</span><br><span class="line">    -p 8081:8081 \</span><br><span class="line">    --mount src=nexus-data,target=/nexus-data \</span><br><span class="line">    sonatype/nexus3</span><br></pre></td></tr></table></figure><p>等待 3-5 分钟，如果 <code>nexus3</code> 容器没有异常退出，那么你可以使用浏览器打开 <code>http://YourIP:8081</code> 访问 Nexus 了。</p><p>第一次启动 Nexus 的默认帐号是 <code>admin</code> 密码是 <code>admin123</code> 登录以后点击页面上方的齿轮按钮进行设置。</p><h2 id="创建仓库"><a href="#创建仓库" class="headerlink" title="创建仓库"></a>创建仓库</h2><p>创建一个私有仓库的方法： <code>Repository-&gt;Repositories</code> 点击右边菜单 <code>Create repository</code> 选择 <code>docker (hosted)</code></p><ul><li>Name: 仓库的名称</li><li>HTTP: 仓库单独的访问端口</li><li>Enable Docker V1 API: 如果需要同时支持 V1 版本请勾选此项（不建议勾选）。</li><li>Hosted -&gt; Deployment pollcy: 请选择 Allow redeploy 否则无法上传 Docker 镜像。</li></ul><p>其它的仓库创建方法请各位自己摸索，还可以创建一个 docker (proxy) 类型的仓库链接到 DockerHub 上。再创建一个 docker (group) 类型的仓库把刚才的 hosted 与 proxy 添加在一起。主机在访问的时候默认下载私有仓库中的镜像，如果没有将链接到 DockerHub 中下载并缓存到 Nexus 中。</p><h2 id="添加访问权限"><a href="#添加访问权限" class="headerlink" title="添加访问权限"></a>添加访问权限</h2><p>菜单 <code>Security-&gt;Realms</code> 把 Docker Bearer Token Realm 移到右边的框中保存。</p><p>添加用户规则：菜单 <code>Security-&gt;Roles</code>-&gt;<code>Create role</code> 在 <code>Privlleges</code> 选项搜索 docker 把相应的规则移动到右边的框中然后保存。</p><p>添加用户：菜单 <code>Security-&gt;Users</code>-&gt;<code>Create local user</code> 在 <code>Roles</code> 选项中选中刚才创建的规则移动到右边的窗口保存。</p><h2 id="NGINX-加密代理"><a href="#NGINX-加密代理" class="headerlink" title="NGINX 加密代理"></a>NGINX 加密代理</h2><p>证书的生成请参见 <a href="https://yeasy.gitbooks.io/docker_practice/content/repository/registry_auth.html" target="_blank" rel="noopener"><code>私有仓库高级配置</code></a> 里面证书生成一节。</p><p>NGINX 示例配置如下</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">upstream</span> register</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attribute">server</span> <span class="string">"YourHostName OR IP"</span>:<span class="number">5001</span>; <span class="comment">#端口为上面添加的私有镜像仓库是设置的 HTTP 选项的端口号</span></span><br><span class="line">    <span class="attribute">check</span> interval=<span class="number">3000</span> rise=<span class="number">2</span> fall=<span class="number">10</span> timeout=<span class="number">1000</span> type=http;</span><br><span class="line">    <span class="attribute">check_http_send</span> <span class="string">"HEAD / HTTP/1.0\r\n\r\n"</span>;</span><br><span class="line">    <span class="attribute">check_http_expect_alive</span> http_4xx;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">server_name</span> YourDomainName;<span class="comment">#如果没有 DNS 服务器做解析，请删除此选项使用本机 IP 地址访问</span></span><br><span class="line">    <span class="attribute">listen</span>       <span class="number">443</span> ssl;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">ssl_certificate</span> key/example.crt;</span><br><span class="line">    <span class="attribute">ssl_certificate_key</span> key/example.key;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">ssl_session_timeout</span>  <span class="number">5m</span>;</span><br><span class="line">    <span class="attribute">ssl_protocols</span> TLSv1 TLSv1.<span class="number">1</span> TLSv1.<span class="number">2</span>;</span><br><span class="line">    <span class="attribute">ssl_ciphers</span>  HIGH:!aNULL:!MD5;</span><br><span class="line">    <span class="attribute">ssl_prefer_server_ciphers</span>   <span class="literal">on</span>;</span><br><span class="line">    <span class="attribute">large_client_header_buffers</span> <span class="number">4</span> <span class="number">32k</span>;</span><br><span class="line">    <span class="attribute">client_max_body_size</span> <span class="number">300m</span>;</span><br><span class="line">    <span class="attribute">client_body_buffer_size</span> <span class="number">512k</span>;</span><br><span class="line">    <span class="attribute">proxy_connect_timeout</span> <span class="number">600</span>;</span><br><span class="line">    <span class="attribute">proxy_read_timeout</span>   <span class="number">600</span>;</span><br><span class="line">    <span class="attribute">proxy_send_timeout</span>   <span class="number">600</span>;</span><br><span class="line">    <span class="attribute">proxy_buffer_size</span>    <span class="number">128k</span>;</span><br><span class="line">    <span class="attribute">proxy_buffers</span>       <span class="number">4</span> <span class="number">64k</span>;</span><br><span class="line">    <span class="attribute">proxy_busy_buffers_size</span> <span class="number">128k</span>;</span><br><span class="line">    <span class="attribute">proxy_temp_file_write_size</span> <span class="number">512k</span>;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">location</span> / &#123;</span><br><span class="line">        <span class="attribute">proxy_set_header</span> Host <span class="variable">$host</span>;</span><br><span class="line">        <span class="attribute">proxy_set_header</span> X-Forwarded-Proto <span class="variable">$scheme</span>;</span><br><span class="line">        <span class="attribute">proxy_set_header</span> X-Forwarded-Port <span class="variable">$server_port</span>;</span><br><span class="line">        <span class="attribute">proxy_set_header</span> X-Forwarded-For <span class="variable">$proxy_add_x_forwarded_for</span>;</span><br><span class="line">        <span class="attribute">proxy_http_version</span> <span class="number">1</span>.<span class="number">1</span>;</span><br><span class="line">        <span class="attribute">proxy_set_header</span> Upgrade <span class="variable">$http_upgrade</span>;</span><br><span class="line">        <span class="attribute">proxy_set_header</span> Connection <span class="variable">$connection_upgrade</span>;</span><br><span class="line">        <span class="attribute">proxy_redirect</span> <span class="literal">off</span>;</span><br><span class="line">        <span class="attribute">proxy_set_header</span> X-Real-IP <span class="variable">$remote_addr</span>;</span><br><span class="line">        <span class="attribute">proxy_pass</span> http://register;</span><br><span class="line">        <span class="attribute">proxy_read_timeout</span> <span class="number">900s</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="attribute">error_page</span>   <span class="number">500</span> <span class="number">502</span> <span class="number">503</span> <span class="number">504</span>  /50x.html;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Docker-主机访问镜像仓库"><a href="#Docker-主机访问镜像仓库" class="headerlink" title="Docker 主机访问镜像仓库"></a>Docker 主机访问镜像仓库</h2><p>如果不启用 SSL 加密可以通过前面章节的方法添加信任地址到 Docker 的配置文件中然后重启 Docker</p><p>使用 SSL 加密以后程序需要访问就不能采用修改配置的访问了。具体方法如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ openssl s_client -showcerts -connect YourDomainName OR HostIP:443 &lt;/dev/null 2&gt;/dev/null|openssl x509 -outform PEM &gt;ca.crt</span><br><span class="line">$ cat ca.crt | sudo tee -a /etc/ssl/certs/ca-certificates.crt</span><br><span class="line">$ systemctl restart docker</span><br></pre></td></tr></table></figure><p>使用 <code>docker login YourDomainName OR HostIP</code> 进行测试，用户名密码填写上面 Nexus 中生成的。</p><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p>本文章摘抄于：<a href="https://yeasy.gitbooks.io/docker_practice/content/" target="_blank" rel="noopener">https://yeasy.gitbooks.io/docker_practice/content/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Docker仓库简介&quot;&gt;&lt;a href=&quot;#Docker仓库简介&quot; class=&quot;headerlink&quot; title=&quot;Docker仓库简介&quot;&gt;&lt;/a&gt;Docker仓库简介&lt;/h1&gt;&lt;p&gt;仓库（&lt;code&gt;Repository&lt;/code&gt;）是集中存放镜像的地方。&lt;/p&gt;
&lt;p&gt;一个容易混淆的概念是注册服务器（&lt;code&gt;Registry&lt;/code&gt;）。实际上注册服务器是管理仓库的具体服务器，每个服务器上可以有多个仓库，而每个仓库下面有多个镜像。从这方面来说，仓库可以被认为是一个具体的项目或目录。例如对于仓库地址 &lt;code&gt;dl.dockerpool.com/ubuntu&lt;/code&gt; 来说，&lt;code&gt;dl.dockerpool.com&lt;/code&gt; 是注册服务器地址，&lt;code&gt;ubuntu&lt;/code&gt; 是仓库名。&lt;/p&gt;
&lt;p&gt;大部分时候，并不需要严格区分这两者的概念。&lt;/p&gt;
    
    </summary>
    
      <category term="Docker" scheme="http://hackycy.github.io/categories/Docker/"/>
    
    
      <category term="Docker" scheme="http://hackycy.github.io/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>Jenkins更换语言</title>
    <link href="http://hackycy.github.io/2019/12/04/Jenkins%E6%9B%B4%E6%8D%A2%E8%AF%AD%E8%A8%80/"/>
    <id>http://hackycy.github.io/2019/12/04/Jenkins更换语言/</id>
    <published>2019-12-04T02:47:49.000Z</published>
    <updated>2019-12-04T03:19:14.463Z</updated>
    
    <content type="html"><![CDATA[<p>最近学习Jenkins中，使用Docker安装完成后，Jenkins的默认语言是狗血的繁体版本，想更换成英文版本或者中文版本。</p><a id="more"></a><h1 id="更换Google浏览器默认语言"><a href="#更换Google浏览器默认语言" class="headerlink" title="更换Google浏览器默认语言"></a>更换Google浏览器默认语言</h1><p>我google之前设置的默认语言第一位是中文繁体版本，我现在直接删除掉了。后面Jenkins就更换回了英文版本。</p><p><img src="changegooglelan.png" alt></p><h1 id="使用Locale插件"><a href="#使用Locale插件" class="headerlink" title="使用Locale插件"></a>使用Locale插件</h1><p>繁体版本下找到插件为<code>管理Jenkins</code>-&gt;<code>外掛程式管理</code></p><p><img src="findplugin.png" alt></p><p>在可用的插件列表搜索Locale插件，选择直接安装。</p><p><img src="findplugin2.png" alt></p><p>安装完成后，进入<code>管理Jenkins</code>-&gt;<code>设定系统</code></p><p><img src="setting.png" alt></p><p>应用并保存即可。</p><blockquote><p>记住Ignore browser preference and force this language to all users这个单选框要勾选上，否则不生效</p></blockquote><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>两种方式中，第二种中文好像并不是完全支持，有些中文有些英文。</p><p>所以我选择了使用第一种方式。学习的情况下还是多些习惯英文吧。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近学习Jenkins中，使用Docker安装完成后，Jenkins的默认语言是狗血的繁体版本，想更换成英文版本或者中文版本。&lt;/p&gt;
    
    </summary>
    
      <category term="Jenkins" scheme="http://hackycy.github.io/categories/Jenkins/"/>
    
    
      <category term="Jenkins" scheme="http://hackycy.github.io/tags/Jenkins/"/>
    
  </entry>
  
  <entry>
    <title>Docker入门（三）——镜像</title>
    <link href="http://hackycy.github.io/2019/12/02/Docker%E5%85%A5%E9%97%A8%EF%BC%88%E4%B8%89%EF%BC%89%E2%80%94%E2%80%94%E9%95%9C%E5%83%8F/"/>
    <id>http://hackycy.github.io/2019/12/02/Docker入门（三）——镜像/</id>
    <published>2019-12-02T08:20:18.000Z</published>
    <updated>2019-12-15T09:00:08.458Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Docker镜像简介"><a href="#Docker镜像简介" class="headerlink" title="Docker镜像简介"></a>Docker镜像简介</h1><p>镜像是 Docker 的三大组件之一。</p><p>Docker 运行容器前需要本地存在对应的镜像，如果本地不存在该镜像，Docker 会从镜像仓库下载该镜像。</p><p>本章将介绍更多关于镜像的内容，包括：</p><ul><li>从仓库获取镜像；</li><li>管理本地主机上的镜像</li></ul><a id="more"></a><h1 id="获取镜像"><a href="#获取镜像" class="headerlink" title="获取镜像"></a>获取镜像</h1><p>之前提到过，<a href="https://hub.docker.com/explore/" target="_blank" rel="noopener">Docker Hub</a> 上有大量的高质量的镜像可以用，这里我们就说一下怎么获取这些镜像。</p><p>从 Docker 镜像仓库获取镜像的命令是 <code>docker pull</code>。其命令格式为：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull [选项] [Docker Registry 地址[:端口号]/]仓库名[:标签]</span><br></pre></td></tr></table></figure><p>具体的选项可以通过 <code>docker pull --help</code> 命令看到，这里我们说一下镜像名称的格式。</p><ul><li>Docker 镜像仓库地址：地址的格式一般是 <code>&lt;域名/IP&gt;[:端口号]</code>。默认地址是 Docker Hub。</li><li>仓库名：如之前所说，这里的仓库名是两段式名称，即 <code>&lt;用户名&gt;/&lt;软件名&gt;</code>。对于 Docker Hub，如果不给出用户名，则默认为 <code>library</code>，也就是官方镜像。</li></ul><p>比如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ docker pull ubuntu:18.04</span><br><span class="line">18.04: Pulling from library/ubuntu</span><br><span class="line">bf5d46315322: Pull complete</span><br><span class="line">9f13e0ac480c: Pull complete</span><br><span class="line">e8988b5b3097: Pull complete</span><br><span class="line">40af181810e7: Pull complete</span><br><span class="line">e6f7c7e5c03e: Pull complete</span><br><span class="line">Digest: sha256:147913621d9cdea08853f6ba9116c2e27a3ceffecf3b492983ae97c3d643fbbe</span><br><span class="line">Status: Downloaded newer image <span class="keyword">for</span> ubuntu:18.04</span><br></pre></td></tr></table></figure><p>上面的命令中没有给出 Docker 镜像仓库地址，因此将会从 Docker Hub 获取镜像。而镜像名称是 <code>ubuntu:18.04</code>，因此将会获取官方镜像 <code>library/ubuntu</code> 仓库中标签为 <code>18.04</code> 的镜像。</p><p>从下载过程中可以看到我们之前提及的分层存储的概念，镜像是由多层存储所构成。下载也是一层层的去下载，并非单一文件。下载过程中给出了每一层的 ID 的前 12 位。并且下载结束后，给出该镜像完整的 <code>sha256</code> 的摘要，以确保下载一致性。</p><p>在使用上面命令的时候，你可能会发现，你所看到的层 ID 以及 <code>sha256</code> 的摘要和这里的不一样。这是因为官方镜像是一直在维护的，有任何新的 bug，或者版本更新，都会进行修复再以原来的标签发布，这样可以确保任何使用这个标签的用户可以获得更安全、更稳定的镜像。</p><p><em>如果从 Docker Hub 下载镜像非常缓慢，可以参照 <a href="https://yeasy.gitbooks.io/docker_practice/content/install/mirror.html" target="_blank" rel="noopener">镜像加速器</a> 一节配置加速器。</em></p><h2 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h2><p>有了镜像后，我们就能够以这个镜像为基础启动并运行一个容器。以上面的 <code>ubuntu:18.04</code> 为例，如果我们打算启动里面的 <code>bash</code> 并且进行交互式操作的话，可以执行下面的命令。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -it --rm \</span><br><span class="line">    ubuntu:18.04 \</span><br><span class="line">    bash</span><br><span class="line"></span><br><span class="line">root@e7009c6ce357:/<span class="comment"># cat /etc/os-release</span></span><br><span class="line">NAME=<span class="string">"Ubuntu"</span></span><br><span class="line">VERSION=<span class="string">"18.04.1 LTS (Bionic Beaver)"</span></span><br><span class="line">ID=ubuntu</span><br><span class="line">ID_LIKE=debian</span><br><span class="line">PRETTY_NAME=<span class="string">"Ubuntu 18.04.1 LTS"</span></span><br><span class="line">VERSION_ID=<span class="string">"18.04"</span></span><br><span class="line">HOME_URL=<span class="string">"https://www.ubuntu.com/"</span></span><br><span class="line">SUPPORT_URL=<span class="string">"https://help.ubuntu.com/"</span></span><br><span class="line">BUG_REPORT_URL=<span class="string">"https://bugs.launchpad.net/ubuntu/"</span></span><br><span class="line">PRIVACY_POLICY_URL=<span class="string">"https://www.ubuntu.com/legal/terms-and-policies/privacy-policy"</span></span><br><span class="line">VERSION_CODENAME=bionic</span><br><span class="line">UBUNTU_CODENAME=bionic</span><br></pre></td></tr></table></figure><p><code>docker run</code> 就是运行容器的命令，具体格式我们会在 <a href="https://yeasy.gitbooks.io/docker_practice/content/container" target="_blank" rel="noopener">容器</a> 一节进行详细讲解，我们这里简要的说明一下上面用到的参数。</p><ul><li><code>-it</code>：这是两个参数，一个是 <code>-i</code>：交互式操作，一个是 <code>-t</code> 终端。我们这里打算进入 <code>bash</code> 执行一些命令并查看返回结果，因此我们需要交互式终端。</li><li><code>--rm</code>：这个参数是说容器退出后随之将其删除。默认情况下，为了排障需求，退出的容器并不会立即删除，除非手动 <code>docker rm</code>。我们这里只是随便执行个命令，看看结果，不需要排障和保留结果，因此使用 <code>--rm</code> 可以避免浪费空间。</li><li><code>ubuntu:18.04</code>：这是指用 <code>ubuntu:18.04</code> 镜像为基础来启动容器。</li><li><code>bash</code>：放在镜像名后的是 <strong>命令</strong>，这里我们希望有个交互式 Shell，因此用的是 <code>bash</code>。</li></ul><p>进入容器后，我们可以在 Shell 下操作，执行任何所需的命令。这里，我们执行了 <code>cat /etc/os-release</code>，这是 Linux 常用的查看当前系统版本的命令，从返回的结果可以看到容器内是 <code>Ubuntu 18.04.1 LTS</code> 系统。</p><p>最后我们通过 <code>exit</code> 退出了这个容器。</p><h1 id="列出镜像"><a href="#列出镜像" class="headerlink" title="列出镜像"></a>列出镜像</h1><p>要想列出已经下载下来的镜像，可以使用 <code>docker image ls</code> 命令。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ docker image ls</span><br><span class="line">REPOSITORY           TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">redis                latest              5f515359c7f8        5 days ago          183 MB</span><br><span class="line">nginx                latest              05a60462f8ba        5 days ago          181 MB</span><br><span class="line">mongo                3.2                 fe9198c04d62        5 days ago          342 MB</span><br><span class="line">&lt;none&gt;               &lt;none&gt;              00285df0df87        5 days ago          342 MB</span><br><span class="line">ubuntu               18.04               f753707788c5        4 weeks ago         127 MB</span><br><span class="line">ubuntu               latest              f753707788c5        4 weeks ago         127 MB</span><br></pre></td></tr></table></figure><p>列表包含了 <code>仓库名</code>、<code>标签</code>、<code>镜像 ID</code>、<code>创建时间</code> 以及 <code>所占用的空间</code>。</p><p>其中仓库名、标签在之前的基础概念章节已经介绍过了。<strong>镜像 ID</strong> 则是镜像的唯一标识，一个镜像可以对应多个 <strong>标签</strong>。因此，在上面的例子中，我们可以看到 <code>ubuntu:18.04</code> 和 <code>ubuntu:latest</code> 拥有相同的 ID，因为它们对应的是同一个镜像。</p><h2 id="镜像体积"><a href="#镜像体积" class="headerlink" title="镜像体积"></a>镜像体积</h2><p>如果仔细观察，会注意到，这里标识的所占用空间和在 Docker Hub 上看到的镜像大小不同。比如，<code>ubuntu:18.04</code> 镜像大小，在这里是 <code>127 MB</code>，但是在 <a href="https://hub.docker.com/r/library/ubuntu/tags/" target="_blank" rel="noopener">Docker Hub</a> 显示的却是 <code>50 MB</code>。这是因为 Docker Hub 中显示的体积是压缩后的体积。在镜像下载和上传过程中镜像是保持着压缩状态的，因此 Docker Hub 所显示的大小是网络传输中更关心的流量大小。而 <code>docker image ls</code> 显示的是镜像下载到本地后，展开的大小，准确说，是展开后的各层所占空间的总和，因为镜像到本地后，查看空间的时候，更关心的是本地磁盘空间占用的大小。</p><p>另外一个需要注意的问题是，<code>docker image ls</code> 列表中的镜像体积总和并非是所有镜像实际硬盘消耗。由于 Docker 镜像是多层存储结构，并且可以继承、复用，因此不同镜像可能会因为使用相同的基础镜像，从而拥有共同的层。由于 Docker 使用 Union FS，相同的层只需要保存一份即可，因此实际镜像硬盘占用空间很可能要比这个列表镜像大小的总和要小的多。</p><p>你可以通过以下命令来便捷的查看镜像、容器、数据卷所占用的空间。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ docker system df</span><br><span class="line"></span><br><span class="line">TYPE                TOTAL               ACTIVE              SIZE                RECLAIMABLE</span><br><span class="line">Images              24                  0                   1.992GB             1.992GB (100%)</span><br><span class="line">Containers          1                   0                   62.82MB             62.82MB (100%)</span><br><span class="line">Local Volumes       9                   0                   652.2MB             652.2MB (100%)</span><br><span class="line">Build Cache                                                 0B                  0B</span><br></pre></td></tr></table></figure><h2 id="虚悬镜像"><a href="#虚悬镜像" class="headerlink" title="虚悬镜像"></a>虚悬镜像</h2><p>上面的镜像列表中，还可以看到一个特殊的镜像，这个镜像既没有仓库名，也没有标签，均为 <code></code>。：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;none&gt;               &lt;none&gt;              00285df0df87        5 days ago          342 MB</span><br></pre></td></tr></table></figure><p>这个镜像原本是有镜像名和标签的，原来为 <code>mongo:3.2</code>，随着官方镜像维护，发布了新版本后，重新 <code>docker pull mongo:3.2</code> 时，<code>mongo:3.2</code> 这个镜像名被转移到了新下载的镜像身上，而旧的镜像上的这个名称则被取消，从而成为了 <code>。除了 `docker pull` 可能导致这种情况，`docker build` 也同样可以导致这种现象。由于新旧镜像同名，旧镜像名称被取消，从而出现仓库名、标签均为</code> 的镜像。这类无标签镜像也被称为 <strong>虚悬镜像(dangling image)</strong> ，可以用下面的命令专门显示这类镜像：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ docker image ls -f dangling=<span class="literal">true</span></span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">&lt;none&gt;              &lt;none&gt;              00285df0df87        5 days ago          342 MB</span><br></pre></td></tr></table></figure><p>一般来说，虚悬镜像已经失去了存在的价值，是可以随意删除的，可以用下面的命令删除。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker image prune</span><br></pre></td></tr></table></figure><h2 id="中间层镜像"><a href="#中间层镜像" class="headerlink" title="中间层镜像"></a>中间层镜像</h2><p>为了加速镜像构建、重复利用资源，Docker 会利用 <strong>中间层镜像</strong>。所以在使用一段时间后，可能会看到一些依赖的中间层镜像。默认的 <code>docker image ls</code> 列表中只会显示顶层镜像，如果希望显示包括中间层镜像在内的所有镜像的话，需要加 <code>-a</code> 参数。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker image ls -a</span><br></pre></td></tr></table></figure><p>这样会看到很多无标签的镜像，与之前的虚悬镜像不同，这些无标签的镜像很多都是中间层镜像，是其它镜像所依赖的镜像。这些无标签镜像不应该删除，否则会导致上层镜像因为依赖丢失而出错。实际上，这些镜像也没必要删除，因为之前说过，相同的层只会存一遍，而这些镜像是别的镜像的依赖，因此并不会因为它们被列出来而多存了一份，无论如何你也会需要它们。只要删除那些依赖它们的镜像后，这些依赖的中间层镜像也会被连带删除。</p><h2 id="列出部分镜像"><a href="#列出部分镜像" class="headerlink" title="列出部分镜像"></a>列出部分镜像</h2><p>不加任何参数的情况下，<code>docker image ls</code> 会列出所有顶层镜像，但是有时候我们只希望列出部分镜像。<code>docker image ls</code> 有好几个参数可以帮助做到这个事情。</p><p>根据仓库名列出镜像</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ docker image ls ubuntu</span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">ubuntu              18.04               f753707788c5        4 weeks ago         127 MB</span><br><span class="line">ubuntu              latest              f753707788c5        4 weeks ago         127 MB</span><br></pre></td></tr></table></figure><p>列出特定的某个镜像，也就是说指定仓库名和标签</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ docker image ls ubuntu:18.04</span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">ubuntu              18.04               f753707788c5        4 weeks ago         127 MB</span><br></pre></td></tr></table></figure><p>除此以外，<code>docker image ls</code> 还支持强大的过滤器参数 <code>--filter</code>，或者简写 <code>-f</code>。之前我们已经看到了使用过滤器来列出虚悬镜像的用法，它还有更多的用法。比如，我们希望看到在 <code>mongo:3.2</code> 之后建立的镜像，可以用下面的命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ docker image ls -f since=mongo:3.2</span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">redis               latest              5f515359c7f8        5 days ago          183 MB</span><br><span class="line">nginx               latest              05a60462f8ba        5 days ago          181 MB</span><br></pre></td></tr></table></figure><p>想查看某个位置之前的镜像也可以，只需要把 <code>since</code> 换成 <code>before</code> 即可。</p><p>此外，如果镜像构建时，定义了 <code>LABEL</code>，还可以通过 <code>LABEL</code> 来过滤。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker image ls -f label=com.example.version=0.1</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h2 id="以特定格式显示"><a href="#以特定格式显示" class="headerlink" title="以特定格式显示"></a>以特定格式显示</h2><p>默认情况下，<code>docker image ls</code> 会输出一个完整的表格，但是我们并非所有时候都会需要这些内容。比如，刚才删除虚悬镜像的时候，我们需要利用 <code>docker image ls</code> 把所有的虚悬镜像的 ID 列出来，然后才可以交给 <code>docker image rm</code> 命令作为参数来删除指定的这些镜像，这个时候就用到了 <code>-q</code> 参数。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ docker image ls -q</span><br><span class="line">5f515359c7f8</span><br><span class="line">05a60462f8ba</span><br><span class="line">fe9198c04d62</span><br><span class="line">00285df0df87</span><br><span class="line">f753707788c5</span><br><span class="line">f753707788c5</span><br><span class="line">1e0c3dd64ccd</span><br></pre></td></tr></table></figure><p><code>--filter</code> 配合 <code>-q</code> 产生出指定范围的 ID 列表，然后送给另一个 <code>docker</code> 命令作为参数，从而针对这组实体成批的进行某种操作的做法在 Docker 命令行使用过程中非常常见，不仅仅是镜像，将来我们会在各个命令中看到这类搭配以完成很强大的功能。因此每次在文档看到过滤器后，可以多注意一下它们的用法。</p><p>另外一些时候，我们可能只是对表格的结构不满意，希望自己组织列；或者不希望有标题，这样方便其它程序解析结果等，这就用到了 <a href="https://gohugo.io/templates/go-templates/" target="_blank" rel="noopener">Go 的模板语法</a>。</p><p>比如，下面的命令会直接列出镜像结果，并且只包含镜像ID和仓库名：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ docker image ls --format <span class="string">"&#123;&#123;.ID&#125;&#125;: &#123;&#123;.Repository&#125;&#125;"</span></span><br><span class="line">5f515359c7f8: redis</span><br><span class="line">05a60462f8ba: nginx</span><br><span class="line">fe9198c04d62: mongo</span><br><span class="line">00285df0df87: &lt;none&gt;</span><br><span class="line">f753707788c5: ubuntu</span><br><span class="line">f753707788c5: ubuntu</span><br><span class="line">1e0c3dd64ccd: ubuntu</span><br></pre></td></tr></table></figure><p>或者打算以表格等距显示，并且有标题行，和默认一样，不过自己定义列：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ docker image ls --format <span class="string">"table &#123;&#123;.ID&#125;&#125;\t&#123;&#123;.Repository&#125;&#125;\t&#123;&#123;.Tag&#125;&#125;"</span></span><br><span class="line">IMAGE ID            REPOSITORY          TAG</span><br><span class="line">5f515359c7f8        redis               latest</span><br><span class="line">05a60462f8ba        nginx               latest</span><br><span class="line">fe9198c04d62        mongo               3.2</span><br><span class="line">00285df0df87        &lt;none&gt;              &lt;none&gt;</span><br><span class="line">f753707788c5        ubuntu              18.04</span><br><span class="line">f753707788c5        ubuntu              latest</span><br></pre></td></tr></table></figure><h1 id="删除本地镜像"><a href="#删除本地镜像" class="headerlink" title="删除本地镜像"></a>删除本地镜像</h1><p>如果要删除本地的镜像，可以使用 <code>docker image rm</code> 命令，其格式为：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker image rm [选项] &lt;镜像1&gt; [&lt;镜像2&gt; ...]</span><br></pre></td></tr></table></figure><h2 id="用-ID、镜像名、摘要删除镜像"><a href="#用-ID、镜像名、摘要删除镜像" class="headerlink" title="用 ID、镜像名、摘要删除镜像"></a>用 ID、镜像名、摘要删除镜像</h2><p>其中，<code>&lt;镜像&gt;</code> 可以是 <code>镜像短 ID</code>、<code>镜像长 ID</code>、<code>镜像名</code> 或者 <code>镜像摘要</code>。</p><p>比如我们有这么一些镜像：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ docker image ls</span><br><span class="line">REPOSITORY                  TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">centos                      latest              0584b3d2cf6d        3 weeks ago         196.5 MB</span><br><span class="line">redis                       alpine              501ad78535f0        3 weeks ago         21.03 MB</span><br><span class="line">docker                      latest              cf693ec9b5c7        3 weeks ago         105.1 MB</span><br><span class="line">nginx                       latest              e43d811ce2f4        5 weeks ago         181.5 MB</span><br></pre></td></tr></table></figure><p>我们可以用镜像的完整 ID，也称为 <code>长 ID</code>，来删除镜像。使用脚本的时候可能会用长 ID，但是人工输入就太累了，所以更多的时候是用 <code>短 ID</code> 来删除镜像。<code>docker image ls</code> 默认列出的就已经是短 ID 了，一般取前3个字符以上，只要足够区分于别的镜像就可以了。</p><p>比如这里，如果我们要删除 <code>redis:alpine</code> 镜像，可以执行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ docker image rm 501</span><br><span class="line">Untagged: redis:alpine</span><br><span class="line">Untagged: redis@sha256:f1ed3708f538b537eb9c2a7dd50dc90a706f7debd7e1196c9264edeea521a86d</span><br><span class="line">Deleted: sha256:501ad78535f015d88872e13fa87a828425117e3d28075d0c117932b05bf189b7</span><br><span class="line">Deleted: sha256:96167737e29ca8e9d74982ef2a0dda76ed7b430da55e321c071f0dbff8c2899b</span><br><span class="line">Deleted: sha256:32770d1dcf835f192cafd6b9263b7b597a1778a403a109e2cc2ee866f74adf23</span><br><span class="line">Deleted: sha256:127227698ad74a5846ff5153475e03439d96d4b1c7f2a449c7a826ef74a2d2fa</span><br><span class="line">Deleted: sha256:1333ecc582459bac54e1437335c0816bc17634e131ea0cc48daa27d32c75eab3</span><br><span class="line">Deleted: sha256:4fc455b921edf9c4aea207c51ab39b10b06540c8b4825ba57b3feed1668fa7c7</span><br></pre></td></tr></table></figure><p>我们也可以用<code>镜像名</code>，也就是 <code>&lt;仓库名&gt;:&lt;标签&gt;</code>，来删除镜像。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ docker image rm centos</span><br><span class="line">Untagged: centos:latest</span><br><span class="line">Untagged: centos@sha256:b2f9d1c0ff5f87a4743104d099a3d561002ac500db1b9bfa02a783a46e0d366c</span><br><span class="line">Deleted: sha256:0584b3d2cf6d235ee310cf14b54667d889887b838d3f3d3033acd70fc3c48b8a</span><br><span class="line">Deleted: sha256:97ca462ad9eeae25941546209454496e1d66749d53dfa2ee32bf1faabd239d38</span><br></pre></td></tr></table></figure><p>当然，更精确的是使用 <code>镜像摘要</code> 删除镜像。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ docker image ls --digests</span><br><span class="line">REPOSITORY                  TAG                 DIGEST                                                                    IMAGE ID            CREATED             SIZE</span><br><span class="line">node                        slim                sha256:b4f0e0bdeb578043c1ea6862f0d40cc4afe32a4a582f3be235a3b164422be228   6e0c4c8e3913        3 weeks ago         214 MB</span><br><span class="line"></span><br><span class="line">$ docker image rm node@sha256:b4f0e0bdeb578043c1ea6862f0d40cc4afe32a4a582f3be235a3b164422be228</span><br><span class="line">Untagged: node@sha256:b4f0e0bdeb578043c1ea6862f0d40cc4afe32a4a582f3be235a3b164422be228</span><br></pre></td></tr></table></figure><h2 id="Untagged-和-Deleted"><a href="#Untagged-和-Deleted" class="headerlink" title="Untagged 和 Deleted"></a>Untagged 和 Deleted</h2><p>如果观察上面这几个命令的运行输出信息的话，你会注意到删除行为分为两类，一类是 <code>Untagged</code>，另一类是 <code>Deleted</code>。我们之前介绍过，镜像的唯一标识是其 ID 和摘要，而一个镜像可以有多个标签。</p><p>因此当我们使用上面命令删除镜像的时候，实际上是在要求删除某个标签的镜像。所以首先需要做的是将满足我们要求的所有镜像标签都取消，这就是我们看到的 <code>Untagged</code> 的信息。因为一个镜像可以对应多个标签，因此当我们删除了所指定的标签后，可能还有别的标签指向了这个镜像，如果是这种情况，那么 <code>Delete</code> 行为就不会发生。所以并非所有的 <code>docker image rm</code> 都会产生删除镜像的行为，有可能仅仅是取消了某个标签而已。</p><p>当该镜像所有的标签都被取消了，该镜像很可能会失去了存在的意义，因此会触发删除行为。镜像是多层存储结构，因此在删除的时候也是从上层向基础层方向依次进行判断删除。镜像的多层结构让镜像复用变得非常容易，因此很有可能某个其它镜像正依赖于当前镜像的某一层。这种情况，依旧不会触发删除该层的行为。直到没有任何层依赖当前层时，才会真实的删除当前层。这就是为什么，有时候会奇怪，为什么明明没有别的标签指向这个镜像，但是它还是存在的原因，也是为什么有时候会发现所删除的层数和自己 <code>docker pull</code> 看到的层数不一样的原因。</p><p>除了镜像依赖以外，还需要注意的是容器对镜像的依赖。如果有用这个镜像启动的容器存在（即使容器没有运行），那么同样不可以删除这个镜像。之前讲过，容器是以镜像为基础，再加一层容器存储层，组成这样的多层存储结构去运行的。因此该镜像如果被这个容器所依赖的，那么删除必然会导致故障。如果这些容器是不需要的，应该先将它们删除，然后再来删除镜像。</p><h2 id="用-docker-image-ls-命令来配合"><a href="#用-docker-image-ls-命令来配合" class="headerlink" title="用 docker image ls 命令来配合"></a>用 docker image ls 命令来配合</h2><p>像其它可以承接多个实体的命令一样，可以使用 <code>docker image ls -q</code> 来配合使用 <code>docker image rm</code>，这样可以成批的删除希望删除的镜像。我们在“镜像列表”章节介绍过很多过滤镜像列表的方式都可以拿过来使用。</p><p>比如，我们需要删除所有仓库名为 <code>redis</code> 的镜像：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker image rm $(docker image ls -q redis)</span><br></pre></td></tr></table></figure><p>或者删除所有在 <code>mongo:3.2</code> 之前的镜像：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker image rm $(docker image ls -q -f before=mongo:3.2)</span><br></pre></td></tr></table></figure><p> Linux 命令行的强大可以完成很多非常赞的功能。</p><h1 id="镜像的实现原理"><a href="#镜像的实现原理" class="headerlink" title="镜像的实现原理"></a>镜像的实现原理</h1><p>Docker 镜像是怎么实现增量的修改和维护的？</p><p>每个镜像都由很多层次构成，Docker 使用 <a href="https://en.wikipedia.org/wiki/UnionFS" target="_blank" rel="noopener">Union FS</a> 将这些不同的层结合到一个镜像中去。</p><p>通常 Union FS 有两个用途, 一方面可以实现不借助 LVM、RAID 将多个 disk 挂到同一个目录下,另一个更常用的就是将一个只读的分支和一个可写的分支联合在一起，Live CD 正是基于此方法可以允许在镜像不变的基础上允许用户在其上进行一些写操作。</p><p>Docker 在 AUFS 上构建的容器也是利用了类似的原理。</p><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p>本文章摘抄于：<a href="https://yeasy.gitbooks.io/docker_practice/content/" target="_blank" rel="noopener">https://yeasy.gitbooks.io/docker_practice/content/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Docker镜像简介&quot;&gt;&lt;a href=&quot;#Docker镜像简介&quot; class=&quot;headerlink&quot; title=&quot;Docker镜像简介&quot;&gt;&lt;/a&gt;Docker镜像简介&lt;/h1&gt;&lt;p&gt;镜像是 Docker 的三大组件之一。&lt;/p&gt;
&lt;p&gt;Docker 运行容器前需要本地存在对应的镜像，如果本地不存在该镜像，Docker 会从镜像仓库下载该镜像。&lt;/p&gt;
&lt;p&gt;本章将介绍更多关于镜像的内容，包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;从仓库获取镜像；&lt;/li&gt;
&lt;li&gt;管理本地主机上的镜像&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Docker" scheme="http://hackycy.github.io/categories/Docker/"/>
    
    
      <category term="Docker" scheme="http://hackycy.github.io/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>Docker入门（二）——容器</title>
    <link href="http://hackycy.github.io/2019/11/28/Docker%E5%85%A5%E9%97%A8%EF%BC%88%E4%BA%8C%EF%BC%89%E2%80%94%E2%80%94%E5%AE%B9%E5%99%A8/"/>
    <id>http://hackycy.github.io/2019/11/28/Docker入门（二）——容器/</id>
    <published>2019-11-28T05:30:20.000Z</published>
    <updated>2019-12-15T08:59:49.418Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Docker容器简介"><a href="#Docker容器简介" class="headerlink" title="Docker容器简介"></a>Docker容器简介</h1><p>容器是 Docker 是一核心概念。</p><p>简单的说，容器是独立运行的一个或一组应用，以及它们的运行态环境。对应的，虚拟机可以理解为模拟运行的一整套操作系统（提供了运行态环境和其他系统环境）和跑在上面的应用。</p><a id="more"></a><p>接下来看看容器的操作使用。</p><h1 id="容器操作"><a href="#容器操作" class="headerlink" title="容器操作"></a>容器操作</h1><h2 id="启动容器"><a href="#启动容器" class="headerlink" title="启动容器"></a>启动容器</h2><p>启动容器有两种方式，一种是基于镜像新建一个容器并启动，另外一个是将在终止状态（<code>stopped</code>）的容器重新启动。</p><h3 id="新建并启动"><a href="#新建并启动" class="headerlink" title="新建并启动"></a>新建并启动</h3><p>所需要的命令主要为 <code>docker run</code>。</p><p>例如，下面的命令输出一个 “Hello World”，之后终止容器。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ docker run ubuntu:18.04 /bin/<span class="built_in">echo</span> <span class="string">'Hello world'</span></span><br><span class="line">Unable to find image <span class="string">'ubuntu:18.04'</span> locally</span><br><span class="line">18.04: Pulling from library/ubuntu</span><br><span class="line">7ddbc47eeb70: Pull complete </span><br><span class="line">c1bbdc448b72: Pull complete </span><br><span class="line">8c3b70e39044: Pull complete </span><br><span class="line">45d437916d57: Pull complete </span><br><span class="line">Digest: sha256:6e9f67fa63b0323e9a1e587fd71c561ba48a034504fb804fd26fd8800039835d</span><br><span class="line">Status: Downloaded newer image <span class="keyword">for</span> ubuntu:18.04</span><br><span class="line">Hello world</span><br></pre></td></tr></table></figure><p>这跟在本地直接执行 <code>/bin/echo &#39;hello world&#39;</code> 几乎感觉不出任何区别。</p><h3 id="启动交互式终端"><a href="#启动交互式终端" class="headerlink" title="启动交互式终端"></a>启动交互式终端</h3><p>我们通过 docker 的两个参数 -i -t，让 docker 运行的容器实现<strong>“对话”</strong>的能力：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -t -i ubuntu:18.04 /bin/bash</span><br><span class="line">root@349a1edaa615:/<span class="comment">#</span></span><br></pre></td></tr></table></figure><p>各个参数解析：</p><ul><li><strong>-t:</strong> 选项让Docker分配一个伪终端（pseudo-tty）并绑定到容器的标准输入上</li><li><strong>-i:</strong> 则让容器的标准输入保持打开。</li><li><strong>ubuntu:18.04</strong>: ubuntu 镜像。</li><li><strong>/bin/bash</strong>：放在镜像名后的是命令，这里我们希望有个交互式 Shell，因此用的是 /bin/bash。</li></ul><p>在交互模式下，用户可以通过所创建的终端来输入命令，例如</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">root@349a1edaa615:/<span class="comment"># pwd</span></span><br><span class="line">/</span><br><span class="line">root@349a1edaa615:/<span class="comment"># ls</span></span><br><span class="line">bin  boot  dev  etc  home  lib  lib64  media  mnt  opt  proc  root  run  sbin  srv  sys  tmp  usr  var</span><br><span class="line">root@349a1edaa615:/<span class="comment"># exit</span></span><br><span class="line"><span class="built_in">exit</span></span><br></pre></td></tr></table></figure><blockquote><p>exit退出交互式 Shell</p></blockquote><p>当利用 <code>docker run</code> 来创建容器时，Docker 在后台运行的标准操作包括：</p><ul><li>检查本地是否存在指定的镜像，不存在就从公有仓库下载</li><li>利用镜像创建并启动一个容器</li><li>分配一个文件系统，并在只读的镜像层外面挂载一层可读写层</li><li>从宿主主机配置的网桥接口中桥接一个虚拟接口到容器中去</li><li>从地址池配置一个 ip 地址给容器</li><li>执行用户指定的应用程序</li><li>执行完毕后容器被终止</li></ul><h3 id="启动已终止容器"><a href="#启动已终止容器" class="headerlink" title="启动已终止容器"></a>启动已终止容器</h3><p>可以利用 <code>docker container start</code> 命令，直接将一个已经终止的容器启动运行。</p><p>容器的核心为所执行的应用程序，所需要的资源都是应用程序运行所必需的。除此之外，并没有其它的资源。可以在伪终端中利用 <code>ps</code> 或 <code>top</code> 来查看进程信息。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">root@181e9d1236d5:/<span class="comment"># ps</span></span><br><span class="line">  PID TTY          TIME CMD</span><br><span class="line">    1 pts/0    00:00:00 bash</span><br><span class="line">   11 pts/0    00:00:00 ps</span><br></pre></td></tr></table></figure><h2 id="守护态运行容器"><a href="#守护态运行容器" class="headerlink" title="守护态运行容器"></a>守护态运行容器</h2><p>如果需要让 Docker 在后台运行而不是直接把执行命令的结果输出在当前宿主机下。此时，可以通过添加 <code>-d</code> 参数来实现。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -d -i -t ubuntu:18.04 /bin/sh</span><br><span class="line">edae8d9d6311b344b3971bafc2a698625242bcf3300e2c850ba1e4ef51d88707</span><br></pre></td></tr></table></figure><p>此时容器启动后会进入后台。如果想要进入容器可以使用<code>docker exec</code>命令，后面会逐渐讲解到。</p><blockquote><p> <strong>注：</strong>容器是否会长久运行，是和 <code>docker run</code> 指定的命令有关，和 <code>-d</code> 参数无关。</p></blockquote><p>使用 <code>-d</code> 参数启动后会返回一个唯一的 id，也可以通过 <code>docker container ls</code> 命令来查看容器信息。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ docker container ls</span><br><span class="line">CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES</span><br><span class="line">edae8d9d6311        ubuntu:18.04        <span class="string">"/bin/sh"</span>           4 minutes ago       Up 4 minutes                            suspicious_pike</span><br></pre></td></tr></table></figure><blockquote><p>要获取容器的输出信息，可以通过 <code>docker container logs</code> 命令。如<code>docker container logs [container ID or NAMES]</code></p></blockquote><h2 id="终止容器"><a href="#终止容器" class="headerlink" title="终止容器"></a>终止容器</h2><p>可以使用 <code>docker container stop</code> 来终止一个运行中的容器。</p><p>此外，当 Docker 容器中指定的应用终结时，容器也自动终止。</p><p>例如对于上一章节中只启动了一个终端的容器，用户通过 <code>exit</code> 命令或 <code>Ctrl+d</code> 来退出终端时，所创建的容器立刻终止。</p><p>终止状态的容器可以用 <code>docker container ls -a</code> 命令看到。例如</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ docker container stop edae</span><br><span class="line">edae</span><br><span class="line">$ docker container ls -a</span><br><span class="line">CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS                        PORTS               NAMES</span><br><span class="line">edae8d9d6311        ubuntu:18.04        <span class="string">"/bin/sh"</span>                7 minutes ago       Exited (137) 36 seconds ago                       suspicious_pike</span><br><span class="line">181e9d1236d5        ubuntu:18.04        <span class="string">"/bin/bash"</span>              2 days ago          Exited (0) 2 days ago                             condescending_feistel</span><br><span class="line">349a1edaa615        ubuntu:18.04        <span class="string">"/bin/bash"</span>              2 days ago          Exited (0) 2 days ago                             suspicious_lehmann</span><br><span class="line">7d6482342da5        ubuntu:18.04        <span class="string">"/bin/echo 'Hello wo…"</span>   2 days ago          Exited (0) 2 days ago                             affectionate_knuth</span><br></pre></td></tr></table></figure><p>处于终止状态的容器，可以通过 <code>docker container start</code> 命令来重新启动。</p><p>此外，<code>docker container restart</code> 命令会将一个运行态的容器终止，然后再重新启动它。</p><blockquote><p>指定容器ID时可以不需要输入完整ID，可以输入ID前几位都可以，只要能够辨识到该容器即可。</p></blockquote><h2 id="进入容器"><a href="#进入容器" class="headerlink" title="进入容器"></a>进入容器</h2><p>在使用 <code>-d</code> 参数时，容器启动后会进入后台。</p><p>某些时候需要进入容器进行操作，包括使用 <code>docker attach</code> 命令或 <code>docker exec</code> 命令，推荐大家使用 <code>docker exec</code> 命令。</p><h3 id="attach命令"><a href="#attach命令" class="headerlink" title="attach命令"></a><code>attach</code>命令</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ docker container ls</span><br><span class="line">CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES</span><br><span class="line">edae8d9d6311        ubuntu:18.04        <span class="string">"/bin/sh"</span>           9 minutes ago       Up 4 seconds                            suspicious_pike</span><br><span class="line">$ docker attach 243c</span><br><span class="line"><span class="comment"># pwd</span></span><br><span class="line">/</span><br><span class="line"><span class="comment"># exit</span></span><br><span class="line">$ docker container ls</span><br><span class="line">CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES</span><br></pre></td></tr></table></figure><p><em>注意：</em> 如果从这个 stdin 中 exit，会导致容器的停止。</p><h3 id="exec命令"><a href="#exec命令" class="headerlink" title="exec命令"></a><code>exec</code>命令</h3><p><code>docker exec</code> 后边可以跟多个参数，这里主要说明 <code>-i</code> <code>-t</code> 参数。</p><p>只用 <code>-i</code> 参数时，由于没有分配伪终端，界面没有我们熟悉的 Linux 命令提示符，但命令执行结果仍然可以返回。</p><p>当 <code>-i</code> <code>-t</code> 参数一起使用时，则可以看到我们熟悉的 Linux 命令提示符。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">$ container ls</span><br><span class="line">CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES</span><br><span class="line">edae8d9d6311        ubuntu:18.04        <span class="string">"/bin/sh"</span>           13 minutes ago      Up 5 seconds                            suspicious_pike</span><br><span class="line">$ docker <span class="built_in">exec</span> -i edae bash</span><br><span class="line">ls</span><br><span class="line">bin</span><br><span class="line">boot</span><br><span class="line">dev</span><br><span class="line">etc</span><br><span class="line">home</span><br><span class="line">lib</span><br><span class="line">lib64</span><br><span class="line">media</span><br><span class="line">mnt</span><br><span class="line">opt</span><br><span class="line">proc</span><br><span class="line">root</span><br><span class="line">run</span><br><span class="line">sbin</span><br><span class="line">srv</span><br><span class="line">sys</span><br><span class="line">tmp</span><br><span class="line">usr</span><br><span class="line">va</span><br><span class="line">$ docker <span class="built_in">exec</span> -i -t edae bash</span><br><span class="line">root@edae8d9d6311:/<span class="comment"># ls</span></span><br><span class="line">bin  boot  dev  etc  home  lib  lib64  media  mnt  opt  proc  root  run  sbin  srv  sys  tmp  usr  var</span><br><span class="line">root@edae8d9d6311:/<span class="comment"># exit</span></span><br><span class="line"><span class="built_in">exit</span></span><br></pre></td></tr></table></figure><p>如果从这个 stdin 中 exit，不会导致容器的停止。这就是为什么推荐大家使用 <code>docker exec</code> 的原因。</p><p>更多参数说明请使用 <code>docker exec --help</code> 查看。</p><h2 id="导出和导入容器"><a href="#导出和导入容器" class="headerlink" title="导出和导入容器"></a>导出和导入容器</h2><h3 id="导出容器"><a href="#导出容器" class="headerlink" title="导出容器"></a>导出容器</h3><p>如果要导出本地某个容器，可以使用 <code>docker export</code> 命令。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ docker container ls -a</span><br><span class="line">CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS                            PORTS               NAMES</span><br><span class="line">edae8d9d6311        ubuntu:18.04        <span class="string">"/bin/sh"</span>                18 minutes ago      Exited (137) About a minute ago                       suspicious_pike</span><br><span class="line">181e9d1236d5        ubuntu:18.04        <span class="string">"/bin/bash"</span>              2 days ago          Exited (0) 2 days ago                                 condescending_feistel</span><br><span class="line">349a1edaa615        ubuntu:18.04        <span class="string">"/bin/bash"</span>              2 days ago          Exited (0) 2 days ago                                 suspicious_lehmann</span><br><span class="line">7d6482342da5        ubuntu:18.04        <span class="string">"/bin/echo 'Hello wo…"</span>   2 days ago          Exited (0) 2 days ago                                 affectionate_knuth</span><br><span class="line">$ docker <span class="built_in">export</span> edae &gt; ubuntu.zip</span><br></pre></td></tr></table></figure><h3 id="导入容器快照"><a href="#导入容器快照" class="headerlink" title="导入容器快照"></a>导入容器快照</h3><p>可以使用 <code>docker import</code> 从容器快照文件中再导入为镜像，例如</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ cat ubuntu.zip | docker import - <span class="built_in">test</span>/ubuntu:v1.0</span><br><span class="line">$ docker image ls</span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED              VIRTUAL SIZE</span><br><span class="line"><span class="built_in">test</span>/ubuntu         v1.0                9d37a6082e97        About a minute ago   171.3 MB</span><br></pre></td></tr></table></figure><p>此外，也可以通过指定 URL 或者某个目录来导入，例如</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker import http://example.com/exampleimage.tgz example/imagerepo</span><br></pre></td></tr></table></figure><blockquote><p><em>注：用户既可以使用 <code>docker load</code> 来导入镜像存储文件到本地镜像库，也可以使用 <code>docker import</code> 来导入一个容器快照到本地镜像库。这两者的区别在于容器快照文件将丢弃所有的历史记录和元数据信息（即仅保存容器当时的快照状态），而镜像存储文件将保存完整记录，体积也要大。此外，从容器快照文件导入时可以重新指定标签等元数据信息。</em></p></blockquote><h2 id="删除容器"><a href="#删除容器" class="headerlink" title="删除容器"></a>删除容器</h2><p>可以使用 <code>docker container rm</code> 来删除一个处于终止状态的容器。例如</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker container rm  edae</span><br><span class="line">edae</span><br></pre></td></tr></table></figure><p>如果要删除一个运行中的容器，可以添加 <code>-f</code> 参数。Docker 会发送 <code>SIGKILL</code> 信号给容器。</p><p><strong>清理所有处于终止状态的容器</strong></p><p>用 <code>docker container ls -a</code> 命令可以查看所有已经创建的包括终止状态的容器，如果数量太多要一个个删除可能会很麻烦，用命令<code>docker container prune</code>可以清理掉所有处于终止状态的容器。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">$ docker container ls -a</span><br><span class="line">CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS                  PORTS               NAMES</span><br><span class="line">181e9d1236d5        ubuntu:18.04        <span class="string">"/bin/bash"</span>              2 days ago          Exited (0) 2 days ago                       condescending_feistel</span><br><span class="line">349a1edaa615        ubuntu:18.04        <span class="string">"/bin/bash"</span>              2 days ago          Exited (0) 2 days ago                       suspicious_lehmann</span><br><span class="line">7d6482342da5        ubuntu:18.04        <span class="string">"/bin/echo 'Hello wo…"</span>   2 days ago          Exited (0) 2 days ago                       affectionate_knuth</span><br><span class="line">$ docker container prune</span><br><span class="line">WARNING! This will remove all stopped containers.</span><br><span class="line">Are you sure you want to <span class="built_in">continue</span>? [y/N] y</span><br><span class="line">Deleted Containers:</span><br><span class="line">181e9d1236d54ee898f8f0ebc5349dbcc0cd2368c34f427f7963c9014c9e1dc8</span><br><span class="line">349a1edaa61597acb426a0961059bf5a73ae0b23350774d5cd5c33963c8b2b12</span><br><span class="line">7d6482342da5f695a5351c15ef17acb521f893548db0891154b5c1268227ce7d</span><br><span class="line"></span><br><span class="line">Total reclaimed space: 20B</span><br><span class="line">$ docker container ls -a</span><br><span class="line">CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES</span><br></pre></td></tr></table></figure><h1 id="数据管理"><a href="#数据管理" class="headerlink" title="数据管理"></a>数据管理</h1><p>在容器中管理数据主要有两种方式：</p><ul><li>数据卷（Volumes）</li><li>挂载主机目录 (Bind mounts)</li></ul><h2 id="数据卷"><a href="#数据卷" class="headerlink" title="数据卷"></a>数据卷</h2><p><code>数据卷</code> 是一个可供一个或多个容器使用的特殊目录，它绕过 UFS，可以提供很多有用的特性：</p><ul><li><code>数据卷</code> 可以在容器之间共享和重用</li><li>对 <code>数据卷</code> 的修改会立马生效</li><li>对 <code>数据卷</code> 的更新，不会影响镜像</li><li><code>数据卷</code> 默认会一直存在，即使容器被删除</li></ul><blockquote><p>注意：<code>数据卷</code> 的使用，类似于 Linux 下对目录或文件进行 mount，镜像中的被指定为挂载点的目录中的文件会隐藏掉，能显示看的是挂载的 <code>数据卷</code>。</p></blockquote><h3 id="创建数据卷"><a href="#创建数据卷" class="headerlink" title="创建数据卷"></a>创建数据卷</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker volume create my-vol</span><br><span class="line">my-vol</span><br></pre></td></tr></table></figure><p>查看所有的 <code>数据卷</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ docker volume ls</span><br><span class="line">DRIVER              VOLUME NAME</span><br><span class="line"><span class="built_in">local</span>               my-vol</span><br></pre></td></tr></table></figure><p>在主机里使用以下命令可以查看指定 <code>数据卷</code> 的信息</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ docker volume inspect my-vol</span><br><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">"CreatedAt"</span>: <span class="string">"2019-12-02T03:25:01Z"</span>,</span><br><span class="line">        <span class="string">"Driver"</span>: <span class="string">"local"</span>,</span><br><span class="line">        <span class="string">"Labels"</span>: &#123;&#125;,</span><br><span class="line">        <span class="string">"Mountpoint"</span>: <span class="string">"/var/lib/docker/volumes/my-vol/_data"</span>,</span><br><span class="line">        <span class="string">"Name"</span>: <span class="string">"my-vol"</span>,</span><br><span class="line">        <span class="string">"Options"</span>: &#123;&#125;,</span><br><span class="line">        <span class="string">"Scope"</span>: <span class="string">"local"</span></span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h3 id="启动一个挂载数据卷的容器"><a href="#启动一个挂载数据卷的容器" class="headerlink" title="启动一个挂载数据卷的容器"></a>启动一个挂载数据卷的容器</h3><p>在用 <code>docker run</code> 命令的时候，使用 <code>--mount</code> 标记来将 <code>数据卷</code> 挂载到容器里。在一次 <code>docker run</code> 中可以挂载多个 <code>数据卷</code>。</p><p>下面创建一个名为 <code>web</code> 的容器，并加载一个 <code>数据卷</code> 到容器的 <code>/webapp</code> 目录。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -d -P \</span><br><span class="line">    --name web \</span><br><span class="line">    <span class="comment"># -v my-vol:/wepapp \</span></span><br><span class="line">    --mount <span class="built_in">source</span>=my-vol,target=/webapp \</span><br><span class="line">    training/webapp \</span><br><span class="line">    python app.py</span><br></pre></td></tr></table></figure><blockquote><p><strong>-P:</strong> 随机端口映射，容器内部端口<strong>随机</strong>映射到主机的高端口</p></blockquote><h3 id="查看数据卷的具体信息"><a href="#查看数据卷的具体信息" class="headerlink" title="查看数据卷的具体信息"></a>查看数据卷的具体信息</h3><p>在主机里使用以下命令可以查看 <code>web</code> 容器的信息</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker inspect web</span><br></pre></td></tr></table></figure><p><code>数据卷</code> 信息在 “Mounts” Key 下面</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">"Mounts": [</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">"Type"</span>: <span class="string">"volume"</span>,</span><br><span class="line">        <span class="attr">"Name"</span>: <span class="string">"my-vol"</span>,</span><br><span class="line">        <span class="attr">"Source"</span>: <span class="string">"/var/lib/docker/volumes/my-vol/_data"</span>,</span><br><span class="line">        <span class="attr">"Destination"</span>: <span class="string">"/app"</span>,</span><br><span class="line">        <span class="attr">"Driver"</span>: <span class="string">"local"</span>,</span><br><span class="line">        <span class="attr">"Mode"</span>: <span class="string">""</span>,</span><br><span class="line">        <span class="attr">"RW"</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="attr">"Propagation"</span>: <span class="string">""</span></span><br><span class="line">    &#125;</span><br><span class="line">],</span><br></pre></td></tr></table></figure><h3 id="删除数据卷"><a href="#删除数据卷" class="headerlink" title="删除数据卷"></a>删除数据卷</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker volume rm my-vol</span><br></pre></td></tr></table></figure><p><code>数据卷</code> 是被设计用来持久化数据的，它的生命周期独立于容器，Docker 不会在容器被删除后自动删除 <code>数据卷</code>，并且也不存在垃圾回收这样的机制来处理没有任何容器引用的 <code>数据卷</code>。如果需要在删除容器的同时移除数据卷。可以在删除容器的时候使用 <code>docker rm -v</code> 这个命令。</p><p>无主的数据卷可能会占据很多空间，要清理请使用以下命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker volume prune</span><br></pre></td></tr></table></figure><h2 id="挂载主机目录"><a href="#挂载主机目录" class="headerlink" title="挂载主机目录"></a>挂载主机目录</h2><h3 id="挂载一个主机目录作为数据卷"><a href="#挂载一个主机目录作为数据卷" class="headerlink" title="挂载一个主机目录作为数据卷"></a>挂载一个主机目录作为数据卷</h3><p>使用 <code>--mount</code> 标记可以指定挂载一个本地主机的目录到容器中去。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -d -P \</span><br><span class="line">    --name web \</span><br><span class="line">    <span class="comment"># -v /src/webapp:/opt/webapp \</span></span><br><span class="line">    --mount <span class="built_in">type</span>=<span class="built_in">bind</span>,<span class="built_in">source</span>=/src/webapp,target=/opt/webapp \</span><br><span class="line">    training/webapp \</span><br><span class="line">    python app.py</span><br></pre></td></tr></table></figure><p>上面的命令加载主机的 <code>/src/webapp</code> 目录到容器的 <code>/opt/webapp</code>目录。这个功能在进行测试的时候十分方便，比如用户可以放置一些程序到本地目录中，来查看容器是否正常工作。本地目录的路径必须是绝对路径，以前使用 <code>-v</code> 参数时如果本地目录不存在 Docker 会自动为你创建一个文件夹，现在使用 <code>--mount</code> 参数时如果本地目录不存在，Docker 会报错。</p><p>Docker 挂载主机目录的默认权限是 <code>读写</code>，用户也可以通过增加 <code>readonly</code> 指定为 <code>只读</code>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -d -P \</span><br><span class="line">    --name web \</span><br><span class="line">    <span class="comment"># -v /src/webapp:/opt/webapp:ro \</span></span><br><span class="line">    --mount <span class="built_in">type</span>=<span class="built_in">bind</span>,<span class="built_in">source</span>=/src/webapp,target=/opt/webapp,<span class="built_in">readonly</span> \</span><br><span class="line">    training/webapp \</span><br><span class="line">    python app.py</span><br></pre></td></tr></table></figure><p>加了 <code>readonly</code> 之后，就挂载为 <code>只读</code> 了。如果你在容器内 <code>/opt/webapp</code> 目录新建文件，会显示如下错误</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/opt/webapp <span class="comment"># touch new.txt</span></span><br><span class="line">touch: new.txt: Read-only file system</span><br></pre></td></tr></table></figure><h3 id="查看数据卷的具体信息-1"><a href="#查看数据卷的具体信息-1" class="headerlink" title="查看数据卷的具体信息"></a>查看数据卷的具体信息</h3><p>在主机里使用以下命令可以查看 <code>web</code> 容器的信息</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker inspect web</span><br></pre></td></tr></table></figure><p><code>挂载主机目录</code> 的配置信息在 “Mounts” Key 下面</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">"Mounts": [</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">"Type"</span>: <span class="string">"bind"</span>,</span><br><span class="line">        <span class="attr">"Source"</span>: <span class="string">"/src/webapp"</span>,</span><br><span class="line">        <span class="attr">"Destination"</span>: <span class="string">"/opt/webapp"</span>,</span><br><span class="line">        <span class="attr">"Mode"</span>: <span class="string">""</span>,</span><br><span class="line">        <span class="attr">"RW"</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="attr">"Propagation"</span>: <span class="string">"rprivate"</span></span><br><span class="line">    &#125;</span><br><span class="line">],</span><br></pre></td></tr></table></figure><h3 id="挂载一个本地主机文件作为数据卷"><a href="#挂载一个本地主机文件作为数据卷" class="headerlink" title="挂载一个本地主机文件作为数据卷"></a>挂载一个本地主机文件作为数据卷</h3><p><code>--mount</code> 标记也可以从主机挂载单个文件到容器中</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ docker run --rm -it \</span><br><span class="line">   <span class="comment"># -v $HOME/.bash_history:/root/.bash_history \</span></span><br><span class="line">   --mount <span class="built_in">type</span>=<span class="built_in">bind</span>,<span class="built_in">source</span>=<span class="variable">$HOME</span>/.bash_history,target=/root/.bash_history \</span><br><span class="line">   ubuntu:18.04 \</span><br><span class="line">   bash</span><br><span class="line"></span><br><span class="line">root@2affd44b4667:/<span class="comment"># history</span></span><br><span class="line">1  ls</span><br><span class="line">2  diskutil list</span><br></pre></td></tr></table></figure><p>这样就可以记录在容器输入过的命令了。</p><h2 id="选择-v-or-–mount-标志"><a href="#选择-v-or-–mount-标志" class="headerlink" title="选择 -v or –mount 标志"></a>选择 -v or –mount 标志</h2><p>最初，<code>-v</code>或<code>--volume</code>标志用于独立容器，而<code>--mount</code>标志用于群集服务。但是，从Docker 17.06开始，您也可以使用<code>--mount</code>独立的容器。一般来说，<code>--mount</code>更明确和详细。最大的区别在于-v语法将所有选项组合在一个字段中，而<code>--mount</code>语法将它们分开。建议新学者使用。</p><p><strong><code>v</code>或<code>- volume</code>:由三个字段组成，由冒号分隔(:)。字段必须按照正确的顺序书写，并且每个字段的含义都不是立刻确定。</strong></p><ul><li>在命名卷的情况下，第一个字段是卷的名称，在给定的主机上是惟一的。对于匿名卷，省略了第一个字段。</li><li>第二个字段是在容器中安装文件或目录的路径。</li><li>第三个字段是可选的，并且是一个逗号分隔的选项列表，如ro。下面讨论这些选项。</li></ul><p><strong><code>--mount</code>:由多个键-值对组成，由逗号分隔，每一对由<code>&lt; key&gt;= &lt;value&gt; tuple(元组）</code>组成。<code>--mount</code> 语法比<code>- v</code>或<code>—volume</code> 更详细，其中键对的顺序并不重要，而且标记的值更容易理解。</strong></p><ul><li>挂载的类型(type)，可以是绑定(bind)、卷(volume)或tmpfs。本主题讨论卷，因此类型将始终是卷。</li><li>挂载源（source)。对于命名卷，是卷的名称。对于匿名卷，该字段被省略。可以指定为source 或src。</li><li>挂在目标(destination)的值是将文件或目录安装在容器中的路径。可以指定为destination、dst或target。</li><li>如果存在readonly选项，则将绑定挂载安装到容器中作为只读。</li><li>可以使用键值对多次指定的volume-opt选项.</li></ul><p>与绑定挂载相反，所有的卷的选项对于<code>--mount</code> 和<code>-v</code>标志 都可以使用。当卷(volume)作为服务时，只支持<code>--mount</code>。</p><h1 id="容器网络"><a href="#容器网络" class="headerlink" title="容器网络"></a>容器网络</h1><p>Docker 允许通过外部访问容器或容器互联的方式来提供网络服务。</p><h2 id="外部访问容器"><a href="#外部访问容器" class="headerlink" title="外部访问容器"></a>外部访问容器</h2><p>容器中可以运行一些网络应用，要让外部也可以访问这些应用，可以通过 <code>-P</code> 或 <code>-p</code> 参数来指定端口映射。</p><p>当使用 <code>-P</code> 标记时，Docker 会随机映射一个 <code>49000~49900</code> 的端口到内部容器开放的网络端口。</p><p>使用 <code>docker container ls</code> 可以看到，本地主机的 49155 被映射到了容器的 5000 端口。此时访问本机的 49155 端口即可访问容器内 web 应用提供的界面。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -d -P training/webapp python app.py</span><br><span class="line">ea7fb3aa1ca874847d7469f62f7cdfcd557438453ad08c283416b5d229468db2</span><br><span class="line">$ docker container ls</span><br><span class="line">CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS                     NAMES</span><br><span class="line">ea7fb3aa1ca8        training/webapp     <span class="string">"python app.py"</span>     About an hour ago   Up About an hour    0.0.0.0:32768-&gt;5000/tcp   serene_buck</span><br></pre></td></tr></table></figure><p>同样的，可以通过 <code>docker logs</code> 命令来查看应用的信息。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ docker logs -f serene_buck</span><br><span class="line"> * Running on http://0.0.0.0:5000/ (Press CTRL+C to quit)</span><br><span class="line">172.17.0.1 - - [02/Dec/2019 06:27:22] <span class="string">"GET / HTTP/1.1"</span> 200 -</span><br><span class="line">172.17.0.1 - - [02/Dec/2019 06:27:23] <span class="string">"GET /favicon.ico HTTP/1.1"</span> 404 -</span><br></pre></td></tr></table></figure><p><code>-p</code> 则可以指定要映射的端口，并且，在一个指定端口上只可以绑定一个容器。支持的格式有 <code>ip:hostPort:containerPort | ip::containerPort | hostPort:containerPort</code>。</p><h3 id="映射所有接口地址"><a href="#映射所有接口地址" class="headerlink" title="映射所有接口地址"></a>映射所有接口地址</h3><p>使用 <code>hostPort:containerPort</code> 格式本地的 8000 端口映射到容器的 5000 端口，可以执行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -d -p 8000:5000 training/webapp python app.py</span><br></pre></td></tr></table></figure><p>此时默认会绑定本地所有接口上的所有地址。</p><h3 id="映射到指定地址的指定端口"><a href="#映射到指定地址的指定端口" class="headerlink" title="映射到指定地址的指定端口"></a>映射到指定地址的指定端口</h3><p>可以使用 <code>ip:hostPort:containerPort</code> 格式指定映射使用一个特定地址，比如 localhost 地址 127.0.0.1</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -d -p 127.0.0.1:5000:5000 training/webapp python app.py</span><br></pre></td></tr></table></figure><h3 id="映射到指定地址的任意端口"><a href="#映射到指定地址的任意端口" class="headerlink" title="映射到指定地址的任意端口"></a>映射到指定地址的任意端口</h3><p>使用 <code>ip::containerPort</code> 绑定 localhost 的任意端口到容器的 5000 端口，本地主机会自动分配一个端口。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -d -p 127.0.0.1::5000 training/webapp python app.py</span><br></pre></td></tr></table></figure><p>还可以使用 <code>udp</code> 标记来指定 <code>udp</code> 端口</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -d -p 127.0.0.1:5000:5000/udp training/webapp python app.py</span><br></pre></td></tr></table></figure><h3 id="查看映射端口配置"><a href="#查看映射端口配置" class="headerlink" title="查看映射端口配置"></a>查看映射端口配置</h3><p>使用 <code>docker port</code> 来查看当前映射的端口配置，也可以查看到绑定的地址</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker port 5f2b 5000</span><br><span class="line">0.0.0.0:8000</span><br></pre></td></tr></table></figure><blockquote><p>注意：</p><ul><li>容器有自己的内部网络和 ip 地址（使用 <code>docker inspect</code> 可以获取所有的变量，Docker 还可以有一个可变的网络配置。）</li><li><code>-p</code> 标记可以多次使用来绑定多个端口</li></ul><p>例如</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -d \</span><br><span class="line">    -p 5000:5000 \</span><br><span class="line">    -p 3000:80 \</span><br><span class="line">    training/webapp \</span><br><span class="line">    python app.py</span><br></pre></td></tr></table></figure><h2 id="容器互联"><a href="#容器互联" class="headerlink" title="容器互联"></a>容器互联</h2><h3 id="新建网络"><a href="#新建网络" class="headerlink" title="新建网络"></a>新建网络</h3><p>下面先创建一个新的 Docker 网络。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker network create -d bridge my-net</span><br><span class="line">cea6b6e901d97a319c537895587df6a1256ccc18fc1e6faccfa911ec843e2e64</span><br></pre></td></tr></table></figure><p><code>-d</code> 参数指定 Docker 网络类型，有 <code>bridge</code> <code>overlay</code>。其中 <code>overlay</code> 网络类型用于 Swarm mode，属于高级用法了。入门章节则不介绍了。</p><h3 id="连接容器"><a href="#连接容器" class="headerlink" title="连接容器"></a>连接容器</h3><p>运行一个容器并连接到新建的 <code>my-net</code> 网络</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -i -t --rm --name busybox1 --network my-net busybox sh</span><br></pre></td></tr></table></figure><p>打开新的终端，再运行一个容器并加入到 <code>my-net</code> 网络</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -i -t --rm --name busybox2 --network my-net busybox sh</span><br></pre></td></tr></table></figure><blockquote><p>Clean up (–rm) 指在容器运行完之后自动清除，<em>注意：–rm 和 -d不能共用！</em></p></blockquote><p>再打开一个新的终端查看容器信息。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ docker container ls       </span><br><span class="line">CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES</span><br><span class="line">4f37d2e62181        busybox             <span class="string">"sh"</span>                48 seconds ago      Up 47 seconds                           busybox2</span><br><span class="line">98b27738599c        busybox             <span class="string">"sh"</span>                2 minutes ago       Up About a minute                       busybox1</span><br></pre></td></tr></table></figure><p>下面通过 <code>ping</code> 来证明 <code>busybox1</code> 容器和 <code>busybox2</code> 容器建立了互联关系。</p><p>在 <code>busybox1</code> 容器输入以下命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/ <span class="comment"># ping busybox2</span></span><br><span class="line">PING busybox2 (172.18.0.3): 56 data bytes</span><br><span class="line">64 bytes from 172.18.0.3: seq=0 ttl=64 time=0.115 ms</span><br><span class="line">64 bytes from 172.18.0.3: seq=1 ttl=64 time=0.138 ms</span><br><span class="line">64 bytes from 172.18.0.3: seq=2 ttl=64 time=0.139 ms</span><br><span class="line">64 bytes from 172.18.0.3: seq=3 ttl=64 time=0.137 ms</span><br><span class="line">64 bytes from 172.18.0.3: seq=4 ttl=64 time=0.138 ms</span><br><span class="line">64 bytes from 172.18.0.3: seq=5 ttl=64 time=0.138 ms</span><br><span class="line">64 bytes from 172.18.0.3: seq=6 ttl=64 time=0.133 ms</span><br></pre></td></tr></table></figure><p>用 ping 来测试连接 <code>busybox2</code> 容器，它会解析成 <code>172.18.0.3</code>。</p><p>同理在 <code>busybox2</code> 容器执行 <code>ping busybox1</code>，也会成功连接到。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/ <span class="comment"># ping busybox1</span></span><br><span class="line">PING busybox1 (172.18.0.2): 56 data bytes</span><br><span class="line">64 bytes from 172.18.0.2: seq=0 ttl=64 time=0.091 ms</span><br><span class="line">64 bytes from 172.18.0.2: seq=1 ttl=64 time=0.137 ms</span><br></pre></td></tr></table></figure><p>这样，<code>busybox1</code> 容器和 <code>busybox2</code> 容器建立了互联关系。</p><blockquote><p>如果有多个容器需要互相连接，推荐使用Docker Compose。</p></blockquote><blockquote><p><code>BusyBox</code> 是一个集成了一百多个最常用 Linux 命令和工具（如 <code>cat</code>、<code>echo</code>、<code>grep</code>、<code>mount</code>、<code>telnet</code> 等）的精简工具箱，它只需要几 MB 的大小，很方便进行各种快速验证，被誉为“Linux 系统的瑞士军刀”。</p><p><code>BusyBox</code> 可运行于多款 <code>POSIX</code> 环境的操作系统中，如 <code>Linux</code>（包括 <code>Android</code>）、<code>Hurd</code>、<code>FreeBSD</code> 等。</p></blockquote><h2 id="配置DNS"><a href="#配置DNS" class="headerlink" title="配置DNS"></a>配置DNS</h2><p>Docker 利用虚拟文件来挂载容器的 3 个相关配置文件。</p><p>在容器中使用 <code>mount</code> 命令可以看到挂载信息：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ mount</span><br><span class="line">/dev/disk/by-uuid/1fec...ebdf on /etc/hostname <span class="built_in">type</span> ext4 ...</span><br><span class="line">/dev/disk/by-uuid/1fec...ebdf on /etc/hosts <span class="built_in">type</span> ext4 ...</span><br><span class="line">tmpfs on /etc/resolv.conf <span class="built_in">type</span> tmpfs ...</span><br></pre></td></tr></table></figure><p>这种机制可以让宿主主机 DNS 信息发生更新后，所有 Docker 容器的 DNS 配置通过 <code>/etc/resolv.conf</code> 文件立刻得到更新。</p><p>配置全部容器的 DNS ，也可以在 <code>/etc/docker/daemon.json</code> 文件中增加以下内容来设置。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"dns"</span> : [</span><br><span class="line">    <span class="string">"114.114.114.114"</span>,</span><br><span class="line">    <span class="string">"8.8.8.8"</span></span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样每次启动的容器 DNS 自动配置为 <code>114.114.114.114</code> 和 <code>8.8.8.8</code>。使用以下命令来证明其已经生效。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -it --rm ubuntu:18.04  cat etc/resolv.conf</span><br><span class="line">nameserver 114.114.114.114</span><br><span class="line">nameserver 8.8.8.8</span><br></pre></td></tr></table></figure><p>如果用户想要手动指定容器的配置，可以在使用 <code>docker run</code> 命令启动容器时加入如下参数：</p><blockquote><p><code>-h HOSTNAME</code> 或者 <code>--hostname=HOSTNAME</code> 设定容器的主机名，它会被写到容器内的 <code>/etc/hostname</code> 和 <code>/etc/hosts</code>。但它在容器外部看不到，既不会在 <code>docker container ls</code> 中显示，也不会在其他的容器的 <code>/etc/hosts</code> 看到。</p><p><code>--dns=IP_ADDRESS</code> 添加 DNS 服务器到容器的 <code>/etc/resolv.conf</code> 中，让容器用这个服务器来解析所有不在 <code>/etc/hosts</code> 中的主机名。</p><p><code>--dns-search=DOMAIN</code> 设定容器的搜索域，当设定搜索域为 <code>.example.com</code> 时，在搜索一个名为 host 的主机时，DNS 不仅搜索 host，还会搜索 <code>host.example.com</code>。</p><p>注意：如果在容器启动时没有指定最后两个参数，Docker 会默认用主机上的<code>/etc/resolv.conf</code> 来配置容器。</p></blockquote><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p>Docker 官网：<a href="https://www.docker.com/" target="_blank" rel="noopener">https://www.docker.com</a></p><p>Github Docker 源码：<a href="https://github.com/docker/docker-ce" target="_blank" rel="noopener">https://github.com/docker/docker-ce</a></p><p>Docker命令大全：<a href="https://www.runoob.com/docker/docker-command-manual.html" target="_blank" rel="noopener">https://www.runoob.com/docker/docker-command-manual.html</a></p><p>本文章摘抄于：<a href="https://yeasy.gitbooks.io/docker_practice/content/" target="_blank" rel="noopener">https://yeasy.gitbooks.io/docker_practice/content/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Docker容器简介&quot;&gt;&lt;a href=&quot;#Docker容器简介&quot; class=&quot;headerlink&quot; title=&quot;Docker容器简介&quot;&gt;&lt;/a&gt;Docker容器简介&lt;/h1&gt;&lt;p&gt;容器是 Docker 是一核心概念。&lt;/p&gt;
&lt;p&gt;简单的说，容器是独立运行的一个或一组应用，以及它们的运行态环境。对应的，虚拟机可以理解为模拟运行的一整套操作系统（提供了运行态环境和其他系统环境）和跑在上面的应用。&lt;/p&gt;
    
    </summary>
    
      <category term="Docker" scheme="http://hackycy.github.io/categories/Docker/"/>
    
    
      <category term="Docker" scheme="http://hackycy.github.io/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>Docker入门（一）——基本概念与安装</title>
    <link href="http://hackycy.github.io/2019/11/27/Docker%E5%85%A5%E9%97%A8%EF%BC%88%E4%B8%80%EF%BC%89%E2%80%94%E2%80%94%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E4%B8%8E%E5%AE%89%E8%A3%85/"/>
    <id>http://hackycy.github.io/2019/11/27/Docker入门（一）——基本概念与安装/</id>
    <published>2019-11-27T09:35:51.000Z</published>
    <updated>2019-12-15T08:59:36.010Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Docker简介"><a href="#Docker简介" class="headerlink" title="Docker简介"></a>Docker简介</h1><p>Docker 是一个开源的应用容器引擎，基于 <a href="https://www.runoob.com/go/go-tutorial.html" target="_blank" rel="noopener">Go 语言</a> 并遵从 Apache2.0 协议开源。</p><p>Docker 可以让开发者打包他们的应用以及依赖包到一个轻量级、可移植的容器中，然后发布到任何流行的 Linux 机器上，也可以实现虚拟化。</p><p>容器是完全使用沙箱机制，相互之间不会有任何接口（类似 iPhone 的 app）,更重要的是容器性能开销极低。</p><p>Docker 从 17.03 版本之后分为 CE（Community Edition: 社区版） 和 EE（Enterprise Edition: 企业版）</p><a id="more"></a><p>Docker 使用 <code>Google</code> 公司推出的 <a href="https://golang.org/" target="_blank" rel="noopener">Go 语言</a> 进行开发实现，基于 <code>Linux</code> 内核的 <a href="https://zh.wikipedia.org/wiki/Cgroups" target="_blank" rel="noopener">cgroup</a>，<a href="https://en.wikipedia.org/wiki/Linux_namespaces" target="_blank" rel="noopener">namespace</a>，以及 <a href="https://en.wikipedia.org/wiki/Aufs" target="_blank" rel="noopener">AUFS</a> 类的 <a href="https://en.wikipedia.org/wiki/Union_mount" target="_blank" rel="noopener">Union FS</a> 等技术，对进程进行封装隔离，属于 <a href="https://en.wikipedia.org/wiki/Operating-system-level_virtualization" target="_blank" rel="noopener">操作系统层面的虚拟化技术</a>。由于隔离的进程独立于宿主和其它的隔离的进程，因此也称其为容器。最初实现是基于 <a href="https://linuxcontainers.org/lxc/introduction/" target="_blank" rel="noopener">LXC</a>，从 0.7 版本以后开始去除 <code>LXC</code>，转而使用自行开发的 <a href="https://github.com/docker/libcontainer" target="_blank" rel="noopener">libcontainer</a>，从 1.11 开始，则进一步演进为使用 <a href="https://github.com/opencontainers/runc" target="_blank" rel="noopener">runC</a> 和 <a href="https://github.com/containerd/containerd" target="_blank" rel="noopener">containerd</a>。</p><p><img src="docker-on-linux.png" alt></p><blockquote><p><code>runc</code> 是一个 Linux 命令行工具，用于根据 <a href="https://github.com/opencontainers/runtime-spec" target="_blank" rel="noopener">OCI容器运行时规范</a> 创建和运行容器。</p><p><code>containerd</code> 是一个守护程序，它管理容器生命周期，提供了在一个节点上执行容器和管理镜像的最小功能集。</p></blockquote><p>Docker在容器的基础上，进行了进一步的封装，从文件系统、网络互联到进程隔离等等，极大的简化了容器的创建和维护。使得 <code>Docker</code> 技术比虚拟机技术更为轻便、快捷。</p><p>下面的图片比较了 <strong>Docker</strong> 和传统虚拟化方式的不同之处。传统虚拟机技术是虚拟出一套硬件后，在其上运行一个完整操作系统，在该系统上再运行所需应用进程；而容器内的应用进程直接运行于宿主的内核，容器内没有自己的内核，而且也没有进行硬件虚拟。因此容器要比传统虚拟机更为轻便。</p><p><img src="virtualization.png" alt></p><p><img src="docker.png" alt></p><h1 id="Docker优点"><a href="#Docker优点" class="headerlink" title="Docker优点"></a>Docker优点</h1><p> Docker 是一个用于开发，交付和运行应用程序的开放平台。Docker 使您能够将应用程序与基础架构分开，从而可以快速交付软件。借助 Docker，您可以与管理应用程序相同的方式来管理基础架构。通过利用 Docker 的方法来快速交付，测试和部署代码，您可以大大减少编写代码和在生产环境中运行代码之间的延迟。 </p><h2 id="快速，一致地交付您的应用程序"><a href="#快速，一致地交付您的应用程序" class="headerlink" title="快速，一致地交付您的应用程序"></a>快速，一致地交付您的应用程序</h2><p>Docker 允许开发人员使用您提供的应用程序或服务的本地容器在标准化环境中工作，从而简化了开发的生命周期。</p><p>容器非常适合持续集成和持续交付（CI / CD）工作流程，请考虑以下示例方案：</p><ul><li>您的开发人员在本地编写代码，并使用 Docker 容器与同事共享他们的工作。</li><li>他们使用 Docker 将其应用程序推送到测试环境中，并执行自动或手动测试。</li><li>当开发人员发现错误时，他们可以在开发环境中对其进行修复，然后将其重新部署到测试环境中，以进行测试和验证。</li><li>测试完成后，将修补程序推送给生产环境，就像将更新的镜像推送到生产环境一样简单。</li></ul><h2 id="响应式部署和扩展"><a href="#响应式部署和扩展" class="headerlink" title="响应式部署和扩展"></a>响应式部署和扩展</h2><p>Docker 是基于容器的平台，允许高度可移植的工作负载。Docker 容器可以在开发人员的本机上，数据中心的物理或虚拟机上，云服务上或混合环境中运行。</p><p>Docker 的可移植性和轻量级的特性，还可以使您轻松地完成动态管理的工作负担，并根据业务需求指示，实时扩展或拆除应用程序和服务。</p><h2 id="更轻松的维护和扩展"><a href="#更轻松的维护和扩展" class="headerlink" title="更轻松的维护和扩展"></a>更轻松的维护和扩展</h2><p> Docker 使用的分层存储以及镜像的技术，使得应用重复部分的复用更为容易，也使得应用的维护更新更加简单，基于基础镜像进一步扩展镜像也变得非常简单。此外，<code>Docker</code> 团队同各个开源项目团队一起维护了一大批高质量的 <a href="https://hub.docker.com/search/?type=image&amp;image_filter=official" target="_blank" rel="noopener">官方镜像</a>，既可以直接在生产环境使用，又可以作为基础进一步定制，大大的降低了应用服务的镜像制作成本。 </p><h2 id="在同一硬件上运行更多工作负载"><a href="#在同一硬件上运行更多工作负载" class="headerlink" title="在同一硬件上运行更多工作负载"></a>在同一硬件上运行更多工作负载</h2><p> Docker 轻巧快速。它为基于虚拟机管理程序的虚拟机提供了可行、经济、高效的替代方案，因此您可以利用更多的计算能力来实现业务目标。Docker 非常适合于高密度环境以及中小型部署，而您可以用更少的资源做更多的事情。 </p><h2 id="对比传统虚拟机总结"><a href="#对比传统虚拟机总结" class="headerlink" title="对比传统虚拟机总结"></a>对比传统虚拟机总结</h2><table><thead><tr><th style="text-align:left">特性</th><th style="text-align:left">容器</th><th style="text-align:left">虚拟机</th></tr></thead><tbody><tr><td style="text-align:left">启动</td><td style="text-align:left">秒级</td><td style="text-align:left">分钟级</td></tr><tr><td style="text-align:left">硬盘使用</td><td style="text-align:left">一般为 <code>MB</code></td><td style="text-align:left">一般为 <code>GB</code></td></tr><tr><td style="text-align:left">性能</td><td style="text-align:left">接近原生</td><td style="text-align:left">弱于</td></tr><tr><td style="text-align:left">系统支持量</td><td style="text-align:left">单机支持上千个容器</td><td style="text-align:left">一般几十个</td></tr></tbody></table><h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><p>Docker 包括三个基本概念</p><ul><li>镜像（<code>Image</code>）</li><li>容器（<code>Container</code>）</li><li>仓库（<code>Repository</code>）</li></ul><h2 id="镜像"><a href="#镜像" class="headerlink" title="镜像"></a>镜像</h2><p>我们都知道，操作系统分为内核和用户空间。对于 Linux 而言，内核启动后，会挂载 <code>root</code> 文件系统为其提供用户空间支持。而 Docker 镜像（Image），就相当于是一个 <code>root</code> 文件系统。比如官方镜像 <code>ubuntu:18.04</code> 就包含了完整的一套 Ubuntu 18.04 最小系统的 <code>root</code> 文件系统。</p><p>Docker 镜像是一个特殊的文件系统，除了提供容器运行时所需的程序、库、资源、配置等文件外，还包含了一些为运行时准备的一些配置参数（如匿名卷、环境变量、用户等）。镜像不包含任何动态数据，其内容在构建之后也不会被改变。</p><h3 id="分层存储"><a href="#分层存储" class="headerlink" title="分层存储"></a>分层存储</h3><p>因为镜像包含操作系统完整的 <code>root</code> 文件系统，其体积往往是庞大的，因此在 Docker 设计时，就充分利用 <a href="https://en.wikipedia.org/wiki/Union_mount" target="_blank" rel="noopener">Union FS</a> 的技术，将其设计为分层存储的架构。所以严格来说，镜像并非是像一个 ISO 那样的打包文件，镜像只是一个虚拟的概念，其实际体现并非由一个文件组成，而是由一组文件系统组成，或者说，由多层文件系统联合组成。</p><p>镜像构建时，会一层层构建，前一层是后一层的基础。每一层构建完就不会再发生改变，后一层上的任何改变只发生在自己这一层。比如，删除前一层文件的操作，实际不是真的删除前一层的文件，而是仅在当前层标记为该文件已删除。在最终容器运行的时候，虽然不会看到这个文件，但是实际上该文件会一直跟随镜像。因此，在构建镜像的时候，需要额外小心，每一层尽量只包含该层需要添加的东西，任何额外的东西应该在该层构建结束前清理掉。</p><p>分层存储的特征还使得镜像的复用、定制变的更为容易。甚至可以用之前构建好的镜像作为基础层，然后进一步添加新的层，以定制自己所需的内容，构建新的镜像。</p><p>关于镜像构建，将会在后续相关章节中做进一步的讲解。</p><h2 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h2><p>镜像（<code>Image</code>）和容器（<code>Container</code>）的关系，就像是面向对象程序设计中的 <code>类</code> 和 <code>实例</code> 一样，镜像是静态的定义，容器是镜像运行时的实体。容器可以被创建、启动、停止、删除、暂停等。</p><p>容器的实质是进程，但与直接在宿主执行的进程不同，容器进程运行于属于自己的独立的 <a href="https://en.wikipedia.org/wiki/Linux_namespaces" target="_blank" rel="noopener">命名空间</a>。因此容器可以拥有自己的 <code>root</code> 文件系统、自己的网络配置、自己的进程空间，甚至自己的用户 ID 空间。容器内的进程是运行在一个隔离的环境里，使用起来，就好像是在一个独立于宿主的系统下操作一样。这种特性使得容器封装的应用比直接在宿主运行更加安全。也因为这种隔离的特性，很多人初学 Docker 时常常会混淆容器和虚拟机。</p><p>前面讲过镜像使用的是分层存储，容器也是如此。每一个容器运行时，是以镜像为基础层，在其上创建一个当前容器的存储层，我们可以称这个为容器运行时读写而准备的存储层为 <strong>容器存储层</strong>。</p><p>容器存储层的生存周期和容器一样，容器消亡时，容器存储层也随之消亡。因此，任何保存于容器存储层的信息都会随容器删除而丢失。</p><p>按照 Docker 最佳实践的要求，容器不应该向其存储层内写入任何数据，容器存储层要保持无状态化。所有的文件写入操作，都应该使用 <strong>数据卷（Volume）</strong>、或者绑定宿主目录，在这些位置的读写会跳过容器存储层，直接对宿主（或网络存储）发生读写，其性能和稳定性更高。</p><p>数据卷的生存周期独立于容器，容器消亡，数据卷不会消亡。因此，使用数据卷后，容器删除或者重新运行之后，数据却不会丢失。</p><h2 id="仓库"><a href="#仓库" class="headerlink" title="仓库"></a>仓库</h2><h3 id="Docker-Registry"><a href="#Docker-Registry" class="headerlink" title="Docker Registry"></a>Docker Registry</h3><p>镜像构建完成后，可以很容易的在当前宿主机上运行，但是，如果需要在其它服务器上使用这个镜像，我们就需要一个集中的存储、分发镜像的服务，<a href="https://yeasy.gitbooks.io/docker_practice/content/repository/registry.html" target="_blank" rel="noopener">Docker Registry</a> 就是这样的服务。</p><p>一个 <strong>Docker Registry</strong> 中可以包含多个 <strong>仓库</strong>（<code>Repository</code>）；每个仓库可以包含多个 <strong>标签</strong>（<code>Tag</code>）；每个标签对应一个镜像。</p><p>通常，一个仓库会包含同一个软件不同版本的镜像，而标签就常用于对应该软件的各个版本。我们可以通过 <code>&lt;仓库名&gt;:&lt;标签&gt;</code> 的格式来指定具体是这个软件哪个版本的镜像。如果不给出标签，将以 <code>latest</code> 作为默认标签。</p><p>以 <a href="https://hub.docker.com/_/ubuntu" target="_blank" rel="noopener">Ubuntu 镜像</a> 为例，<code>ubuntu</code> 是仓库的名字，其内包含有不同的版本标签，如，<code>16.04</code>, <code>18.04</code>。我们可以通过 <code>ubuntu:16.04</code>，或者 <code>ubuntu:18.04</code> 来具体指定所需哪个版本的镜像。如果忽略了标签，比如 <code>ubuntu</code>，那将视为 <code>ubuntu:latest</code>。</p><p>仓库名经常以 <em>两段式路径</em> 形式出现，比如 <code>jwilder/nginx-proxy</code>，前者往往意味着 Docker Registry 多用户环境下的用户名，后者则往往是对应的软件名。但这并非绝对，取决于所使用的具体 Docker Registry 的软件或服务。</p><h3 id="Docker-Registry-公开服务"><a href="#Docker-Registry-公开服务" class="headerlink" title="Docker Registry 公开服务"></a>Docker Registry 公开服务</h3><p>Docker Registry 公开服务是开放给用户使用、允许用户管理镜像的 Registry 服务。一般这类公开服务允许用户免费上传、下载公开的镜像，并可能提供收费服务供用户管理私有镜像。</p><p>最常使用的 Registry 公开服务是官方的 <a href="https://hub.docker.com/" target="_blank" rel="noopener">Docker Hub</a>，这也是默认的 Registry，并拥有大量的高质量的官方镜像。除此以外，还有 <a href="https://coreos.com/" target="_blank" rel="noopener">CoreOS</a> 的 <a href="https://quay.io/repository/" target="_blank" rel="noopener">Quay.io</a>，CoreOS 相关的镜像存储在这里；Google 的 <a href="https://cloud.google.com/container-registry/" target="_blank" rel="noopener">Google Container Registry</a>，<a href="https://kubernetes.io/" target="_blank" rel="noopener">Kubernetes</a> 的镜像使用的就是这个服务。</p><p>由于某些原因，在国内访问这些服务可能会比较慢。国内的一些云服务商提供了针对 Docker Hub 的镜像服务（<code>Registry Mirror</code>），这些镜像服务被称为<strong>加速器</strong>。常见的有 <a href="https://cr.console.aliyun.com/#/accelerator" target="_blank" rel="noopener">阿里云加速器</a>、<a href="https://www.daocloud.io/mirror#accelerator-doc" target="_blank" rel="noopener">DaoCloud 加速器</a> 等。使用加速器会直接从国内的地址下载 Docker Hub 的镜像，比直接从 Docker Hub 下载速度会提高很多。</p><p>国内也有一些云服务商提供类似于 Docker Hub 的公开服务。比如 <a href="https://hub.tenxcloud.com/" target="_blank" rel="noopener">时速云镜像仓库</a>、<a href="https://c.163.com/hub#/m/library/" target="_blank" rel="noopener">网易云镜像服务</a>、<a href="https://hub.daocloud.io/" target="_blank" rel="noopener">DaoCloud 镜像市场</a>、<a href="https://cr.console.aliyun.com/" target="_blank" rel="noopener">阿里云镜像库</a> 等。</p><h3 id="私有-Docker-Registry"><a href="#私有-Docker-Registry" class="headerlink" title="私有 Docker Registry"></a>私有 Docker Registry</h3><p>除了使用公开服务外，用户还可以在本地搭建私有 Docker Registry。Docker 官方提供了 <a href="https://hub.docker.com/_/registry/" target="_blank" rel="noopener">Docker Registry</a> 镜像，可以直接使用做为私有 Registry 服务。在 <a href="https://yeasy.gitbooks.io/docker_practice/content/repository/registry.html" target="_blank" rel="noopener">私有仓库</a> 一节中，会有进一步的搭建私有 Registry 服务的讲解。</p><p>开源的 Docker Registry 镜像只提供了 <a href="https://docs.docker.com/registry/spec/api/" target="_blank" rel="noopener">Docker Registry API</a> 的服务端实现，足以支持 <code>docker</code> 命令，不影响使用。但不包含图形界面，以及镜像维护、用户管理、访问控制等高级功能。在官方的商业化版本 <a href="https://docs.docker.com/datacenter/dtr/2.0/" target="_blank" rel="noopener">Docker Trusted Registry</a> 中，提供了这些高级功能。</p><p>除了官方的 Docker Registry 外，还有第三方软件实现了 Docker Registry API，甚至提供了用户界面以及一些高级功能。比如，<a href="https://github.com/goharbor/harbor" target="_blank" rel="noopener">Harbor</a> 和 <a href="https://yeasy.gitbooks.io/docker_practice/content/repository/nexus3_registry.html" target="_blank" rel="noopener">Sonatype Nexus</a>。</p><h1 id="Docker安装"><a href="#Docker安装" class="headerlink" title="Docker安装"></a>Docker安装</h1><p>Docker 分为 CE 和 EE 两大版本。CE 即社区版（免费，支持周期 7 个月），EE 即企业版，强调安全，付费使用，支持周期 24 个月。</p><p>Docker CE 分为 <code>stable</code> <code>test</code> 和 <code>nightly</code> 三个更新频道。每六个月发布一个 <code>stable</code> 版本 (<code>18.09</code>, <code>19.03</code>, <code>19.09</code>…)。</p><p>官方网站上有各种环境下的 <a href="https://docs.docker.com/install/" target="_blank" rel="noopener">安装指南</a>，这里主要介绍 Docker CE 在 <code>Linux</code> 、 <code>macOS</code> 上的安装。</p><h2 id="Linux—CentOS"><a href="#Linux—CentOS" class="headerlink" title="Linux—CentOS"></a>Linux—CentOS</h2><h3 id="系统要求"><a href="#系统要求" class="headerlink" title="系统要求"></a>系统要求</h3><p> Docker CE 支持 64 位版本 CentOS 7，并且要求内核版本不低于 3.10。 CentOS 7 满足最低内核的要求，但由于内核版本比较低，部分功能（如 <code>overlay2</code> 存储层驱动）无法使用，并且部分功能可能不太稳定。 </p><h3 id="卸载旧版本"><a href="#卸载旧版本" class="headerlink" title="卸载旧版本"></a>卸载旧版本</h3><p> 旧版本的 Docker 称为 <code>docker</code> 或者 <code>docker-engine</code>，使用以下命令卸载旧版本： </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ sudo yum remove docker \</span><br><span class="line">                  docker-client \</span><br><span class="line">                  docker-client-latest \</span><br><span class="line">                  docker-common \</span><br><span class="line">                  docker-latest \</span><br><span class="line">                  docker-latest-logrotate \</span><br><span class="line">                  docker-logrotate \</span><br><span class="line">                  docker-selinux \</span><br><span class="line">                  docker-engine-selinux \</span><br><span class="line">                  docker-engine</span><br></pre></td></tr></table></figure><h3 id="使用yum安装"><a href="#使用yum安装" class="headerlink" title="使用yum安装"></a>使用yum安装</h3><p> 执行以下命令安装依赖包： </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ sudo yum install -y yum-utils \</span><br><span class="line">           device-mapper-persistent-data \</span><br><span class="line">           lvm2</span><br></pre></td></tr></table></figure><p>鉴于国内网络问题，强烈建议使用国内源，官方源请在注释中查看。</p><p>执行下面的命令添加 <code>yum</code> 软件源：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ sudo yum-config-manager \</span><br><span class="line">    --add-repo \</span><br><span class="line">    https://mirrors.ustc.edu.cn/docker-ce/linux/centos/docker-ce.repo</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 官方源</span></span><br><span class="line"><span class="comment"># $ sudo yum-config-manager \</span></span><br><span class="line"><span class="comment">#     --add-repo \</span></span><br><span class="line"><span class="comment">#     https://download.docker.com/linux/centos/docker-ce.repo</span></span><br></pre></td></tr></table></figure><blockquote><p> 如果需要测试版本的 Docker CE 请使用以下命令： </p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo yum-config-manager --<span class="built_in">enable</span> docker-ce-test</span><br></pre></td></tr></table></figure><blockquote><p> 如果需要每日构建版本的 Docker CE 请使用以下命令： </p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo yum-config-manager --<span class="built_in">enable</span> docker-ce-nightly</span><br></pre></td></tr></table></figure><h3 id="安装Docker-CE"><a href="#安装Docker-CE" class="headerlink" title="安装Docker CE"></a>安装Docker CE</h3><p> 更新 <code>yum</code> 软件源缓存，并安装 <code>docker-ce</code>。 </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo yum makecache fast</span><br><span class="line">$ sudo yum install docker-ce</span><br></pre></td></tr></table></figure><h3 id="使用脚本自动安装"><a href="#使用脚本自动安装" class="headerlink" title="使用脚本自动安装"></a>使用脚本自动安装</h3><p> 在测试或开发环境中 Docker 官方为了简化安装流程，提供了一套便捷的安装脚本，CentOS 系统上可以使用这套脚本安装，另外可以通过 <code>--mirror</code> 选项使用国内源进行安装： </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ curl -fsSL get.docker.com -o get-docker.sh</span><br><span class="line">$ sudo sh get-docker.sh --mirror Aliyun</span><br><span class="line"><span class="comment"># $ sudo sh get-docker.sh --mirror AzureChinaCloud</span></span><br></pre></td></tr></table></figure><p> 执行这个命令后，脚本就会自动的将一切准备工作做好，并且把 Docker CE 的稳定(stable)版本安装在系统中。 </p><h3 id="启动Docker"><a href="#启动Docker" class="headerlink" title="启动Docker"></a>启动Docker</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo systemctl <span class="built_in">enable</span> docker</span><br><span class="line">$ sudo systemctl start docker</span><br></pre></td></tr></table></figure><h3 id="建立-docker-用户组"><a href="#建立-docker-用户组" class="headerlink" title="建立 docker 用户组"></a>建立 docker 用户组</h3><p>默认情况下，<code>docker</code> 命令会使用 <a href="https://en.wikipedia.org/wiki/Unix_domain_socket" target="_blank" rel="noopener">Unix socket</a> 与 Docker 引擎通讯。而只有 <code>root</code> 用户和 <code>docker</code> 组的用户才可以访问 Docker 引擎的 Unix socket。出于安全考虑，一般 Linux 系统上不会直接使用 <code>root</code> 用户。因此，更好地做法是将需要使用 <code>docker</code> 的用户加入 <code>docker</code> 用户组。</p><p>建立 <code>docker</code> 组：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo groupadd docker</span><br></pre></td></tr></table></figure><p> 将当前用户加入 <code>docker</code> 组： </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo usermod -aG docker <span class="variable">$USER</span></span><br></pre></td></tr></table></figure><p> 退出当前终端并重新登录，进行如下测试。 </p><h3 id="测试-Docker-是否安装正确"><a href="#测试-Docker-是否安装正确" class="headerlink" title="测试 Docker 是否安装正确"></a>测试 Docker 是否安装正确</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">$ docker run hello-world</span><br><span class="line"></span><br><span class="line">Unable to find image <span class="string">'hello-world:latest'</span> locally</span><br><span class="line">latest: Pulling from library/hello-world</span><br><span class="line">d1725b59e92d: Pull complete</span><br><span class="line">Digest: sha256:0add3ace90ecb4adbf7777e9aacf18357296e799f81cabc9fde470971e499788</span><br><span class="line">Status: Downloaded newer image <span class="keyword">for</span> hello-world:latest</span><br><span class="line"></span><br><span class="line">Hello from Docker!</span><br><span class="line">This message shows that your installation appears to be working correctly.</span><br><span class="line"></span><br><span class="line">To generate this message, Docker took the following steps:</span><br><span class="line"> 1. The Docker client contacted the Docker daemon.</span><br><span class="line"> 2. The Docker daemon pulled the <span class="string">"hello-world"</span> image from the Docker Hub.</span><br><span class="line">    (amd64)</span><br><span class="line"> 3. The Docker daemon created a new container from that image <span class="built_in">which</span> runs the</span><br><span class="line">    executable that produces the output you are currently reading.</span><br><span class="line"> 4. The Docker daemon streamed that output to the Docker client, <span class="built_in">which</span> sent it</span><br><span class="line">    to your terminal.</span><br><span class="line"></span><br><span class="line">To try something more ambitious, you can run an Ubuntu container with:</span><br><span class="line"> $ docker run -it ubuntu bash</span><br><span class="line"></span><br><span class="line">Share images, automate workflows, and more with a free Docker ID:</span><br><span class="line"> https://hub.docker.com/</span><br><span class="line"></span><br><span class="line">For more examples and ideas, visit:</span><br><span class="line"> https://docs.docker.com/get-started/</span><br></pre></td></tr></table></figure><p> 若能正常输出以上信息，则说明安装成功。 </p><blockquote><p>个人作为开发者，建议直接使用宝塔进行安装，bt.cn安装后可以查看软件商店找到docker直接进行安装。对于开发者而言更加方便使用。</p></blockquote><h2 id="macOS"><a href="#macOS" class="headerlink" title="macOS"></a>macOS</h2><h3 id="系统要求-1"><a href="#系统要求-1" class="headerlink" title="系统要求"></a>系统要求</h3><p> <a href="https://docs.docker.com/docker-for-mac/" target="_blank" rel="noopener">Docker Desktop for Mac</a> 要求系统最低为 macOS Sierra 10.12。 </p><h3 id="Homebrew-安装"><a href="#Homebrew-安装" class="headerlink" title="Homebrew 安装"></a>Homebrew 安装</h3><p> <a href="https://brew.sh/" target="_blank" rel="noopener">Homebrew</a> 的 <a href="https://caskroom.github.io/" target="_blank" rel="noopener">Cask</a> 已经支持 Docker Desktop for Mac，因此可以很方便的使用 Homebrew Cask 来进行安装： </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ brew cask install docker</span><br></pre></td></tr></table></figure><h3 id="手动下载安装"><a href="#手动下载安装" class="headerlink" title="手动下载安装"></a>手动下载安装</h3><p> <a href="https://hub.docker.com/editions/community/docker-ce-desktop-mac" target="_blank" rel="noopener">https://hub.docker.com/editions/community/docker-ce-desktop-mac</a> </p><p><a href="https://docs.docker.com/toolbox/overview/" target="_blank" rel="noopener">https://docs.docker.com/toolbox/overview/</a></p><p>也可以点击以下链接直接下载 <a href="https://download.docker.com/mac/stable/Docker.dmg" target="_blank" rel="noopener">Stable</a> 或 <a href="https://download.docker.com/mac/edge/Docker.dmg" target="_blank" rel="noopener">Edge</a> 版本的 Docker Desktop for Mac。</p><blockquote><p>点击链接注册Docker ID即可下载。傻瓜式安装。安装后点击图标运行即可。</p><p>可关掉开机自启。preference -&gt; general -&gt; start Docker Desktop when you log in</p></blockquote><p>启动终端后，通过命令可以检查安装后的 Docker 版本。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ docker --version</span><br><span class="line">Docker version 19.03.5, build 633a0ea</span><br><span class="line">$ docker-compose --version</span><br><span class="line">docker-compose version 1.24.1, build 4667896b</span><br><span class="line">$ docker-machine --version</span><br><span class="line">docker-machine version 0.16.2, build bd45ab13</span><br></pre></td></tr></table></figure><h2 id="镜像加速器"><a href="#镜像加速器" class="headerlink" title="镜像加速器"></a>镜像加速器</h2><p>国内从 Docker Hub 拉取镜像有时会遇到困难，此时可以配置镜像加速器。国内很多云服务商都提供了国内加速器服务，例如：</p><ul><li><a href="https://github.com/Azure/container-service-for-azure-china/blob/master/aks/README.md#22-container-registry-proxy" target="_blank" rel="noopener">Azure 中国镜像 <code>https://dockerhub.azk8s.cn</code></a></li><li><a href="https://cr.console.aliyun.com/cn-hangzhou/mirrors" target="_blank" rel="noopener">阿里云加速器(需登录账号获取)</a></li><li><a href="https://kirk-enterprise.github.io/hub-docs/#/user-guide/mirror" target="_blank" rel="noopener">七牛云加速器 <code>https://reg-mirror.qiniu.com</code></a></li></ul><blockquote><p>由于镜像服务可能出现宕机，建议同时配置多个镜像。</p><p>国内各大云服务商均提供了 Docker 镜像加速服务，建议根据运行 Docker 的云平台选择对应的镜像加速服务，具体请参考官方文档。</p></blockquote><p>这里以 Azure 中国镜像 <code>https://dockerhub.azk8s.cn</code> 为例进行介绍。</p><h3 id="Ubuntu-16-04-、Debian-8-、CentOS-7"><a href="#Ubuntu-16-04-、Debian-8-、CentOS-7" class="headerlink" title="Ubuntu 16.04+、Debian 8+、CentOS 7"></a>Ubuntu 16.04+、Debian 8+、CentOS 7</h3><p> 对于使用 <a href="https://www.freedesktop.org/wiki/Software/systemd/" target="_blank" rel="noopener">systemd</a> 的系统，请在 <code>/etc/docker/daemon.json</code> 中写入如下内容（如果文件不存在请新建该文件） </p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"registry-mirrors"</span>: [</span><br><span class="line">    <span class="string">"https://dockerhub.azk8s.cn"</span>,</span><br><span class="line">    <span class="string">"https://reg-mirror.qiniu.com"</span></span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p> 注意，一定要保证该文件符合 json 规范，否则 Docker 将不能启动。 </p></blockquote><p> 之后重新启动服务。 </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo systemctl daemon-reload</span><br><span class="line">$ sudo systemctl restart docker</span><br></pre></td></tr></table></figure><blockquote><p> 注意：如果您之前查看旧教程，修改了 <code>docker.service</code> 文件内容，请去掉您添加的内容（<code>--registry-mirror=https://dockerhub.azk8s.cn</code>）。 </p></blockquote><h3 id="macOS-1"><a href="#macOS-1" class="headerlink" title="macOS"></a>macOS</h3><p> 对于使用 macOS 的用户，在任务栏点击 Docker Desktop 应用图标 -&gt; <code>Perferences</code>，在左侧导航菜单选择 <code>Docker Engine</code>，在右侧像下边一样编辑 json 文件。修改完成之后，点击 <code>Apply &amp; Restart</code> 按钮，Docker 就会重启并应用配置的镜像地址了。 </p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"registry-mirrors"</span>: [</span><br><span class="line">    <span class="string">"https://dockerhub.azk8s.cn"</span>,</span><br><span class="line">    <span class="string">"https://reg-mirror.qiniu.com"</span></span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="检查加速器是否生效"><a href="#检查加速器是否生效" class="headerlink" title="检查加速器是否生效"></a>检查加速器是否生效</h3><p> 执行 <code>$ docker info</code>，如果从结果中看到了如下内容，说明配置成功。 </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Registry Mirrors:</span><br><span class="line"> https://dockerhub.azk8s.cn/</span><br></pre></td></tr></table></figure><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p>Docker 官网：<a href="https://www.docker.com/" target="_blank" rel="noopener">https://www.docker.com</a></p><p>Github Docker 源码：<a href="https://github.com/docker/docker-ce" target="_blank" rel="noopener">https://github.com/docker/docker-ce</a></p><p>Docker命令大全：<a href="https://www.runoob.com/docker/docker-command-manual.html" target="_blank" rel="noopener">https://www.runoob.com/docker/docker-command-manual.html</a></p><p>本文章摘抄于：<a href="https://yeasy.gitbooks.io/docker_practice/content/" target="_blank" rel="noopener">https://yeasy.gitbooks.io/docker_practice/content/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Docker简介&quot;&gt;&lt;a href=&quot;#Docker简介&quot; class=&quot;headerlink&quot; title=&quot;Docker简介&quot;&gt;&lt;/a&gt;Docker简介&lt;/h1&gt;&lt;p&gt;Docker 是一个开源的应用容器引擎，基于 &lt;a href=&quot;https://www.runoob.com/go/go-tutorial.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Go 语言&lt;/a&gt; 并遵从 Apache2.0 协议开源。&lt;/p&gt;
&lt;p&gt;Docker 可以让开发者打包他们的应用以及依赖包到一个轻量级、可移植的容器中，然后发布到任何流行的 Linux 机器上，也可以实现虚拟化。&lt;/p&gt;
&lt;p&gt;容器是完全使用沙箱机制，相互之间不会有任何接口（类似 iPhone 的 app）,更重要的是容器性能开销极低。&lt;/p&gt;
&lt;p&gt;Docker 从 17.03 版本之后分为 CE（Community Edition: 社区版） 和 EE（Enterprise Edition: 企业版）&lt;/p&gt;
    
    </summary>
    
      <category term="Docker" scheme="http://hackycy.github.io/categories/Docker/"/>
    
    
      <category term="Docker" scheme="http://hackycy.github.io/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>了解JSON Web Token</title>
    <link href="http://hackycy.github.io/2019/11/11/%E4%BA%86%E8%A7%A3JSON-Web-Token/"/>
    <id>http://hackycy.github.io/2019/11/11/了解JSON-Web-Token/</id>
    <published>2019-11-11T04:19:51.000Z</published>
    <updated>2019-11-11T06:37:51.747Z</updated>
    
    <content type="html"><![CDATA[<p>JSON Web Token（缩写 JWT）是目前最流行的跨域认证解决方案。<a href="https://jwt.io" target="_blank" rel="noopener">JWT</a></p><a id="more"></a><h1 id="跨域认证问题"><a href="#跨域认证问题" class="headerlink" title="跨域认证问题"></a>跨域认证问题</h1><p>互联网服务离不开用户认证。一般流程是下面这样。</p><blockquote><p>1、用户向服务器发送用户名和密码。</p><p>2、服务器验证通过后，在当前对话（session）里面保存相关数据，比如用户角色、登录时间等等。</p><p>3、服务器向用户返回一个 session_id，写入用户的 Cookie。</p><p>4、用户随后的每一次请求，都会通过 Cookie，将 session_id 传回服务器。</p><p>5、服务器收到 session_id，找到前期保存的数据，由此得知用户的身份。</p></blockquote><p>这种模式的问题在于，扩展性（scaling）不好。单机当然没有问题，如果是服务器集群，或者是跨域的服务导向架构，就要求 session 数据共享，每台服务器都能够读取 session。</p><p>举例来说，A 网站和 B 网站是同一家公司的关联服务。现在要求，用户只要在其中一个网站登录，再访问另一个网站就会自动登录，请问怎么实现？</p><p>一种解决方案是 session 数据持久化，写入数据库或别的持久层。各种服务收到请求后，都向持久层请求数据。这种方案的优点是架构清晰，缺点是工程量比较大。另外，持久层万一挂了，就会单点失败。</p><p>另一种方案是服务器索性不保存 session 数据了，所有数据都保存在客户端，每次请求都发回服务器。JWT 就是这种方案的一个代表。</p><h1 id="JWT原理"><a href="#JWT原理" class="headerlink" title="JWT原理"></a>JWT原理</h1><p>JWT 的原理是，服务器认证以后，生成一个 JSON 对象，发回给用户，就像下面这样。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"username"</span>: <span class="string">"张三"</span>,</span><br><span class="line">  <span class="attr">"role"</span>: <span class="string">"管理员"</span>,</span><br><span class="line">  <span class="attr">"exp"</span>: <span class="string">"2018年7月1日0点0分"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以后，用户与服务端通信的时候，都要发回这个 JSON 对象。服务器完全只靠这个对象认定用户身份。为了防止用户篡改数据，服务器在生成这个对象的时候，会加上签名（详见后文）。</p><p>服务器就不保存任何 session 数据了，也就是说，服务器变成无状态了，从而比较容易实现扩展。</p><h1 id="JWT的数据结构"><a href="#JWT的数据结构" class="headerlink" title="JWT的数据结构"></a>JWT的数据结构</h1><p>实际的 JWT 大概就像下面这样。</p><p><img src="jsonwebtoken.png" alt></p><p>它是一个很长的字符串，中间用点（<code>.</code>）分隔成三个部分。注意，JWT 内部是没有换行的，这里只是为了便于展示，将它写成了几行。</p><p>JWT 的三个部分依次如下：</p><ul><li>Header（头部）</li><li>Payload（负载）</li><li>Signature（签名）</li></ul><p>写成一行，就是<code>Header.Payload.Signature</code>。</p><p><img src="jsonwebtoken1.jpg" alt></p><h2 id="Header"><a href="#Header" class="headerlink" title="Header"></a>Header</h2><p>Header 部分是一个 JSON 对象，描述 JWT 的元数据，通常是下面的样子。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"alg"</span>: <span class="string">"HS256"</span>,</span><br><span class="line">  <span class="attr">"typ"</span>: <span class="string">"JWT"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，<code>alg</code>属性表示签名的算法（algorithm），默认是 HMAC SHA256（写成 HS256）；<code>typ</code>属性表示这个令牌（token）的类型（type），JWT 令牌统一写为<code>JWT</code>。</p><p>最后，将上面的 JSON 对象使用 Base64URL 算法（详见后文）转成字符串。</p><h2 id="Payload"><a href="#Payload" class="headerlink" title="Payload"></a>Payload</h2><p>Payload 部分也是一个 JSON 对象，用来存放实际需要传递的数据。JWT 规定了7个官方字段，供选用。</p><ul><li>iss (issuer)：签发人</li><li>exp (expiration time)：过期时间</li><li>sub (subject)：主题</li><li>aud (audience)：受众</li><li>nbf (Not Before)：生效时间</li><li>iat (Issued At)：签发时间</li><li>jti (JWT ID)：编号</li></ul><p>除了官方字段，你还可以在这个部分定义私有字段，下面就是一个例子。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"sub"</span>: <span class="string">"1234567890"</span>,</span><br><span class="line">  <span class="attr">"name"</span>: <span class="string">"John Doe"</span>,</span><br><span class="line">  <span class="attr">"admin"</span>: <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，JWT 默认是不加密的，任何人都可以读到，所以不要把秘密信息放在这个部分。</p><p>这个 JSON 对象也要使用 Base64URL 算法转成字符串。</p><h2 id="Signature"><a href="#Signature" class="headerlink" title="Signature"></a>Signature</h2><p>Signature 部分是对前两部分的签名，防止数据篡改。</p><p>首先，需要指定一个密钥（secret）。这个密钥只有服务器才知道，不能泄露给用户。然后，使用 Header 里面指定的签名算法（默认是 HMAC SHA256），按照下面的公式产生签名。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">HMACSHA256(</span><br><span class="line">  base64UrlEncode(header) + &quot;.&quot; +</span><br><span class="line">  base64UrlEncode(payload),</span><br><span class="line">  secret)</span><br></pre></td></tr></table></figure><p>算出签名以后，把 Header、Payload、Signature 三个部分拼成一个字符串，每个部分之间用”点”（<code>.</code>）分隔，就可以返回给用户。</p><h2 id="Base64URL"><a href="#Base64URL" class="headerlink" title="Base64URL"></a>Base64URL</h2><p>前面提到，Header 和 Payload 串型化的算法是 Base64URL。这个算法跟 Base64 算法基本类似，但有一些小的不同。</p><p>JWT 作为一个令牌（token），有些场合可能会放到 URL（比如 api.example.com/?token=xxx）。Base64 有三个字符<code>+</code>、<code>/</code>和<code>=</code>，在 URL 里面有特殊含义，所以要被替换掉：<code>=</code>被省略、<code>+</code>替换成<code>-</code>，<code>/</code>替换成<code>_</code> 。这就是 Base64URL 算法。</p><h1 id="JWT-的使用方式"><a href="#JWT-的使用方式" class="headerlink" title="JWT 的使用方式"></a>JWT 的使用方式</h1><p>客户端收到服务器返回的 JWT，可以储存在 Cookie 里面，也可以储存在 localStorage。</p><p>此后，客户端每次与服务器通信，都要带上这个 JWT。你可以把它放在 Cookie 里面自动发送，但是这样不能跨域，所以更好的做法是放在 HTTP 请求的头信息<code>Authorization</code>字段里面。</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Authorization</span>: Bearer &lt;token&gt;</span><br></pre></td></tr></table></figure><p>另一种做法是，跨域的时候，JWT 就放在 POST 请求的数据体里面。</p><blockquote><p>在node中使用jwt：<a href="https://segmentfault.com/a/1190000009494020" target="_blank" rel="noopener">jsonwebtoken中文文档</a> ｜ <a href="https://www.npmjs.com/package/jsonwebtoken" target="_blank" rel="noopener">jsonwebtoken npm</a></p></blockquote><h1 id="JWT-的几个特点"><a href="#JWT-的几个特点" class="headerlink" title="JWT 的几个特点"></a>JWT 的几个特点</h1><p>（1）JWT 默认是不加密，但也是可以加密的。生成原始 Token 以后，可以用密钥再加密一次。</p><p>（2）JWT 不加密的情况下，不能将秘密数据写入 JWT。</p><p>（3）JWT 不仅可以用于认证，也可以用于交换信息。有效使用 JWT，可以降低服务器查询数据库的次数。</p><p>（4）JWT 的最大缺点是，由于服务器不保存 session 状态，因此无法在使用过程中废止某个 token，或者更改 token 的权限。也就是说，一旦 JWT 签发了，在到期之前就会始终有效，除非服务器部署额外的逻辑。</p><p>（5）JWT 本身包含了认证信息，一旦泄露，任何人都可以获得该令牌的所有权限。为了减少盗用，JWT 的有效期应该设置得比较短。对于一些比较重要的权限，使用时应该再次对用户进行认证。</p><p>（6）为了减少盗用，JWT 不应该使用 HTTP 协议明码传输，要使用 HTTPS 协议传输。</p><h1 id="JWT优点"><a href="#JWT优点" class="headerlink" title="JWT优点"></a>JWT优点</h1><p>使用 JSON Web Token 保护应用安全，你至少可以获得以下几个优势：</p><p>更少的数据库连接：因其基于算法来实现身份认证，在使用 JWT 时查询数据的次数更少(更少的数据连接不等于不连接数据库)，可以获得更快的系统响应时间。构建更简单：如果你的应用程序本身是无状态的，那么选择 JWT 可以加快系统构建过程。</p><p>跨服务调用：你可以构建一个认证中心来处理用户身份认证和发放签名的工作，其他应用服务在后续的用户请求中不需要(理论上)在询问认证中心，可使用自有的公钥对用户签名进行验证。</p><p>无状态：你不需要向传统的 Web 应用那样将用户状态保存于 Session 中。</p><h1 id="JWT弊端"><a href="#JWT弊端" class="headerlink" title="JWT弊端"></a>JWT弊端</h1><p>JWT 不是万能的，使用 JWT 也会带来诸多问题。就个人使用情况，使用 JWT 时可能会面临以下几个麻烦：</p><ul><li>严重依赖于秘钥：JWT 的生成与解析过程都需要依赖于秘钥(Secret)，且都以硬编码的方式存在于系统中(也有放在外部配置文件中的)。如果秘钥不小心泄露，系统的安全性将收到威胁。</li><li>服务端无法管理客户端的信息：如果用户身份发生异常(信息泄露，或者被攻击)，服务端很难向操作 Session 那样主动将异常用户进行隔离。</li><li>服务端无法主动推送消息：服务端由于是无状态的，他将无法使用像 Session 那样的方式推送消息到客户端，例如过期时间将至，服务端无法主动为用户续约，需要客户端向服务端发起续约请求。</li><li>冗余的数据开销：一个 JWT 签名的大小要远比一个 Session ID 长很多，如果你对有效载荷(payload)中的数据不做有效控制，其长度会成几何倍数增长，且在每一次请求时都需要负担额外的网络开销。</li><li>JSON Web Token 很流行，但是它相比于 Session,OIDC(OpenId Connect)等技术还比较新，支持 JSON Web Token 的库还比较少，而且 JWT 也并非比传统 Session 更安全，他们都没有解决 CSRF 和 XSS 的问题。因此，在决定使用 JWT 前，你需要仔细考虑其利弊。</li></ul><h1 id="安全隐患思考"><a href="#安全隐患思考" class="headerlink" title="安全隐患思考"></a>安全隐患思考</h1><p><strong>考虑这样一个问题：如果客户端的 JWT 令牌泄露或者被盗取，会发生什么严重的后果？有什么补救措施？</strong></p><ul><li>如果单纯的依靠 JSON Web Token 解决用户认证的所有问题，那么系统的安全性将是脆弱的。由于 JWT 令牌存储于客户端中，一旦客户端存储的令牌发生泄露事件或者被攻击，攻击者就可以轻而易举的伪造用户身份去修改/删除系统资源，岁如按 JWT 自带过期时间，但在过期之前，攻击者可以肆无忌惮的操作系统数据。通过算法来校验用户身份合法性是 JWT 的优势，同时也是最大的弊端——它太过于依赖算法。</li><li>反观传统的用户认证措施，通常会包含多种组合，如手机验证码，人脸识别，语音识别，指纹锁等。用户名和密码只做用户身份识别使用，当用户名和密码泄露后，在遇到敏感操作时(如新增，修改，删除，下载，上传)，都会采用另外的方式对用户的合法性进行验证(发送验证码，邮箱验证码，指纹信息等)以确保数据安全。</li><li>与传统的身份验证方式相比，JWT 过多的依赖于算法，缺乏灵活性，而且服务端往往是被动执行用户身份验证操作，无法及时对异常用户进行隔离。那是否有补救措施呢？答案是肯定的。接下来，将介绍在发生令牌泄露事件后，如何保证系统的安全。</li></ul><h1 id="防范手段"><a href="#防范手段" class="headerlink" title="防范手段"></a>防范手段</h1><p>不管是基于 Sessions 还是基于 JSON Web Token，一旦密令被盗取，都是一件棘手的事情。接下来，将讲述基于 JSON Web Token 的方式发生令牌泄露是该采取什么样的措施(解决方案包含但不局限与本文所涉及的内容)。</p><p>为了防止用户 JWT 令牌泄露而威胁系统安全，你可以在以下几个方面完善系统功能：</p><ol><li>清除已泄露的令牌：此方案最直接，也容易实现，你需将 JWT 令牌在服务端也存储一份，若发现有异常的令牌存在，则从服务端令牌列表中将此异常令牌清除。当用户发起请求时，强制用户重新进行身份验证，直至验证成功。对于服务端的令牌存储，可以借助 Redis 等缓存服务器进行管理，也可以使用 Ehcache 将令牌信息存储在内存中。</li><li>敏感操作保护：在涉及到诸如新增，修改，删除，上传，下载等敏感性操作时，定期(30分钟，15分钟甚至更短)检查用户身份，如手机验证码，扫描二维码等手段，确认操作者是用户本人。如果身份验证不通过，则终止请求，并要求重新验证用户身份信息。</li><li>地域检查：通常用户会在一个相对固定的地理范围内访问应用程序，可以将地理位置信息作为一个辅助来甄别用户的 JWT 令牌是否存在问题。如果发现用户A由经常所在的地区 1 变到了相对较远的地区 2 ，或者频繁在多个地区间切换，不管用户有没有可能在短时间内在多个地域活动(一般不可能)，都应当终止当前请求，强制用户重新进行验证身份，颁发新的 JWT 令牌，并提醒(或要求)用户重置密码。</li><li>监控请求频率：如果 JWT 密令被盗取，攻击者或通过某些工具伪造用户身份，高频次的对系统发送请求，以套取用户数据。针对这种情况，可以监控用户在单位时间内的请求次数，当单位时间内的请求次数超出预定阈值值，则判定该用户密令是有问题的。例如 1 秒内连续超过 5 次请求，则视为用户身份非法，服务端终止请求并强制将该用户的 JWT 密令清除，然后回跳到认证中心对用户身份进行验证。</li><li>客户端环境检查：对于一些移动端应用来说，可以将用户信息与设备(手机,平板)的机器码进行绑定，并存储于服务端中，当客户端发起请求时，可以先校验客户端的机器码与服务端的是否匹配，如果不匹配，则视为非法请求，并终止用户的后续请求。</li></ol><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://jwt.io/introduction/" target="_blank" rel="noopener">https://jwt.io/introduction/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;JSON Web Token（缩写 JWT）是目前最流行的跨域认证解决方案。&lt;a href=&quot;https://jwt.io&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;JWT&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="架构之路" scheme="http://hackycy.github.io/categories/%E6%9E%B6%E6%9E%84%E4%B9%8B%E8%B7%AF/"/>
    
    
      <category term="Json Web Token" scheme="http://hackycy.github.io/tags/Json-Web-Token/"/>
    
  </entry>
  
  <entry>
    <title>理解OAuth 2.0</title>
    <link href="http://hackycy.github.io/2019/10/25/%E7%90%86%E8%A7%A3OAuth-2-0/"/>
    <id>http://hackycy.github.io/2019/10/25/理解OAuth-2-0/</id>
    <published>2019-10-25T08:56:03.000Z</published>
    <updated>2019-10-25T09:17:02.347Z</updated>
    
    <content type="html"><![CDATA[<p>最近需要接入到第三方应用登陆接触到了这个<a href="http://en.wikipedia.org/wiki/OAuth" target="_blank" rel="noopener">OAuth</a>概念，它是一个关于授权（authorization）的开放网络标准，在全世界得到广泛应用（QQ，Github，微博等），目前的版本是2.0版。</p><p>所以记录下OAuth 2.0的设计思路和运行流程，做一个简明通俗的解释，主要参考材料为<a href="http://www.rfcreader.com/#rfc6749" target="_blank" rel="noopener">RFC 6749</a>。</p><a id="more"></a><h1 id="名词定义"><a href="#名词定义" class="headerlink" title="名词定义"></a>名词定义</h1><p>在详细讲解OAuth 2.0之前，需要了解几个专用名词。它们对读懂后面的讲解，尤其是几张图，至关重要。</p><ul><li><strong>Third-party application</strong>：第三方应用程序，本文中又称”客户端”（client），即上一节例子中的”云冲印”。</li><li><strong>HTTP service</strong>：HTTP服务提供商，本文中简称”服务提供商”。</li><li><strong>User Agent</strong>：用户代理，本文中就是指浏览器。</li><li><strong>Authorization server</strong>：认证服务器，即服务提供商专门用来处理认证的服务器。</li><li><strong>Resource server</strong>：资源服务器，即服务提供商存放用户生成的资源的服务器。它与认证服务器，可以是同一台服务器，也可以是不同的服务器。</li></ul><blockquote><p>OAuth的作用就是让”客户端”安全可控地获取”用户”的授权，与”服务商提供商”进行互动。</p></blockquote><h1 id="OAuth的思路"><a href="#OAuth的思路" class="headerlink" title="OAuth的思路"></a>OAuth的思路</h1><p>OAuth在”客户端”与”服务提供商”之间，设置了一个授权层（authorization layer）。”客户端”不能直接登录”服务提供商”，只能登录授权层，以此将用户与客户端区分开来。”客户端”登录授权层所用的令牌（token），与用户的密码不同。用户可以在登录的时候，指定授权层令牌的权限范围和有效期。</p><p>“客户端”登录授权层以后，”服务提供商”根据令牌的权限范围和有效期，向”客户端”开放用户储存的资料。</p><h1 id="运行流程"><a href="#运行流程" class="headerlink" title="运行流程"></a>运行流程</h1><p>OAuth 2.0的运行流程如下图，摘自RFC 6749。</p><p><img src="1.png" alt></p><blockquote><p>（A）用户打开客户端以后，客户端要求用户给予授权。</p><p>（B）用户同意给予客户端授权。</p><p>（C）客户端使用上一步获得的授权，向认证服务器申请令牌。</p><p>（D）认证服务器对客户端进行认证以后，确认无误，同意发放令牌。</p><p>（E）客户端使用令牌，向资源服务器申请获取资源。</p><p>（F）资源服务器确认令牌无误，同意向客户端开放资源。</p></blockquote><p>上面六个步骤之中，B是关键，即用户怎样才能给于客户端授权。有了这个授权以后，客户端就可以获取令牌，进而凭令牌获取资源。</p><p>下面讲解客户端获取授权的四种模式。</p><h1 id="客户端的授权模式"><a href="#客户端的授权模式" class="headerlink" title="客户端的授权模式"></a>客户端的授权模式</h1><p>客户端必须得到用户的授权（authorization grant），才能获得令牌（access token）。OAuth 2.0定义了四种授权方式。</p><ul><li>授权码模式（authorization code）</li><li>简化模式（implicit）</li><li>密码模式（resource owner password credentials）</li><li>客户端模式（client credentials）</li></ul><h2 id="授权码模式"><a href="#授权码模式" class="headerlink" title="授权码模式"></a>授权码模式</h2><p>授权码模式（authorization code）是功能最完整、流程最严密的授权模式。它的特点就是通过客户端的后台服务器，与”服务提供商”的认证服务器进行互动。</p><p><img src="authorizationcode.png" alt></p><p>它的步骤如下：</p><blockquote><p>（A）用户访问客户端，后者将前者导向认证服务器。</p><p>（B）用户选择是否给予客户端授权。</p><p>（C）假设用户给予授权，认证服务器将用户导向客户端事先指定的”重定向URI”（redirection URI），同时附上一个授权码。</p><p>（D）客户端收到授权码，附上早先的”重定向URI”，向认证服务器申请令牌。这一步是在客户端的后台的服务器上完成的，对用户不可见。</p><p>（E）认证服务器核对了授权码和重定向URI，确认无误后，向客户端发送访问令牌（access token）和更新令牌（refresh token）。</p></blockquote><p>下面是上面这些步骤所需要的参数。</p><p>A步骤中，客户端申请认证的URI，包含以下参数：</p><ul><li>response_type：表示授权类型，必选项，此处的值固定为”code”</li><li>client_id：表示客户端的ID，必选项</li><li>redirect_uri：表示重定向URI，可选项</li><li>scope：表示申请的权限范围，可选项</li><li>state：表示客户端的当前状态，可以指定任意值，认证服务器会原封不动地返回这个值。</li></ul><p>下面是一个例子。</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">GET /authorize?response_type=code&amp;client_id=s6BhdRkqt3&amp;state=xyz</span><br><span class="line">        &amp;redirect_uri=https%3A%2F%2Fclient%2Eexample%2Ecom%2Fcb HTTP/1.1</span><br><span class="line"><span class="attribute">Host</span>: server.example.com</span><br></pre></td></tr></table></figure><p>C步骤中，服务器回应客户端的URI，包含以下参数：</p><ul><li>code：表示授权码，必选项。该码的有效期应该很短，通常设为10分钟，客户端只能使用该码一次，否则会被授权服务器拒绝。该码与客户端ID和重定向URI，是一一对应关系。</li><li>state：如果客户端的请求中包含这个参数，认证服务器的回应也必须一模一样包含这个参数。</li></ul><p>下面是一个例子。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 <span class="number">302</span> Found</span><br><span class="line"><span class="attribute">Location</span>: https://client.example.com/cb?code=SplxlOBeZQQYbYS6WxSbIA</span><br><span class="line">          &amp;state=xyz</span><br></pre></td></tr></table></figure><p>D步骤中，客户端向认证服务器申请令牌的HTTP请求，包含以下参数：</p><ul><li>grant_type：表示使用的授权模式，必选项，此处的值固定为”authorization_code”。</li><li>code：表示上一步获得的授权码，必选项。</li><li>redirect_uri：表示重定向URI，必选项，且必须与A步骤中的该参数值保持一致。</li><li>client_id：表示客户端ID，必选项。</li></ul><p>下面是一个例子。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">POST</span> <span class="string">/token</span> HTTP/1.1</span><br><span class="line"><span class="attribute">Host</span>: server.example.com</span><br><span class="line"><span class="attribute">Authorization</span>: Basic czZCaGRSa3F0MzpnWDFmQmF0M2JW</span><br><span class="line"><span class="attribute">Content-Type</span>: application/x-www-form-urlencoded</span><br><span class="line"></span><br><span class="line">grant_type=authorization_code&amp;code=SplxlOBeZQQYbYS6WxSbIA</span><br><span class="line">&amp;redirect_uri=https%3A%2F%2Fclient%2Eexample%2Ecom%2Fcb</span><br></pre></td></tr></table></figure><p>E步骤中，认证服务器发送的HTTP回复，包含以下参数：</p><ul><li>access_token：表示访问令牌，必选项。</li><li>token_type：表示令牌类型，该值大小写不敏感，必选项，可以是bearer类型或mac类型。</li><li>expires_in：表示过期时间，单位为秒。如果省略该参数，必须其他方式设置过期时间。</li><li>refresh_token：表示更新令牌，用来获取下一次的访问令牌，可选项。</li><li>scope：表示权限范围，如果与客户端申请的范围一致，此项可省略。</li></ul><p>下面是一个例子。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 <span class="number">200</span> OK</span><br><span class="line"><span class="attribute">Content-Type</span>: application/json;charset=UTF-8</span><br><span class="line"><span class="attribute">Cache-Control</span>: no-store</span><br><span class="line"><span class="attribute">Pragma</span>: no-cache</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">"access_token":"2YotnFZFEjr1zCsicMWpAA",</span><br><span class="line">"token_type":"example",</span><br><span class="line">"expires_in":3600,</span><br><span class="line">"refresh_token":"tGzv3JOkF0XG5Qx2TlKWIA",</span><br><span class="line">"example_parameter":"example_value"</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面代码可以看到，相关参数使用JSON格式发送（Content-Type: application/json）。此外，HTTP头信息中明确指定不得缓存。</p><h2 id="简化模式"><a href="#简化模式" class="headerlink" title="简化模式"></a>简化模式</h2><p>简化模式（implicit grant type）不通过第三方应用程序的服务器，直接在浏览器中向认证服务器申请令牌，跳过了”授权码”这个步骤，因此得名。所有步骤在浏览器中完成，令牌对访问者是可见的，且客户端不需要认证。</p><p><img src="implicitgranttype.png" alt></p><p>它的步骤如下：</p><blockquote><p>（A）客户端将用户导向认证服务器。</p><p>（B）用户决定是否给于客户端授权。</p><p>（C）假设用户给予授权，认证服务器将用户导向客户端指定的”重定向URI”，并在URI的Hash部分包含了访问令牌。</p><p>（D）浏览器向资源服务器发出请求，其中不包括上一步收到的Hash值。</p><p>（E）资源服务器返回一个网页，其中包含的代码可以获取Hash值中的令牌。</p><p>（F）浏览器执行上一步获得的脚本，提取出令牌。</p><p>（G）浏览器将令牌发给客户端。</p></blockquote><p>下面是上面这些步骤所需要的参数。</p><p>A步骤中，客户端发出的HTTP请求，包含以下参数：</p><ul><li>response_type：表示授权类型，此处的值固定为”token”，必选项。</li><li>client_id：表示客户端的ID，必选项。</li><li>redirect_uri：表示重定向的URI，可选项。</li><li>scope：表示权限范围，可选项。</li><li>state：表示客户端的当前状态，可以指定任意值，认证服务器会原封不动地返回这个值。</li></ul><p>下面是一个例子。</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">GET /authorize?response_type=token&amp;client_id=s6BhdRkqt3&amp;state=xyz</span><br><span class="line">        &amp;redirect_uri=https%3A%2F%2Fclient%2Eexample%2Ecom%2Fcb HTTP/1.1</span><br><span class="line"><span class="attribute">Host</span>: server.example.com</span><br></pre></td></tr></table></figure><p>C步骤中，认证服务器回应客户端的URI，包含以下参数：</p><ul><li>access_token：表示访问令牌，必选项。</li><li>token_type：表示令牌类型，该值大小写不敏感，必选项。</li><li>expires_in：表示过期时间，单位为秒。如果省略该参数，必须其他方式设置过期时间。</li><li>scope：表示权限范围，如果与客户端申请的范围一致，此项可省略。</li><li>state：如果客户端的请求中包含这个参数，认证服务器的回应也必须一模一样包含这个参数。</li></ul><p>下面是一个例子。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 <span class="number">302</span> Found</span><br><span class="line"><span class="attribute">Location</span>: http://example.com/cb#access_token=2YotnFZFEjr1zCsicMWpAA</span><br><span class="line">               &amp;state=xyz&amp;token_type=example&amp;expires_in=3600</span><br></pre></td></tr></table></figure><p>在上面的例子中，认证服务器用HTTP头信息的Location栏，指定浏览器重定向的网址。注意，在这个网址的Hash部分包含了令牌。</p><p>根据上面的D步骤，下一步浏览器会访问Location指定的网址，但是Hash部分不会发送。接下来的E步骤，服务提供商的资源服务器发送过来的代码，会提取出Hash中的令牌。</p><h2 id="密码模式"><a href="#密码模式" class="headerlink" title="密码模式"></a>密码模式</h2><p>密码模式（Resource Owner Password Credentials Grant）中，用户向客户端提供自己的用户名和密码。客户端使用这些信息，向”服务商提供商”索要授权。</p><p>在这种模式中，用户必须把自己的密码给客户端，但是客户端不得储存密码。这通常用在用户对客户端高度信任的情况下，比如客户端是操作系统的一部分，或者由一个著名公司出品。而认证服务器只有在其他授权模式无法执行的情况下，才能考虑使用这种模式。</p><p><img src="ResourceOwnerPasswordCredentialsGrant.png" alt></p><p>它的步骤如下：</p><blockquote><p>（A）用户向客户端提供用户名和密码。</p><p>（B）客户端将用户名和密码发给认证服务器，向后者请求令牌。</p><p>（C）认证服务器确认无误后，向客户端提供访问令牌。</p></blockquote><p>B步骤中，客户端发出的HTTP请求，包含以下参数：</p><ul><li>grant_type：表示授权类型，此处的值固定为”password”，必选项。</li><li>username：表示用户名，必选项。</li><li>password：表示用户的密码，必选项。</li><li>scope：表示权限范围，可选项。</li></ul><p>下面是一个例子。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">POST</span> <span class="string">/token</span> HTTP/1.1</span><br><span class="line"><span class="attribute">Host</span>: server.example.com</span><br><span class="line"><span class="attribute">Authorization</span>: Basic czZCaGRSa3F0MzpnWDFmQmF0M2JW</span><br><span class="line"><span class="attribute">Content-Type</span>: application/x-www-form-urlencoded</span><br><span class="line"></span><br><span class="line">grant_type=password&amp;username=johndoe&amp;password=A3ddj3w</span><br></pre></td></tr></table></figure><p>C步骤中，认证服务器向客户端发送访问令牌，下面是一个例子。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 <span class="number">200</span> OK</span><br><span class="line"><span class="attribute">Content-Type</span>: application/json;charset=UTF-8</span><br><span class="line"><span class="attribute">Cache-Control</span>: no-store</span><br><span class="line"><span class="attribute">Pragma</span>: no-cache</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">   "access_token":"2YotnFZFEjr1zCsicMWpAA",</span><br><span class="line">   "token_type":"example",</span><br><span class="line">   "expires_in":3600,</span><br><span class="line">   "refresh_token":"tGzv3JOkF0XG5Qx2TlKWIA",</span><br><span class="line">   "example_parameter":"example_value"</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，各个参数的含义参见《授权码模式》一节。</p><p>整个过程中，客户端不得保存用户的密码。</p><blockquote><p>个人觉得这种模式对于用户来说，用户需要对你的系统需要有极大的信任度才会这样做，所以很少会有这种模式的授权方式。</p></blockquote><h2 id="客户端模式"><a href="#客户端模式" class="headerlink" title="客户端模式"></a>客户端模式</h2><p>客户端模式（Client Credentials Grant）指客户端以自己的名义，而不是以用户的名义，向”服务提供商”进行认证。严格地说，客户端模式并不属于OAuth框架所要解决的问题。在这种模式中，用户直接向客户端注册，客户端以自己的名义要求”服务提供商”提供服务，其实不存在授权问题。</p><p><img src="ClientCredentialsGrant.png" alt></p><p>它的步骤如下：</p><blockquote><p>（A）客户端向认证服务器进行身份认证，并要求一个访问令牌。</p><p>（B）认证服务器确认无误后，向客户端提供访问令牌。</p></blockquote><p>A步骤中，客户端发出的HTTP请求，包含以下参数：</p><ul><li>grant<em>type：表示授权类型，此处的值固定为”client</em>credentials”，必选项。</li><li>scope：表示权限范围，可选项。</li></ul><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">POST</span> <span class="string">/token</span> HTTP/1.1</span><br><span class="line"><span class="attribute">Host</span>: server.example.com</span><br><span class="line"><span class="attribute">Authorization</span>: Basic czZCaGRSa3F0MzpnWDFmQmF0M2JW</span><br><span class="line"><span class="attribute">Content-Type</span>: application/x-www-form-urlencoded</span><br><span class="line"></span><br><span class="line">grant_type=client_credentials</span><br></pre></td></tr></table></figure><p>认证服务器必须以某种方式，验证客户端身份。</p><p>B步骤中，认证服务器向客户端发送访问令牌，下面是一个例子。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 <span class="number">200</span> OK</span><br><span class="line"><span class="attribute">Content-Type</span>: application/json;charset=UTF-8</span><br><span class="line"><span class="attribute">Cache-Control</span>: no-store</span><br><span class="line"><span class="attribute">Pragma</span>: no-cache</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">   "access_token":"2YotnFZFEjr1zCsicMWpAA",</span><br><span class="line">   "token_type":"example",</span><br><span class="line">   "expires_in":3600,</span><br><span class="line">   "example_parameter":"example_value"</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，各个参数的含义参见《授权码模式》一节。</p><h1 id="更新令牌"><a href="#更新令牌" class="headerlink" title="更新令牌"></a>更新令牌</h1><p>如果用户访问的时候，客户端的”访问令牌”已经过期，则需要使用”更新令牌”申请一个新的访问令牌。</p><p>客户端发出更新令牌的HTTP请求，包含以下参数：</p><ul><li>grant<em>type：表示使用的授权模式，此处的值固定为”refresh</em>token”，必选项。</li><li>refresh_token：表示早前收到的更新令牌，必选项。</li><li>scope：表示申请的授权范围，不可以超出上一次申请的范围，如果省略该参数，则表示与上一次一致。</li></ul><p>下面是一个例子。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">POST</span> <span class="string">/token</span> HTTP/1.1</span><br><span class="line"><span class="attribute">Host</span>: server.example.com</span><br><span class="line"><span class="attribute">Authorization</span>: Basic czZCaGRSa3F0MzpnWDFmQmF0M2JW</span><br><span class="line"><span class="attribute">Content-Type</span>: application/x-www-form-urlencoded</span><br><span class="line"></span><br><span class="line">grant_type=refresh_token&amp;refresh_token=tGzv3JOkF0XG5Qx2TlKWIA</span><br></pre></td></tr></table></figure><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="http://www.ruanyifeng.com/blog/2014/05/oauth_2_0.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2014/05/oauth_2_0.html</a></p><p><a href="https://www.bilibili.com/video/av35979732?from=search&amp;seid=13491637330338351260" target="_blank" rel="noopener">https://www.bilibili.com/video/av35979732?from=search&amp;seid=13491637330338351260</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近需要接入到第三方应用登陆接触到了这个&lt;a href=&quot;http://en.wikipedia.org/wiki/OAuth&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;OAuth&lt;/a&gt;概念，它是一个关于授权（authorization）的开放网络标准，在全世界得到广泛应用（QQ，Github，微博等），目前的版本是2.0版。&lt;/p&gt;
&lt;p&gt;所以记录下OAuth 2.0的设计思路和运行流程，做一个简明通俗的解释，主要参考材料为&lt;a href=&quot;http://www.rfcreader.com/#rfc6749&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;RFC 6749&lt;/a&gt;。&lt;/p&gt;
    
    </summary>
    
      <category term="架构之路" scheme="http://hackycy.github.io/categories/%E6%9E%B6%E6%9E%84%E4%B9%8B%E8%B7%AF/"/>
    
    
      <category term="OAuth 2.0" scheme="http://hackycy.github.io/tags/OAuth-2-0/"/>
    
  </entry>
  
  <entry>
    <title>Gradle构建脚本</title>
    <link href="http://hackycy.github.io/2019/10/17/Gradle%E6%9E%84%E5%BB%BA%E8%84%9A%E6%9C%AC/"/>
    <id>http://hackycy.github.io/2019/10/17/Gradle构建脚本/</id>
    <published>2019-10-17T02:47:40.000Z</published>
    <updated>2019-10-17T03:08:50.348Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>Gradle提供了一种领域特定语言，目前同时支持 Groovy 和 Kotlin 。在 Groovy 构建脚本中（.gradle) 你可以使用任何 Groovy 元素。</p><p>在 Kotlin 构建脚本中 (.gradle.kts) 你可以使用任何 Kotlin 元素。</p><a id="more"></a><h1 id="项目（Project）和任务（Task）"><a href="#项目（Project）和任务（Task）" class="headerlink" title="项目（Project）和任务（Task）"></a>项目（Project）和任务（Task）</h1><p>Gradle 构建的一切都是基于两个概念 ：项目和任务；</p><p>一个构建是由一个或多个项目组成的。</p><p>项目的概念比较抽象，你可以创建一个 Project 用于生成一个 jar,也可以定义个项目用于生成 war 包，还可以定义一个项目用于发布上传你的 war等。</p><p>一个项目就是在你的业务范围内，被你抽象出来的一个独立的模块，你可以根据工程的实际情况抽象归类，最后这一个个的项目组成了整个 Gradle 构建。</p><p>一个项目又包含很多个任务，每个项目是由一个或多个任务组成的。</p><p>任务就是一个操作，一个原子性的操作。比如打个 jar 包，复制一份文件，编译一次 java 代码等，这就是一个任务。</p><h1 id="build-gradle-amp-Project-API"><a href="#build-gradle-amp-Project-API" class="headerlink" title="build.gradle &amp; Project API"></a>build.gradle &amp; Project API</h1><p>每个项目都有一个 build.gradle 文件，该文件是该项目的构建入口，可以在这这个文件里对该项目进行配置，比如配置版本，需要哪些插件，依赖哪些库等。</p><p>我们通过配置这个文件描述我们的构建，这其实就是一个配置脚本。</p><p>每一个脚本在执行的时候都会被关联到一个 Project 实例上。</p><p>在构建生命周期的初始化阶段，Gradle 会为每个项目创建一个 Project 实例，并根据 build.gradle的内容配置这个实例。</p><p>也就是说每个 build.gradle 的配置都会被配置到 Project 实例上。</p><p>实际上，build.gradle 中几乎所有的顶级属性和代码块都是 Project 类的 API，</p><p>下面通过访问 Project.name 属性验证一下。</p><p>在 <code>build.gradle</code></p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">println <span class="string">"name is $name"</span></span><br><span class="line">println <span class="string">"project.name is $&#123;project.name&#125;"</span></span><br></pre></td></tr></table></figure><blockquote><p>执行 build 任务，你将会得到下面的输出,输出的值都是 项目的名字</p></blockquote><p>第一条语句使用的是Project的顶级属性。</p><p>第二条语句使用的 project 属性 可以在脚本的任何地方访问，它代表的是当前脚本的Project对象。</p><p>只有在你定义了和Project的成员（方法，属性）同名的时候才需要使用 project ，其他时候直接使用 名称即可访问，例如第一条语句。</p><p><strong>一个构建是由多个Project组成的，是通过项目树的形式表示的。</strong></p><p>可以在项目树的根项目对所有的项目统一配置一些配置。例如，应用的插件，依赖的 Maven 中心库等。</p><p>为所有子项目配置仓库为 jcenter</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">subprojects&#123;</span><br><span class="line">    repositories &#123;</span><br><span class="line">        jcenter()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也可以为所有子项目配置 使用 Java 插件</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">subprojects&#123;</span><br><span class="line">    apply <span class="string">plugin:</span><span class="string">'java'</span></span><br><span class="line">    repositories &#123;</span><br><span class="line">        jcenter()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除了 subprojects 还有 allprojects ,从名字就可以看出来这不仅是对子项目的配置而是对所有项目的配置。</p><p>这两个配置其实是两个方法，接受一个闭包参数，对项目进行遍历，遍历的过程中调用我们自定义的闭包，所以我们可以在闭包里配置，打印，输出或者修改 Project 的属性。</p><h1 id="Project的属性"><a href="#Project的属性" class="headerlink" title="Project的属性"></a>Project的属性</h1><p>Project 对象的属性在 脚本全局都是可以使用的。</p><p>下面列出一些常用的属性，更全的属性可以在 Project API 中查询。</p><table><thead><tr><th>名字</th><th>类型</th><th>默认值</th></tr></thead><tbody><tr><td>project</td><td>Project</td><td>Project 实例</td></tr><tr><td>name</td><td>String</td><td>项目名字</td></tr><tr><td>path</td><td>String</td><td>项目的绝对路径</td></tr><tr><td>description</td><td>String</td><td>项目描述</td></tr><tr><td>projectDir</td><td>File</td><td>配置脚本所在的目录</td></tr><tr><td>buildDir</td><td>File</td><td>projectDir/build 输出目录</td></tr><tr><td>group</td><td>Object</td><td>未指定</td></tr><tr><td>version</td><td>Object</td><td>未指定</td></tr><tr><td>ant</td><td>AntBuilder</td><td>AntBuilder 实例</td></tr></tbody></table><h1 id="settings-gradle"><a href="#settings-gradle" class="headerlink" title="settings.gradle"></a>settings.gradle</h1><p>这个文件是由 Gradle 约定命名的，默认名为 settings.gradle ，在初始化阶段被执行。</p><p>对于多项目构建，必须在这里声明要参与构建的所有项目。对于单项目构建就是可选的了，可有可无。</p><p>Gradle 是如何寻找 settings.gradle 的？</p><p>1.在当前目录寻找2.没有找到的话就去父目录寻找3.仍然没有找到就是是单项目构建了4.如果找到了就是确定其中的项目，如果当前执行的项目在 settings.gradle 有定义就执行多项目构建，否则就执行单项目构建。</p><p>一个脚本的属性访问和方法调用是委托给 Project 类的实例的，</p><p>类似的 settings.gradle 的属性访问和方法调用是委托给 Settings 类的实例对象的。</p><h1 id="script-API"><a href="#script-API" class="headerlink" title="script API"></a>script API</h1><p>当 Gradle 执行 Groovy 脚本(.gradle)时，会编译脚本到实现了 <code>Script</code> 的类中。也就是说，Script 接口中的所有属性和方法都可以在脚本中使用。</p><p>当 Gradle 执行 Kotlin 脚本(.gradle.kts)时,会编译脚本到 <code>KotlinBuildScript</code>的子类中。</p><p>也就是说 KotlinBuildScript 类中的所有属性和方法都可以在脚本中使用。</p><p>更详细的可以参考 KotlinSettingsScript 和 KotlinInitScript 类，分别用于设置脚本和init脚本。</p><p>写的确实是脚本，但不是简单的脚本。在脚本里可以定义 Class ，内部类，导入包，定义方法、常量、接口等。</p><p>不要把它当作简单的脚本，我们可以灵活的使用 Java ，Groovy ，Kotlin 和 Gradle.</p><p>例如 定义一个获取当前日期的方法</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> buildTime()&#123;</span><br><span class="line">     <span class="keyword">def</span> date = <span class="keyword">new</span> Date()</span><br><span class="line">     <span class="keyword">def</span> formattedDate = date.format(<span class="string">'yyyyMMdd'</span>)</span><br><span class="line">     <span class="keyword">return</span> formattedDate</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h1 id="变量-amp-额外的自定义属性"><a href="#变量-amp-额外的自定义属性" class="headerlink" title="变量 &amp; 额外的自定义属性"></a>变量 &amp; 额外的自定义属性</h1><p>Gradle 支持两种变量 ：</p><ul><li>局部变量</li><li>自定义属性</li></ul><h2 id="局部变量"><a href="#局部变量" class="headerlink" title="局部变量"></a>局部变量</h2><p>局部变量使用 def 关键字声明，局部变量只能在声明的范围内可见。</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> myName = <span class="string">'local var'</span></span><br></pre></td></tr></table></figure><h1 id="额外的自定义属性"><a href="#额外的自定义属性" class="headerlink" title="额外的自定义属性"></a>额外的自定义属性</h1><p>Gradle 领域模型中 所有的对象 都可以添加额外的自定义属性。</p><p>通过对象的 ext 属性实现对自定义属性的添加，访问，设置值的操作。</p><p>添加之后可以通过 ext 属性对自定义属性读取和设置，也可以同时添加多个自定义属性。</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//为 project 添加一个 age 属性 并赋值 20</span></span><br><span class="line"> ext.age = <span class="number">20</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">//为 project 添加两个属性</span></span><br><span class="line"> ext&#123;</span><br><span class="line">     phone =<span class="number">110</span></span><br><span class="line">     address = <span class="string">'404'</span></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> task myTask &#123;</span><br><span class="line">     <span class="comment">//为 myTask 任务添加属性</span></span><br><span class="line">     ext.myProperty = <span class="string">"myValue"</span></span><br><span class="line"> &#125;</span><br><span class="line"> task extra&#123;</span><br><span class="line">      doLast&#123;</span><br><span class="line">          println <span class="string">"project : age= $&#123;project.ext.age&#125;,phone= $&#123;project.ext.phone&#125; , address = $&#123;project.ext.address&#125;"</span></span><br><span class="line">          println <span class="string">"myTask :  $&#123;myTask.myProperty&#125;"</span></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h1 id="创建一个任务"><a href="#创建一个任务" class="headerlink" title="创建一个任务"></a>创建一个任务</h1><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">task hello &#123;</span><br><span class="line">     doLast &#123;</span><br><span class="line">         println <span class="string">'Hello world!'</span></span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>这里的 task 看着像一个关键字，实际上是一个方法，这个方法的原型是 TaskContainer.create(）</p><p>任务的创建就是使用这个方法给 Project 添加一个 Task 类型的属性；</p><p>所以才能使用任务名字引用一些API，例如为任务添加额外的属性。</p><h1 id="任务依赖和任务排序"><a href="#任务依赖和任务排序" class="headerlink" title="任务依赖和任务排序"></a>任务依赖和任务排序</h1><p>一个任务可以依赖其他任务或者在其他任务执行后再执行。</p><p>Gradle 确保在执行任务时遵守所有任务依赖性和排序规则，以便在所有依赖项和任何 “必须运行” 的任务执行之后再执行任务。</p><p>Gradle 为我们提供了几个方法用来控制任务的依赖和排序，就是下面这几个</p><ul><li>Task.dependsOn(java.lang.Object[])</li><li>Task.setDependsOn(java.lang.Iterable)</li><li>Task.mustRunAfter(java.lang.Object[])</li><li>Task.setMustRunAfter(java.lang.Iterable)</li><li>Task.shouldRunAfter(java.lang.Object[])</li><li>Task.setShouldRunAfter(java.lang.Iterable)</li></ul><p>这些方法可以接收 任务，任务名字，路径等，具体参数可以在 <a href="https://docs.gradle.org/current/userguide/more_about_tasks.html" target="_blank" rel="noopener">Task文档</a> 里查看</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">task hello &#123;</span><br><span class="line">     doLast &#123;</span><br><span class="line">         println <span class="string">'Hello world!'</span></span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> task taskX &#123;</span><br><span class="line">     dependsOn hello</span><br><span class="line">     doLast&#123;</span><br><span class="line">         println <span class="string">"I'm  $name."</span></span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> task taskY &#123;</span><br><span class="line">     doFirst &#123;</span><br><span class="line">         println <span class="string">"I'm $name."</span></span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>如果 taskX 要依赖 taskY 的话，并不能直接引用，因为 taskY 是在 taskX 之后定义的。</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">task taskX &#123;</span><br><span class="line">     dependsOn <span class="string">'taskY'</span></span><br><span class="line">     doLast&#123;</span><br><span class="line">         println <span class="string">"I'm  $name."</span></span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h1 id="默认任务"><a href="#默认任务" class="headerlink" title="默认任务"></a>默认任务</h1><p>在没有指定执行任务的时候，可以在脚本中定义默认任务，使用 defaultTasks 方法</p><p>这个方法接收 字符串参数，传入任务的名称即可</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">defaultTasks <span class="string">'hello'</span>,<span class="string">'taskY'</span></span><br></pre></td></tr></table></figure><h1 id="外部依赖"><a href="#外部依赖" class="headerlink" title="外部依赖"></a>外部依赖</h1><p>用添加外部依赖，必须添加依赖所在仓库。例如 jcenter,maven，google等</p><p>添加 google 仓库</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">allprojects &#123;</span><br><span class="line">    repositories &#123;</span><br><span class="line">        mavenCentral()</span><br><span class="line">        google()</span><br><span class="line">        jcenter()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 Android 的项目中，这都是放在根项目里的 allprojects 方法里，对所有项目统一配置</p><p>添加外部依赖</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    implementation <span class="string">'io.reactivex.rxjava2:rxjava:2.1.2'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 Android 中依赖的添加放在了各个module 中，按需添加，哪个模块需要在哪个模块的构建脚本里添加。</p><p>依赖属性分为三部分</p><ul><li>group：这个属性用来标识一个组织、公司或者项目，可以用点号分隔，例如上面的 io.reactivex.rxjava2</li><li>name：name属性唯一的描述了这个依赖，例如上面的 rxjava</li><li>version：一个库可以有很多个版本。例如上面的 2.1.2</li></ul><p>其中 implementation 为配置项，配置也有很多种类型，</p><table><thead><tr><th>新配置(3.0后)</th><th>弃用配置(3.0前)</th><th>说明</th><th>作用</th></tr></thead><tbody><tr><td><code>implementation</code></td><td><code>compile</code></td><td>依赖项在编译时对模块可用，并且仅在运行时对模块的消费者可用。 对于大型多项目构建，使用<code>implementation</code>而不是<code>api/compile</code>可以显著缩短构建时间，因为它可以减少构建系统需要重新编译的项目量。 大多数应用和测试模块都应使用此配置。</td><td>使用<code>implementation</code>方式来依赖项目或库，该库在编译时，只对当前的module可见，对其他的module不可见。</td></tr><tr><td><code>api</code></td><td><code>compile</code></td><td>依赖项在编译时对模块可用，并且在编译时和运行时还对模块的消费者可用。 此配置的行为类似于<code>compile</code>（现在已弃用），一般情况下，您应当仅在库模块中使用它。 应用模块应使用<code>implementation</code>，除非您想要将其 API 公开给单独的测试模块。</td><td>使用<code>api</code>方式来依赖项目或库，该库在编译和运行时都可以对其他module可见。</td></tr><tr><td><code>compileOnly</code></td><td><code>provided</code></td><td>依赖项仅在编译时对模块可用，并且在编译或运行时对其消费者不可用。 此配置的行为类似于<code>provided</code>（现在已弃用）。</td><td>使用<code>compileOnly</code>方式来依赖项目或库，该库仅在编译时有效可用。</td></tr><tr><td><code>runtimeOnly</code></td><td><code>apk</code></td><td>依赖项仅在运行时对模块及其消费者可用。 此配置的行为类似于<code>apk</code>（现在已弃用）。</td><td>使用<code>runtimeOnly</code>方式来依赖项目或库，该库仅在运行时有效可用。</td></tr></tbody></table><blockquote><p>最后留个 DSL 的查询地址：<a href="https://docs.gradle.org/current/dsl/index.html" target="_blank" rel="noopener">https://docs.gradle.org/current/dsl/index.html</a></p></blockquote><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://www.cnblogs.com/skymxc/p/buildscript.html" target="_blank" rel="noopener">https://www.cnblogs.com/skymxc/p/buildscript.html</a></p><p><a href="https://www.jianshu.com/p/d183c3b554e5" target="_blank" rel="noopener">https://www.jianshu.com/p/d183c3b554e5</a></p><p><a href="https://docs.gradle.org/" target="_blank" rel="noopener">https://docs.gradle.org/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;Gradle提供了一种领域特定语言，目前同时支持 Groovy 和 Kotlin 。在 Groovy 构建脚本中（.gradle) 你可以使用任何 Groovy 元素。&lt;/p&gt;
&lt;p&gt;在 Kotlin 构建脚本中 (.gradle.kts) 你可以使用任何 Kotlin 元素。&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="http://hackycy.github.io/categories/Android/"/>
    
    
      <category term="Android" scheme="http://hackycy.github.io/tags/Android/"/>
    
      <category term="Gradle" scheme="http://hackycy.github.io/tags/Gradle/"/>
    
  </entry>
  
  <entry>
    <title>图解TCP/IP协议</title>
    <link href="http://hackycy.github.io/2019/10/16/%E5%9B%BE%E8%A7%A3TCP-IP%E5%8D%8F%E8%AE%AE/"/>
    <id>http://hackycy.github.io/2019/10/16/图解TCP-IP协议/</id>
    <published>2019-10-16T02:48:15.000Z</published>
    <updated>2019-10-16T03:04:15.610Z</updated>
    
    <content type="html"><![CDATA[<h1 id="TCP-IP-协议族"><a href="#TCP-IP-协议族" class="headerlink" title="TCP/IP 协议族"></a>TCP/IP 协议族</h1><p>Internet 的核心协议就是 TCP/IP，广泛应用于局域网和广域网，目前已有20+年发展史，是现用国际通行标准。TCP/IP 是个协议族，包含有多种协议，网络模型及分层如图所示</p><a id="more"></a><p><img src="1.jpg" alt></p><h1 id="TCP-IP-五层网络模型"><a href="#TCP-IP-五层网络模型" class="headerlink" title="TCP/IP 五层网络模型"></a>TCP/IP 五层网络模型</h1><p><strong>应用层：</strong>应用程序通过TCP/IP互联网络后发送、接受数据。选择所需服务类型，按照传输层要求组织数据，向下传递报文序列或字节流2种类型。</p><p><strong>传输层：</strong>提供应用层间通信服务，又称端到端通信。提供可靠的数据传输服务，确保数据准确、有序送达目的地。数据发送后需对方回送确认信息，有丢失的数据需发送方重发分组。传输的对象是传输层分组。</p><p><strong>网络层：</strong>又称<strong>IP层</strong>，负责机器间通信，接收到传输层请求后，向目的地传送信息分组。此分组会被封装进IP数据报中，由路由选择算法决定直送目的地或发给路由，然后将数据向下传递给网络接口层。接收到数据报时，检验正确性，由路由选择算法决定本地处理或转发，若目的地属于本机所在网络，就把数据报的报头剥去，选择适当的传输层协议向上传递分组。</p><p><strong>连接层：</strong>又称<strong>数据链路层</strong>，处于TCP/IP协议层之下，负责接收IP数据报并将数据报通过选定网络发送出去</p><p><strong>硬件层：</strong>处理连接网络的硬件部分。包括控制操作系统、硬件的设备驱动、NIC（Network Interface Card，网络适配器，即网卡），及光纤等 物理可见部分（还包括连接器等一切传输媒介）</p><h1 id="TCP-IP-内含协议职责"><a href="#TCP-IP-内含协议职责" class="headerlink" title="TCP/IP 内含协议职责"></a>TCP/IP 内含协议职责</h1><p><img src="2.jpg" alt></p><h1 id="TCP-IP-协议传输数据流程"><a href="#TCP-IP-协议传输数据流程" class="headerlink" title="TCP/IP 协议传输数据流程"></a>TCP/IP 协议传输数据流程</h1><p>传输控制协议（Transmission Control Protocol,TCP）是 Internet 传输层协议，提供面向连接的可靠传输服务，可靠性由重发技术保证。TCP 报文首部的大小一定是4字节的倍数，其中固定首部大小为20字节且不变</p><p><img src="3.jpg" alt></p><p>TCP 数据包示意图</p><p>ACK：确认位，当它的值为1时，确认号才是有效的<br>SYN：同步请求，TCP连接中连接双方协商初始的序号<br>RST：复位，TCP连接中数据传输发生异常需要重新发送<br>FIN ：通信结束后，当它的值为1时拆除连接</p><p><strong>TCP 三次握手建立连接</strong></p><p>第一次握手：建立连接时，客户端发送SYN包（syn=i）到服务器，并进入SYN_SEND状态，等待服务器确认。SYN表示同步序列编码（Synchronize Sequence Numbers）</p><p>第二次握手：服务器收到syn包，必须确认客户的SYN（ack=i+1），同时自己也发送一个SYN包（seq=j），即SYN+ACK包，此时服务器进入SYN_RECV状态</p><p>第三次握手：客户端收到服务器的SYN+ACK的包后，向服务器发送确认包ACK(j+1)，此包发送完毕，客户端与服务器进入ESTABLISHED状态，完成三次握手</p><p><img src="4.jpg" alt></p><p><strong>TCP 正常数据传输过程</strong></p><p>本图表示传输2个数据报的过程。主机A向B发送第一个 N 字节的数据包，SEQ为 i ，主机B收到后需要立即向主机A发送确认ACK包，ACK = i + N +1 ，这样主机A才可确认数据传输成功。第二个数据包传输时，SEQ数值 = R，主机B收到后立即回传ACK，此时ACK = R + N + 1，之后数据包传输的过程持续此流程，需要注意的是发送方只有收到目标方的确认包后才会清除缓冲区中的数据</p><p>ACK确认位 = SEQ数据编号 + 传递的字节数N + 1。第一个字节的SEQ编号由本地随机产生，SEQ+N的作用是为了让主机A确认发送给主机B的数据是否全部接收 / 是否出现丢失</p><p><img src="5.jpg" alt></p><p><strong>TCP 数据重传与快重传</strong></p><ul><li><strong>数据重传</strong>：主机A向主机B传送数据，但中间发生错误，主机B未能收到。经过一段时间后，主机A未收到主机B的ACK确认包，故主机A再次重传此数据包。主机A每次发送数据时都会启动一个定时器，规定时间没收到响应包则启动重传</li><li><strong>快重传</strong>：重传发生在超时之后，但当主机A收到3个以上重复的ACK，其实就说明有数据丢失，也需要重传，此时重传定时器还没有结束，所以叫快速重传</li></ul><p><img src="6.jpg" alt></p><p><strong>TCP 四次挥手结束连接</strong></p><p>第一次挥手：客户端发送一个FIN，用来关闭客户端到服务器的数据传送，客户端进入FIN_WAIT_1状态</p><p>第二次挥手：服务端收到FIN后，发送一个ACK给客户端，确认序号为收到序号+1（与SYN相同，一个FIN占用一个序号），服务端进入CLOSE_WAIT状态</p><p>第三次挥手：服务端发送一个FIN，用来关闭服务端到客户端的数据传送，服务端进入LAST_ACK状态</p><p>第四次挥手：客户端收到FIN后，客户端进入TIME_WAIT状态，接着发送一个ACK给服务端，确认序号为收到序号+1，服务端进入CLOSED状态，完成四次挥手</p><p><img src="7.jpg" alt></p><h1 id="IP-协议数据传输流程"><a href="#IP-协议数据传输流程" class="headerlink" title="IP 协议数据传输流程"></a>IP 协议数据传输流程</h1><p>网络协议（Internet Protocol,IP）通常被认为提供的是无连接和不可靠的，但实际上，在网络性能良好的情况下，IP传送的数据能够完好无损的到达目的地</p><p>无连接是指没有确定目标系统是否已做好接收数据的准备之前就发送数据。不可靠是指目的系统不对成功完成接收到的分组进行确认</p><p><img src="8.jpg" alt></p><p><strong>IP 发送数据</strong></p><p>发送数据时，源计算机上的IP协议需要确定目的地是否在同一网络，若目的地在同一网络，使用直达通信，若不在同一网络，则需要通过网关或路由器完成通信：</p><p>主机A组装目的IP地址为主机B的数据报，之后进行路由选择，再将次数据报发送至默认路由器（由APR地址解析确定路由器，得到下一默认路由器IP地址与MAC地址的映射关系，然后以该MAC地址为帧的目的地址形成一个帧，并将IP数据报封装在帧的数据区，最后由具体的物理网络（以太网）完成数据报的真正传输）</p><p><strong>IP 转发数据</strong></p><p>路由器接收到主机A的数据帧后，去掉帧头并对其进行处理，发现此数据报的目的地非本地，需要将其转发，由路由选择算法及本地路由表确定下一跳路由器地址，通过ARP地址解析确定下一跳路由的IP地址与MAC地址的映射关系后，将该MAC地址作为数据帧的目的地将数据报封装为数据帧，通过以太网完成数据转发。重复此步骤直到第N个路由器与目的地直连，通过ARP地址解析确定目的主机的IP地址与MAC地址的映射关系，利用该MAC地址作为帧的目的地址，将IP数据报封装成帧，并由以太网实现数据的真正传递</p><p><strong>IP 接收数据</strong></p><p>主机B接收到数据帧后，解封该帧并对其进行处理，确定本机即为目的地址后，将数据报中封装的数据交由上层协议进行处理，随即逐层处理并上交直到应用层，完成此次通信</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p><strong>TCP/IP 五大重要特性</strong></p><p><strong>逻辑编址</strong>：通过IP地址+主机ID，确保计算机可寻</p><p><strong>路由选择</strong>：通过网络路径选择协议，确保数据包到达目的地</p><p><strong>域名解析</strong>：将域名映射为IP地址，使用域名一是便于记忆，二是域名相对固定不变</p><p><strong>错误检测</strong>：确保分组交换的可靠性传递，确认数据正常接收</p><p><strong>流量控制</strong>：监测网络流量，防止网络拥塞出现</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;TCP-IP-协议族&quot;&gt;&lt;a href=&quot;#TCP-IP-协议族&quot; class=&quot;headerlink&quot; title=&quot;TCP/IP 协议族&quot;&gt;&lt;/a&gt;TCP/IP 协议族&lt;/h1&gt;&lt;p&gt;Internet 的核心协议就是 TCP/IP，广泛应用于局域网和广域网，目前已有20+年发展史，是现用国际通行标准。TCP/IP 是个协议族，包含有多种协议，网络模型及分层如图所示&lt;/p&gt;
    
    </summary>
    
      <category term="程序人生" scheme="http://hackycy.github.io/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/"/>
    
    
      <category term="TCP/IP" scheme="http://hackycy.github.io/tags/TCP-IP/"/>
    
  </entry>
  
  <entry>
    <title>软件工程之瀑布模型</title>
    <link href="http://hackycy.github.io/2019/10/03/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E4%B9%8B%E7%80%91%E5%B8%83%E6%A8%A1%E5%9E%8B/"/>
    <id>http://hackycy.github.io/2019/10/03/软件工程之瀑布模型/</id>
    <published>2019-10-03T02:44:40.000Z</published>
    <updated>2019-12-03T04:10:42.162Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>软件工程（software engineering）的本质：用工程化的方法去规范软件开发，让项目可以按时完成、成本可控、质量有保障。</p><p>而瀑布模型则算是现代工程软件的起源，软件工程的发展，很多都是构建于瀑布模型基础之上的。</p><a id="more"></a><h1 id="瀑布模型的诞生"><a href="#瀑布模型的诞生" class="headerlink" title="瀑布模型的诞生"></a>瀑布模型的诞生</h1><p>为了解决软件危机中的这些问题，在 1970 年，Winston Royce 博士借鉴了其他工程领域的思想，比如建筑工程，提出了瀑布开发模型，指出软件开发应有完整之周期，并将软件开发过程分成了若干阶段。像瀑布一样，从上往下，完成一个阶段继续下一个阶段。</p><p><img src="pubumoxing.jpeg" alt></p><p>瀑布模型把整个项目过程分成了六个主要阶段：</p><ul><li><p>一、问题的定义及规划</p><p>这个阶段是需求方和开发方共同确定软件开发目标，同时还要做可行性研究，以确定项目可行。这个阶段会产生需求文档和可行性研究报告。</p></li><li><p>二、需求分析</p><p>对需求方提出的所有需求，进行详细的分析。这个阶段需要和客户反复确认，以保证能充分理解客户需求。最终形成需求分析文档。</p></li><li><p>三、软件设计</p><p>根据需求分析的结果，对整个软件系统进行抽象和设计，如系统框架设计，数据库设计等等。最终行程架构设计文档。</p></li><li><p>四、程序编码</p><p>将架构设计和界面设计的结果转换成计算机能运行的程序代码。</p></li><li><p>五、软件测试</p><p>在编码完成后，对可运行的结果对照需求分析文档进行严密的测试。如果测试发现问题，需要进行修复。最终测试完成后，形成测试报告。</p></li><li><p>六、运行维护</p><p>在软件开发完成，正式运行上线后，需要继续维护，修复错误和增加功能，交付时要提供说明文档。</p></li></ul><blockquote><p>瀑布模型在提出后，因为其简单可行，切实有效，马上就在很多软件项目中应用起来，一直到 2000 年前后，都是最主流的软件开发模型，即使到现在，你也能在很多软件项目中看到它的影子。</p><p><strong>也是从那时开始，有了“软件生命周期”(Software Life Cycle,SLC) 的概念。</strong></p></blockquote><h1 id="瀑布模型进行开发项目"><a href="#瀑布模型进行开发项目" class="headerlink" title="瀑布模型进行开发项目"></a>瀑布模型进行开发项目</h1><p>虽然现在瀑布模型已经不是最主流的开发模式。</p><p><strong>但是不管什么软件项目，不管采用什么开发模式，有四种活动是必不可少的，那就是需求、设计、编码和测试。而这四项活动，都是起源自瀑布模型，也是瀑布模型中核心的部分。</strong></p><p>这里使用案例来直观理解一下用瀑布模型进行开发整个软件的过程。</p><p><strong>问题的定义及项目规划阶段</strong></p><p>公司老板打算做一个游戏领域的社交网站，问题很明确，就是一个社交网站，并且用户能按照游戏来交友。至于可行性分析，总多社交是已经很火的事情了，似乎是可行的。那么就立项了。</p><p>然后老板就问项目经理，这样的一个网站，大概需要多久做得出来？项目经理回答，如此复杂的网站大概需要半年出来一个版本，老板说半年太久了，给你三个月吧，最后讨价还价，决定四个月上线。</p><p>于是项目经理按照四个月开始了倒推项目计划：</p><blockquote><p>需求分析——2周</p><p>软件设计——4周</p><p>程序编码——6周</p><p>软件测试——4周</p></blockquote><p><strong>需求分析的阶段</strong></p><p>在项目立项后，产品经理首先和老板充分的沟通，了解老板的想法是什么，要做一个什么样的网站。在了解老板的想法后，产品经理对市场上同类的社交网站进行了调研，然后用原型工具设计了网站的原型。原型虽然很简陋，但是从原型可以看出来，项目要做成什么样子，便于确认需求。</p><p>原型拿给老板看后，老板再根据自己的想法提一些反馈，这样反复沟通确认，在原型设计确认清楚后，产品经理开始撰写产品设计文档，将原型设计落实到文档，将整个网站划分成不同的功能模块，例如用户注册、登录、添加好友等，确定每个功能模块需要哪些功能。</p><p>这个阶段产品经理是最忙的，那这时候其他人在干嘛呢？其他人都还挺轻松的，架构师研究网上流行的社交网站都采用什么架构，程序员、测试看看技术文档。</p><p>虽然最终确定了产品设计文档，但是因为中间反复确认的时间过长，原定 2 周能完成的需求分析，最后拖到了 3 周。项目经理一看，最终上线时间点没法延，那就只好压缩编码时间了，不行加加班！</p><p>项目计划变成了：</p><blockquote><p>需求分析——3周</p><p>软件设计——4周</p><p>程序编码——5周</p><p>软件测试——4周</p></blockquote><p><strong>软件设计</strong></p><p>产品经理的产品设计文档确定后，架构师开始做架构设计，UI 设计师开始设计 UI，测试经理开始针对产品设计文档写测试用例，产品经理还要进一步设计交互。</p><p>由于前期原型设计工作做的好，所以 UI 设计还是很顺利的，主风格定下来以后，各个界面就是细节的确认了。</p><p>因为产品设计文档写的详细，输入输出很清楚，测试用例也进展顺利。</p><p>至于架构设计这边，架构师很有经验，先把整体架构确定，写了个技术方案文档，和大家一起开会讨论，几次后确认了整体技术方案。按照功能模块一拆分，把其中一个功能模块做了一个样板，然后把各个子模块分给开发人员，大家一起协助做详细设计，然后再分别确认。</p><p>大家都如火如荼地忙起来了。如果一切顺利的话，软件设计 4 周应该能完成，可以进入编码阶段了。但是软件设计进行到第 3 周的时候，老板的想法发生了一些变化。</p><p>因为市场上已经有了游戏社交的网站，而且运营结果不算太好，而网页游戏正流行，如果我们的平台能接入网页游戏，这会是个不错的机会。</p><p>于是需求变更了，我们要能和其他网页游戏的用户系统对接，这个需求最开始是没有提出来，也没有考虑的。</p><p>项目经理考虑再三，决定还是接受这个需求变更，但是希望能多一些时间，老板没同意，认为时间点很重要，哪怕砍一点功能，牺牲一点质量也要如期上线。但就算这时候砍功能，设计工作还是少不了多少。</p><p>于是产品经理重新修改相应原型，再确认，再重新修改产品设计文档。变更完后，UI 设计的相关页面重新修改设计、测试人员修改测试用例，最苦的是架构师，当初没有考虑到要和其他用户系统对接，现在用户系统的设计都要重新考虑了。</p><p>于是为了赶进度，项目组开始加班，即使如此，软件设计阶段也推迟到了第 5 周才勉强完成。</p><p>项目计划又变了：</p><blockquote><p>需求分析——3周</p><p>软件设计——5周</p><p>程序编码——5周</p><p>软件测试——3周</p></blockquote><p><strong>程序编码</strong></p><p>于进入编码阶段了，为了保证进度，加班还在继续，哪怕前期做了大量的设计，真到编码的时候还是有好多没有考虑到的，同时各个模块之间还存在相互依赖，有时候虽然自己功能开发完成，还需要等待其他人的功能完成才能调试，所以 5 周时间很快就过去了，而程序还不能完整地跑起来。</p><p>其实中间还有个小插曲，老板觉得还要加上支付的功能，但是项目经理觉得这个阶段改需求已经不可能了，以辞职为威胁总算顶回去了，打算放在下个版本加上。</p><p>终于到第 6 周的时候，有了一个勉强可以测试的版本。</p><p>项目计划现在变成了：</p><blockquote><p>需求分析——3周</p><p>软件设计——5周</p><p>程序编码——6周</p><p>软件测试——2周</p></blockquote><p><strong>软件测试</strong></p><p>留给测试的时间只有两周了，但是前期实在 bug 太多，两周测试时间过去，软件质量还是很糟糕，完全无法正常使用，于是项目不得不延期，一直延期了 4 周后，才算具备上线条件。</p><p>所以最终的项目计划差不多是：</p><blockquote><p>需求分析——3周</p><p>软件设计——5周</p><p>程序编码——6周</p><p>软件测试——6周</p></blockquote><p>与原定计划延迟了4周。</p><p><strong>运行维护</strong></p><p>网站上线后，好在前期并没有多少用户，但是线上 Bug 还是不少，需要继续修复线上发现的 Bug。</p><h1 id="瀑布模型的优缺点"><a href="#瀑布模型的优缺点" class="headerlink" title="瀑布模型的优缺点"></a>瀑布模型的优缺点</h1><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ul><li>简单易行。</li><li>可以按照阶段检查，能及时发现问题。</li><li>前一个阶段完成后，就可以重点关注下一个阶段。</li><li>有很好的分工协作。</li><li>对质量有保障。</li></ul><h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><ul><li>难以响应需求的变更，当需求发生改变时，越到后期代价越大。</li><li>工作量分布不均衡。例如前期开发、测试人员无法参与，而后期开发、测试人员又特别忙碌。</li><li>前期进度受阻，会一直压缩后续阶段时间，导致延期或影响质量。</li><li>一直到最后阶段才能看到结果。</li></ul><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>瀑布模型的出现，也解决了软件项目开发中的几个重要问题。</p><ul><li><strong>让软件开发过程有序可控。</strong>瀑布模型的每个阶段都有明确的任务，每个阶段都有明确的交付产物，都有相应的里程碑。这些让整个过程更可控，而且能及早发现问题。</li><li><strong>让分工协作变成可能。</strong>瀑布模型的六个阶段，也让软件开发产生相应的基础分工：项目经理、产品经理、架构师、软件工程师、测试工程师、运维工程师。</li><li><strong>质量有保障。</strong>瀑布模型每个阶段都需要交付相应的文档，而文档的撰写和评审，可以帮助在动手之前把问题沟通清楚，想清楚。瀑布模型在编码结束后，会有严密的测试，只有测试验收通过后，才能上线发布。这些措施都让软件的质量更有保障。</li></ul><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>极客时间 ——《软件工程之美》</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;软件工程（software engineering）的本质：用工程化的方法去规范软件开发，让项目可以按时完成、成本可控、质量有保障。&lt;/p&gt;
&lt;p&gt;而瀑布模型则算是现代工程软件的起源，软件工程的发展，很多都是构建于瀑布模型基础之上的。&lt;/p&gt;
    
    </summary>
    
      <category term="架构之路" scheme="http://hackycy.github.io/categories/%E6%9E%B6%E6%9E%84%E4%B9%8B%E8%B7%AF/"/>
    
    
      <category term="软件工程" scheme="http://hackycy.github.io/tags/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>github和git基操</title>
    <link href="http://hackycy.github.io/2019/09/25/github%E5%92%8Cgit%E5%9F%BA%E6%93%8D/"/>
    <id>http://hackycy.github.io/2019/09/25/github和git基操/</id>
    <published>2019-09-25T02:50:31.000Z</published>
    <updated>2019-12-22T05:06:06.934Z</updated>
    
    <content type="html"><![CDATA[<p>一些Git 和 GitHub基操。</p><a id="more"></a><h1 id="Github"><a href="#Github" class="headerlink" title="Github"></a>Github</h1><h2 id="快捷键-t-和-w"><a href="#快捷键-t-和-w" class="headerlink" title="快捷键: t 和 w"></a>快捷键: t 和 w</h2><p>在你的源码浏览页面，按 <strong>t</strong> 可以快速进入模糊文件名搜索模式：</p><p><img src="1.png" alt></p><p>在你仓库主页，按 <strong>w</strong> 可以快速进行分支过滤：</p><p><img src="2.png" alt></p><p>在任意 GitHub 页面中，按 <strong>?</strong> 展示当前页面可用的快捷键：</p><p><img src="3.png" alt></p><h2 id="忽略空格-w-1"><a href="#忽略空格-w-1" class="headerlink" title="忽略空格: ?w=1"></a>忽略空格: ?w=1</h2><p>在任意的 diff URL 添加 <strong>?w=1</strong> 用来整理缩进:</p><p><img src="4.jpg" alt></p><h2 id="按范围过滤提交记录-master-time-master"><a href="#按范围过滤提交记录-master-time-master" class="headerlink" title="按范围过滤提交记录: master@{time}..master"></a>按范围过滤提交记录: master@{time}..master</h2><p>你可以创建一个对比页面通过使用 URL github.com/user/repo/compare/{range}。范围 (range) 可以是两个 SHA 例如 sha1…sha2 或者两个分支名称例如 master…my-branch。范围同时也非常智能的支持使用时间作为关注点。你可以通过 master@{1.day.ago}…master 过滤从昨天开始的提交。例如：链接，<a href="https://github.com/rails/rails/compare/master@{1.day.ago}…master" target="_blank" rel="noopener">https://github.com/rails/rails/compare/master@{1.day.ago}…master</a> 显示 Rails 项目中全部昨天开始的提交记录和变化：</p><p><img src="5.jpg" alt></p><p>##按作者过滤提交记录: ?author=github_handle</p><p>你可以通过在对比页面URL中增加 ?author=github_handle 来按作者过滤提交记录。例如：链接 <a href="https://github.com/dynjs/dynjs/commits/master?author=jingweno" target="_blank" rel="noopener">https://github.com/dynjs/dynjs/commits/master?author=jingweno</a> 显示 jingweno 对 <strong>Dynjs</strong> 的提交记录：</p><p><img src="6.jpg" alt></p><h2 id="diff-和-patch"><a href="#diff-和-patch" class="headerlink" title=".diff 和 .patch"></a>.diff 和 .patch</h2><p>在比较页面、合并请求页面或者评论页面的URL后增加 .diff 或者 .patch，可以得到 diff 或者 patch 的文本格式。例如：链接 <a href="https://github.com/rails/rails/compare/master@{1.day.ago}…master.patch" target="_blank" rel="noopener">https://github.com/rails/rails/compare/master@{1.day.ago}…master.patch</a> 显示Rails项目中全部昨天开始的提交记录和变化的文本格式：</p><p><img src="7.jpg" alt></p><h2 id="链接行"><a href="#链接行" class="headerlink" title="链接行"></a>链接行</h2><p>在文件展示页面，点击某行或者通过按 SHIFT 选择多行，URL 会有相应的改变。如果你要给你的队友分享一段代码是非常方便的：</p><p><img src="8.jpg" alt></p><h2 id="自动链接"><a href="#自动链接" class="headerlink" title="自动链接"></a>自动链接</h2><p>在合并请求、问题、或者任何评论中，sha和问题码(例如：#1)会被自动链接。并且，你也可以链接其它仓库的 sha 或者问题码，格式：<code>user/repo@sha1</code> 或者 <code>user/repo#1</code>。下面是一个评论中通过sha自动链接的例子：</p><p><img src="9.jpg" alt></p><h2 id="hub"><a href="#hub" class="headerlink" title="hub"></a>hub</h2><p>Hub 是 GitHub的命令行。它提供了Git和Github之间的集成。一个最有用的命令就是在命令行输入 hub pull-request 创建pull request。详见 <strong>readme.</strong>（<a href="https://github.com/defunkt/hub#commands）。" target="_blank" rel="noopener">https://github.com/defunkt/hub#commands）。</a></p><h1 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h1><h2 id="Git工作流程"><a href="#Git工作流程" class="headerlink" title="Git工作流程"></a>Git工作流程</h2><p><img src="Git工作流程.webp" alt></p><p>以上包括一些简单而常用的命令，但是先不关心这些，先来了解下面这4个专有名词。</p><ul><li>Workspace：工作区</li><li>Index / Stage：暂存区</li><li>Repository：仓库区（或本地仓库）</li><li>Remote：远程仓库</li></ul><p><strong>工作区</strong></p><p>程序员进行开发改动的地方，是你当前看到的，也是最新的。</p><p>平常我们开发就是拷贝远程仓库中的一个分支，基于该分支进行开发。在开发过程中就是对工作区的操作。</p><p><strong>暂存区</strong></p><p>.git目录下的index文件, 暂存区会记录<code>git add</code>添加文件的相关信息(文件名、大小、timestamp…)，不保存文件实体, 通过id指向每个文件实体。可以使用<code>git status</code>查看暂存区的状态。暂存区标记了你当前工作区中，哪些内容是被git管理的。</p><p>当你完成某个需求或功能后需要提交到远程仓库，那么第一步就是通过<code>git add</code>先提交到暂存区，被git管理。</p><p><strong>本地仓库</strong></p><p>保存了对象被提交 过的各个版本，比起工作区和暂存区的内容，它要更旧一些。</p><p><code>git commit</code>后同步index的目录树到本地仓库，方便从下一步通过<code>git push</code>同步本地仓库与远程仓库的同步。</p><p><strong>远程仓库</strong></p><p>远程仓库的内容可能被分布在多个地点的处于协作关系的本地仓库修改，因此它可能与本地仓库同步，也可能不同步，但是它的内容是最旧的。</p><h2 id="常用Git命令"><a href="#常用Git命令" class="headerlink" title="常用Git命令"></a>常用Git命令</h2><p><img src="gitcommandtable.jpeg" alt></p><h3 id="add"><a href="#add" class="headerlink" title="add"></a>add</h3><p>add相关命令很简单，主要实现将工作区修改的内容提交到暂存区，交由git管理。</p><table><thead><tr><th style="text-align:left"><strong>git add .</strong></th><th><strong>添加当前目录的所有文件到暂存区</strong></th></tr></thead><tbody><tr><td style="text-align:left"><strong>git add </strong></td><td><strong>添加指定目录到暂存区，包括子目录</strong></td></tr><tr><td style="text-align:left"><strong>git add </strong></td><td><strong>添加指定文件到暂存区</strong></td></tr></tbody></table><h3 id="commit"><a href="#commit" class="headerlink" title="commit"></a>commit</h3><p>commit相关命令也很简单，主要实现将暂存区的内容提交到本地仓库，并使得当前分支的HEAD向后移动一个提交点。</p><table><thead><tr><th><strong>git commit -m </strong></th><th><strong>提交暂存区到本地仓库,message代表说明信息</strong></th></tr></thead><tbody><tr><td><strong>git commit  -m </strong></td><td><strong>提交暂存区的指定文件到本地仓库</strong></td></tr><tr><td><strong>git commit –amend -m </strong></td><td><strong>使用一次新的commit，替代上一次提交</strong></td></tr></tbody></table><h3 id="branch"><a href="#branch" class="headerlink" title="branch"></a>branch</h3><p>涉及到协作，自然会涉及到分支，关于分支，大概有展示分支，切换分支，创建分支，删除分支这四种操作。</p><table><thead><tr><th><strong>git branch</strong></th><th><strong>列出所有本地分支</strong></th></tr></thead><tbody><tr><td><strong>git branch -r</strong></td><td><strong>列出所有远程分支</strong></td></tr><tr><td><strong>git branch -a</strong></td><td><strong>列出所有本地分支和远程分支</strong></td></tr><tr><td><strong>git branch </strong></td><td><strong>新建一个分支，但依然停留在当前分支</strong></td></tr><tr><td><strong>git checkout -b </strong></td><td><strong>新建一个分支，并切换到该分支</strong></td></tr><tr><td><strong>git branch –track </strong></td><td><strong>新建一个分支，与指定的远程分支建立追踪关系</strong></td></tr><tr><td><strong>git checkout </strong></td><td><strong>切换到指定分支，并更新工作区</strong></td></tr><tr><td><strong>git branch -d </strong></td><td><strong>删除分支</strong></td></tr><tr><td><strong>git push origin –delete </strong></td><td><strong>删除远程分支</strong></td></tr></tbody></table><h3 id="merge"><a href="#merge" class="headerlink" title="merge"></a>merge</h3><p>merge命令把不同的分支合并起来。如上图，在实际开放中，我们可能从master分支中切出一个分支，然后进行开发完成需求，中间经过R3,R4,R5的commit记录，最后开发完成需要合入master中，这便用到了merge。</p><table><thead><tr><th><strong>git fetch </strong></th><th><strong>merge之前先拉一下远程仓库最新代码</strong></th></tr></thead><tbody><tr><td><strong>git merge </strong></td><td><strong>合并指定分支到当前分支</strong></td></tr></tbody></table><p>一般在merge之后，会出现conflict，需要针对冲突情况，手动解除冲突。主要是因为两个用户修改了同一文件的同一块区域。如下图所示，需要手动解除。</p><p><img src="手动解除.webp" alt></p><h3 id="rebase"><a href="#rebase" class="headerlink" title="rebase"></a>rebase</h3><p>rebase又称为衍合，是合并的另外一种选择。</p><p>在开始阶段，我们处于new分支上，执行<code>git rebase dev</code>，那么new分支上新的commit都在master分支上重演一遍，最后checkout切换回到new分支。这一点与merge是一样的，合并前后所处的分支并没有改变。<code>git rebase dev</code>，通俗的解释就是new分支想站在dev的肩膀上继续下去。rebase也需要手动解决冲突。</p><blockquote><p>如果你想保留完整的历史记录，并且想要避免重写commit history的风险，你应该选择使用git merge</p></blockquote><h3 id="reset"><a href="#reset" class="headerlink" title="reset"></a>reset</h3><p>reset命令把当前分支指向另一个位置，并且相应的变动工作区和暂存区。</p><table><thead><tr><th><strong>git reset —soft </strong></th><th>只改变提交点，暂存区和工作目录的内容都不改变</th></tr></thead><tbody><tr><td><strong>git reset —mixed </strong></td><td><strong>改变提交点，同时改变暂存区的内容</strong></td></tr><tr><td><strong>git reset —hard </strong></td><td><strong>暂存区、工作区的内容都会被修改到与提交点完全一致的状态</strong></td></tr><tr><td><strong>git reset –hard HEAD</strong></td><td><strong>让工作区回到上次提交时的状态</strong></td></tr></tbody></table><h3 id="revert"><a href="#revert" class="headerlink" title="revert"></a>revert</h3><p>git revert用一个新提交来消除一个历史提交所做的任何修改。</p><p><strong>revert与reset的区别</strong></p><ul><li>git revert是用一次新的commit来回滚之前的commit，git reset是直接删除指定的commit。</li><li>在回滚这一操作上看，效果差不多。但是在日后继续merge以前的老版本时有区别。因为git revert是用一次逆向的commit“中和”之前的提交，因此日后合并老的branch时，导致这部分改变不会再次出现，减少冲突。但是git reset是之间把某些commit在某个branch上删除，因而和老的branch再次merge时，这些被回滚的commit应该还会被引入，产生很多冲突。关于这一点，不太理解的可以看这篇文章。</li><li>git reset 是把HEAD向后移动了一下，而git revert是HEAD继续前进，只是新的commit的内容和要revert的内容正好相反，能够抵消要被revert的内容。</li></ul><h3 id="push"><a href="#push" class="headerlink" title="push"></a>push</h3><p>上传本地仓库分支到远程仓库分支，实现同步。</p><table><thead><tr><th>git push <remote><branch></branch></remote></th><th>上传本地指定分支到远程仓库</th></tr></thead><tbody><tr><td><strong>git push  –force</strong></td><td><strong>强行推送当前分支到远程仓库，即使有冲突</strong></td></tr><tr><td><strong>git push  –all</strong></td><td><strong>推送所有分支到远程仓库</strong></td></tr></tbody></table><h3 id="其他命令"><a href="#其他命令" class="headerlink" title="其他命令"></a>其他命令</h3><table><thead><tr><th>git status</th><th>显示有变更的文件</th></tr></thead><tbody><tr><td><strong>git log</strong></td><td><strong>显示当前分支的版本历史</strong></td></tr><tr><td><strong>git diff</strong></td><td><strong>显示暂存区和工作区的差异</strong></td></tr><tr><td><strong>git diff HEAD</strong></td><td><strong>显示工作区与当前分支最新commit之间的差异</strong></td></tr><tr><td><strong>git cherry-pick </strong></td><td><strong>选择一个commit，合并进当前分支</strong></td></tr></tbody></table><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>Git 是一个设计良好的工具。Git操作常用的命令都在这里了。了解它可以直接让你更有效率并成为一个更有才华的程序员。GitHub，在另一个方面，在 Git 基础上提供便利的团队合作特性。有能力使用 GitHub 也会提高你日常效率。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一些Git 和 GitHub基操。&lt;/p&gt;
    
    </summary>
    
      <category term="程序人生" scheme="http://hackycy.github.io/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/"/>
    
    
      <category term="Git" scheme="http://hackycy.github.io/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>IOS之安装服务器上的IPA包</title>
    <link href="http://hackycy.github.io/2019/09/11/IOS%E4%B9%8B%E5%AE%89%E8%A3%85%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8A%E7%9A%84IPA%E5%8C%85/"/>
    <id>http://hackycy.github.io/2019/09/11/IOS之安装服务器上的IPA包/</id>
    <published>2019-09-11T04:20:59.000Z</published>
    <updated>2019-09-11T09:56:23.842Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>如果想要将导出的ad-hoc包或者企业级别开发者账号才能够打包的in-house的ipa包通过自己服务器上下载安装的话，还需要一些简单的配置。</p><a id="more"></a><h1 id="部署准备"><a href="#部署准备" class="headerlink" title="部署准备"></a>部署准备</h1><p>准备文件：一个plist文件，ipa安装包，网页下载页面（可不需要），<code>57*57</code>像素icon与<code>512*512</code>像素icon。</p><p>这里利用github来进行测试打包发布应用。github仓库测试完就会删除，需要自行进行准备。</p><p>由于本人没有企业级别的开发者账号，只能通过打包ad-hoc包来进行测试。ad-hoc包如果profile签名文件中没有安装在已有的测试设备上是无法安装使用的。而企业级别的in-house包只需要信任即可。</p><blockquote><p>plist文件在IOS7之后仅支持部署在https。</p></blockquote><h2 id="plist文件"><a href="#plist文件" class="headerlink" title="plist文件"></a>plist文件</h2><p>一个plist模版：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd"&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">plist</span> <span class="attr">version</span>=<span class="string">"1.0"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dict</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">key</span>&gt;</span>items<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">array</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dict</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">key</span>&gt;</span>assets<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">array</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dict</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">key</span>&gt;</span>kind<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">string</span>&gt;</span>software-package<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">key</span>&gt;</span>url<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">string</span>&gt;</span>ipa安装包路径<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dict</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dict</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">key</span>&gt;</span>kind<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">string</span>&gt;</span>display-image<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">key</span>&gt;</span>url<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">string</span>&gt;</span>57*57像素icon路径<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dict</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dict</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">key</span>&gt;</span>kind<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">string</span>&gt;</span>full-size-image<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">key</span>&gt;</span>url<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">string</span>&gt;</span>512*512像素icon路径<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dict</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">array</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">key</span>&gt;</span>metadata<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dict</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">key</span>&gt;</span>bundle-identifier<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">string</span>&gt;</span>cn.sweetlover.jytools<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">key</span>&gt;</span>bundle-version<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">string</span>&gt;</span>1.2<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">key</span>&gt;</span>kind<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">string</span>&gt;</span>software<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">key</span>&gt;</span>title<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">string</span>&gt;</span>jytools<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dict</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dict</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">array</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dict</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plist</span>&gt;</span></span><br></pre></td></tr></table></figure><p>或者在打包的时候一并使用xcode生成</p><p><img src="plist.png" alt></p><p>next后，填写完即可。</p><p><img src="plist2.png" alt></p><p>导出后会看到一个manifest.plist文件就是所需要用到的文件。</p><blockquote><p>在生成的时候可以随便填写一些https的域名即可，但是真正发布时候还是需要修改好配置。</p></blockquote><h1 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h1><p><strong>可以先上传ipa包和icon文件上传到github，获取到下载路径之后填写到plist文件当中，然后再将plist文件上传到github。</strong></p><p>Demo完整plist文件配置</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd"&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">plist</span> <span class="attr">version</span>=<span class="string">"1.0"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dict</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">key</span>&gt;</span>items<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">array</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dict</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">key</span>&gt;</span>assets<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">array</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dict</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">key</span>&gt;</span>kind<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">string</span>&gt;</span>software-package<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">key</span>&gt;</span>url<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">string</span>&gt;</span>https://github.com/hackycy/mitaoquan/raw/master/jytools.ipa<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dict</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dict</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">key</span>&gt;</span>kind<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">string</span>&gt;</span>display-image<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">key</span>&gt;</span>url<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">string</span>&gt;</span>https://github.com/hackycy/mitaoquan/raw/master/icon-57.png<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dict</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dict</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">key</span>&gt;</span>kind<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">string</span>&gt;</span>full-size-image<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">key</span>&gt;</span>url<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">string</span>&gt;</span>https://github.com/hackycy/mitaoquan/raw/master/icon-512.png<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dict</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">array</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">key</span>&gt;</span>metadata<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dict</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">key</span>&gt;</span>bundle-identifier<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">string</span>&gt;</span>net.cn.sweetlover.mitaoquan<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">key</span>&gt;</span>bundle-version<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">string</span>&gt;</span>1.5<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">key</span>&gt;</span>kind<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">string</span>&gt;</span>software<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">key</span>&gt;</span>title<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">string</span>&gt;</span>mitao<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dict</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dict</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">array</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dict</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plist</span>&gt;</span></span><br></pre></td></tr></table></figure><p>github目录：</p><p><img src="public.png" alt></p><p>获取plist文件的路径，通过</p><p><img src="public2.png" alt></p><p>案例中获取的plist文件路径为<code>https://raw.githubusercontent.com/hackycy/mitaoquan/master/manifest.plist</code></p><p>最后通过<code>itms-services://?action=download-manifest&amp;url=</code>后面拼接上plist的url即可。</p><p><strong>demo中为<code>itms-services://?action=download-manifest&amp;url=https://raw.githubusercontent.com/hackycy/mitaoquan/master/manifest.plist</code></strong></p><blockquote><p>前端可以直接通过location.href或者a标签等跳转该链接即可安装。本地测试可以直接用safari打开上面的地址即可安装</p></blockquote><p>这里直接本地测试，复制该链接到safari直接打开安装。</p><p><img src="public3.png" alt></p><p><img src="public4.png" alt></p><h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><p>通过<code>itms-services</code>协议，在safari浏览器可以直接在ios设备上安装应用程序。<code>itms-services</code>协议需要一个plist配置文件。<code>itms-services://?action=download-manifest&amp;url=</code>是固定不变的，url根据环境变化。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;如果想要将导出的ad-hoc包或者企业级别开发者账号才能够打包的in-house的ipa包通过自己服务器上下载安装的话，还需要一些简单的配置。&lt;/p&gt;
    
    </summary>
    
      <category term="Ios" scheme="http://hackycy.github.io/categories/Ios/"/>
    
    
      <category term="Ios" scheme="http://hackycy.github.io/tags/Ios/"/>
    
  </entry>
  
  <entry>
    <title>IOS之App Store完整上架流程</title>
    <link href="http://hackycy.github.io/2019/08/20/IOS%E4%B9%8BApp-Store%E5%AE%8C%E6%95%B4%E4%B8%8A%E6%9E%B6%E6%B5%81%E7%A8%8B/"/>
    <id>http://hackycy.github.io/2019/08/20/IOS之App-Store完整上架流程/</id>
    <published>2019-08-20T08:59:20.000Z</published>
    <updated>2019-08-21T07:54:55.657Z</updated>
    
    <content type="html"><![CDATA[<p>最近在处理App Store上架的问题，和Android的打包流程比起来的确比较棘手些，因为涉及到很多的一些概念，现在也完整的梳理并记录一下。</p><a id="more"></a><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>发布上架都需要一个苹果开发者账号，免费的账号是有诸多限制的。</p><p><strong>苹果开发者帐号体系</strong></p><p><strong>Apple Developer：</strong>直接在<a href="https://link.juejin.im/?target=https%3A%2F%2Fdeveloper.apple.com%2F" target="_blank" rel="noopener">Apple Developer</a>登录，同意Apple Developer协议后的账号，免费，只可以使用Xcode进行真机调试，Xcode 7之后苹果推出的功能</p><p><strong>Apple Developer Program：</strong>分个人和组织类型，费用都是每年 99 美元，可以使用Xcode进行真机调试，打包Ad-Hoc测试，在App Store发布App</p><p><strong>Apple Developer Enterprise Program：</strong>企业账号，费用是每年 299 美元，可以使用Xcode进行真机调试，打包Ad-Hoc测试，打包In-House App，但不能在App Store发布App</p><p>不同安装方式对应的证书类型</p><ul><li>非App Store<ul><li>Development（真机调试）：iOS App Development</li><li>Ad Hoc：iOS Distribution (App Store and Ad Hoc)</li><li>Enterprise：iOS Distribution (In-House and Ad Hoc)</li></ul></li><li>App Store：iOS Distribution (App Store and Ad Hoc)</li></ul><p>在iOS的项目中，只要不是运行在模拟器上，都会涉及到开发者帐号、证书、<code>Provisioning Profile</code>这些概念。</p><p><strong>免费账号的限制：</strong></p><ul><li>创建的<code>Provisioning Profile</code>有效期只有7天</li><li>在7天内最多注册10个Bundle Id</li><li>只能同时注册3台iOS设备</li><li>在同一台iOS设备上，只能同时安装3个使用免费账号签名的App。当该设备上已经存在3个App，则无法安装任何免费账号签名的任何App，就算是那3个App其中一个也不行，只能先把其中一个删除</li></ul><blockquote><p>以下介绍是以我的Apple Developer Program个人账号来进行演示</p></blockquote><h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><p>证书、加密等原理这里不作介绍，主要讲解一些IOS所必要的概念。</p><h2 id="certSigningRequest"><a href="#certSigningRequest" class="headerlink" title=".certSigningRequest"></a>.certSigningRequest</h2><p>在<code>Mac</code>中的<code>钥匙串访问</code>里的 <code>证书助理 -&gt; 从证书颁发机构请求证书</code>：</p><p><img src="certSigningRequest.png" alt></p><p>最后会创建出一个<code>.certSigningRequest</code>文件，其实这个过程就是创建了一对公私钥</p><p><img src="certSigningRequest2.png" alt></p><ul><li>其中<code>.certSigningRequest</code>文件保存着<ul><li>申请者信息申请者的公钥</li><li>摘要算法</li><li>公钥加密算法</li></ul></li><li>私钥保存在 <code>keychain</code>中</li></ul><h2 id="AppleWWDRCA证书"><a href="#AppleWWDRCA证书" class="headerlink" title="AppleWWDRCA证书"></a>AppleWWDRCA证书</h2><p><code>iOS</code>以及 <code>mac OS</code>（在安装 Xcode 时）将自动安装 <code>AppleWWDRCA.cer</code>这个中间证书（Intermediate Certificates），它实际上就是 iOS（开发）证书的证书，即根证书（Apple Root Certificate）。</p><h2 id="iOS-App-Development证书"><a href="#iOS-App-Development证书" class="headerlink" title="iOS App Development证书"></a>iOS App Development证书</h2><p>iOS的开发证书，在开发阶段进行真机测试时需要用到的证书。可以在苹果开发网站上手动创建，需要上传<code>.certSigningRequest</code>文件；或者使用Xcode自动创建。</p><h2 id="iOS-Distribution证书"><a href="#iOS-Distribution证书" class="headerlink" title="iOS Distribution证书"></a>iOS Distribution证书</h2><p>iOS的发布证书，可以用于进行 <code>Ad Hoc</code> 测试、打包上传到 <code>App Store</code> 或者打包成 <code>Enterprisee（In-House）</code> 类型供企业内部使用。可以在苹果开发网站上手动创建，需要上传<code>.certSigningRequest</code>文件；或者使用Xcode自动创建。</p><h2 id="p12"><a href="#p12" class="headerlink" title=".p12"></a>.p12</h2><p>在<code>Mac</code>的<code>钥匙串访问</code>里选择一张证书，右击该证书，选择<code>导出&quot;xxxxx&quot;</code>，然后设置密码，可以导出该证书对应的<code>.p12</code>文件。<code>.p12</code>文件包含个人信息、公钥和私钥，也就是<code>证书 + 私钥</code>。iOS类型的每种证书同时存在数量有限制，而证书是依靠<code>mac OS</code>上的<code>.certSigningRequest</code>文件创建的，所以正常情况下，每种类型的证书只能在有限的Mac电脑上使用，如果需要在更多不同的Mac电脑上进行App开发、测试、签名，可以导出对应<code>.p12</code>文件代替证书来使用。</p><p><img src="p12.png" alt></p><h2 id="Provisioning-Profile"><a href="#Provisioning-Profile" class="headerlink" title="Provisioning Profile"></a>Provisioning Profile</h2><p><code>Provisioning Profile</code>的文件格式为<code>.mobileprovision</code>，里面包含着</p><ul><li>可以使用的证书</li><li>App ID，由 TeamID 和 BundleID 组合而成，类似于 <code>A1B2C3D4.com.domain.appName</code>形式</li><li>可安装该App的设备列表的UDID</li><li>Entitlements，授权文件，列出了App可以进行哪些行为</li><li>以上信息的签名</li></ul><p>在苹果开发网站上手动创建，或者使用Xcode自动创建。</p><h2 id="ipa"><a href="#ipa" class="headerlink" title=".ipa"></a>.ipa</h2><p><code>.ipa</code>文件是iOS上的App安装文件，其实它只是一个压缩包，等同于<code>.zip</code>格式，用<code>mac OS</code>自带的<code>归档实用工具</code>可以直接对它解压，可以看到里面的内容</p><p><img src="ipa.png" alt></p><h2 id="app"><a href="#app" class="headerlink" title=".app"></a>.app</h2><p>右击<code>.app</code>文件，选择<code>显示包内容</code>，可以看到里面的内容</p><p><img src="app.png" alt></p><p><code>.app</code>文件主要包含三部分：</p><ul><li><code>Mach-O</code>格式的二进制可执行文件，这个是一个App最重要的文件，我们编写的<code>Objective-C</code>、<code>Swift</code>代码都被编译在里面</li><li>资源文件，包括：<code>.bundle</code>文件，<code>.framework</code>文件，<code>.dylib</code>文件，<code>.nib</code>文件，图片文件，音视频文件，字体文件等所有项目用到的文件</li><li><code>CodeResources</code>，签名信息</li><li><code>embedded.mobileprovision</code>文件，或者<code>entitlements</code>文件<ul><li>对于没有上传App Store的<code>.app</code>文件，里面会包含<code>embedded.mobileprovision</code>文件，没有<code>entitlements</code>文件</li><li>App Store下载的<code>.app</code>文件，里面会包含<code>.entitlements</code>文件，没有<code>embedded.mobileprovision</code>文件</li></ul></li></ul><h1 id="Automatic-signing"><a href="#Automatic-signing" class="headerlink" title="Automatic signing"></a>Automatic signing</h1><p>在Xcode 7之前，只有加入到Apple Developer Program（即付费）才能进行真机调试，Xcode 7之后苹果推出了<code>Automatic signing</code>功能，只要在Xcode上登陆Apple ID，就会自动管理证书和Provisioning Profile，同时没有加入Apple Developer Program的账号也能进行真机调试。</p><p><img src="automanagesigning.png" alt></p><p>勾选Xcode中的<code>AutoMatically manager signing</code>，选择对应的<code>Team</code>后，无论是加入Apple Developer Program的账号（即付费账号）还是Apple Developer的账号（即免费账号）：</p><ul><li>如果Xcode没有帮该账号自动生成过<code>iOS App Development</code>类型的证书， 无论在苹果后台是否已经存在其他<code>iOS App Development</code>类型的证书，都会生成一张新的<code>iOS App Development</code>类型证书，证书名称的格式是：开发者账号名称(当前Mac电脑名称)， 如：Brian Hui (Daniels的MacBook Pro)，同时会保存在当前Mac电脑的<code>keychain</code>中</li><li>免费账号无法进入苹果的管理证书后台，但可以猜测出在苹果后台也会存在该证书</li><li>如果Xcode没有帮该App的Bundle ID自动生成过对应的<code>Provisioning Profile</code>，就会使用上面那张证书生成一个<code>Provisioning Profile</code>，保存在<code>~/Library/MobileDevice/Provisioning Profiles</code>，但在苹果后台则不会存在这个<code>Provisioning Profile</code></li><li>如果在<code>钥匙串访问</code>中删除了那张证书，Xcode会提示你的账号有<code>iOS App Development</code>类型的证书，但这台电脑没有安装，需要先把那张证书<code>Revoke</code>，<code>Revoke</code>后会再次重复前面的步骤，生成新的证书和<code>Provisioning Profile</code></li><li>如果在<code>~/Library/MobileDevice/Provisioning Profiles</code>里面，删除了该<code>Provisioning Profile</code>文件，Xcode会马上重新生成<code>Provisioning Profile</code></li></ul><p>在使用Xcode的<code>Automatic signing</code>功能的前提下，进行<code>Archive</code>，然后<code>Distribute App</code>的时候，选择非<code>Development</code>的选项，再选择AutoMatically manager signing</p><ul><li>如果本地存在<code>iOS Distribution</code>类型的证书，则会直接进行重签名</li><li>如果没有存在<code>iOS Distribution</code>类型的证书，而苹果的后台有，则会告诉你，该账号存在<code>iOS Distribution</code>类型的证书，但这台电脑没有安装，请联系创建人拿到备份（.p12文件）进行安装，当你安装了该证书（或者.p12文件），则会直接进行重签名</li><li>如果没有存在<code>iOS Distribution</code>类型的证书，而苹果的后台也没有，则Xcode会询问你是否需要生成<code>iOS Distribution</code>类型的证书，如果选择需要，则会自动生成<code>iOS Distribution</code>类型的证书，并且建议你保存在本地，证书名称的格式是：Team Name， 如：Hutchison Telephone (Macau) Company Limited，同时使用这张证书生成一个<code>Provisioning Profile</code>，保存在<code>~/Library/MobileDevice/Provisioning Profiles</code>，但在苹果后台则不会存在这个`Provisioning Profile。</li></ul><h2 id="Xcode对Provisioning-Profile的验证"><a href="#Xcode对Provisioning-Profile的验证" class="headerlink" title="Xcode对Provisioning Profile的验证"></a>Xcode对Provisioning Profile的验证</h2><p>Xcode怎么把App和证书、<code>Provisioning Profile</code>绑定在一起呢？什么时候需要一张新的证书，什么时候需要一个新的<code>Provisioning Profile</code>？</p><p>Bundle ID是App的唯一标识，App和证书、<code>Provisioning Profile</code>绑定在一起，其实就是Bundle ID和证书、<code>Provisioning Profile</code>绑定在一起，两种情况：</p><h3 id="Automatic-signing-1"><a href="#Automatic-signing-1" class="headerlink" title="Automatic signing"></a>Automatic signing</h3><p>Bundle ID与开发者账号绑定。使用<code>Automatic signing</code>时，选择开发者账号（Team）后，Xcode会根据开发者账号去本地检索是否存在该账号对应的<code>Provisioning Profile</code>，再验证是否存在与该Bundle ID匹配的<code>Provisioning Profile</code>，再根据<code>Provisioning Profile</code>去本地检索是否存在对应的证书，都验证通过，则会设置成功。如果不存在<code>Provisioning Profile</code>，则会判断该Bundle ID是否已经被其他账号注册，如果已经被其他账号注册，则整个流程失败，需要选择对应的账号。如果该Bundle ID没有被其他账号注册或者账号已经对应上，则按照文章前面所说的步骤，最后生成<code>Provisioning Profile</code>。</p><h3 id="没有使用Automatic-signing"><a href="#没有使用Automatic-signing" class="headerlink" title="没有使用Automatic signing"></a>没有使用Automatic signing</h3><p>需要手动选择<code>Provisioning Profile</code>，当选择了其中一个<code>Provisioning Profile</code>时，则会分别验证Bundle ID是否对应、<code>Provisioning Profile</code>是否过期、是否存在对应的证书、App的权限是否对应、证书的类型和<code>Code Signing Identity</code>设置是否对应，如果都通过验证，则会设置成功。</p><h1 id="App-Store上架打包流程"><a href="#App-Store上架打包流程" class="headerlink" title="App Store上架打包流程"></a>App Store上架打包流程</h1><p>xcode构建好一个bundle id为<code>cn.sweetlover.uploadstore</code>的项目，假设已为一个正常的项目APP。</p><blockquote><p>空demo的APP是无法构建成功的。</p></blockquote><p>准备好一个开发者账号，并登陆<a href="https://developer.apple.com/" target="_blank" rel="noopener">苹果开发者官网</a>，选择<code>Certificates, IDs &amp; Profiles</code>：</p><p><img src="appstore2.png" alt></p><h2 id="创建APP-ID"><a href="#创建APP-ID" class="headerlink" title="创建APP ID"></a>创建APP ID</h2><p>选择<code>Identifiers</code>，创建一个APP ID：</p><p><img src="appstore5.png" alt></p><p>这里创建一个BundleID为<code>cn.sweetlover.uploadstore</code>，BundleID格式这里不细讲了。</p><p><img src="appstore3.png" alt></p><p>下面的选择是想要让你APP所接入的能力，例如常用的推送功能</p><p><img src="appstore4.png" alt></p><p>选择继续，并注册后，会看到<code>Identifiers</code>会出现你刚刚创建的APP ID：</p><p><img src="appstore6.png" alt></p><h2 id="注册测试设备"><a href="#注册测试设备" class="headerlink" title="注册测试设备"></a>注册测试设备</h2><p>选择<code>Devices</code>，添加</p><p><img src="appstore7.png" alt></p><p>填写设备名称和UDID即可，UDID可以使用ITunes查看。</p><p><img src="appstore8.png" alt></p><h2 id="创建CSR"><a href="#创建CSR" class="headerlink" title="创建CSR"></a>创建CSR</h2><p>打开<code>Mac</code>-&gt;<code>钥匙串访问</code>-&gt;<code>证书助理</code>-&gt;<code>从证书颁发机构请求证书..</code>，填写，并选择存储到磁盘</p><p><img src="appstore10.png" alt></p><p><img src="appstore11.png" alt></p><h2 id="创建证书"><a href="#创建证书" class="headerlink" title="创建证书"></a>创建证书</h2><p>选择<code>Certificates</code>，添加</p><h3 id="创建开发证书"><a href="#创建开发证书" class="headerlink" title="创建开发证书"></a>创建开发证书</h3><p>选择<code>IOS App Development</code>，并继续</p><p><img src="appstore9.png" alt></p><p>上传CSR文件，即选择我们刚刚创建好的CSR文件。并继续</p><p><img src="appstore12.png" alt></p><p>创建好后，选择下载证书，双击安装：</p><p><img src="appstore13.png" alt></p><p>打开钥匙串访问即可看到我们刚刚安装好的证书</p><p><img src="appstore14.png" alt></p><p>发布证书就创建完毕了。</p><h3 id="创建发布证书"><a href="#创建发布证书" class="headerlink" title="创建发布证书"></a>创建发布证书</h3><p>重复上述创建开发证书的步骤，只不过选项发生变化：</p><p><img src="appstore15.png" alt></p><p>最后下载安装，看到钥匙串访问出现证书即可</p><p><img src="appstore16.png" alt></p><h2 id="创建Profiles"><a href="#创建Profiles" class="headerlink" title="创建Profiles"></a>创建Profiles</h2><p>选择<code>Profiles</code></p><h3 id="创建开发Provisioning-Profile"><a href="#创建开发Provisioning-Profile" class="headerlink" title="创建开发Provisioning Profile"></a>创建开发Provisioning Profile</h3><p>选择<code>IOS App Development</code>，并继续</p><p><img src="appstore17.png" alt></p><p>选择好我们之前创建的APP ID，如<code>cn.sweetlover.uploadstore</code>，并继续</p><p><img src="appstore18.png" alt></p><p>选择开发证书，并继续</p><p><img src="appstore19.png" alt></p><p>选择测试设备，并继续</p><p><img src="appstore20.png" alt></p><p>填写Provisioning Profile Name，并选择生成</p><p><img src="appstore21.png" alt></p><p>下载并双击安装：</p><p><img src="appstore22.png" alt></p><p><img src="appstore24.png" alt></p><p>xcode签名方式选择手动以便查看：</p><p><img src="appstore23.png" alt></p><h3 id="创建发布Provisioning-Profile"><a href="#创建发布Provisioning-Profile" class="headerlink" title="创建发布Provisioning Profile"></a>创建发布Provisioning Profile</h3><p>重复上述创建开发证书的步骤，只不过选项发生变化：</p><p><img src="appstore25.png" alt></p><p>xcode：</p><p><img src="appstore26.png" alt></p><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><p>如果不安装证书，选择profile，xcode会报错缺少证书文件：</p><p><img src="appstore27.png" alt></p><h2 id="App-Store-Connect发布"><a href="#App-Store-Connect发布" class="headerlink" title="App Store Connect发布"></a>App Store Connect发布</h2><h3 id="APP创建"><a href="#APP创建" class="headerlink" title="APP创建"></a>APP创建</h3><p>点击<code>Account</code>登陆后点击<code>App Store Connect</code>，选择<code>我的App</code></p><p><img src="appstore1.png" alt></p><p>新建APP，填写好资料，并创建，创建后进入APP，编辑APP应用信息和定价情况</p><p><img src="appstore28.png" alt></p><p><img src="appstore30.png" alt></p><h3 id="版本提交"><a href="#版本提交" class="headerlink" title="版本提交"></a>版本提交</h3><p>首次提交会出现以下界面，填写好里面所需要的资料，里面都可按照提示进行编写。</p><p><img src="appstore32.png" alt></p><p>如果已经发布了，需要继续发版本，则点击</p><p><img src="appstore33.png" alt></p><p>由于首次提交还未上架过，所以按钮是置灰的状态，无法点击。</p><h2 id="Xcode-Archive构建版本"><a href="#Xcode-Archive构建版本" class="headerlink" title="Xcode Archive构建版本"></a>Xcode Archive构建版本</h2><p>进入<code>Xcode</code>选择<code>Product</code>-&gt;<code>Archive</code>，注意不要选中到模拟器，要选中<code>Generic IOS Device</code>。因为上架的包不是针对某种设备来进行Archive的。</p><p><img src="appstore34.png" alt></p><p>出现以下界面，选择Distrubite App，如果Archive过多次版本也会出现以往的版本。</p><p><img src="appstore35.png" alt></p><p>选择IOS App Store</p><p><img src="appstore36.png" alt></p><p>这里直接选择上传，也可以选择导出成IPA，使用Application Loader进行发布。</p><p><img src="appstore37.png" alt></p><p>next~</p><p><img src="appstore38.png" alt></p><p>选择好发布的证书和profile文件</p><p><img src="appstore39.png" alt></p><p>选择上传即可。</p><p><img src="appstore40.png" alt></p><p>经过一段漫长的时间等待后，回到App Store Connect的页面中，可能需要一段时间等到，建置版本后出现按钮即可选择构建好的版本。</p><p><img src="appstore41.png" alt></p><p>填写好所需要的资料就可以提交审核了。</p><h1 id="关于Application-Loader"><a href="#关于Application-Loader" class="headerlink" title="关于Application Loader"></a>关于Application Loader</h1><p>打开<code>Xcode</code> -&gt; <code>Open Developer Tool</code> -&gt; <code>Application Loader</code>，登陆你的APP ID。</p><p><img src="applicationloader.png" alt></p><p>密码登陆非APPLE ID的密码，需要登录appleid.apple.com上，输入AppleID密码后会产生一个密码，去<code>Application Loader</code>中输入产生的密码即可。</p><p><img src="applicationloader2.png" alt></p><h1 id="关于TestFlight"><a href="#关于TestFlight" class="headerlink" title="关于TestFlight"></a>关于TestFlight</h1><p>等上传构建版本处理完成后，一般会显示缺少出口合规证明。点击黄色提示那，在弹出的页面选择否，点击开始内部测试。</p><p><img src="testflight.png" alt></p><p>选择App Store connect用户选项，点击测试员旁边+号，选择测试的苹果账号！</p><p><img src="testflight2.png" alt></p><p>然后手机端下载TestFlight后，兑换邀请码即可。</p><h1 id="App审核指南"><a href="#App审核指南" class="headerlink" title="App审核指南"></a>App审核指南</h1><p>App Store Review Guidelines：<a href="https://developer.apple.com/app-store/review/guidelines/" target="_blank" rel="noopener">https://developer.apple.com/app-store/review/guidelines/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近在处理App Store上架的问题，和Android的打包流程比起来的确比较棘手些，因为涉及到很多的一些概念，现在也完整的梳理并记录一下。&lt;/p&gt;
    
    </summary>
    
      <category term="Ios" scheme="http://hackycy.github.io/categories/Ios/"/>
    
    
      <category term="Ios" scheme="http://hackycy.github.io/tags/Ios/"/>
    
  </entry>
  
</feed>
