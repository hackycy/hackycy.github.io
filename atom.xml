<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>思忆技术</title>
  
  <subtitle>思忆，分享技术</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://hackycy.github.io/"/>
  <updated>2021-05-03T11:11:23.416Z</updated>
  <id>http://hackycy.github.io/</id>
  
  <author>
    <name>hackycy</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Git项目换行符LF与CRLF导致ESLint报错解决方法</title>
    <link href="http://hackycy.github.io/2021/03/19/Git%E9%A1%B9%E7%9B%AE%E6%8D%A2%E8%A1%8C%E7%AC%A6LF%E4%B8%8ECRLF%E5%AF%BC%E8%87%B4ESLint%E6%8A%A5%E9%94%99%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/"/>
    <id>http://hackycy.github.io/2021/03/19/Git项目换行符LF与CRLF导致ESLint报错解决方法/</id>
    <published>2021-03-19T10:13:13.000Z</published>
    <updated>2021-05-03T11:11:23.416Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="产生该问题的原因"><a href="#产生该问题的原因" class="headerlink" title="产生该问题的原因"></a>产生该问题的原因</h1><p>产生该问题的原因是由于Windows平台和linux平台的默认换行符是不一样的,linux使用的是<code>0x0A(LF)</code>而Windows使用的是<code>0x0D0A(CRLF)</code>,这就导致了当Windows下的代码放到linux下运行时,虽然代码没有错,但是linux下的git检测到项目的换行符为CRLF时会自动换成LF。</p><a id="more"></a><h1 id="该问题的症状"><a href="#该问题的症状" class="headerlink" title="该问题的症状"></a>该问题的症状</h1><p>出现这个问题的症状表现为git会提示项目的每一个文件的所有位置都发生了修改,但是查看diff的时候发现其实哪都没修改,这是因为换行符被换了但是我们是看不出来的。</p><h1 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h1><p>由于代码多是运行在linux,所以现在主流的换行符标准就是LF,所以我们的项目一开始就应该有将换行符设置为LF的意识.</p><p>项目一开始创建,还没有加入git仓库的时候就应该将换行符设置为LF,vscode等工具都提供了这个简单的功能,</p><p><img src="1.png" alt></p><p>如果项目已经加入了git仓库,那就让git帮我们解决问题,git有一个<code>autocrlf</code>配置,可以在我们提交时自动转换换行符,它有3个选项:</p><ul><li><strong>true:</strong> 提交时转换为 LF，检出时转换为 CRLF</li><li><strong>false:</strong> 提交检出均不转换</li><li><strong>input:</strong> 提交时转换为LF，检出时不转换</li></ul><p>另一个设置项<code>safecrlf</code>用于检查文件是否包含着混合换行符,也有3个选项:</p><ul><li><strong>true:</strong> 拒绝提交包含混合换行符的文件</li><li><strong>false:</strong> 允许提交包含混合换行符的文件</li><li><strong>warn:</strong> 提交包含混合换行符的文件时给出警告</li></ul><p>所以,如果我们要将已经加入git的大量CRLF结尾文件批量转换成LF结尾的文件,可以这样设置:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git config --global core.autocrlf input</span><br><span class="line">$ git config --global core.safecrlf warn</span><br></pre></td></tr></table></figure><p>这样设置之后,先将项目提交一次,这样所有的文件就都会被改成LF结尾.</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://jiayaoo3o.github.io/2019/06/26/git项目换行符LF与CRLF导致的大量更改解决办法" target="_blank" rel="noopener">link</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;产生该问题的原因&quot;&gt;&lt;a href=&quot;#产生该问题的原因&quot; class=&quot;headerlink&quot; title=&quot;产生该问题的原因&quot;&gt;&lt;/a&gt;产生该问题的原因&lt;/h1&gt;&lt;p&gt;产生该问题的原因是由于Windows平台和linux平台的默认换行符是不一样的,linux使用的是&lt;code&gt;0x0A(LF)&lt;/code&gt;而Windows使用的是&lt;code&gt;0x0D0A(CRLF)&lt;/code&gt;,这就导致了当Windows下的代码放到linux下运行时,虽然代码没有错,但是linux下的git检测到项目的换行符为CRLF时会自动换成LF。&lt;/p&gt;
    
    </summary>
    
      <category term="程序人生" scheme="http://hackycy.github.io/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/"/>
    
    
      <category term="Git" scheme="http://hackycy.github.io/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>密码学之MD5 + Salt</title>
    <link href="http://hackycy.github.io/2021/03/17/%E5%AF%86%E7%A0%81%E5%AD%A6%E4%B9%8BMD5-Salt/"/>
    <id>http://hackycy.github.io/2021/03/17/密码学之MD5-Salt/</id>
    <published>2021-03-17T11:02:05.000Z</published>
    <updated>2021-05-03T11:11:23.944Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="MD算法的基本概念"><a href="#MD算法的基本概念" class="headerlink" title="MD算法的基本概念"></a>MD算法的基本概念</h1><p>MD5算法是典型的消息摘要算法，其前身有MD2、MD3和MD4算法，它由MD4、MD3和MD2算法改进而来。不论是哪一种MD算法，它们都需 要获得一个随机长度的信息并产生一个128位的信息摘要。如果将这个128位的二进制摘要信息换算成十六进制，可以得到一个32位的字符串，故我们见到的 大部分MD5算法的数字指纹都是32为十六进制的字符串。</p><a id="more"></a><h1 id="MD算法的发展史"><a href="#MD算法的发展史" class="headerlink" title="MD算法的发展史"></a>MD算法的发展史</h1><h2 id="MD2算法"><a href="#MD2算法" class="headerlink" title="MD2算法"></a>MD2算法</h2><p>1989年，著名的非对称算法RSA发明人之一—-麻省理工学院教授罗纳德.李维斯特开发了MD2算法。这个算法首先对信息进行数据补位，使信 息的字节长度是16的倍数。再以一个16位的检验和做为补充信息追加到原信息的末尾。最后根据这个新产生的信息计算出一个128位的散列值，MD2算法由 此诞生。</p><h2 id="MD4算法"><a href="#MD4算法" class="headerlink" title="MD4算法"></a>MD4算法</h2><p>1990年，罗纳德.李维斯特教授开发出较之MD2算法有着更高安全性的MD4算法。在这个算法中，我们仍需对信息进行数据补位。不同的是，这种补 位使其信息的字节长度加上448个字节后成为512的倍数（信息字节长度mod 512 =448）。此外，关于MD4算的处理和MD2算法有很大的差别。但最终仍旧会获得一个128为的散列值。MD4算法对后续消息摘要算法起到了推动作用， 许多比较有名的消息摘要算法都是在MD4算法的基础上发展而来的，如MD5、SHA-1、RIPE-MD和HAVAL算法等。</p><h2 id="MD5算法"><a href="#MD5算法" class="headerlink" title="MD5算法"></a>MD5算法</h2><p>1991年，继MD4算法后，罗纳德.李维斯特教授开发了MD5算法，将MD算法推向成熟。MD5算法经MD2、MD3和MD4算法发展而来，算法复杂程度和安全强度打打提高，但浙西MD算法的最终结果都是产生一个128位的信息摘要。这也是MD系列算法的特点。MD5算法的算法特点如下： （1）压缩性：任意长度的数据，算出的MD5值长度都是固定的。 （2）容易计算：从原数据计算出MD5值很容易。 （3）抗修改性：对原数据进行任何改动，哪怕只修改1个字节，所得到的MD5值都有很大区别。 （4）弱抗碰撞：已知原数据和其MD5值，想找到一个具有相同MD5值的数据（即伪造数据）是非常困难的。 （5）强抗碰撞：想找到两个不同的数据，使它们具有相同的MD5值，是非常困难的。</p><h2 id="MD5破解方面"><a href="#MD5破解方面" class="headerlink" title="MD5破解方面"></a>MD5破解方面</h2><p>在破解md5方面，最常用的方法是“跑字典”，有两种方法得到字典，一种是日常搜集的用做密码的字符串表，另一种是用排列组合方法生成的，先用MD5程序计算出这些字典项的MD5值，然后再用目标的MD5值在这个字典中检索。我们假设密码的最大长度为8位字节（8 Bytes），同时密码只能是字母和数字，共26+26+10=62个字节，排列组合出的字典的项数则是P（62,1）+P（62,2）….+P（62,8），那也已经是一个很天文的数字了，存储这个字典就需要TB级的磁盘阵列，而且这种方法还有一个前提，就是能获得目标账户的密码MD5值的情况下才可以。</p><p>所以总体而言，md5加密是十分安全的，即使有一些瑕疵，但并不影响具体的使用，外加md5是免费的，所以它的应用还是十分广泛的。</p><h1 id="MD5算法应用"><a href="#MD5算法应用" class="headerlink" title="MD5算法应用"></a>MD5算法应用</h1><h2 id="Md5-密码存储加盐"><a href="#Md5-密码存储加盐" class="headerlink" title="Md5 密码存储加盐"></a>Md5 密码存储加盐</h2><p>MD5算法，可以用来保存用户的密码信息。为了更好的保存，可以在保存的过程中，加入盐。/在保存用户密码的时候，盐可以利用生成的随机数。可以将密码结合MD5加盐，生成的数据摘要和盐保存起来 。以便于下次用户验证使用。在用户表里面，也保存salt。</p><h2 id="Md5-文件完整性校验"><a href="#Md5-文件完整性校验" class="headerlink" title="Md5 文件完整性校验"></a>Md5 文件完整性校验</h2><p>每个文件都可以用MD5验证程序算出一个固定的MD5值，是独一无二的。一般来说，开发方会在软件发布时预先算出文件的MD5值，如果文件被盗用，加了木马或者被篡改版权，那么它的MD5值也随之改变，也就是说我们对比文件当前的MD5值和它标准的MD5值来检验它是否正确和完整。 （1）例如网盘中的秒传4G文件，可以使用用户需要上传的文件进行Md5运算，判断与服务器中是否存在该文件，如果存在只需添加文件索引，不存在再真正上传。 （2）例如自动升级的客户端，判断下载的程序安装包是否完整，可以计算文件的MD5值，与服务器端计算的Md5值进行比对。</p><h1 id="MD5加盐"><a href="#MD5加盐" class="headerlink" title="MD5加盐"></a>MD5加盐</h1><p>我们知道，如果直接对密码进行散列，那么黑客可以对通过获得这个密码散列值，然后通过查散列值字典（例如MD5密码破解网站），得到某用户的密码。</p><p>加Salt可以一定程度上解决这一问题。所谓加Salt方法，就是加点“佐料”。其基本想法是这样的：当用户首次提供密码时（通常是注册时），由系统自动往这个密码里撒一些“佐料”，然后再散列。而当用户登录时，系统为用户提供的代码撒上同样的“佐料”，然后散列，再比较散列值，已确定密码是否正确。</p><p><strong>这里的“佐料”被称作“Salt值”，这个值是由系统随机生成的，并且只有系统知道。这样，即便两个用户使用了同一个密码，由于系统为它们生成的salt值不同，他们的散列值也是不同的。即便黑客可以通过自己的密码和自己生成的散列值来找具有特定密码的用户，但这个几率太小了（密码和salt值都得和黑客使用的一样才行）。 </strong></p><p>下面详细介绍一下加Salt散列的过程。介绍之前先强调一点，前面说过，验证密码时要使用和最初散列密码时使用“相同的”佐料。所以Salt值是要存放在数据库里的。</p><p><strong>用户注册时，</strong></p><ol><li>用户输入【账号】和【密码】（以及其他用户信息）；</li><li>系统为用户生成【Salt值】；</li><li>系统将【Salt值】和【用户密码】连接到一起；</li><li>对连接后的值进行散列，得到【Hash值】；</li><li>将【Hash值1】和【Salt值】分别放到数据库中。</li></ol><p><strong>用户登录时，</strong></p><ol><li>用户输入【账号】和【密码】；</li><li>系统通过用户名找到与之对应的【Hash值】和【Salt值】；</li><li>系统将【Salt值】和【用户输入的密码】连接到一起；</li><li>对连接后的值进行散列，得到【Hash值2】（注意是即时运算出来的值）；</li><li>比较【Hash值1】和【Hash值2】是否相等，相等则表示密码正确，否则表示密码错误。</li></ol><p>有时候，为了减轻开发压力，程序员会统一使用一个salt值（储存在某个地方），而不是每个用户都生成私有的salt值。</p><p>例子详解：</p><h2 id="第一代密码"><a href="#第一代密码" class="headerlink" title="第一代密码"></a>第一代密码</h2><p>早期的软件系统或者互联网应用，数据库中设计用户表的时候，大致是这样的结构：</p><p><img src="d1.png" alt></p><p>数据存储形式如下：</p><p><img src="d1-s.png" alt></p><p>主要的关键字段就是这么两个，一个是登陆时的用户名，对应的一个密码，而且那个时候的用户名是明文存储的，如果你登陆时用户名是 123，那么数据库里存的就是 <code>123</code>。这种设计思路非常简单，但是缺陷也非常明显，数据库一旦泄露，那么所有用户名和密码都会泄露，后果非常严重。</p><h2 id="第二代密码"><a href="#第二代密码" class="headerlink" title="第二代密码"></a>第二代密码</h2><p>为了规避第一代密码设计的缺陷，聪明的人在数据库中不在存储明文密码，转而存储加密后的密码，典型的加密算法是 MD5 和 SHA1，其数据表大致是这样设计的：</p><p><img src="d2.png" alt></p><p>数据存储形式如下： </p><p><img src="d2-s.png" alt></p><p>假如你设置的密码是<code>123</code>，那么数据库中存储的就是<code>202cb962ac59075b964b07152d234b70</code>或 <code>40bd001563085fc35165329ea1ff5c5ecbdbbeef</code>。当用户登陆的时候，会把用户输入的密码执行 MD5（或者 SHA1）后再和数据库就行对比，判断用户身份是否合法，这种加密算法称为散列。</p><p>严格地说，这种算法不能算是加密，因为理论上来说，它不能被解密。所以即使数据库丢失了，但是由于数据库里的密码都是密文，根本无法判断用户的原始密码，所以后果也不算太严重。</p><h2 id="第三代密码"><a href="#第三代密码" class="headerlink" title="第三代密码"></a>第三代密码</h2><p>本来第二代密码设计方法已经很不错了，只要你密码设置得稍微复杂一点，就几乎没有被破解的可能性。但是如果你的密码设置得不够复杂，被破解出来的可能性还是比较大的。</p><p>好事者收集常用的密码，然后对他们执行 MD5 或者 SHA1，然后做成一个数据量非常庞大的数据字典，然后对泄露的数据库中的密码就行对比，如果你的原始密码很不幸的被包含在这个数据字典中，那么花不了多长时间就能把你的原始密码匹配出来。这个数据字典很容易收集，CSDN 泄露的那 600w 个密码，就是很好的原始素材。</p><p>于是，第三代密码设计方法诞生，用户表中多了一个字段：</p><p><img src="d3.png" alt></p><p> 数据存储形式如下：</p><p><img src="d3-s.png" alt></p><p>Salt 可以是任意字母、数字、或是字母或数字的组合，但必须是随机产生的，每个用户的 Salt 都不一样，用户注册的时候，数据库中存入的不是明文密码，也不是简单的对明文密码进行散列，而是 MD5( 明文密码 + Salt)，也就是说： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MD5(&apos;123&apos; + &apos;1ck12b13k1jmjxrg1h0129h2lj&apos;) = &apos;6c22ef52be70e11b6f3bcf0f672c96ce&apos;</span><br><span class="line">MD5(&apos;456&apos; + &apos;1h029kh2lj11jmjxrg13k1c12b&apos;) = &apos;7128f587d88d6686974d6ef57c193628&apos;</span><br></pre></td></tr></table></figure><p>由于加了 Salt，即便数据库泄露了，但是由于密码都是加了 Salt 之后的散列，坏人们的数据字典已经无法直接匹配，明文密码被破解出来的概率也大大降低。</p><p>是不是加了 Salt 之后就绝对安全了呢？淡然没有！坏人们还是可以他们数据字典中的密码，加上我们泄露数据库中的 Salt，然后散列，然后再匹配。但是由于我们的 Salt 是随机产生的，假如我们的用户数据表中有 30w 条数据，数据字典中有 600w 条数据，坏人们如果想要完全覆盖的坏，他们加上 Salt 后再散列的数据字典数据量就应该是 300000* 6000000 = 1800000000000，一万八千亿啊，干坏事的成本太高了吧。但是如果只是想破解某个用户的密码的话，只需为这 600w 条数据加上 Salt，然后散列匹配。可见 Salt 虽然大大提高了安全系数，但也并非绝对安全。</p><p>实际项目中，Salt 不一定要加在最前面或最后面，也可以插在中间嘛，也可以分开插入，也可以倒序，程序设计时可以灵活调整，都可以使破解的难度指数级增长。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://www.cnblogs.com/myseries/p/11581170.html" target="_blank" rel="noopener">https://www.cnblogs.com/myseries/p/11581170.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;MD算法的基本概念&quot;&gt;&lt;a href=&quot;#MD算法的基本概念&quot; class=&quot;headerlink&quot; title=&quot;MD算法的基本概念&quot;&gt;&lt;/a&gt;MD算法的基本概念&lt;/h1&gt;&lt;p&gt;MD5算法是典型的消息摘要算法，其前身有MD2、MD3和MD4算法，它由MD4、MD3和MD2算法改进而来。不论是哪一种MD算法，它们都需 要获得一个随机长度的信息并产生一个128位的信息摘要。如果将这个128位的二进制摘要信息换算成十六进制，可以得到一个32位的字符串，故我们见到的 大部分MD5算法的数字指纹都是32为十六进制的字符串。&lt;/p&gt;
    
    </summary>
    
      <category term="程序人生" scheme="http://hackycy.github.io/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/"/>
    
    
  </entry>
  
  <entry>
    <title>Windows Server 2012/2016搭建VPN教程</title>
    <link href="http://hackycy.github.io/2021/03/09/Windows-Server-2012-2016%E6%90%AD%E5%BB%BAVPN%E6%95%99%E7%A8%8B/"/>
    <id>http://hackycy.github.io/2021/03/09/Windows-Server-2012-2016搭建VPN教程/</id>
    <published>2021-03-09T10:17:53.000Z</published>
    <updated>2021-05-03T11:11:23.780Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前置准备"><a href="#前置准备" class="headerlink" title="前置准备"></a>前置准备</h1><ul><li>Windows Server 2012/2016版服务器</li></ul><blockquote><p>该文以腾讯云创建的Server 2016服务器为例</p></blockquote><a id="more"></a><p>需要先放通服务器安全组端口，以腾讯云服务器为例：</p><p><img src="server_port.png" alt></p><p>以及关闭服务器的防火墙。</p><h1 id="配置步骤"><a href="#配置步骤" class="headerlink" title="配置步骤"></a>配置步骤</h1><p>连接远程服务器，打开服务器管理器。</p><p><img src="open_manager.png" alt></p><p>点击<code>添加角色和功能</code>，进行下图所示配置。</p><p><img src="add_role.png" alt></p><p>开始之前直接点击下一步</p><p><img src="config_1.png" alt></p><p>安装类型直接点击下一步</p><p><img src="config_2.png" alt></p><p>服务器选择直接点击下一步</p><p><img src="config_3.png" alt></p><p>服务器角色增加<code>网络策略和访问服务</code>以及<code>远程访问</code></p><p><img src="config_4.png" alt></p><p>选择添加功能</p><p><img src="config_5.png" alt></p><p>勾选后点击下一步</p><p><img src="config_6.png" alt></p><p>功能默认即可，直接点击下一步</p><p><img src="config_7.png" alt></p><p>网络策略和访问服务直接点击下一步</p><p><img src="config_8.png" alt></p><p>远程访问直接点击下一步</p><p><img src="config_9.png" alt></p><p>角色服务增加<code>DirectAccess和VPN(RAS)</code>以及路由</p><p><img src="config_10.png" alt></p><p>选择添加功能即可</p><p><img src="config_11.png" alt></p><p>勾选后点击下一步</p><p><img src="config_12.png" alt></p><p>Web服务器角色直接点击下一步</p><p><img src="config_13.png" alt></p><p>角色服务默认即可直接点击下一步</p><p><img src="config_14.png" alt></p><p>确认安装</p><p><img src="config_15.png" alt></p><p>点击安装后等待安装完毕关闭即可。</p><p><img src="config_16.png" alt></p><p>打开服务器管理器，点击工具，选择路由和远程访问</p><p><img src="config_17.png" alt></p><p>右键本地服务器，选择“配置并启用路由和远程访问”，启动配置向导。</p><p><img src="config_18.png" alt></p><p>点击下一步</p><p><img src="config_19.png" alt></p><p>选择自定义配置</p><p><img src="config_20.png" alt></p><p>全部勾选，并点击下一步</p><p><img src="config_21.png" alt></p><p>点击完成</p><p><img src="config_22.png" alt></p><p>如出现该提示直接点击确定</p><p><img src="config_23.png" alt></p><p>点击启动服务</p><p><img src="config_24.png" alt></p><p>展开本地服务器，展开<code>IPv4</code>，右键<code>NAT</code>，选择<code>新建接口</code></p><p><img src="config_25.png" alt></p><p>选择<code>以太网</code>，点击确定</p><p><img src="config_26.png" alt></p><p>勾选公用以及启用NAT，如图所示，点击确定</p><p><img src="config_27.png" alt></p><p>再次展开本地服务器，展开<code>IPv4</code>，右键<code>NAT</code>，选择<code>新建接口</code></p><p>选择<code>内部</code>，点击确定</p><p><img src="config_28.png" alt></p><p>勾选专用，点击确定</p><p><img src="config_29.png" alt></p><p>配置本地服务器属性</p><p><img src="config_30.png" alt></p><p>点击<code>IPv4</code>标签页为远端连接分配IP地址池</p><p><img src="config_31.png" alt></p><p><img src="config_32.png" alt></p><p>再次配置本地服务器属性</p><p>选择<code>安全</code>标签页，配置允许L2TP策略选项，并填入<strong>预共享密钥</strong>，点击确定</p><blockquote><p>务必记住该密钥，后续需要填写</p></blockquote><p><img src="config_33.png" alt></p><p>点击确定</p><p><img src="config_34.png" alt></p><p>打开服务器管理器，点击工具选择计算机管理</p><p><img src="config_35.png" alt></p><p>展开本地用户和组，选择新建组</p><p><img src="config_36.png" alt></p><p>展开本地用户和组，选择新用户</p><p><img src="config_37.png" alt></p><p>点击新建的用户名右键选择属性</p><p><img src="config_38.png" alt></p><p>按图中依次点击<code>隶属于</code>–<code>添加</code>–<code>高级</code>—<code>立即查找</code>—<code>VPNGroup（刚刚创建的组）</code>—<code>确定</code></p><p><img src="config_39.png" alt></p><p>点击确定</p><p><img src="config_40.png" alt></p><p>配置 VPN 访问权限，回到服务器管理器，点击<code>NAPS</code>–<code>选择服务器</code>–启动<code>网络策略服务器</code>配置</p><p><img src="config_41.png" alt></p><p>展开策略，右键点击网络策略并新建</p><p><img src="config_42.png" alt></p><p>填写名称并在“网络访问服务器的类型”中选择<code>远程访问服务器(VPN 拨号)</code>，点击下一步</p><p><img src="config_43.png" alt></p><p>在指定条件中，根据实际需求，选择合适的匹配条件。比如，文中选择了域中的<code>VPNGroup</code>用户组。</p><p><img src="config_44.png" alt></p><p><img src="config_45.png" alt></p><p><img src="config_46.png" alt></p><p>点击下一步</p><p><img src="config_47.png" alt></p><p>点击下一步</p><p><img src="config_48.png" alt></p><p>点击下一步</p><p><img src="config_49.png" alt></p><p>点击下一步</p><p><img src="config_50.png" alt></p><p>点击完成</p><p><img src="config_51.png" alt></p><p>然后重启服务器（重启服务）但懒得找服务直接重启服务器了。</p><p>重启完成后打开服务器管理器，找到远程访问，并启动对应的服务。</p><p><img src="config_52.png" alt></p><p>右键启动即可</p><p><img src="config_53.png" alt></p><h1 id="连接测试"><a href="#连接测试" class="headerlink" title="连接测试"></a>连接测试</h1><h2 id="Mac环境"><a href="#Mac环境" class="headerlink" title="Mac环境"></a>Mac环境</h2><p>打开<code>设置</code>—<code>网络</code>，点击<code>+</code>号新建</p><p><img src="test_1.png" alt></p><p>选择图中对应类型</p><p><img src="test_2.png" alt></p><p><img src="test_3.png" alt></p><p><img src="test_4.png" alt></p><h2 id="Win10环境"><a href="#Win10环境" class="headerlink" title="Win10环境"></a>Win10环境</h2><p>打开<code>设置</code>—<code>网络和Internet</code>—<code>VPN</code></p><p><img src="wtest_1.png" alt></p><p>配置如图所示</p><p><img src="wtest_2.png" alt></p><p><img src="wtest_3.png" alt></p><h1 id="错误修复"><a href="#错误修复" class="headerlink" title="错误修复"></a>错误修复</h1><p>这边测试在Win7或Win10连接时会出现<code>无法建立计算机与VPN服务器之间的网络连接,因为远程服务器未响应</code>的问题。查找了文章修复了问题。</p><h2 id="错误1：因为没有修改过注册表，所以是报这样的错误"><a href="#错误1：因为没有修改过注册表，所以是报这样的错误" class="headerlink" title="错误1：因为没有修改过注册表，所以是报这样的错误"></a>错误1：因为没有修改过注册表，所以是报这样的错误</h2><p><img src="fix_1.jpg" alt></p><p><strong>解决办法</strong></p><p>按<code>windows图标键 + R键</code> &gt;在运行中输入<code>regedit</code>，单击<code>确定</code>，进入<code>注册表编辑器</code></p><p><img src="fix_2.png" alt></p><p>在注册表编辑器”页面的左侧导航树点开 <code>HKEY_LOCAL_MACHINE</code>&gt;<code>SYSTEM</code>&gt;<code>CurrentControlSet</code>&gt;<code>Services</code>&gt;<code>PolicyAgent</code></p><p><img src="fix_3.jpg" alt></p><p>在右边空白处新建 &gt; <code>DWORD值</code>，名称为<code>AssumeUDPEncapsulationContextOnSendRule</code></p><p><img src="fix_4.jpg" alt></p><p>右键单击<code>AssumeUDPEncapsulationContextOnSendRule</code>，选择“修改”，进入修改界面，修改值为<code>2</code>(表示可以与位于NAT设备后方的服务器建立安全关联)</p><p><img src="fix_5.jpg" alt></p><blockquote><p>重启电脑即可。一般Win7配置完该步骤后即可连接，但Win10还会出现问题。</p></blockquote><h2 id="错误2：修改完注册表，错误就变了，是因为认证的协议问题"><a href="#错误2：修改完注册表，错误就变了，是因为认证的协议问题" class="headerlink" title="错误2：修改完注册表，错误就变了，是因为认证的协议问题"></a>错误2：修改完注册表，错误就变了，是因为认证的协议问题</h2><p><img src="fix_6.jpg" alt></p><p><strong>解决办法</strong></p><p>打开更改适配器选项，找到对应的VPN名称的适配器，右键属性</p><p><img src="fix_7.jpg" alt></p><p>打开安全选项，选择使用这些协议勾上；注意此处还有高级设置里面的L2TP身份验证类型，这里也要填写的（秘钥方式还是证书方式）</p><p><img src="fix_8.jpg" alt></p><blockquote><p>再次连接，即可修复</p></blockquote><h1 id="参考教程"><a href="#参考教程" class="headerlink" title="参考教程"></a>参考教程</h1><p><a href="https://www.365jz.com/article/24912" target="_blank" rel="noopener">https://www.365jz.com/article/24912</a></p><p><a href="https://me.jinchuang.org/archives/381.html" target="_blank" rel="noopener">https://me.jinchuang.org/archives/381.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前置准备&quot;&gt;&lt;a href=&quot;#前置准备&quot; class=&quot;headerlink&quot; title=&quot;前置准备&quot;&gt;&lt;/a&gt;前置准备&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;Windows Server 2012/2016版服务器&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;该文以腾讯云创建的Server 2016服务器为例&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="程序人生" scheme="http://hackycy.github.io/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/"/>
    
    
  </entry>
  
  <entry>
    <title>利用Canvas进行前端图片压缩</title>
    <link href="http://hackycy.github.io/2021/02/25/%E5%88%A9%E7%94%A8Canvas%E8%BF%9B%E8%A1%8C%E5%89%8D%E7%AB%AF%E5%9B%BE%E7%89%87%E5%8E%8B%E7%BC%A9/"/>
    <id>http://hackycy.github.io/2021/02/25/利用Canvas进行前端图片压缩/</id>
    <published>2021-02-25T10:36:00.000Z</published>
    <updated>2021-05-03T11:11:23.940Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><strong>纯前端利用Canvas来进行图片压缩的方法</strong></p><a id="more"></a><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 压缩方法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">compress</span>(<span class="params">file, callback</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> reader = <span class="keyword">new</span> FileReader();</span><br><span class="line">  reader.readAsDataURL(file);</span><br><span class="line">  reader.onload = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> base64Image = e.target.result;</span><br><span class="line">    <span class="keyword">var</span> image = <span class="keyword">new</span> Image();</span><br><span class="line">    image.src = base64Image;</span><br><span class="line"></span><br><span class="line">    image.addEventListener(<span class="string">'load'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">var</span> needCompress = <span class="literal">false</span>; <span class="comment">// 是否需要压缩</span></span><br><span class="line">      <span class="keyword">var</span> ratio;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 支持最大的宽高</span></span><br><span class="line">      <span class="keyword">var</span> maxH = <span class="number">400</span>;</span><br><span class="line">      <span class="keyword">var</span> maxW = <span class="number">800</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">var</span> imageH = image.naturalHeight;</span><br><span class="line">      <span class="keyword">var</span> imageW = image.naturalWidth;</span><br><span class="line">      </span><br><span class="line">      <span class="comment">// 宽高压缩</span></span><br><span class="line">      <span class="keyword">if</span> (maxH &lt; imageH) &#123;</span><br><span class="line">        needCompress = <span class="literal">true</span>;</span><br><span class="line">        ratio = imageH / maxH;</span><br><span class="line">        maxW = imageW / ratio;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (maxW &lt; imageW) &#123;</span><br><span class="line">        needCompress = <span class="literal">true</span>;</span><br><span class="line">        ratio = imageW / maxW;</span><br><span class="line">        maxH = imageH / ratio;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (!needCompress) &#123;</span><br><span class="line">        maxW = imageW;</span><br><span class="line">        maxH = imageH;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 创建canvas并隐藏</span></span><br><span class="line">      <span class="keyword">var</span> canvas = <span class="built_in">document</span>.createElement(<span class="string">'canvas'</span>);</span><br><span class="line">      canvas.setAttribute(<span class="string">'id'</span>, <span class="string">'__compress__'</span>);</span><br><span class="line">      canvas.width = maxW;</span><br><span class="line">      canvas.height = maxH;</span><br><span class="line">      canvas.style.visibility = <span class="string">'hidden'</span>;</span><br><span class="line">      <span class="built_in">document</span>.body.appendChild(canvas);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">var</span> ctx = canvas.getContext(<span class="string">'2d'</span>);</span><br><span class="line">      ctx.clearRect(<span class="number">0</span>, <span class="number">0</span>, maxW, maxH);</span><br><span class="line">      ctx.drawImage(image, <span class="number">0</span>, <span class="number">0</span>, maxW, maxH);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// canvas 压缩比值，不宜过小</span></span><br><span class="line">      <span class="keyword">const</span> compressImage = canvas.toDataURL(file.type, <span class="number">0.9</span>);</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'原来大小：'</span> + base64Image.length);</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'压缩后大小：'</span> + compressImage.length)</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'压缩比：'</span> + base64Image.length / compressImage.length);</span><br><span class="line">      callback(compressImage);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>使用案例</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">"upload"</span> <span class="attr">type</span>=<span class="string">"file"</span> /&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 支持的类型</span></span><br><span class="line"><span class="keyword">var</span> ACCEPT_TYPE = [ <span class="string">'image/jpeg'</span>, <span class="string">'image/png'</span>, <span class="string">'image/jpg'</span> ];</span><br><span class="line"><span class="keyword">const</span> upload = <span class="built_in">document</span>.getElementById(<span class="string">'upload'</span>);</span><br><span class="line">upload.addEventListener(<span class="string">'change'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line"><span class="keyword">const</span> [ file ] = e.target.files;</span><br><span class="line"><span class="keyword">if</span> (!file) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> &#123; <span class="attr">type</span>: fileType, <span class="attr">size</span>: fileSize &#125; = file;</span><br><span class="line"><span class="keyword">if</span> (ACCEPT_TYPE.indexOf(fileType) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">upload.value = <span class="literal">null</span>;</span><br><span class="line">alert(<span class="string">'不支持的文件类型'</span> + fileType);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">compress(file, (compressImage) =&gt; <span class="built_in">console</span>.log(compressImage));</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><blockquote><p><a href="https://github.com/hackycy/practice-examples/blob/master/javascript/canvas/compress.html" target="_blank" rel="noopener">案例源码</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;纯前端利用Canvas来进行图片压缩的方法&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="http://hackycy.github.io/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="http://hackycy.github.io/tags/JavaScript/"/>
    
      <category term="Canvas" scheme="http://hackycy.github.io/tags/Canvas/"/>
    
  </entry>
  
  <entry>
    <title>解决Mac出现Kotlin could not find the required JDK tools in the Java installation</title>
    <link href="http://hackycy.github.io/2020/12/25/%E8%A7%A3%E5%86%B3Mac%E5%87%BA%E7%8E%B0Kotlin-could-not-find-the-required-JDK-tools-in-the-Java-installation/"/>
    <id>http://hackycy.github.io/2020/12/25/解决Mac出现Kotlin-could-not-find-the-required-JDK-tools-in-the-Java-installation/</id>
    <published>2020-12-25T18:17:38.000Z</published>
    <updated>2021-05-03T11:11:23.984Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt; Task :compileKotlin FAILED</span><br><span class="line"></span><br><span class="line">FAILURE: Build failed with an exception.</span><br><span class="line"></span><br><span class="line">* What went wrong:</span><br><span class="line">Execution failed <span class="keyword">for</span> task <span class="string">':compileKotlin'</span>.</span><br><span class="line">&gt; Kotlin could not find the require JDK tools <span class="keyword">in</span> the Java installtion <span class="string">'/Library/Internet Plug-Ins/JavaAppletPlugin.plugin/Contents/Home'</span> used by Gradle. Make sure is running on a JDK, not JRE.</span><br></pre></td></tr></table></figure><p>在混编开发过程中，打包的时候出现了该问题，排查很久，总算找到了原因：<strong>没有配置JAVA_HOME环境变量</strong>。</p><a id="more"></a><p><strong>解决方案</strong></p><p>安装好JDK后，获取JAVA的安装路径</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ /usr/libexec/java_home -V</span><br><span class="line">Matching Java Virtual Machines (2):</span><br><span class="line">    1.8.201.09 (x86_64) <span class="string">"Oracle Corporation"</span> - <span class="string">"Java"</span> /Library/Internet Plug-Ins/JavaAppletPlugin.plugin/Contents/Home</span><br><span class="line">    1.8.0_201 (x86_64) <span class="string">"Oracle Corporation"</span> - <span class="string">"Java SE 8"</span> /Library/Java/JavaVirtualMachines/jdk1.8.0_201.jdk/Contents/Home</span><br><span class="line">/Library/Java/JavaVirtualMachines/jdk1.8.0_201.jdk/Contents/Home</span><br></pre></td></tr></table></figure><p>mac下编辑profile：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ vi ~/.bash_profile</span><br><span class="line"></span><br><span class="line"><span class="comment"># android</span></span><br><span class="line"><span class="built_in">export</span> ANDROID_HOME=/Users/zjyzy/Library/Android/sdk</span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$&#123;PATH&#125;</span>:<span class="variable">$&#123;ANDROID_HOME&#125;</span>/tools</span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$&#123;PATH&#125;</span>:<span class="variable">$&#123;ANDROID_HOME&#125;</span>/platform-tools</span><br><span class="line"></span><br><span class="line"><span class="comment"># java</span></span><br><span class="line"><span class="built_in">export</span> JAVA_HOME=/Library/Java/JavaVirtualMachines/jdk1.8.0_201.jdk/Contents/Home</span><br><span class="line"><span class="built_in">export</span> CLASSPAHT=.:<span class="variable">$JAVA_HOME</span>/lib/dt.jar:<span class="variable">$JAVA_HOME</span>/lib/tools.jar</span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$JAVA_HOME</span>/bin:<span class="variable">$PATH</span>:</span><br></pre></td></tr></table></figure><p>编辑完成后，按<code>esc</code>退出插入模式，输入<code>:wq</code>退出保存即可。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">source</span> ~/.bash_profile</span><br></pre></td></tr></table></figure><p>生效后验证：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> <span class="variable">$JAVA_HOME</span></span><br><span class="line">/Library/Java/JavaVirtualMachines/jdk1.8.0_201.jdk/Contents/Home</span><br></pre></td></tr></table></figure><p>问题解决。</p>]]></content>
    
    <summary type="html">
    
      &lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&amp;gt; Task :compileKotlin FAILED&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;FAILURE: Build failed with an exception.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;* What went wrong:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Execution failed &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; task &lt;span class=&quot;string&quot;&gt;&#39;:compileKotlin&#39;&lt;/span&gt;.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;gt; Kotlin could not find the require JDK tools &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; the Java installtion &lt;span class=&quot;string&quot;&gt;&#39;/Library/Internet Plug-Ins/JavaAppletPlugin.plugin/Contents/Home&#39;&lt;/span&gt; used by Gradle. Make sure is running on a JDK, not JRE.&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;在混编开发过程中，打包的时候出现了该问题，排查很久，总算找到了原因：&lt;strong&gt;没有配置JAVA_HOME环境变量&lt;/strong&gt;。&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="http://hackycy.github.io/categories/Android/"/>
    
    
      <category term="Android" scheme="http://hackycy.github.io/tags/Android/"/>
    
      <category term="Android Studio" scheme="http://hackycy.github.io/tags/Android-Studio/"/>
    
  </entry>
  
  <entry>
    <title>Flutter屏幕适配攻略</title>
    <link href="http://hackycy.github.io/2020/12/25/Flutter%E5%B1%8F%E5%B9%95%E9%80%82%E9%85%8D%E6%94%BB%E7%95%A5/"/>
    <id>http://hackycy.github.io/2020/12/25/Flutter屏幕适配攻略/</id>
    <published>2020-12-25T10:08:58.000Z</published>
    <updated>2021-05-03T11:11:23.416Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><strong>目前移动端的设备已经非常多，并且不同的设备手机屏幕也不相同。</strong></p><p><strong>目前做移动端开发都要针对不同的设备进行一定的适配，无论是移动原生开发、小程序、H5页面。</strong></p><a id="more"></a><h1 id="Flutter中的单位"><a href="#Flutter中的单位" class="headerlink" title="Flutter中的单位"></a>Flutter中的单位</h1><p>在进行Flutter开发时，我们通常不需要传入尺寸的单位，那么Flutter使用的是什么单位呢？</p><ul><li>Flutter使用的是类似于iOS中的点pt，也就是point。</li><li>所以我们经常说iPhone6的尺寸是375x667，但是它的分辨率其实是750x1334。</li><li>因为iPhone6的dpr（devicePixelRatio）是2.0，iPhone6plus的dpr是3.0</li></ul><p><img src="1.png" alt></p><blockquote><p> 在Flutter开发中，我们使用的是对应的逻辑分辨率</p></blockquote><h1 id="Flutter设备信息"><a href="#Flutter设备信息" class="headerlink" title="Flutter设备信息"></a>Flutter设备信息</h1><p>获取屏幕上的一些信息，可以通过MediaQuery：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.媒体查询信息</span></span><br><span class="line"><span class="keyword">final</span> mediaQueryData = MediaQuery.of(context);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.获取宽度和高度</span></span><br><span class="line"><span class="keyword">final</span> screenWidth = mediaQueryData.size.width;</span><br><span class="line"><span class="keyword">final</span> screenHeight = mediaQueryData.size.height;</span><br><span class="line"><span class="keyword">final</span> physicalWidth = <span class="built_in">window</span>.physicalSize.width;</span><br><span class="line"><span class="keyword">final</span> physicalHeight = <span class="built_in">window</span>.physicalSize.height;</span><br><span class="line"><span class="keyword">final</span> dpr = <span class="built_in">window</span>.devicePixelRatio;</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"屏幕width:<span class="subst">$screenWidth</span> height:<span class="subst">$screenHeight</span>"</span>);</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"分辨率: <span class="subst">$physicalWidth</span> - <span class="subst">$physicalHeight</span>"</span>);</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"dpr: <span class="subst">$dpr</span>"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.状态栏的高度</span></span><br><span class="line"><span class="comment">// 有刘海的屏幕:44 没有刘海的屏幕为20</span></span><br><span class="line"><span class="keyword">final</span> statusBarHeight = mediaQueryData.padding.top;</span><br><span class="line"><span class="comment">// 有刘海的屏幕:34 没有刘海的屏幕0</span></span><br><span class="line"><span class="keyword">final</span> bottomHeight = mediaQueryData.padding.bottom;</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"状态栏height: <span class="subst">$statusBarHeight</span> 底部高度:<span class="subst">$bottomHeight</span>"</span>);</span><br></pre></td></tr></table></figure><p>获取一些设备相关的信息，可以使用官方提供的一个库：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dependencies:</span><br><span class="line">  device_info: ^<span class="number">0.4</span><span class="number">.2</span>+<span class="number">1</span></span><br></pre></td></tr></table></figure><h1 id="适配方案"><a href="#适配方案" class="headerlink" title="适配方案"></a>适配方案</h1><p>假如我们有下面这样一段代码：</p><ul><li>在屏幕中间显示一个200*200的Container</li><li>Container中有一段文字是30</li></ul><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HomePage</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> Scaffold(</span><br><span class="line">      appBar: AppBar(</span><br><span class="line">        title: Text(<span class="string">"首页"</span>),</span><br><span class="line">      ),</span><br><span class="line">      body: Center(</span><br><span class="line">        child: Container(</span><br><span class="line">          width: <span class="number">200</span>,</span><br><span class="line">          height: <span class="number">200</span>,</span><br><span class="line">          color: Colors.red,</span><br><span class="line">          alignment: Alignment.center,</span><br><span class="line">          child: Text(<span class="string">"Hello World"</span>, style: TextStyle(fontSize: <span class="number">30</span>, color: Colors.white),),</span><br><span class="line">        ),</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码在不同屏幕上会有不同的表现：</p><ul><li>很明显，如果按照上面的规则，在iPhone5上面，尺寸过大，在iPhone6plus上面尺寸过小</li><li>在开发中，我们应该可以根据不同的屏幕来完成尺寸的缩放</li></ul><p><img src="2.png" alt></p><p>在前端开发中，针对不同的屏幕常见的适配方案有下面几种：</p><ul><li>rem：<ul><li>rem是给根标签（HTML标签）设置一个字体大小；</li><li>但是不同的屏幕要动画设置不同的字体大小（可以通过媒体查询，也可以通过js动态计算）；</li><li>其它所有的单位都使用rem单位（相对于根标签）；</li></ul></li><li>vw、wh：<ul><li>vw和vh是将屏幕（视口）分成100等份，一个1vw相当于是1%的大小；</li><li>其它所有的单位都使用vw或wh单位；</li></ul></li><li>rpx：<ul><li>rpx是小程序中的适配方案，它将750px作为设计稿，1rpx=屏幕宽度/750；</li><li>其它所有的单位都使用rpx单位；</li></ul></li></ul><p><strong>该文采用类似小程序的rpx方案来完成Flutter的适配</strong></p><h1 id="rpx适配"><a href="#rpx适配" class="headerlink" title="rpx适配"></a>rpx适配</h1><p>小程序中rpx的原理是什么呢？</p><ul><li>不管是什么屏幕，统一分成750份</li><li>在iPhone5上：1rpx = 320/750 = 0.4266 ≈ 0.42px</li><li>在iPhone6上： 1rpx = 375/750 = 0.5px</li><li>在iPhone6plus上：1rpx = 414/750 = 0.552px</li></ul><p>那么我们就可以通过上面的计算方式，算出一个rpx，再将自己的size和rpx单位相乘即可：</p><ul><li>比如100px的宽度：100 <em> 2 </em> rpx</li><li>在iPhone5上计算出的结果是84px</li><li>在iPhone6上计算出的结果是100px</li><li>在iPhone6plus上计算出的结果是110.4px</li></ul><p>我们自己来封装一个工具类：</p><ul><li>工具类需要进行初始化，传入context</li><li>可以通过传入context，利用媒体查询获取屏幕的宽度和高度</li><li>也可以传入一个可选的参数，以什么尺寸作为设计稿</li></ul><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'package:flutter/material.dart'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// <span class="markdown">屏幕适配工具类</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ScreenAdapterUtils</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> ScreenAdapterUtils _instance;</span><br><span class="line">  <span class="keyword">static</span> MediaQueryData _mediaQueryData;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">double</span> screenWidth;</span><br><span class="line">  <span class="built_in">double</span> screenHeight;</span><br><span class="line">  <span class="built_in">double</span> density = <span class="number">2.0</span>;</span><br><span class="line">  <span class="built_in">double</span> standartWidth = <span class="number">750</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// <span class="markdown">比值</span></span></span><br><span class="line">  <span class="built_in">double</span> _rpxW;</span><br><span class="line">  <span class="built_in">double</span> _rpxH;</span><br><span class="line"></span><br><span class="line">  ScreenAdapterUtils._() &#123;</span><br><span class="line">    screenWidth = _mediaQueryData.size.width;</span><br><span class="line">    screenHeight = _mediaQueryData.size.height;</span><br><span class="line">    _rpxW = screenWidth / standartWidth;</span><br><span class="line">    _rpxH = screenHeight / standartWidth;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">factory</span> ScreenAdapterUtils.instance() &#123;</span><br><span class="line">    <span class="keyword">return</span> _instance;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// <span class="markdown">初始化</span></span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">void</span> init(BuildContext context) &#123;</span><br><span class="line">    _mediaQueryData = MediaQuery.of(context);</span><br><span class="line">    _instance = ScreenAdapterUtils._();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// <span class="markdown">是否为横屏</span></span></span><br><span class="line">  <span class="built_in">bool</span> isLand() &#123;</span><br><span class="line">    <span class="keyword">return</span> _mediaQueryData.orientation == Orientation.landscape;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// <span class="markdown">需要考虑横屏和竖屏</span></span></span><br><span class="line">  <span class="built_in">double</span> px(<span class="built_in">double</span> size) &#123;</span><br><span class="line">    <span class="keyword">return</span> (isLand() ? _rpxH : _rpxW) * size * density;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">double</span> rpx(<span class="built_in">double</span> size) &#123;</span><br><span class="line">    <span class="keyword">return</span> (isLand() ? _rpxH : _rpxW) * size;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>初始化<code>ScreenAdapterUtils</code>类的属性：</p><ul><li>注意：必须在已经有<code>MaterialApp</code>的Widget中使用context，否则是无效的</li></ul><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HomePage</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="comment">// 初始化ScreenAdapterUtils</span></span><br><span class="line">    ScreenAdapterUtils.init(context);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用rpx来完成屏幕适配：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HomePage</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    ScreenAdapterUtils.init(context);</span><br><span class="line">    <span class="keyword">return</span> Scaffold(</span><br><span class="line">      appBar: AppBar(</span><br><span class="line">        title: Text(<span class="string">"首页"</span>),</span><br><span class="line">      ),</span><br><span class="line">      body: Center(</span><br><span class="line">        child: Container(</span><br><span class="line">          width: ScreenAdapterUtils.instance().px(<span class="number">200</span>),</span><br><span class="line">          height: ScreenAdapterUtils.instance().rpx(<span class="number">400</span>),</span><br><span class="line">          color: Colors.red,</span><br><span class="line">          alignment: Alignment.center,</span><br><span class="line">          child: Text(<span class="string">"Hello World"</span>, style: TextStyle(fontSize: SizeFit.setPx(<span class="number">30</span>), color: Colors.white),),</span><br><span class="line">        ),</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现效果：</p><p><img src="4.png" alt></p><h1 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h1><p>如果每次我们需要将现在的宽度或者高度，去使用<code>ScreenAdapterUtils.instance().px(200)</code>或者<code>ScreenAdapterUtils.instance().rpx(400)</code>类似的方式去适配，显然看起来非常麻烦。</p><p><strong>有没有更好的方案可以实现了？比如 200.px或者400.rpx，非常的清晰简洁</strong></p><p><strong>当然可以，我们需要依赖Dart语言的一个特性：extension</strong></p><ul><li>Dart从<code>2.7.0</code>开始，可以通过extension来给现有的类进行扩展（事实上Swift里面也有）</li><li>对现有的类包括：自定义的类、第三方库的类、系统的类</li></ul><p>比如我们现在对String类型扩展：</p><ul><li>扩展一个parseInt的方法，当然内部调用的是<code>int.parse(this)</code>，只是调用者变成了<code>String</code>本身</li></ul><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 步骤一：扩展代码</span></span><br><span class="line"><span class="keyword">extension</span> NumberParsing <span class="keyword">on</span> <span class="built_in">String</span> &#123;</span><br><span class="line">  <span class="built_in">int</span> parseInt() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">int</span>.parse(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ···</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 步骤二：调用代码</span></span><br><span class="line"><span class="comment">// 导入扩展类对应的模块</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">'string_apis.dart'</span>;</span><br><span class="line"><span class="comment">// 使用里面的方法</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">'42'</span>.parseInt()); <span class="comment">// 使用String扩展的方法</span></span><br></pre></td></tr></table></figure><p>显然，数字（比如200、200.0）有对应的包装类int、double，我们可以对其进行扩展：</p><p><strong>对int类型扩展</strong></p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'../utils/screen_adapter.dart'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extension</span> IntScreenAdapter <span class="keyword">on</span> <span class="built_in">int</span> &#123;</span><br><span class="line">  <span class="built_in">double</span> <span class="keyword">get</span> rpx &#123;</span><br><span class="line">    <span class="keyword">return</span> ScreenAdapterUtils.instance().rpx(<span class="keyword">this</span>.toDouble());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">double</span> <span class="keyword">get</span> px &#123;</span><br><span class="line">    <span class="keyword">return</span> ScreenAdapterUtils.instance().px(<span class="keyword">this</span>.toDouble());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>对double类型扩展</strong></p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'../utils/screen_adapter.dart'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extension</span> DoubleScreenAdapter <span class="keyword">on</span> <span class="built_in">double</span> &#123;</span><br><span class="line">  <span class="built_in">double</span> <span class="keyword">get</span> rpx &#123;</span><br><span class="line">    <span class="keyword">return</span> ScreenAdapterUtils.instance().rpx(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">double</span> <span class="keyword">get</span> px &#123;</span><br><span class="line">    <span class="keyword">return</span> ScreenAdapterUtils.instance().px(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>使用</strong></p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'./extension/adapter.dart'</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="number">200.</span>px); <span class="comment">// 在不同屏幕下200px是不同的值</span></span><br><span class="line"><span class="built_in">print</span>(<span class="number">400.</span>rpx); <span class="comment">// 在不同屏幕下400rpx是不同的值</span></span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>如果美工提供的设计稿为iPhone6尺寸的设计稿（最好不过），那么直接使用对着稿子量多少代码填多少rpx单位即可。</p><h1 id="题外话"><a href="#题外话" class="headerlink" title="题外话"></a>题外话</h1><p>当使用extension时出现报错时，例如</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Undefined class <span class="string">'extension'</span>.</span><br><span class="line">Try changing the name to the name of an existing class, or creating a class with the name <span class="string">'extension'</span>. dartundefined_class</span><br><span class="line">This requires the <span class="string">'extension-methods'</span> language feature to be enabled.</span><br></pre></td></tr></table></figure><p><strong>解决办法：</strong></p><p>在项目根目录下创建<code>analysis_options.yaml</code>，并写入以下内容：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">include:</span></span><br><span class="line"></span><br><span class="line"><span class="attr">analyzer:</span></span><br><span class="line">  <span class="attr">enable-experiment:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">extension-methods</span></span><br><span class="line"></span><br><span class="line"><span class="attr">linter:</span></span><br></pre></td></tr></table></figure><p>以及设置<code>pubspec.yaml</code>的environment</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">environment:</span></span><br><span class="line">  <span class="attr">sdk:</span> <span class="string">'&gt;=2.6.0 &lt;3.0.0'</span></span><br></pre></td></tr></table></figure><p>重启VSCode即可。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li><a href="https://juejin.cn/post/6844904176489594893" target="_blank" rel="noopener">https://juejin.cn/post/6844904176489594893</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;目前移动端的设备已经非常多，并且不同的设备手机屏幕也不相同。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;目前做移动端开发都要针对不同的设备进行一定的适配，无论是移动原生开发、小程序、H5页面。&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Flutter" scheme="http://hackycy.github.io/categories/Flutter/"/>
    
    
      <category term="Flutter" scheme="http://hackycy.github.io/tags/Flutter/"/>
    
  </entry>
  
  <entry>
    <title>Android各版本迭代信息集合</title>
    <link href="http://hackycy.github.io/2020/12/22/Android%E5%90%84%E7%89%88%E6%9C%AC%E8%BF%AD%E4%BB%A3%E4%BF%A1%E6%81%AF%E9%9B%86%E5%90%88/"/>
    <id>http://hackycy.github.io/2020/12/22/Android各版本迭代信息集合/</id>
    <published>2020-12-22T14:29:43.000Z</published>
    <updated>2021-05-03T11:11:23.376Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>今天分享的面试题是：</p><p>Android在版本迭代中，总会进行很多改动，那么你熟知各版本都改动了什么内容？又要怎么适配呢？</p><a id="more"></a><h1 id="Android4-4"><a href="#Android4-4" class="headerlink" title="Android4.4"></a>Android4.4</h1><ul><li>发布<code>ART</code>虚拟机，提供选项可以开启。</li><li><code>HttpURLConnection</code>的底层实现改为了OkHttp。</li></ul><h1 id="Android5-0"><a href="#Android5-0" class="headerlink" title="Android5.0"></a>Android5.0</h1><ul><li><code>ART</code>成为默认虚拟机，完全代替Dalvik虚拟机。</li><li><code>Context.bindService()</code> 方法需要显式 Intent，如果提供隐式 intent，将引发异常。</li></ul><h1 id="Android6-0"><a href="#Android6-0" class="headerlink" title="Android6.0"></a>Android6.0</h1><ul><li>增加运行时权限限制</li></ul><p>如果你的应用使用到了危险权限，比如在运行时进行检查和请求权限。<code>checkSelfPermission()</code>方法用于检查权限，<code>requestPermissions()</code> 方法用于请求权限。</p><ul><li>取消支持Apache HTTP</li></ul><p>Android 6.0 版移除了对 <code>Apache HTTP</code>相关类库的支持。要继续使用 Apache HTTP API，您必须先在 build.gradle 文件中声明以下编译时依赖项：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">android &#123;useLibrary &apos;org.apache.http.legacy&apos;&#125;</span><br></pre></td></tr></table></figure><p>有的小伙伴可能不熟悉这是啥，简单说下：</p><blockquote><p>Apache HttpClient 是Apache开源组织提供的一个开源的项目,它是一个简单的HTTP客户端（并不是浏览器），可以发送HTTP请求，接受HTTP响应。</p></blockquote><p>所以说白了，其实就是一个请求网络的项目框架。</p><h1 id="Android-7-0"><a href="#Android-7-0" class="headerlink" title="Android 7.0"></a>Android 7.0</h1><ul><li>Android 7.0 引入一项新的应用签名方案 APK Signature Scheme v2</li><li>Toast导致的BadTokenException</li><li>在Android7.0系统上，Android 框架强制执行了 StrictMode API 政策禁止向你的应用外公开 file:// URI。如果一项包含文件 file:// URI类型 的 Intent 离开你的应用，应用失败，并出现 <code>FileUriExposedException</code> 异常，如调用系统相机拍照录制视频，或裁切照片。</li></ul><p>这一点其实就是限制了在应用间共享文件，如果需要在应用间共享，需要授予要访问的URI临时访问权限，我们要做的就是注册<code>FileProvider</code>：</p><p>1）声明FileProvider。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">provider</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:name</span>=<span class="string">"android.support.v4.content.FileProvider"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:authorities</span>=<span class="string">"app的包名.fileProvider"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:grantUriPermissions</span>=<span class="string">"true"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:exported</span>=<span class="string">"false"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta-data</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:name</span>=<span class="string">"android.support.FILE_PROVIDER_PATHS"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:resource</span>=<span class="string">"@xml/file_paths"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">provider</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--androidx版本类路径为：androidx.core.content.FileProvider--&gt;</span></span><br></pre></td></tr></table></figure><p>2）编写xml文件，确定可访问的目录</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">paths</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span>&gt;</span></span><br><span class="line"> //代表设备的根目录new File("/");</span><br><span class="line">    <span class="tag">&lt;<span class="name">root-path</span> <span class="attr">name</span>=<span class="string">"root"</span> <span class="attr">path</span>=<span class="string">"."</span> /&gt;</span> </span><br><span class="line">    //context.getFilesDir()</span><br><span class="line">    <span class="tag">&lt;<span class="name">files-path</span> <span class="attr">name</span>=<span class="string">"files"</span> <span class="attr">path</span>=<span class="string">"."</span> /&gt;</span> </span><br><span class="line">    //context.getCacheDir()</span><br><span class="line">    <span class="tag">&lt;<span class="name">cache-path</span> <span class="attr">name</span>=<span class="string">"cache"</span> <span class="attr">path</span>=<span class="string">"."</span> /&gt;</span> </span><br><span class="line">    //Environment.getExternalStorageDirectory()</span><br><span class="line">    <span class="tag">&lt;<span class="name">external-path</span> <span class="attr">name</span>=<span class="string">"external"</span> <span class="attr">path</span>=<span class="string">"."</span> /&gt;</span></span><br><span class="line">    //context.getExternalFilesDirs()</span><br><span class="line">    <span class="tag">&lt;<span class="name">external-files-path</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">path</span>=<span class="string">"path"</span> /&gt;</span></span><br><span class="line">    //getExternalCacheDirs()</span><br><span class="line">     <span class="tag">&lt;<span class="name">external-cache-path</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">path</span>=<span class="string">"path"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">paths</span>&gt;</span></span><br></pre></td></tr></table></figure><p>3）使用FileProvider</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.N) &#123;</span><br><span class="line">    Uri uri = FileProvider.getUriForFile(CameraActivity.<span class="keyword">this</span>, <span class="string">"app的包名.fileProvider"</span>, photoFile);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    Uri uri = Uri.fromFile(photoFile);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Android8-0"><a href="#Android8-0" class="headerlink" title="Android8.0"></a>Android8.0</h1><ul><li>修改运行时权限错误</li></ul><p>在 <code>Android 8.0</code> 之前，如果应用在运行时请求权限并且被授予该权限，系统会错误地将属于同一权限组并且在清单中注册的其他权限也一起授予应用。对于针对 Android 8.0 的应用，系统只会授予应用明确请求的权限。然而，一旦用户为应用授予某个权限，则所有后续对该权限组中权限的请求都将被自动批准。</p><p>也就是说，以前你申请了<code>READ_EXTERNAL_STORAGE</code>权限，应用会同时给你授予同权限组的<code>WRITE_EXTERNAL_STORAGE</code>权限。如果Android8.0以上，只会给你授予你请求的<code>READ_EXTERNAL_STORAGE</code>权限。如果需要<code>WRITE_EXTERNAL_STORAGE</code>权限，还要单独申请，不过系统会立即授予，不会提示。</p><ul><li>修改通知</li></ul><p>Android 8.0 对于通知修改了很多，比如通知渠道、通知标志、通知超时、背景颜色。其中比较重要的就是通知渠道，其允许您为要显示的每种通知类型创建用户可自定义的渠道。</p><p>这样的好处就是对于某个应用可以把权限分成很多类，用户来控制是否显示哪些类别的通知。而开发者要做的就是必须设置这个渠道id，否则通知可能会失效。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">createNotificationChannel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.O) &#123;</span><br><span class="line"></span><br><span class="line">            NotificationManager notificationManager = (NotificationManager)</span><br><span class="line">                    getSystemService(Context.NOTIFICATION_SERVICE);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//分组（可选）</span></span><br><span class="line">            <span class="comment">//groupId要唯一</span></span><br><span class="line">            String groupId = <span class="string">"group_001"</span>;</span><br><span class="line">            NotificationChannelGroup group = <span class="keyword">new</span> NotificationChannelGroup(groupId, <span class="string">"广告"</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//创建group</span></span><br><span class="line">            notificationManager.createNotificationChannelGroup(group);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//channelId要唯一</span></span><br><span class="line">            String channelId = <span class="string">"channel_001"</span>;</span><br><span class="line"></span><br><span class="line">            NotificationChannel adChannel = <span class="keyword">new</span> NotificationChannel(channelId,</span><br><span class="line">                    <span class="string">"推广信息"</span>, NotificationManager.IMPORTANCE_DEFAULT);</span><br><span class="line">            <span class="comment">//补充channel的含义（可选）</span></span><br><span class="line">            adChannel.setDescription(<span class="string">"推广信息"</span>);</span><br><span class="line">            <span class="comment">//将渠道添加进组（先创建组才能添加）</span></span><br><span class="line">            adChannel.setGroup(groupId);</span><br><span class="line">            <span class="comment">//创建channel</span></span><br><span class="line">            notificationManager.createNotificationChannel(adChannel);</span><br><span class="line"></span><br><span class="line">   <span class="comment">//创建通知时，标记你的渠道id</span></span><br><span class="line">            Notification notification = <span class="keyword">new</span> Notification.Builder(MainActivity.<span class="keyword">this</span>, channelId)</span><br><span class="line">                    .setSmallIcon(R.mipmap.ic_launcher)</span><br><span class="line">                    .setLargeIcon(BitmapFactory.decodeResource(getResources(), R.mipmap.ic_launcher))</span><br><span class="line">                    .setContentTitle(<span class="string">"一条新通知"</span>)</span><br><span class="line">                    .setContentText(<span class="string">"这是一条测试消息"</span>)</span><br><span class="line">                    .setAutoCancel(<span class="keyword">true</span>)</span><br><span class="line">                    .build();</span><br><span class="line">            notificationManager.notify(<span class="number">1</span>, notification);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ul><li>悬浮窗</li></ul><p>Android8.0以上必须使用新的窗口类型(<code>TYPE_APPLICATION_OVERLAY</code>)才能显示提醒悬浮窗：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.O) &#123;</span><br><span class="line">    mWindowParams.type = WindowManager.LayoutParams.TYPE_APPLICATION_OVERLAY</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">    mWindowParams.type = WindowManager.LayoutParams.TYPE_SYSTEM_ALERT</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>不允许安装未知来源的应用</li></ul><p>Android 8.0去除了“允许未知来源”选项，所以如果我们的App有安装App的功能（检查更新之类的），那么会无法正常安装。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// &lt;uses-permission android:name="android.permission.REQUEST_INSTALL_PACKAGES"/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">installAPK</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.O) &#123;</span><br><span class="line">            <span class="keyword">boolean</span> hasInstallPermission = getPackageManager().canRequestPackageInstalls();</span><br><span class="line">            <span class="keyword">if</span> (hasInstallPermission) &#123;</span><br><span class="line">                <span class="comment">//安装应用</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//跳转至“安装未知应用”权限界面，引导用户开启权限</span></span><br><span class="line">                Uri selfPackageUri = Uri.parse(<span class="string">"package:"</span> + <span class="keyword">this</span>.getPackageName());</span><br><span class="line">                Intent intent = <span class="keyword">new</span> Intent(Settings.ACTION_MANAGE_UNKNOWN_APP_SOURCES, selfPackageUri);</span><br><span class="line">                startActivityForResult(intent, <span class="number">100</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//安装应用</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//接收“安装未知应用”权限的开启结果</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onActivityResult</span><span class="params">(<span class="keyword">int</span> requestCode, <span class="keyword">int</span> resultCode, Intent data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onActivityResult(requestCode, resultCode, data);</span><br><span class="line">        <span class="keyword">if</span> (requestCode == <span class="number">100</span>) &#123;</span><br><span class="line">            installAPK();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ul><li>Only fullscreen opaque activities can request orientation</li></ul><p>只有全屏不透明的<code>activity</code>才可以设置方向。这应该是个bug，在Android8.0中出现，8.1中被修复。</p><p>我们的处理办法就是要么去掉设置方向的代码，要么舍弃透明效果。</p><h1 id="Android9-0"><a href="#Android9-0" class="headerlink" title="Android9.0"></a>Android9.0</h1><ul><li>在9.0中默认情况下启用网络传输层安全协议 (TLS)，默认情况下已停用明文支持。也就是不允许使用http请求，要求使用<code>https</code>。解决办法就是添加网络安全配置：</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">application</span> <span class="attr">android:networkSecurityConfig</span>=<span class="string">"@xml/network_security_config"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">network-security-config</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">base-config</span> <span class="attr">cleartextTrafficPermitted</span>=<span class="string">"true"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">network-security-config</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--或者在AndroidManifest.xml中配置：</span></span><br><span class="line"><span class="comment">android:usesCleartextTraffic="true"</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br></pre></td></tr></table></figure><ul><li>移除Apache HTTP 客户端</li></ul><p>在6.0中取消了对<code>Apache HTTP</code> 客户端的支持，Android9.0中直接移除了该库，要使用的话需要添加配置：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">uses-library</span> <span class="attr">android:name</span>=<span class="string">"org.apache.http.legacy"</span> <span class="attr">android:required</span>=<span class="string">"false"</span>/&gt;</span></span><br></pre></td></tr></table></figure><ul><li>前台服务调用</li></ul><p>Android 9.0 要求创建一个前台服务需要请求 FOREGROUND_SERVICE 权限，否则系统会引发 SecurityException。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// &lt;uses-permission android:name="android.permission.FOREGROUND_SERVICE" /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (android.os.Build.VERSION.SDK_INT &gt;= android.os.Build.VERSION_CODES.O) &#123;</span><br><span class="line">    startForegroundService(intentService);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    startService(intentService);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>不能在非Acitivity环境中启动Activity</li></ul><p>在9.0 中，不能直接非 Activity 环境中（比如Service，Application）启动 Activity，否则会崩溃报错，解决办法就是加上<code>FLAG_ACTIVITY_NEW_TASK</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Intent intent = <span class="keyword">new</span> Intent(<span class="keyword">this</span>, TestActivity<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);</span><br><span class="line">startActivity(intent);</span><br></pre></td></tr></table></figure><h1 id="Android10"><a href="#Android10" class="headerlink" title="Android10"></a>Android10</h1><ul><li>分区存储</li></ul><p>Android10中默认开启了分区存储，也就是沙盒模式。应用只能看到本应用专有的目录（通过 <code>Context.getExternalFilesDir()</code> 访问）以及特定类型的媒体。</p><p>如果需要关闭这个功能可以配置：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">android:requestLegacyExternalStorage="true"</span><br></pre></td></tr></table></figure><p>分区存储下，访问文件的方法：</p><p>1）应用专属目录</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//分区存储空间</span></span><br><span class="line"><span class="keyword">val</span> file = File(context.filesDir, filename)</span><br><span class="line"></span><br><span class="line"><span class="comment">//应用专属外部存储空间</span></span><br><span class="line"><span class="keyword">val</span> appSpecificExternalDir = File(context.getExternalFilesDir(), filename)</span><br></pre></td></tr></table></figure><p>2）访问公共媒体目录文件</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> cursor = contentResolver.query(MediaStore.Images.Media.EXTERNAL_CONTENT_URI, <span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">null</span>, <span class="string">"<span class="subst">$&#123;MediaStore.MediaColumns.DATE_ADDED&#125;</span> desc"</span>)</span><br><span class="line"><span class="keyword">if</span> (cursor != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">while</span> (cursor.moveToNext()) &#123;</span><br><span class="line">        <span class="keyword">val</span> id = cursor.getLong(cursor.getColumnIndexOrThrow(MediaStore.MediaColumns._ID))</span><br><span class="line">        <span class="keyword">val</span> uri = ContentUris.withAppendedId(MediaStore.Images.Media.EXTERNAL_CONTENT_URI, id)</span><br><span class="line">        println(<span class="string">"image uri is <span class="variable">$uri</span>"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    cursor.close()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3）SAF(存储访问框架–Storage Access Framework)</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> intent = Intent(Intent.ACTION_OPEN_DOCUMENT)</span><br><span class="line">intent.addCategory(Intent.CATEGORY_OPENABLE)</span><br><span class="line">intent.type = <span class="string">"image/*"</span></span><br><span class="line">startActivityForResult(intent, <span class="number">100</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">@RequiresApi(Build.VERSION_CODES.KITKAT)</span></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onActivityResult</span><span class="params">(requestCode: <span class="type">Int</span>, resultCode: <span class="type">Int</span>, <span class="keyword">data</span>: <span class="type">Intent</span>?)</span></span> &#123;</span><br><span class="line">    <span class="keyword">super</span>.onActivityResult(requestCode, resultCode, <span class="keyword">data</span>)</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">data</span> == <span class="literal">null</span> || resultCode != Activity.RESULT_OK) <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">if</span> (requestCode == <span class="number">100</span>) &#123;</span><br><span class="line">        <span class="keyword">val</span> uri = <span class="keyword">data</span>.<span class="keyword">data</span></span><br><span class="line">        println(<span class="string">"image uri is <span class="variable">$uri</span>"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>权限再次升级</li></ul><p>从Android10开始普通应用不再允许请求权限android.permission.READ_PHONE_STATE。而且，无论你的App是否适配过Android Q（既targetSdkVersion是否大于等于29），均无法再获取到设备IMEI等设备信息。</p><p>如果Android10以下设备获取设备IMEI等信息，可以配置最大sdk版本：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">"android.permission.READ_PHONE_STATE"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:maxSdkVersion</span>=<span class="string">"28"</span>/&gt;</span></span><br></pre></td></tr></table></figure><h1 id="Android-11"><a href="#Android-11" class="headerlink" title="Android 11"></a>Android 11</h1><ul><li>分区存储强制执行</li></ul><p>没错，Android11强制执行分区存储，也就是沙盒模式。这次真的没有关闭功能了，离Android11出来也有一段时间了，还是抓紧适配把。</p><ul><li>修改电话权限</li></ul><p>改动了两个API：getLine1Number()和 getMsisdn() ，需要加上READ_PHONE_NUMBERS权限</p><ul><li>不允许自定义toast从后台显示了</li><li>必须加上v2签名</li><li>增加5g相关API</li><li>后台位置访问权限再次限制</li></ul><p>你一定很奇怪，为什么<code>Android11</code>的适配就这么草草收尾了？这可是我们最需要的啊？</p><p>哈哈，因为改动还是挺多的，所以给你推荐文章—<code>Android11最全适配指南</code>，应该有很多朋友都看过了：<a href="https://juejin.cn/post/6860370635664261128，或者点击文末的“阅读原文”即可。" target="_blank" rel="noopener">https://juejin.cn/post/6860370635664261128，或者点击文末的“阅读原文”即可。</a></p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://juejin.cn/post/6898176468661059597" target="_blank" rel="noopener">https://juejin.cn/post/6898176468661059597</a> <a href="https://blog.csdn.net/qq_17766199/article/details/80965631" target="_blank" rel="noopener">https://blog.csdn.net/qq_17766199/article/details/80965631</a> <a href="https://weilu.blog.csdn.net/article/details/98336225" target="_blank" rel="noopener">https://weilu.blog.csdn.net/article/details/98336225</a></p><h1 id="相关阅读"><a href="#相关阅读" class="headerlink" title="相关阅读"></a>相关阅读</h1><p><a href="http://mp.weixin.qq.com/s?__biz=MzIxNzU1Nzk3OQ==&amp;mid=2247488324&amp;idx=1&amp;sn=617d63108f012d02d426817ee62978cd&amp;chksm=97f6adf0a08124e652c7c03bfb956c6a3823a1aab4d1ace50042a2db2c76cce2c903379355b4&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">Android 适配之版本适配</a></p><p><a href="http://mp.weixin.qq.com/s?__biz=MzIxNzU1Nzk3OQ==&amp;mid=2247491967&amp;idx=1&amp;sn=631436731bd07a3f6b8dbb90ec513ce0&amp;chksm=97f55fcba082d6dd0e1180ab7d505ce4d5786d8acb4f81d44afc47360739f2e4d7d0705d1e7b&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">谷歌：未来 Android 手机将获得 4 年软件更新</a></p><p><a href="http://mp.weixin.qq.com/s?__biz=MzIxNzU1Nzk3OQ==&amp;mid=2247487853&amp;idx=1&amp;sn=1ab4a680b0d9e76f2226311f1e2ae53f&amp;chksm=97f6afd9a08126cfef73a185fd984bf8cfda36c24573134fde196fb9ade4278f5a61f4a6a14e&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">Android-图片的选择，裁剪，压缩，适配高版本</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;今天分享的面试题是：&lt;/p&gt;
&lt;p&gt;Android在版本迭代中，总会进行很多改动，那么你熟知各版本都改动了什么内容？又要怎么适配呢？&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="http://hackycy.github.io/categories/Android/"/>
    
    
      <category term="Android" scheme="http://hackycy.github.io/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>多线程NSThread基础小记</title>
    <link href="http://hackycy.github.io/2020/12/15/%E5%A4%9A%E7%BA%BF%E7%A8%8BNSThread%E5%9F%BA%E7%A1%80%E5%B0%8F%E8%AE%B0/"/>
    <id>http://hackycy.github.io/2020/12/15/多线程NSThread基础小记/</id>
    <published>2020-12-15T14:17:52.000Z</published>
    <updated>2021-05-03T11:11:23.944Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>NSThread 基于OC的API,使用其简单，面向对象操作。但线程周期由程序员管理。</p><p><strong>优点：</strong>轻量级<br><strong>缺点：</strong>需要自己管理线程的生命周期，线程同步。线程同步对数据的加锁会有一定的系统开销</p><p><strong>苹果推荐是用GCD 和 NSOperation</strong></p><a id="more"></a><blockquote><p>注意：<br> [NSThread currentThread]跟踪任务所在线程，适用于NSThread、NSOperation、GCD<br> 使用NSThread的线程，不会自动添加autoreleasepool<br> 线程中的自动释放池：<br> @autoreleasepool{}自动释放池。主线程中是有自动释放池，使用NSThread 和 NSObject 不会有。如果在后台线程中创建了autoreleasepool的对象，需要使用自动释放池，否则会出现内存泄漏。当自动释放池销毁时，对池中的所有对象发送release消息，清空自动释放池。当所有的autorelease对象，在出了作用域后，会自动添加到最近一次创建的自动释放池中。</p></blockquote><h1 id="NSThread-常用属性"><a href="#NSThread-常用属性" class="headerlink" title="NSThread 常用属性"></a>NSThread 常用属性</h1><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@property</span> (<span class="keyword">nullable</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> *name  <span class="comment">//线程名字</span></span><br><span class="line"><span class="keyword">@property</span> <span class="built_in">NSUInteger</span> stackSize  <span class="comment">//线程栈大小,默认主线程1m ,子线程512k,次属性可读写,但是写入大小必须为4k的倍数,最小为16k</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">readonly</span>) <span class="built_in">BOOL</span> isMainThread <span class="comment">// 是否是主线程</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">readonly</span>, <span class="keyword">getter</span>=isExecuting) <span class="built_in">BOOL</span> executing  <span class="comment">//是否正在执行</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">readonly</span>, <span class="keyword">getter</span>=isFinished) <span class="built_in">BOOL</span> finished  <span class="comment">//是否已经完成</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">readonly</span>, <span class="keyword">getter</span>=isCancelled) <span class="built_in">BOOL</span> cancelled  <span class="comment">//是否已经取消</span></span><br></pre></td></tr></table></figure><h1 id="NSThread类方法-作用于当前线程"><a href="#NSThread类方法-作用于当前线程" class="headerlink" title="NSThread类方法 作用于当前线程"></a>NSThread类方法 作用于当前线程</h1><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="keyword">void</span>)detachNewThreadSelector:(SEL)selector toTarget:(<span class="keyword">id</span>)target withObject:(<span class="keyword">nullable</span> <span class="keyword">id</span>)argument; <span class="comment">//开辟一个新的线程</span></span><br><span class="line">+ (<span class="keyword">void</span>)sleepUntilDate:(<span class="built_in">NSDate</span> *)date;<span class="comment">//休眠到什么时候（具体日期）</span></span><br><span class="line">+ (<span class="keyword">void</span>)sleepForTimeInterval:(<span class="built_in">NSTimeInterval</span>)ti; <span class="comment">//休眠一段时间单位秒</span></span><br><span class="line">+ (<span class="keyword">void</span>)exit; <span class="comment">//结束当前线程</span></span><br><span class="line">+ (<span class="keyword">double</span>)threadPriority; <span class="comment">//返回当前线程优先级</span></span><br><span class="line">+ (<span class="built_in">BOOL</span>)setThreadPriority:(<span class="keyword">double</span>)p; <span class="comment">//设置当前线程优先级 0.0~1.0</span></span><br><span class="line">+ (<span class="built_in">NSArray</span>&lt;<span class="built_in">NSNumber</span> *&gt; *)callStackReturnAddresses <span class="comment">//返回当前线程访问的堆栈信息</span></span><br><span class="line">+ (<span class="built_in">NSArray</span>&lt;<span class="built_in">NSString</span> *&gt; *)callStackSymbols <span class="comment">//返回一堆十六进制的地址</span></span><br><span class="line">+ (<span class="built_in">BOOL</span>)isMainThread <span class="comment">//返回当前线程是否是主线程</span></span><br><span class="line">+ (<span class="built_in">NSThread</span> *)mainThread <span class="comment">//返回主线程</span></span><br></pre></td></tr></table></figure><h1 id="NSThread实例方法"><a href="#NSThread实例方法" class="headerlink" title="NSThread实例方法"></a>NSThread实例方法</h1><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">instancetype</span>)init</span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithTarget:(<span class="keyword">id</span>)target selector:(SEL)selector object:(<span class="keyword">nullable</span> <span class="keyword">id</span>)argument </span><br><span class="line">- (<span class="keyword">void</span>)main    <span class="comment">//主方法，用于子类继承重写</span></span><br><span class="line">- (<span class="keyword">void</span>)start   <span class="comment">//开始线程</span></span><br><span class="line">- (<span class="keyword">void</span>)cancel  <span class="comment">//取消线程</span></span><br></pre></td></tr></table></figure><h1 id="NSThread-详解"><a href="#NSThread-详解" class="headerlink" title="NSThread 详解"></a>NSThread 详解</h1><h2 id="线程的生命周期"><a href="#线程的生命周期" class="headerlink" title="线程的生命周期"></a>线程的生命周期</h2><ul><li>创建线程的方法</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">instancetype</span>)initWithTarget:(<span class="keyword">id</span>)target selector:(SEL)selector object:(<span class="keyword">id</span>)argument <span class="comment">//此方法创建的线程需要手动启动</span></span><br><span class="line">+ (<span class="keyword">void</span>)detachNewThreadSelector:(SEL)selector toTarget:(<span class="keyword">id</span>)target withObject:(<span class="keyword">id</span>)argument<span class="comment">//创建线程后自动启动</span></span><br><span class="line">- (<span class="keyword">void</span>)performSelectorInBackground:(SEL)aSelector withObject:(<span class="keyword">id</span>)arg<span class="comment">//隐式创建线程并启动</span></span><br></pre></td></tr></table></figure><ul><li>配置线程</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//通过name属性设置线程名字</span></span><br><span class="line">+ (<span class="built_in">BOOL</span>)setThreadPriority:(<span class="keyword">double</span>)p设置线程的优先级</span><br></pre></td></tr></table></figure><ul><li>启动线程</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)start</span><br></pre></td></tr></table></figure><ul><li>阻塞线程</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="keyword">void</span>)sleepUntilDate:(<span class="built_in">NSDate</span> *)date</span><br><span class="line">+ (<span class="keyword">void</span>)sleepForTimeInterval:(<span class="built_in">NSTimeInterval</span>)time</span><br></pre></td></tr></table></figure><ul><li>取消线程</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)cancel <span class="comment">//当前正在执行的线程不会立刻停止</span></span><br></pre></td></tr></table></figure><ul><li>强制退出线程</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="keyword">void</span>)exit</span><br></pre></td></tr></table></figure><h2 id="NSThread的其他操作"><a href="#NSThread的其他操作" class="headerlink" title="NSThread的其他操作"></a>NSThread的其他操作</h2><ul><li>与主线程相关</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="built_in">NSThread</span> *)mainThread <span class="comment">//获取主线程</span></span><br><span class="line">+ (<span class="built_in">BOOL</span>)isMainThread<span class="comment">//判断当前线程是不是主线程</span></span><br></pre></td></tr></table></figure><ul><li>与当前线程相关</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="built_in">NSThread</span> *)currentThread <span class="comment">//获取当前线程</span></span><br></pre></td></tr></table></figure><ul><li>判断线程的状态</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">* 通过executing属性判断线程是否正在执行</span><br><span class="line">* 通过finished属性判断线程是否执行完毕</span><br><span class="line">* 通过cancelled属性判断线程是否被取消</span><br></pre></td></tr></table></figure><ul><li>线程同步</li><li>原因：多个线程访问同一资源，很可能会引起数据错乱和数据安全问题</li><li>解决方案：使用互斥锁来解决互斥资源访问问题，iOS中通常使用@synchronized(锁){}对临界资源进行锁定，通常使用self作为锁</li><li>注意：由于线程同步会消耗大量的资源，应尽量避免多个线程访问同一资源，且通常将线程同步的逻辑交由服务器端实现</li></ul><h2 id="线程之间的通信"><a href="#线程之间的通信" class="headerlink" title="线程之间的通信"></a>线程之间的通信</h2><ul><li>从子线程回到主线程</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)performSelectorOnMainThread:(SEL)aSelector withObject:(<span class="keyword">id</span>)arg waitUntilDone:(<span class="built_in">BOOL</span>)wait modes:(<span class="built_in">NSArray</span> *)array</span><br><span class="line"><span class="comment">//array指定runLoop的模式，若为空，则不执行aselector方法的调用者即为aselector的调用者</span></span><br><span class="line">- (<span class="keyword">void</span>)performSelectorOnMainThread:(SEL)aSelector withObject:(<span class="keyword">id</span>)arg waitUntilDone:(<span class="built_in">BOOL</span>)wait</span><br></pre></td></tr></table></figure><ul><li>从一个线程到另一个线程(包括主线程)</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)performSelector:(SEL)aSelector onThread:(<span class="built_in">NSThread</span> )thr withObject:(<span class="keyword">id</span>)arg waitUntilDone:(<span class="built_in">BOOL</span>)wait modes:(<span class="built_in">NSArray</span> )array</span><br><span class="line">- (<span class="keyword">void</span>)performSelector:(SEL)aSelector onThread:(<span class="built_in">NSThread</span> *)thr withObject:(<span class="keyword">id</span>)arg waitUntilDone:(<span class="built_in">BOOL</span>)wait</span><br></pre></td></tr></table></figure><p><strong>也可以通过NSPort对象实现通信</strong></p><h1 id="反思"><a href="#反思" class="headerlink" title="反思"></a>反思</h1><h2 id="资源共享"><a href="#资源共享" class="headerlink" title="资源共享"></a>资源共享</h2><ul><li>1块资源可能会被多个线程共享，也就是多个线程可能会访问同一块资源</li><li>当多个线程访问同一块资源时，很容易引发数据错乱和数据安全问题</li></ul><h2 id="解决办法互斥锁"><a href="#解决办法互斥锁" class="headerlink" title="解决办法互斥锁"></a>解决办法互斥锁</h2><ul><li>互斥锁使用格式</li></ul><blockquote><p>1.@synchronized(锁对象) { // 需要锁定的代码 }<br>2.只用一把锁,多锁是无效的</p></blockquote><ul><li>互斥锁的优缺点</li></ul><blockquote><p>优点：能有效防止因多线程抢夺资源造成的数据安全问题<br>缺点：需要消耗大量的CPU资源</p></blockquote><ul><li>互斥锁的使用前提：多条线程抢夺同一块资源</li></ul><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>摘抄自 <a href="https://www.jianshu.com/p/8c7635428599" target="_blank" rel="noopener">https://www.jianshu.com/p/8c7635428599</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;NSThread 基于OC的API,使用其简单，面向对象操作。但线程周期由程序员管理。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;优点：&lt;/strong&gt;轻量级&lt;br&gt;&lt;strong&gt;缺点：&lt;/strong&gt;需要自己管理线程的生命周期，线程同步。线程同步对数据的加锁会有一定的系统开销&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;苹果推荐是用GCD 和 NSOperation&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Ios" scheme="http://hackycy.github.io/categories/Ios/"/>
    
    
      <category term="Ios" scheme="http://hackycy.github.io/tags/Ios/"/>
    
  </entry>
  
  <entry>
    <title>Flutter解决 警告 Waiting for another flutter command to release the startup lock</title>
    <link href="http://hackycy.github.io/2020/12/14/Flutter%E8%A7%A3%E5%86%B3-%E8%AD%A6%E5%91%8A-Waiting-for-another-flutter-command-to-release-the-startup-lock/"/>
    <id>http://hackycy.github.io/2020/12/14/Flutter解决-警告-Waiting-for-another-flutter-command-to-release-the-startup-lock/</id>
    <published>2020-12-14T09:49:26.000Z</published>
    <updated>2021-05-03T11:11:23.416Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><strong>运行flutter命令的时候显示出如下警告时</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Waiting <span class="keyword">for</span> another flutter <span class="built_in">command</span> to release the startup lock</span><br></pre></td></tr></table></figure><p>当项目异常关闭，或者<code>android studio</code>用任务管理器强制关闭，下次启动就会出现上面的一行话。</p><p>此时需要打开<code>${flutter的安装目录}/bin/cache/lockfile</code>，删除就行了。</p><p>或者直接用下面的命令：<code>rm -rf ${flutter的安装目录}/bin/cache/lockfile</code></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="Flutter" scheme="http://hackycy.github.io/categories/Flutter/"/>
    
    
      <category term="Flutter" scheme="http://hackycy.github.io/tags/Flutter/"/>
    
  </entry>
  
  <entry>
    <title>package.json中的browser字段</title>
    <link href="http://hackycy.github.io/2020/12/07/package-json%E4%B8%AD%E7%9A%84browser%E5%AD%97%E6%AE%B5/"/>
    <id>http://hackycy.github.io/2020/12/07/package-json中的browser字段/</id>
    <published>2020-12-07T09:34:37.000Z</published>
    <updated>2021-05-03T11:11:23.936Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>有时候，我们想要写一个能够跑在浏览器上和node上的包，但是由于二者在执行环境上有微弱的区别，比如浏览器上请求数据是用XMLHttpRequest对象，但是node上用的确是http或者https，诸如此类的差异还有很多。这就导致了我们要为浏览器端和node端准备不同的源文件，那我们要怎么区分不同的环境呢？</p><a id="more"></a><h1 id="依赖打包器的process-browser"><a href="#依赖打包器的process-browser" class="headerlink" title="依赖打包器的process.browser"></a>依赖打包器的process.browser</h1><p>在此，以实现base64编码为例，在同一个入口文件，可以根据打包器提供的process.browser字段（在浏览器环境下为true，在node环境下为false）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (process.browser) &#123;</span><br><span class="line">    <span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span> (<span class="params">string</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> btoa(string)</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span> (<span class="params">string</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Buffer.from(string, <span class="string">'binary'</span>).toString(<span class="string">'base64'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是这种方式有一个很大的问题，打包器会在执行上诉代码中会为包引入polyfill，在这个例子中就是在浏览器中的Buffer实现<a href="https://github.com/feross/buffer" target="_blank" rel="noopener">buffer</a>。这样打包出来的体积就会很大。</p><h1 id="使用package-json的browser字段"><a href="#使用package-json的browser字段" class="headerlink" title="使用package.json的browser字段"></a>使用package.json的browser字段</h1><p><a href="https://docs.npmjs.com/files/package.json" target="_blank" rel="noopener">npm doc</a>上的解释如下</p><blockquote><p>If your module is meant to be used client-side the browser field should be used instead of the main field. This is helpful to hint users that it might rely on primitives that aren’t available in Node.js modules. (e.g. window)</p></blockquote><p>总而言之就是在浏览器环境下用来替换main字段，包的作者可以通过browser字段提示包中要替换掉哪些模块或者要替换掉哪些源文件的实现。</p><p>browser的用法有以下几种</p><h2 id="browser为某一个单个的字符串"><a href="#browser为某一个单个的字符串" class="headerlink" title="browser为某一个单个的字符串"></a>browser为某一个单个的字符串</h2><p>替换main成为浏览器环境的入口文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;browser&quot;: &quot;./lib/browser/main.js&quot;</span><br></pre></td></tr></table></figure><h2 id="browser为一个对象，声明要替换或者忽略的文件"><a href="#browser为一个对象，声明要替换或者忽略的文件" class="headerlink" title="browser为一个对象，声明要替换或者忽略的文件"></a>browser为一个对象，声明要替换或者忽略的文件</h2><p>这种形式比较适合替换部分文件，不需要创建新的入口。key是要替换的module或者文件名，右侧是替换的</p>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;browser&quot;: &#123;&quot;module-a&quot;: &quot;./browser/module-a.js&quot;,&quot;./server/module-b.js&quot;: &quot;./browser/module-b.js&quot;&#125;</span><br></pre></td></tr></table></figure><p>打包器在打包到浏览器环境时，会将来自<code>module-a</code>的替换为<code>./browser/module-a.js</code>。将文件’./server/module-b.js’的引入替换为<code>./browser/module-b.js</code>。</p><p>还可以使用布尔值防止将module加载到包中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;browser&quot;: &#123;&quot;module-a&quot;:false,&quot;./server/only.js&quot;:&quot;./shims/server-only.js&quot;&#125;</span><br></pre></td></tr></table></figure><p>这种写法<code>module-a</code>在浏览器环境中将不会被打包。</p><p>上面的所有写法的路径都是基于<code>package.json</code>文件地址。</p><p><strong>需要注意的是如果你的包能在浏览器和node上无差异化地实现，就不需要browser字段了。</strong></p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://zhuanlan.zhihu.com/p/25215447" target="_blank" rel="noopener">[译] 怎样写一个能同时用于 Node 和浏览器的 JavaScript 包？</a></p><p><a href="https://juejin.im/post/5cfe6d3be51d454d544abf30" target="_blank" rel="noopener">package.json 中 你还不清楚的 browser，module，main 字段优先级</a></p><p><a href="https://www.helplib.com/GitHub/article_134305" target="_blank" rel="noopener">package-browser-field-spec, 在 package.json 中，’browser’字段的规范文档</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;有时候，我们想要写一个能够跑在浏览器上和node上的包，但是由于二者在执行环境上有微弱的区别，比如浏览器上请求数据是用XMLHttpRequest对象，但是node上用的确是http或者https，诸如此类的差异还有很多。这就导致了我们要为浏览器端和node端准备不同的源文件，那我们要怎么区分不同的环境呢？&lt;/p&gt;
    
    </summary>
    
      <category term="NodeJS" scheme="http://hackycy.github.io/categories/NodeJS/"/>
    
    
      <category term="NodeJS" scheme="http://hackycy.github.io/tags/NodeJS/"/>
    
      <category term="Package.json" scheme="http://hackycy.github.io/tags/Package-json/"/>
    
  </entry>
  
  <entry>
    <title>发布npm包填坑小记</title>
    <link href="http://hackycy.github.io/2020/09/21/%E5%8F%91%E5%B8%83npm%E5%8C%85%E5%A1%AB%E5%9D%91%E5%B0%8F%E8%AE%B0/"/>
    <id>http://hackycy.github.io/2020/09/21/发布npm包填坑小记/</id>
    <published>2020-09-21T11:09:24.000Z</published>
    <updated>2021-05-03T11:11:23.940Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><strong>发布NPM包时遇到的一些问题记录</strong></p><h1 id="问题1"><a href="#问题1" class="headerlink" title="问题1"></a>问题1</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm ERR! publish Failed PUT 403</span><br><span class="line">npm ERR! code E403</span><br><span class="line">npm ERR! you must verify your email before publishing a new package: https://www.npmjs.com/email-edit : your-package</span><br></pre></td></tr></table></figure><p>这是注册的npm账号邮箱未进行验证，先去验证。一开始出现这个原因我是邮箱填错一直没收到邮件。</p><a id="more"></a><h1 id="问题2"><a href="#问题2" class="headerlink" title="问题2"></a>问题2</h1><p>在发布<code>npm</code>包的时候可能会出现报错信息：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm ERR! 403 403 Forbidden - PUT https://registry.npm.taobao.org/@hackycy%2fegg-typeorm - [no_perms] Private mode <span class="built_in">enable</span>, only admin can publish this module</span><br><span class="line">npm ERR! 403 In most cases, you or one of your dependencies are requesting</span><br><span class="line">npm ERR! 403 a package version that is forbidden by your security policy.</span><br></pre></td></tr></table></figure><p>出现这个问题是因为当前设置的是<code>cnpm</code>登录到的是<code>cnpm</code>，所以需要切换回来。<br>之前登录的时候就提出登录的是<code>taobao</code>只不过那个时候没注意。</p><p>可以输入一下命令查看当前的登录源：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ npm config get registry</span><br><span class="line">https://registry.npm.taobao.org/</span><br></pre></td></tr></table></figure><p>可以看到返回的地址是淘宝源，需要切回到npmjs源，输入以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm config <span class="built_in">set</span> registry=http://registry.npmjs.org</span><br></pre></td></tr></table></figure><p>设置完之后在查看当前登录的源地址：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ npm config get registry</span><br><span class="line">http://registry.npmjs.org/</span><br></pre></td></tr></table></figure><p>然后重新<code>npm login</code>再发布即可。</p><h1 id="问题3"><a href="#问题3" class="headerlink" title="问题3"></a>问题3</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm ERR! publish Failed PUT 403</span><br><span class="line">npm ERR! code E403</span><br><span class="line">npm ERR! You <span class="keyword">do</span> not have permission to publish <span class="string">"your-package"</span>. Are you logged <span class="keyword">in</span> as the correct user? : your-package</span><br></pre></td></tr></table></figure><p>你的包和别人的包重名了，npm 里的包不允许重名，所以去 <a href="https://links.jianshu.com/go?to=https%3A%2F%2Fwww.npmjs.com%2F" target="_blank" rel="noopener">npm</a> 搜一下，改个没人用的名字就可以了。或者用<code>@your-name/your-package</code>来命名。</p><h1 id="问题4"><a href="#问题4" class="headerlink" title="问题4"></a>问题4</h1><p>无法发布私有包：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm ERR! publish Failed PUT 402</span><br><span class="line">npm ERR! code E402</span><br><span class="line">npm ERR! You must sign up <span class="keyword">for</span> private packages :</span><br></pre></td></tr></table></figure><p>大多数是因为当你的包名为<code>@your-name/your-package</code>时才会出现，原因是当包名以<code>@your-name</code>开头时，<code>npm publish</code>会默认发布为私有包，但是 npm 的私有包需要付费，所以需要添加如下参数进行发布：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm publish --access public</span><br></pre></td></tr></table></figure><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://blog.csdn.net/weixin_38080573/article/details/88080556" target="_blank" rel="noopener">https://blog.csdn.net/weixin_38080573/article/details/88080556</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;发布NPM包时遇到的一些问题记录&lt;/strong&gt;&lt;/p&gt;
&lt;h1 id=&quot;问题1&quot;&gt;&lt;a href=&quot;#问题1&quot; class=&quot;headerlink&quot; title=&quot;问题1&quot;&gt;&lt;/a&gt;问题1&lt;/h1&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;npm ERR! publish Failed PUT 403&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;npm ERR! code E403&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;npm ERR! you must verify your email before publishing a new package: https://www.npmjs.com/email-edit : your-package&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这是注册的npm账号邮箱未进行验证，先去验证。一开始出现这个原因我是邮箱填错一直没收到邮件。&lt;/p&gt;
    
    </summary>
    
      <category term="NodeJS" scheme="http://hackycy.github.io/categories/NodeJS/"/>
    
    
      <category term="NPM" scheme="http://hackycy.github.io/tags/NPM/"/>
    
  </entry>
  
  <entry>
    <title>解决Element-UI el-tree有关子、父节点选中问题</title>
    <link href="http://hackycy.github.io/2020/09/15/%E8%A7%A3%E5%86%B3Element-UI-el-tree%E6%9C%89%E5%85%B3%E5%AD%90%E3%80%81%E7%88%B6%E8%8A%82%E7%82%B9%E9%80%89%E4%B8%AD%E9%97%AE%E9%A2%98/"/>
    <id>http://hackycy.github.io/2020/09/15/解决Element-UI-el-tree有关子、父节点选中问题/</id>
    <published>2020-09-15T17:23:07.000Z</published>
    <updated>2021-05-03T11:11:23.984Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="问题1"><a href="#问题1" class="headerlink" title="问题1"></a>问题1</h1><p>在使用el-tree组件在获取完数据进行页面回显数据时，因为后端返回的数据中包含父节点的关系，但是子节点并没有全部选中，就把不该选中的子节点也全部勾上了。</p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><ul><li><p>isLeaf（判断节点是否为叶子节点）</p></li><li><p>getNode（获取tree中对应的节点）</p></li><li><p>setChecked （设置tree中对应的节点为选中状态）</p></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> res = [<span class="number">1</span>,<span class="number">11</span>,<span class="number">23</span>,<span class="number">25</span>,<span class="number">28</span>,<span class="number">37</span>];</span><br><span class="line">res.map(<span class="function">(<span class="params">i, n</span>) =&gt;</span> &#123;     </span><br><span class="line">     <span class="comment">//根据i获取tree中的节点     </span></span><br><span class="line">     <span class="keyword">const</span> node = that.$refs.menuListTree.getNode(i);     </span><br><span class="line">     <span class="keyword">if</span> (node &amp;&amp; node.isLeaf) &#123;          </span><br><span class="line">         <span class="comment">//设置某个节点的勾选状态          </span></span><br><span class="line">         that.$refs.menuListTree.setChecked(node, <span class="literal">true</span>);      </span><br><span class="line">     &#125;</span><br><span class="line"> &#125;);</span><br></pre></td></tr></table></figure><a id="more"></a><blockquote><p>注意，手动更新节点后无需在用回显数据赋值给data中绑定的值，否则会无效</p></blockquote><h1 id="问题2"><a href="#问题2" class="headerlink" title="问题2"></a>问题2</h1><p>在获取选择的节点数据时，子节点未全部选中时，<code>getCheckedKeys</code>中没有包含父节点id。</p><h2 id="解决方案-1"><a href="#解决方案-1" class="headerlink" title="解决方案"></a><strong>解决方案</strong></h2><ul><li>halfCheckedKeys中为半选中的节点（具体可查看官方API）</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">getCheckedKeys() &#123;  </span><br><span class="line"><span class="keyword">const</span> childKeys = <span class="keyword">this</span>.$refs.menuListTree.getCheckedKeys()</span><br><span class="line">  <span class="keyword">const</span> halfKeys = <span class="keyword">this</span>.$refs.menuListTree.getHalfCheckedKeys()</span><br><span class="line">  <span class="keyword">return</span> [...childKeys, ...halfKeys]</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><h1 id="文档"><a href="#文档" class="headerlink" title="文档"></a>文档</h1><p><a href="https://element.eleme.cn/#/zh-CN/component/tree" target="_blank" rel="noopener">https://element.eleme.cn/#/zh-CN/component/tree</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;问题1&quot;&gt;&lt;a href=&quot;#问题1&quot; class=&quot;headerlink&quot; title=&quot;问题1&quot;&gt;&lt;/a&gt;问题1&lt;/h1&gt;&lt;p&gt;在使用el-tree组件在获取完数据进行页面回显数据时，因为后端返回的数据中包含父节点的关系，但是子节点并没有全部选中，就把不该选中的子节点也全部勾上了。&lt;/p&gt;
&lt;h2 id=&quot;解决方案&quot;&gt;&lt;a href=&quot;#解决方案&quot; class=&quot;headerlink&quot; title=&quot;解决方案&quot;&gt;&lt;/a&gt;解决方案&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;isLeaf（判断节点是否为叶子节点）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;getNode（获取tree中对应的节点）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;setChecked （设置tree中对应的节点为选中状态）&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; res = [&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;11&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;23&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;25&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;28&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;37&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;res.map(&lt;span class=&quot;function&quot;&gt;(&lt;span class=&quot;params&quot;&gt;i, n&lt;/span&gt;) =&amp;gt;&lt;/span&gt; &amp;#123;     &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     &lt;span class=&quot;comment&quot;&gt;//根据i获取tree中的节点     &lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     &lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; node = that.$refs.menuListTree.getNode(i);     &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (node &amp;amp;&amp;amp; node.isLeaf) &amp;#123;          &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;         &lt;span class=&quot;comment&quot;&gt;//设置某个节点的勾选状态          &lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;         that.$refs.menuListTree.setChecked(node, &lt;span class=&quot;literal&quot;&gt;true&lt;/span&gt;);      &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="Vue" scheme="http://hackycy.github.io/categories/Vue/"/>
    
    
      <category term="Element-UI" scheme="http://hackycy.github.io/tags/Element-UI/"/>
    
  </entry>
  
  <entry>
    <title>egg-core源码分析</title>
    <link href="http://hackycy.github.io/2020/08/26/egg-core%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    <id>http://hackycy.github.io/2020/08/26/egg-core源码分析/</id>
    <published>2020-08-26T11:17:20.000Z</published>
    <updated>2021-05-03T11:11:23.928Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>最近在翻查<a href="https://www.npmjs.com/package/egg-cool-router" target="_blank" rel="noopener">egg-cool-router</a>源码查看如何使用装饰器来注册egg路由，看到了一些很牛逼的操作，想知道为什么就查了一下关于源码讲解的文章，解惑了所以摘抄了下来。</p><a id="more"></a><h1 id="egg-core是什么"><a href="#egg-core是什么" class="headerlink" title="egg-core是什么"></a>egg-core是什么</h1><h2 id="应用、框架、插件之间的关系"><a href="#应用、框架、插件之间的关系" class="headerlink" title="应用、框架、插件之间的关系"></a>应用、框架、插件之间的关系</h2><p>在学习egg-core是什么之前，我们先了解一下关于Egg框架中应用，框架，插件这三个概念及其之间的关系：</p><ul><li>一个应用必须指定一个框架才能运行起来，根据需要我们可以给一个应用配置多个不同的插件</li><li>插件只完成特定独立的功能，实现即插即拔的效果</li><li>框架是一个启动器，必须有它才能运行起来。框架还是一个封装器，它可以在已有框架的基础上进行封装，框架也可以配置插件，其中Egg，EggCore都是框架</li><li>在框架的基础上还可以扩展出新的框架，也就是说框架是可以无限级继承的，有点像类的继承</li><li>框架/应用/插件的关于service/controler/config/middleware的目录结构配置基本相同，称之为加载单元（loadUnit），包括后面源码分析中的getLoadUnits都是为了获取这个结构</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"># 加载单元的目录结构如下图，其中插件和框架没有controller和router.js</span><br><span class="line"># 这个目录结构很重要，后面所有的load方法都是针对这个目录结构进行的</span><br><span class="line">        loadUnit</span><br><span class="line">        ├── package.json</span><br><span class="line">        ├── app</span><br><span class="line">        │   ├── extend</span><br><span class="line">        │   |   ├── helper.js</span><br><span class="line">        │   |   ├── request.js</span><br><span class="line">        │   |   ├── response.js</span><br><span class="line">        │   |   ├── context.js</span><br><span class="line">        │   |   ├── application.js</span><br><span class="line">        │   |   └── agent.js</span><br><span class="line">        │   ├── service</span><br><span class="line">        |   ├── controller</span><br><span class="line">        │   ├── middleware</span><br><span class="line">        │   └── router.js</span><br><span class="line">        └── config</span><br><span class="line">            ├── config.default.js</span><br><span class="line">            ├── config.prod.js</span><br><span class="line">            ├── config.test.js</span><br><span class="line">            ├── config.local.js</span><br><span class="line">            └── config.unittest.js</span><br></pre></td></tr></table></figure><h2 id="eggCore的主要工作"><a href="#eggCore的主要工作" class="headerlink" title="eggCore的主要工作"></a>eggCore的主要工作</h2><p>egg.js的大部分核心代码实现都在<a href="https://github.com/eggjs/egg-core" target="_blank" rel="noopener">egg-core库</a>中，egg-core主要export四个对象:</p><ul><li>EggCore类：继承于Koa，做一些初始化工作，EggCore中最主要的一个属性是loader，也就是egg-core的导出的第二个类EggLoader的实例</li><li>EggLoader类：整个框架目录结构（controller，service，middleware，extend，route.js）的加载和初始化工作都在该类中实现的，主要提供了几个load函数(loadPlugin,loadConfig,loadMiddleware,loadService,loadController,loadRouter等)，这些函数会根据指定目录结构下文件输出形式不同进行适配，最终挂载输出内容。</li><li>BaseContextClass类：这个类主要是为了我们在使用框架开发时，在controller和service作为基类使用，只有继承了该类，我们才可以通过this.ctx获取到当前请求的上下文对象</li><li>utils对象：几个主要的函数，包括转换成中间件函数middleware，根据不同类型文件获取文件导出内容函数loadFile等</li></ul><p>所以egg-core做的主要事情就是根据loadUnit的目录结构规范，将目录结构中的config，controller，service，middleware，plugin，router等文件load到app或者context上，开发人员只要按照这套约定规范，就可以很方便进行开发，以下是EggCore的exports对象源码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//egg-core源码 -&gt; index文件导出的数据结构</span></span><br><span class="line"><span class="keyword">const</span> EggCore = <span class="built_in">require</span>(<span class="string">'./lib/egg'</span>);</span><br><span class="line"><span class="keyword">const</span> EggLoader = <span class="built_in">require</span>(<span class="string">'./lib/loader/egg_loader'</span>);</span><br><span class="line"><span class="keyword">const</span> BaseContextClass = <span class="built_in">require</span>(<span class="string">'./lib/utils/base_context_class'</span>);</span><br><span class="line"><span class="keyword">const</span> utils = <span class="built_in">require</span>(<span class="string">'./lib/utils'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  EggCore,</span><br><span class="line">  EggLoader,</span><br><span class="line">  BaseContextClass,</span><br><span class="line">  utils,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="EggLoader的具体实现源码学习"><a href="#EggLoader的具体实现源码学习" class="headerlink" title="EggLoader的具体实现源码学习"></a>EggLoader的具体实现源码学习</h3><h4 id="EggCore类源码学习"><a href="#EggCore类源码学习" class="headerlink" title="EggCore类源码学习"></a>EggCore类源码学习</h4><p>EggCore类是算是上文提到的框架范畴，它从Koa类继承而来，并做了一些初始化工作，其中有三个主要属性是：</p><ul><li>loader：这个对象是EggLoader的实例，定义了多个load函数，用于对loadUnit目录下的文件进行加载，后面后专门讲这个类的是实现</li><li>router：是EggRouter类的实例，从<a href="https://github.com/alexmingoia/koa-router" target="_blank" rel="noopener">koa-router</a>继承而来，用于egg框架的路由管理和分发，这个类的实现在后面的loadRouter函数会有说明</li><li>lifecycle：这个属性用于app的生命周期管理，由于和整个文件加载逻辑关系不大，所以这里不作说明</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//egg-core源码 -&gt; EggCore类的部分实现</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> KoaApplication = <span class="built_in">require</span>(<span class="string">'koa'</span>);</span><br><span class="line"><span class="keyword">const</span> EGG_LOADER = <span class="built_in">Symbol</span>.for(<span class="string">'egg#loader'</span>);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EggCore</span> <span class="keyword">extends</span> <span class="title">KoaApplication</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(options = &#123;&#125;) &#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        <span class="keyword">const</span> Loader = <span class="keyword">this</span>[EGG_LOADER];</span><br><span class="line">        <span class="comment">//初始化loader对象</span></span><br><span class="line">        <span class="keyword">this</span>.loader = <span class="keyword">new</span> Loader(&#123;</span><br><span class="line">            baseDir: options.baseDir,          <span class="comment">//项目启动的根目录</span></span><br><span class="line">            app: <span class="keyword">this</span>,                         <span class="comment">//EggCore实例本身</span></span><br><span class="line">            plugins: options.plugins,          <span class="comment">//自定义插件配置信息，设置插件配置信息有多种方式，后面我们会讲</span></span><br><span class="line">            logger: <span class="keyword">this</span>.console,             </span><br><span class="line">            serverScope: options.serverScope, </span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">get</span> [EGG_LOADER]() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">require</span>(<span class="string">'./loader/egg_loader'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//router对象</span></span><br><span class="line">    <span class="keyword">get</span> router() &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>[ROUTER]) &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">this</span>[ROUTER];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">const</span> router = <span class="keyword">this</span>[ROUTER] = <span class="keyword">new</span> Router(&#123; <span class="attr">sensitive</span>: <span class="literal">true</span> &#125;, <span class="keyword">this</span>);</span><br><span class="line">        <span class="comment">// register router middleware</span></span><br><span class="line">        <span class="keyword">this</span>.beforeStart(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">this</span>.use(router.middleware());</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> router;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//生命周期对象初始化</span></span><br><span class="line">    <span class="keyword">this</span>.lifecycle = <span class="keyword">new</span> Lifecycle(&#123;</span><br><span class="line">        baseDir: options.baseDir,</span><br><span class="line">        app: <span class="keyword">this</span>,</span><br><span class="line">        logger: <span class="keyword">this</span>.console,</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="EggLoader类源码学习"><a href="#EggLoader类源码学习" class="headerlink" title="EggLoader类源码学习"></a>EggLoader类源码学习</h4><p>如果说eggCore是egg框架的精华所在，那么eggLoader可以说是eggCore的精华所在，下面我们主要从EggLoader的实现细节开始学习eggCore这个库：</p><p>EggLoader首先对app中的一些基本信息（pkg/eggPaths/serverEnv/appInfo/serverScope/baseDir等）进行整理，并且定义一些基础共用函数(getEggPaths/getTypeFiles/getLoadUnits/loadFile)，所有的这些基础准备都是为了后面介绍的几个load函数作准备，我们下面看一下其基础部分的实现：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//egg-core源码 -&gt; EggLoader中基本属性和基本函数的实现</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EggLoader</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(options) &#123;</span><br><span class="line">        <span class="keyword">this</span>.options = options;</span><br><span class="line">        <span class="keyword">this</span>.app = <span class="keyword">this</span>.options.app;</span><br><span class="line">        <span class="comment">//pkg是根目录的package.json输出对象</span></span><br><span class="line">        <span class="keyword">this</span>.pkg = utility.readJSONSync(path.join(<span class="keyword">this</span>.options.baseDir, <span class="string">'package.json'</span>));</span><br><span class="line">        <span class="comment">//eggPaths是所有框架目录的集合体，虽然我们上面提到一个应用只有一个框架，但是框架可以在框架的基础上实现多级继承，所以是多个eggPath</span></span><br><span class="line">        <span class="comment">//在实现框架类的时候，必须指定属性Symbol.for('egg#eggPath')，这样才能找到框架的目录结构</span></span><br><span class="line">        <span class="comment">//下面有关于getEggPaths函数的实现分析</span></span><br><span class="line">        <span class="keyword">this</span>.eggPaths = <span class="keyword">this</span>.getEggPaths();</span><br><span class="line">        <span class="keyword">this</span>.serverEnv = <span class="keyword">this</span>.getServerEnv();</span><br><span class="line">        <span class="comment">//获取app的一些基本配置信息(name,baseDir,env,scope,pkg等)</span></span><br><span class="line">        <span class="keyword">this</span>.appInfo = <span class="keyword">this</span>.getAppInfo();</span><br><span class="line">        <span class="keyword">this</span>.serverScope = options.serverScope !== <span class="literal">undefined</span></span><br><span class="line">            ? options.serverScope</span><br><span class="line">            : <span class="keyword">this</span>.getServerScope();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//递归获取继承链上所有eggPath</span></span><br><span class="line">    getEggPaths() &#123;</span><br><span class="line">        <span class="keyword">const</span> EggCore = <span class="built_in">require</span>(<span class="string">'../egg'</span>);</span><br><span class="line">        <span class="keyword">const</span> eggPaths = [];</span><br><span class="line">        <span class="keyword">let</span> proto = <span class="keyword">this</span>.app;</span><br><span class="line">        <span class="comment">//循环递归的获取原型链上的框架Symbol.for('egg#eggPath')属性</span></span><br><span class="line">        <span class="keyword">while</span> (proto) &#123;</span><br><span class="line">            proto = <span class="built_in">Object</span>.getPrototypeOf(proto);</span><br><span class="line">            <span class="comment">//直到proto属性等于EggCore本身，说明到了最上层的框架类，停止循环</span></span><br><span class="line">            <span class="keyword">if</span> (proto === <span class="built_in">Object</span>.prototype || proto === EggCore.prototype) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">const</span> eggPath = proto[<span class="built_in">Symbol</span>.for(<span class="string">'egg#eggPath'</span>)];</span><br><span class="line">            <span class="keyword">const</span> realpath = fs.realpathSync(eggPath);</span><br><span class="line">            <span class="keyword">if</span> (!eggPaths.includes(realpath)) &#123;</span><br><span class="line">                eggPaths.unshift(realpath);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> eggPaths;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//函数输入：config或者plugin；函数输出：当前环境下的所有配置文件</span></span><br><span class="line">    <span class="comment">//该函数会根据serverScope，serverEnv的配置信息，返回当前环境对应filename的所有配置文件</span></span><br><span class="line">    <span class="comment">//比如我们的serverEnv=prod，serverScope=online，那么返回的config配置文件是['config.default', 'config.prod', 'config.online_prod']</span></span><br><span class="line">    <span class="comment">//这几个文件加载顺序非常重要，因为最终获取到的config信息会进行深度的覆盖，后面的文件信息会覆盖前面的文件信息</span></span><br><span class="line">    getTypeFiles(filename) &#123;</span><br><span class="line">        <span class="keyword">const</span> files = [ <span class="string">`<span class="subst">$&#123;filename&#125;</span>.default`</span> ];</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.serverScope) files.push(<span class="string">`<span class="subst">$&#123;filename&#125;</span>.<span class="subst">$&#123;<span class="keyword">this</span>.serverScope&#125;</span>`</span>);</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.serverEnv === <span class="string">'default'</span>) <span class="keyword">return</span> files;</span><br><span class="line"></span><br><span class="line">        files.push(<span class="string">`<span class="subst">$&#123;filename&#125;</span>.<span class="subst">$&#123;<span class="keyword">this</span>.serverEnv&#125;</span>`</span>);</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.serverScope) files.push(<span class="string">`<span class="subst">$&#123;filename&#125;</span>.<span class="subst">$&#123;<span class="keyword">this</span>.serverScope&#125;</span>_<span class="subst">$&#123;<span class="keyword">this</span>.serverEnv&#125;</span>`</span>);</span><br><span class="line">        <span class="keyword">return</span> files;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//获取框架、应用、插件的loadUnits目录集合，上文有关于loadUnits的说明</span></span><br><span class="line">    <span class="comment">//这个函数在下文中介绍的loadSerivce,loadMiddleware,loadConfig,loadExtend中都会用到，因为plugin，framework，app中都会有关系这些信息的配置</span></span><br><span class="line">    getLoadUnits() &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.dirs) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.dirs;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">const</span> dirs = <span class="keyword">this</span>.dirs = [];</span><br><span class="line">        <span class="comment">//插件目录，关于orderPlugins会在后面的loadPlugin函数中讲到</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.orderPlugins) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">const</span> plugin <span class="keyword">of</span> <span class="keyword">this</span>.orderPlugins) &#123;</span><br><span class="line">                dirs.push(&#123;</span><br><span class="line">                    path: plugin.path,</span><br><span class="line">                    type: <span class="string">'plugin'</span>,</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//框架目录</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> eggPath <span class="keyword">of</span> <span class="keyword">this</span>.eggPaths) &#123;</span><br><span class="line">            dirs.push(&#123;</span><br><span class="line">                path: eggPath,</span><br><span class="line">                type: <span class="string">'framework'</span>,</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//应用目录</span></span><br><span class="line">        dirs.push(&#123;</span><br><span class="line">            path: <span class="keyword">this</span>.options.baseDir,</span><br><span class="line">            type: <span class="string">'app'</span>,</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> dirs;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这个函数用于读取某个LoadUnit下的文件具体内容，包括js文件，json文件及其它普通文件</span></span><br><span class="line">    loadFile(filepath, ...inject) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!filepath || !fs.existsSync(filepath)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (inject.length === <span class="number">0</span>) inject = [ <span class="keyword">this</span>.app ];</span><br><span class="line">        <span class="keyword">let</span> ret = <span class="keyword">this</span>.requireFile(filepath);</span><br><span class="line">        <span class="comment">//这里要注意，如果某个js文件导出的是一个函数，且不是一个Class，那么Egg认为这个函数的格式是：app =&gt; &#123;&#125;,输入是EggCore实例，输出是真正需要的信息</span></span><br><span class="line">        <span class="keyword">if</span> (is<span class="function">.<span class="keyword">function</span>(<span class="params">ret</span>) &amp;&amp; !<span class="title">is</span>.<span class="title">class</span>(<span class="params">ret</span>)) </span>&#123;</span><br><span class="line">            ret = ret(...inject);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="各种loader函数的实现源码分析"><a href="#各种loader函数的实现源码分析" class="headerlink" title="各种loader函数的实现源码分析"></a>各种loader函数的实现源码分析</h3><p>上文中只是介绍了EggLoader中的一些基本属性和函数，那么如何将LoadUnits中的不同类型的文件分别加载进来呢，egg-core中每一种类型（service/controller等）的文件加载都在一个独立的文件里实现。比如我们加载controller文件可以通过’./mixin/controller’目录下的loadController完成，加载service文件可以通过’./mixin/service’下的loadService函数完成，然后将这些方法挂载EggLoader的原型上，这样就可以直接在EggLoader的实例上使用</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//egg-core源码 -&gt; 混入不同目录文件的加载方法到EggLoader的原型上</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> loaders = [</span><br><span class="line">  <span class="built_in">require</span>(<span class="string">'./mixin/plugin'</span>),            <span class="comment">//loadPlugin方法</span></span><br><span class="line">  <span class="built_in">require</span>(<span class="string">'./mixin/config'</span>),            <span class="comment">//loadConfig方法</span></span><br><span class="line">  <span class="built_in">require</span>(<span class="string">'./mixin/extend'</span>),            <span class="comment">//loadExtend方法</span></span><br><span class="line">  <span class="built_in">require</span>(<span class="string">'./mixin/custom'</span>),            <span class="comment">//loadCustomApp和loadCustomAgent方法</span></span><br><span class="line">  <span class="built_in">require</span>(<span class="string">'./mixin/service'</span>),           <span class="comment">//loadService方法</span></span><br><span class="line">  <span class="built_in">require</span>(<span class="string">'./mixin/middleware'</span>),        <span class="comment">//loadMiddleware方法</span></span><br><span class="line">  <span class="built_in">require</span>(<span class="string">'./mixin/controller'</span>),        <span class="comment">//loadController方法</span></span><br><span class="line">  <span class="built_in">require</span>(<span class="string">'./mixin/router'</span>),            <span class="comment">//loadRouter方法</span></span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> loader <span class="keyword">of</span> loaders) &#123;</span><br><span class="line">  <span class="built_in">Object</span>.assign(EggLoader.prototype, loader);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们按照上述loaders中定义的元素顺序，对各个load函数的源码实现进行一一分析：</p><h4 id="loadPlugin函数"><a href="#loadPlugin函数" class="headerlink" title="loadPlugin函数"></a>loadPlugin函数</h4><p>插件是一个迷你的应用，没有包含router.js和controller文件夹，我们上文也提到，应用和框架里都可以包含插件，而且还可以通过环境变量和初始化参数传入，关于插件初始化的几个参数：</p><ul><li>enable： 是否开启插件</li><li>env： 选择插件在哪些环境运行</li><li>path： 插件的所在路径</li><li>package： 和path只能设置其中一个，根据package名称去node_modules里查询plugin，后面源码里有详细说明</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//egg-core源码 -&gt; loadPlugin函数部分源码</span></span><br><span class="line"></span><br><span class="line">loadPlugin() &#123;</span><br><span class="line">    <span class="comment">//加载应用目录下的plugins</span></span><br><span class="line">    <span class="comment">//readPluginConfigs这个函数会先调用我们上文提到的getTypeFiles获取到app目录下所有的plugin文件名，然后按照文件顺序进行加载并合并，并规范plugin的数据结构</span></span><br><span class="line">    <span class="keyword">const</span> appPlugins = <span class="keyword">this</span>.readPluginConfigs(path.join(<span class="keyword">this</span>.options.baseDir, <span class="string">'config/plugin.default'</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//加载框架目录下的plugins</span></span><br><span class="line">    <span class="keyword">const</span> eggPluginConfigPaths = <span class="keyword">this</span>.eggPaths.map(<span class="function"><span class="params">eggPath</span> =&gt;</span> path.join(eggPath, <span class="string">'config/plugin.default'</span>));</span><br><span class="line">    <span class="keyword">const</span> eggPlugins = <span class="keyword">this</span>.readPluginConfigs(eggPluginConfigPaths);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//可以通过环境变量EGG_PLUGINS对配置plugins，从环境变量加载plugins</span></span><br><span class="line">    <span class="keyword">let</span> customPlugins;</span><br><span class="line">    <span class="keyword">if</span> (process.env.EGG_PLUGINS) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        customPlugins = <span class="built_in">JSON</span>.parse(process.env.EGG_PLUGINS);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">        debug(<span class="string">'parse EGG_PLUGINS failed, %s'</span>, e);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//从启动参数options里加载plugins</span></span><br><span class="line">    <span class="comment">//启动参数的plugins和环境变量的plugins都是自定义的plugins，可以对默认的应用和框架plugin进行覆盖</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.options.plugins) &#123;</span><br><span class="line">      customPlugins = <span class="built_in">Object</span>.assign(&#123;&#125;, customPlugins, <span class="keyword">this</span>.options.plugins);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.allPlugins = &#123;&#125;;</span><br><span class="line">    <span class="keyword">this</span>.appPlugins = appPlugins;</span><br><span class="line">    <span class="keyword">this</span>.customPlugins = customPlugins;</span><br><span class="line">    <span class="keyword">this</span>.eggPlugins = eggPlugins;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//按照顺序对plugin进行合并及覆盖</span></span><br><span class="line">    <span class="comment">//_extendPlugins在合并的过程中，对相同name的plugin中的属性进行覆盖，有一个特殊处理的地方，如果某个属性的值是空数组，那么不会覆盖前者</span></span><br><span class="line">    <span class="keyword">this</span>._extendPlugins(<span class="keyword">this</span>.allPlugins, eggPlugins);</span><br><span class="line">    <span class="keyword">this</span>._extendPlugins(<span class="keyword">this</span>.allPlugins, appPlugins);</span><br><span class="line">    <span class="keyword">this</span>._extendPlugins(<span class="keyword">this</span>.allPlugins, customPlugins);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> enabledPluginNames = []; <span class="comment">// enabled plugins that configured explicitly</span></span><br><span class="line">    <span class="keyword">const</span> plugins = &#123;&#125;;</span><br><span class="line">    <span class="keyword">const</span> env = <span class="keyword">this</span>.serverEnv;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> name <span class="keyword">in</span> <span class="keyword">this</span>.allPlugins) &#123;</span><br><span class="line">      <span class="keyword">const</span> plugin = <span class="keyword">this</span>.allPlugins[name];</span><br><span class="line">      <span class="comment">//plugin的path可能是直接指定的，也有可能指定了一个package的name，然后从node_modules中查找</span></span><br><span class="line">      <span class="comment">//从node_modules中查找的顺序是：&#123;APP_PATH&#125;/node_modules -&gt; &#123;EGG_PATH&#125;/node_modules -&gt; $CWD/node_modules</span></span><br><span class="line">      plugin.path = <span class="keyword">this</span>.getPluginPath(plugin, <span class="keyword">this</span>.options.baseDir);</span><br><span class="line">      <span class="comment">//这个函数会读取每个plugin.path路径下的package.json,获取plugin的version，并会使用package.json中的dependencies，optionalDependencies, env变量作覆盖</span></span><br><span class="line">      <span class="keyword">this</span>.mergePluginConfig(plugin);</span><br><span class="line">      <span class="comment">// 有些plugin只有在某些环境（serverEnv）下才能使用，否则改成enable=false</span></span><br><span class="line">      <span class="keyword">if</span> (env &amp;&amp; plugin.env.length &amp;&amp; !plugin.env.includes(env)) &#123;</span><br><span class="line">        plugin.enable = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//获取enable=true的所有pluginnName</span></span><br><span class="line">      plugins[name] = plugin;</span><br><span class="line">      <span class="keyword">if</span> (plugin.enable) &#123;</span><br><span class="line">        enabledPluginNames.push(name);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这个函数会检查插件的依赖关系，插件的依赖关系在dependencies中定义，最后返回所有需要的插件</span></span><br><span class="line">    <span class="comment">//如果enable=true的插件依赖的插件不在已有的插件中，或者插件的依赖关系存在循环引用，则会抛出异常</span></span><br><span class="line">    <span class="comment">//如果enable=true的依赖插件为enable=false，那么该被依赖的插件会被改为enable=true</span></span><br><span class="line">    <span class="keyword">this</span>.orderPlugins = <span class="keyword">this</span>.getOrderPlugins(plugins, enabledPluginNames, appPlugins);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//最后我们以对象的方式将enable=true的插件挂载在this对象上</span></span><br><span class="line">    <span class="keyword">const</span> enablePlugins = &#123;&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> plugin <span class="keyword">of</span> <span class="keyword">this</span>.orderPlugins) &#123;</span><br><span class="line">      enablePlugins[plugin.name] = plugin;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.plugins = enablePlugins;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="loadConfig函数"><a href="#loadConfig函数" class="headerlink" title="loadConfig函数"></a>loadConfig函数</h4><p>配置信息的管理对于一个应用来说非常重要，我们需要对不同的部署环境的配置进行管理，Egg就是针对环境加载不同的配置文件，然后将配置挂载在app上，</p><p>加载config的逻辑相对简单，就是按照顺序加载所有loadUnit目录下的config文件内容，进行合并，最后将config信息挂载在this对象上，整个加载函数请看下面源码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//egg-core源码 -&gt; loadConfig函数分析</span></span><br><span class="line"></span><br><span class="line">loadConfig() &#123;</span><br><span class="line">    <span class="keyword">this</span>.configMeta = &#123;&#125;;</span><br><span class="line">    <span class="keyword">const</span> target = &#123;&#125;;</span><br><span class="line">    <span class="comment">//这里之所以先加载app相关的config，是因为在加载plugin和framework的config时会使用到app的config</span></span><br><span class="line">    <span class="keyword">const</span> appConfig = <span class="keyword">this</span>._preloadAppConfig();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//config的加载顺序为：plugin config.default -&gt; framework config.default -&gt; app config.default -&gt; plugin config.&#123;env&#125; -&gt; framework config.&#123;env&#125; -&gt; app config.&#123;env&#125;</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> filename <span class="keyword">of</span> <span class="keyword">this</span>.getTypeFiles(<span class="string">'config'</span>)) &#123;</span><br><span class="line">    <span class="comment">// getLoadUnits函数前面有介绍，获取loadUnit目录集合</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">const</span> unit <span class="keyword">of</span> <span class="keyword">this</span>.getLoadUnits()) &#123;</span><br><span class="line">        <span class="keyword">const</span> isApp = unit.type === <span class="string">'app'</span>;</span><br><span class="line">        <span class="comment">//如果是加载插件和框架下面的config，那么会将appConfig当作参数传入</span></span><br><span class="line">        <span class="comment">//这里appConfig已经加载了一遍了，又重复加载了，不知道处于什么原因，下面会有_loadConfig函数源码分析</span></span><br><span class="line">        <span class="keyword">const</span> config = <span class="keyword">this</span>._loadConfig(unit.path, filename, isApp ? <span class="literal">undefined</span> : appConfig, unit.type);</span><br><span class="line">        <span class="keyword">if</span> (!config) &#123;</span><br><span class="line">          <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//config进行覆盖</span></span><br><span class="line">        extend(<span class="literal">true</span>, target, config);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.config = target;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">_loadConfig(dirpath, filename, extraInject, type) &#123;</span><br><span class="line">    <span class="keyword">const</span> isPlugin = type === <span class="string">'plugin'</span>;</span><br><span class="line">    <span class="keyword">const</span> isApp = type === <span class="string">'app'</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> filepath = <span class="keyword">this</span>.resolveModule(path.join(dirpath, <span class="string">'config'</span>, filename));</span><br><span class="line">    <span class="comment">//如果没有config.default文件，则用config.js文件替代，隐藏逻辑</span></span><br><span class="line">    <span class="keyword">if</span> (filename === <span class="string">'config.default'</span> &amp;&amp; !filepath) &#123;</span><br><span class="line">      filepath = <span class="keyword">this</span>.resolveModule(path.join(dirpath, <span class="string">'config/config'</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//loadFile函数我们在EggLoader中讲到过，如果config导出的是一个函数会先执行这个函数，将函数的返回结果导出，函数的参数也就是[this.appInfo extraInject]</span></span><br><span class="line">    <span class="keyword">const</span> config = <span class="keyword">this</span>.loadFile(filepath, <span class="keyword">this</span>.appInfo, extraInject);</span><br><span class="line">    <span class="keyword">if</span> (!config) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//框架使用哪些中间件也是在config里作配置的，后面关于loadMiddleware函数实现中有说明</span></span><br><span class="line">    <span class="comment">//coreMiddleware只能在框架里使用</span></span><br><span class="line">    <span class="keyword">if</span> (isPlugin || isApp) &#123;</span><br><span class="line">      assert(!config.coreMiddleware, <span class="string">'Can not define coreMiddleware in app or plugin'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//middleware只能在应用里定义</span></span><br><span class="line">    <span class="keyword">if</span> (!isApp) &#123;</span><br><span class="line">      assert(!config.middleware, <span class="string">'Can not define middleware in '</span> + filepath);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//这里是为了设置configMeta，表示每个配置项是从哪里来的</span></span><br><span class="line">    <span class="keyword">this</span>[SET_CONFIG_META](config, filepath);</span><br><span class="line">    <span class="keyword">return</span> config;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h4 id="loadExtend相关函数"><a href="#loadExtend相关函数" class="headerlink" title="loadExtend相关函数"></a>loadExtend相关函数</h4><p>这里的loadExtend是一个笼统的概念，其实是针对koa中的app.response，app.respond，app.context以及app本身进行扩展，同样是根据所有loadUnits下的配置顺序进行加载</p><p>下面看一下loadExtend这个函数的实现，一个通用的加载函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//egg-core -&gt; loadExtend函数实现</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//name输入是"response"/"respond"/"context"/"app"中的一个，proto是被扩展的对象</span></span><br><span class="line">loadExtend(name, proto) &#123;</span><br><span class="line">    <span class="comment">//获取指定name所有loadUnits下的配置文件路径</span></span><br><span class="line">    <span class="keyword">const</span> filepaths = <span class="keyword">this</span>.getExtendFilePaths(name);</span><br><span class="line">    <span class="keyword">const</span> isAddUnittest = <span class="string">'EGG_MOCK_SERVER_ENV'</span> <span class="keyword">in</span> process.env &amp;&amp; <span class="keyword">this</span>.serverEnv !== <span class="string">'unittest'</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, l = filepaths.length; i &lt; l; i++) &#123;</span><br><span class="line">      <span class="keyword">const</span> filepath = filepaths[i];</span><br><span class="line">      filepaths.push(filepath + <span class="string">`.<span class="subst">$&#123;<span class="keyword">this</span>.serverEnv&#125;</span>`</span>);</span><br><span class="line">      <span class="keyword">if</span> (isAddUnittest) filepaths.push(filepath + <span class="string">'.unittest'</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这里并没有对属性的直接覆盖，而是对原先的PropertyDescriptor的get和set进行合并</span></span><br><span class="line">    <span class="keyword">const</span> mergeRecord = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> filepath <span class="keyword">of</span> filepaths) &#123;</span><br><span class="line">      filepath = <span class="keyword">this</span>.resolveModule(filepath);</span><br><span class="line">      <span class="keyword">const</span> ext = <span class="keyword">this</span>.requireFile(filepath);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">const</span> properties = <span class="built_in">Object</span>.getOwnPropertyNames(ext)</span><br><span class="line">        .concat(<span class="built_in">Object</span>.getOwnPropertySymbols(ext));</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">const</span> property <span class="keyword">of</span> properties) &#123;</span><br><span class="line">        <span class="keyword">let</span> descriptor = <span class="built_in">Object</span>.getOwnPropertyDescriptor(ext, property);</span><br><span class="line">        <span class="keyword">let</span> originalDescriptor = <span class="built_in">Object</span>.getOwnPropertyDescriptor(proto, property);</span><br><span class="line">        <span class="keyword">if</span> (!originalDescriptor) &#123;</span><br><span class="line">          <span class="keyword">const</span> originalProto = originalPrototypes[name];</span><br><span class="line">          <span class="keyword">if</span> (originalProto) &#123;</span><br><span class="line">            originalDescriptor = <span class="built_in">Object</span>.getOwnPropertyDescriptor(originalProto, property);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果原始对象上已经存在相关属性的Descriptor，那么对其set和get方法进行合并</span></span><br><span class="line">        <span class="keyword">if</span> (originalDescriptor) &#123;</span><br><span class="line">          <span class="comment">// don't override descriptor</span></span><br><span class="line">          descriptor = <span class="built_in">Object</span>.assign(&#123;&#125;, descriptor);</span><br><span class="line">          <span class="keyword">if</span> (!descriptor.set &amp;&amp; originalDescriptor.set) &#123;</span><br><span class="line">            descriptor.set = originalDescriptor.set;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">if</span> (!descriptor.get &amp;&amp; originalDescriptor.get) &#123;</span><br><span class="line">            descriptor.get = originalDescriptor.get;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//否则直接覆盖</span></span><br><span class="line">        <span class="built_in">Object</span>.defineProperty(proto, property, descriptor);</span><br><span class="line">        mergeRecord.set(property, filepath);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h4 id="loadService函数"><a href="#loadService函数" class="headerlink" title="loadService函数"></a>loadService函数</h4><h5 id="如何在egg框架中使用service"><a href="#如何在egg框架中使用service" class="headerlink" title="如何在egg框架中使用service"></a>如何在egg框架中使用service</h5><p>loadService函数的实现是所有load函数中最复杂的一个，我们不着急看源码，先看一下service在egg框架中如何使用</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//egg-core源码 -&gt; 如何在egg框架中使用service</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//方式1：app/service/user1.js</span></span><br><span class="line"><span class="comment">//这个是最标准的做法，导出一个class，这个class继承了require('egg').Service，其实也就是我们上文提到的eggCore导出的BaseContextClass</span></span><br><span class="line"><span class="comment">//最终我们在业务逻辑中获取到的是这个class的一个实例，在load的时候是将app.context当作新建实例的参数</span></span><br><span class="line"><span class="comment">//在controller中调用方式：this.ctx.service.user1.find(1)</span></span><br><span class="line"><span class="keyword">const</span> Service = <span class="built_in">require</span>(<span class="string">'egg'</span>).Service;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserService</span> <span class="keyword">extends</span> <span class="title">Service</span> </span>&#123;</span><br><span class="line">  <span class="keyword">async</span> find(uid) &#123;</span><br><span class="line">    <span class="comment">//此时我们可以通过this.ctx,this.app,this.config,this.service获取到有用的信息，尤其是this.ctx非常重要，每个请求对应一个ctx，我们可以查询到当前请求的所有信息</span></span><br><span class="line">    <span class="keyword">const</span> user = <span class="keyword">await</span> <span class="keyword">this</span>.ctx.db.query(<span class="string">'select * from user where uid = ?'</span>, uid);</span><br><span class="line">    <span class="keyword">return</span> user;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">module</span>.exports = UserService;</span><br><span class="line"></span><br><span class="line"><span class="comment">//方式2：app/service/user2.js</span></span><br><span class="line"><span class="comment">//这个做法是我模拟了一个BaseContextClass，当然也就可以实现方法1的目的，但是不推荐</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(ctx) &#123;</span><br><span class="line">    <span class="keyword">this</span>.ctx = ctx;</span><br><span class="line">    <span class="keyword">this</span>.app = ctx.app;</span><br><span class="line">    <span class="keyword">this</span>.config = ctx.app.config;</span><br><span class="line">    <span class="keyword">this</span>.service = ctx.service;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">async</span> find(uid) &#123;</span><br><span class="line">    <span class="keyword">const</span> user = <span class="keyword">await</span> <span class="keyword">this</span>.ctx.db.query(<span class="string">'select * from user where uid = ?'</span>, uid);</span><br><span class="line">    <span class="keyword">return</span> user;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">module</span>.exports = UserService;</span><br><span class="line"></span><br><span class="line"><span class="comment">//方式3：app/service/user3.js</span></span><br><span class="line"><span class="comment">//service中也可以export函数，在load的时候会主动调用这个函数，把appInfo参数传入，最终获取到的是函数返回结果</span></span><br><span class="line"><span class="comment">//在controller中调用方式：this.ctx.service.user3.getAppName(1)，这个时候在service中获取不到当前请求的上下文ctx</span></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function">(<span class="params">appInfo</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="keyword">async</span> getAppName(uid)&#123;</span><br><span class="line">            <span class="keyword">return</span> appInfo.name;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//方式4：app/service/user4.js</span></span><br><span class="line"><span class="comment">//service也可以直接export普通的原生对象，load的时候会将该普通对象返回，同样获取不到当前请求的上下文ctx</span></span><br><span class="line"><span class="comment">//在controller中调用方式：this.ctx.service.user4.getAppName(1)</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    <span class="keyword">async</span> getAppName(uid)&#123;</span><br><span class="line">        <span class="keyword">return</span> appInfo.name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>我们上面列举了service下的js文件的四种写法，都是从每次请求的上下文this.ctx获取到service对象，然后就可以使用到每个service文件导出的对象了，这里主要有两个地方需要注意：</p><ol><li><p>为什么我们可以从每个请求的this.ctx上获取到service对象呢：</p><p>看过koa源码的同学知道，this.ctx其实是从app.context继承而来，所以我们只要把service绑定到app.context上，那么当前请求的上下文ctx自然可以拿到service对象，eggLoader也是这样做的</p></li><li><p>针对上述四种使用场景，具体导出实例是怎么处理的呢？</p><ul><li>如果导出的是一个类，EggLoader会主动以ctx对象去初始化这个实例并导出，所以我们就可以直接在该类中使用this.ctx获取当前请求的上下文了</li><li>如果导出的是一个函数，那么EggLoader会以app作为参数运行这个函数并将结果导出</li><li>如果是一个普通的对象，直接导出</li></ul></li></ol><h5 id="FileLoader类的实现分析"><a href="#FileLoader类的实现分析" class="headerlink" title="FileLoader类的实现分析"></a>FileLoader类的实现分析</h5><p>在实现loadService函数时，有一个基础类就是FileLoader，它同时也是loadMiddleware，loadController实现的基础，这个类提供一个load函数根据目录结构和文件内容进行解析，返回一个target对象，我们可以根据文件名以及子文件名以及函数名称获取到service里导出的内容，target结构类似这样：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"file1"</span>: &#123;</span><br><span class="line">        <span class="attr">"file11"</span>: &#123;</span><br><span class="line">            <span class="attr">"function1"</span>: a =&gt; a</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"file2"</span>: &#123;</span><br><span class="line">        <span class="attr">"function2"</span>: a =&gt; a</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面我们先看一下fileLoader这个类的实现</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//egg-core源码 -&gt; FileLoader实现</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FileLoader</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(options) &#123;</span><br><span class="line">    <span class="comment">/*options里几个重要参数的含义:</span></span><br><span class="line"><span class="comment">    1.directory: 需要加载文件的所有目录</span></span><br><span class="line"><span class="comment">    2.target: 最终加载成功后的目标对象</span></span><br><span class="line"><span class="comment">    3.initializer：一个初始化函数，对文件导出内容进行初始化，这个在loadController实现时会用到</span></span><br><span class="line"><span class="comment">    4.inject：如果某个文件的导出对象是一个函数，那么将该值传入函数并执行导出，一般都是this.app</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">this</span>.options = <span class="built_in">Object</span>.assign(&#123;&#125;, defaults, options);</span><br><span class="line">  &#125;</span><br><span class="line">  load() &#123;</span><br><span class="line">    <span class="comment">//解析directory下的文件，下面有parse函数的部分实现</span></span><br><span class="line">    <span class="keyword">const</span> items = <span class="keyword">this</span>.parse();</span><br><span class="line">    <span class="keyword">const</span> target = <span class="keyword">this</span>.options.target;</span><br><span class="line">    <span class="comment">//item1 = &#123; properties: [ 'a', 'b', 'c'], exports1 &#125;,item2 = &#123; properties: [ 'a', 'b', 'd'], exports2 &#125;</span></span><br><span class="line">    <span class="comment">// =&gt; target = &#123;a: &#123;b: &#123;c: exports1, d: exports2&#125;&#125;&#125;</span></span><br><span class="line">    <span class="comment">//根据文件路径名称递归生成一个大的对象target，我们通过target.file1.file2就可以获取到对应的导出内容</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> item <span class="keyword">of</span> items) &#123;</span><br><span class="line">      item.properties.reduce(<span class="function">(<span class="params">target, property, index</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> obj;</span><br><span class="line">        <span class="keyword">const</span> properties = item.properties.slice(<span class="number">0</span>, index + <span class="number">1</span>).join(<span class="string">'.'</span>);</span><br><span class="line">        <span class="keyword">if</span> (index === item.properties.length - <span class="number">1</span>) &#123;</span><br><span class="line">          obj = item.exports;</span><br><span class="line">          <span class="keyword">if</span> (obj &amp;&amp; !is.primitive(obj)) &#123;</span><br><span class="line">            <span class="comment">//这步骤很重要，确定这个target是不是一个exports，有可能只是一个路径而已</span></span><br><span class="line">            obj[FULLPATH] = item.fullpath;</span><br><span class="line">            obj[EXPORTS] = <span class="literal">true</span>;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          obj = target[property] || &#123;&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        target[property] = obj;</span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">      &#125;, target);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> target;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//最终生成[&#123; properties: [ 'a', 'b', 'c'], exports，fullpath&#125;]形式，properties文件路径名称的数组，exports是导出对象，fullpath是文件的绝对路径</span></span><br><span class="line">  parse() &#123;</span><br><span class="line">    <span class="comment">//文件目录转换为数组</span></span><br><span class="line">    <span class="keyword">let</span> directories = <span class="keyword">this</span>.options.directory;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">Array</span>.isArray(directories)) &#123;</span><br><span class="line">      directories = [ directories ];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//遍历所有文件路径</span></span><br><span class="line">    <span class="keyword">const</span> items = [];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> directory <span class="keyword">of</span> directories) &#123;</span><br><span class="line">      <span class="comment">//每个文件目录下面可能还会有子文件夹，所以globby.sync函数是获取所有文件包括子文件下的文件的路径</span></span><br><span class="line">      <span class="keyword">const</span> filepaths = globby.sync(files, &#123; <span class="attr">cwd</span>: directory &#125;);</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">const</span> filepath <span class="keyword">of</span> filepaths) &#123;</span><br><span class="line">        <span class="keyword">const</span> fullpath = path.join(directory, filepath);</span><br><span class="line">        <span class="keyword">if</span> (!fs.statSync(fullpath).isFile()) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="comment">//获取文件路径上的以"/"分割的所有文件名，foo/bar.js =&gt; [ 'foo', 'bar' ]，这个函数会对propertie同一格式，默认为驼峰</span></span><br><span class="line">        <span class="keyword">const</span> properties = getProperties(filepath, <span class="keyword">this</span>.options);</span><br><span class="line">        <span class="comment">//app/service/foo/bar.js =&gt; service.foo.bar</span></span><br><span class="line">        <span class="keyword">const</span> pathName = directory.split(<span class="regexp">/[/\\]/</span>).slice(<span class="number">-1</span>) + <span class="string">'.'</span> + properties.join(<span class="string">'.'</span>);</span><br><span class="line">        <span class="comment">//getExports函数获取文件内容，并将结果做一些处理，看下面实现</span></span><br><span class="line">        <span class="keyword">const</span> exports = getExports(fullpath, <span class="keyword">this</span>.options, pathName);</span><br><span class="line">        <span class="comment">//如果导出的是class，会设置一些属性，这个属性下文中对于class的特殊处理地方会用到</span></span><br><span class="line">        <span class="keyword">if</span> (is.class(exports)) &#123;</span><br><span class="line">          exports.prototype.pathName = pathName;</span><br><span class="line">          exports.prototype.fullPath = fullpath;</span><br><span class="line">        &#125;</span><br><span class="line">        items.push(&#123; fullpath, properties, exports &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> items;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//根据指定路径获取导出对象并作预处理</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getExports</span>(<span class="params">fullpath, &#123; initializer, call, inject &#125;, pathName</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> exports = utils.loadFile(fullpath);</span><br><span class="line">  <span class="comment">//用initializer函数对exports结果做预处理</span></span><br><span class="line">  <span class="keyword">if</span> (initializer) &#123;</span><br><span class="line">    exports = initializer(exports, &#123; <span class="attr">path</span>: fullpath, pathName &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//如果exports是class，generatorFunction，asyncFunction则直接返回    </span></span><br><span class="line">  <span class="keyword">if</span> (is.class(exports) || is.generatorFunction(exports) || is.asyncFunction(exports)) &#123;</span><br><span class="line">    <span class="keyword">return</span> exports;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//如果导出的是一个普通函数，并且设置了call=true，默认是true，会将inject传入并调用该函数，上文中提到过好几次，就是在这里实现的</span></span><br><span class="line">  <span class="keyword">if</span> (call &amp;&amp; is<span class="function">.<span class="keyword">function</span>(<span class="params">exports</span>)) </span>&#123;</span><br><span class="line">    exports = exports(inject);</span><br><span class="line">    <span class="keyword">if</span> (exports != <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> exports;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//其它情况直接返回</span></span><br><span class="line">  <span class="keyword">return</span> exports;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="ContextLoader类的实现分析"><a href="#ContextLoader类的实现分析" class="headerlink" title="ContextLoader类的实现分析"></a>ContextLoader类的实现分析</h5><p>上文中说道loadService函数其实最终把service对象挂载在了app.context上，所以为此提供了ContextLoader这个类，继承了FileLoader类，用于将FileLoader解析出来的target挂载在app.context上，下面是其实现：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//egg-core -&gt; ContextLoader类的源码实现</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ContextLoader</span> <span class="keyword">extends</span> <span class="title">FileLoader</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(options) &#123;</span><br><span class="line">    <span class="keyword">const</span> target = options.target = &#123;&#125;;</span><br><span class="line">    <span class="keyword">super</span>(options);</span><br><span class="line">    <span class="comment">//FileLoader已经讲过inject就是app</span></span><br><span class="line">    <span class="keyword">const</span> app = <span class="keyword">this</span>.options.inject;</span><br><span class="line">    <span class="comment">//property就是要挂载的属性，比如"service"</span></span><br><span class="line">    <span class="keyword">const</span> property = options.property;</span><br><span class="line">    <span class="comment">//将service属性挂载在app.context上</span></span><br><span class="line">    <span class="built_in">Object</span>.defineProperty(app.context, property, &#123;</span><br><span class="line">      <span class="keyword">get</span>() &#123;</span><br><span class="line">        <span class="comment">//做缓存，由于不同的请求ctx不一样，这里是针对同一个请求的内容进行缓存</span></span><br><span class="line">        <span class="keyword">if</span> (!<span class="keyword">this</span>[CLASSLOADER]) &#123;</span><br><span class="line">          <span class="keyword">this</span>[CLASSLOADER] = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">const</span> classLoader = <span class="keyword">this</span>[CLASSLOADER];</span><br><span class="line">        <span class="comment">//获取导出实例，这里就是上文用例中获取this.ctx.service.file1.fun1的实现，这里的实例就是this.ctx.service,实现逻辑请看下面的getInstance的实现</span></span><br><span class="line">        <span class="keyword">let</span> instance = classLoader.get(property);</span><br><span class="line">        <span class="keyword">if</span> (!instance) &#123;</span><br><span class="line">          <span class="comment">//这里传入的this就是为了初始化require('egg').Service实例时当作参数传入</span></span><br><span class="line">          <span class="comment">//this会根据调用者的不同而改变，比如是app.context的实例调用那么就是app.context，如果是app.context子类的实例调用，那么就是其子类的实例</span></span><br><span class="line">          <span class="comment">//就是因为这个this，我们service里继承require('egg').Service，才可以通过this.ctx获取到当前请求的上下文</span></span><br><span class="line">          instance = getInstance(target, <span class="keyword">this</span>);</span><br><span class="line">          classLoader.set(property, instance);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//values是FileLoader/load函数生成target对象</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getInstance</span>(<span class="params">values, ctx</span>) </span>&#123;</span><br><span class="line">  <span class="comment">//上文FileLoader里实现中我们讲过，target对象是一个由路径和exports组装成的一个大对象，这里Class是为了确定其是不是一个exports，有可能是一个路径名</span></span><br><span class="line">  <span class="keyword">const</span> Class = values[EXPORTS] ? values : <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">let</span> instance;</span><br><span class="line">  <span class="keyword">if</span> (Class) &#123;</span><br><span class="line">    <span class="keyword">if</span> (is.class(Class)) &#123;</span><br><span class="line">        <span class="comment">//这一步很重要，如果是类，就用ctx进行初始化获取实例</span></span><br><span class="line">      instance = <span class="keyword">new</span> Class(ctx);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">//普通对象直接导出，这里要注意的是如果是exports函数，在FileLoader实现中已经将其执行并转换为了对象</span></span><br><span class="line">      <span class="comment">//function和class分别在子类和父类的处理的原因是，function的处理逻辑loadMiddleware,loadService,loadController公用，而class的处理逻辑loadService使用</span></span><br><span class="line">      instance = Class;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (is.primitive(values)) &#123;</span><br><span class="line">    <span class="comment">//原生类型直接导出</span></span><br><span class="line">    instance = values;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//如果目前的target部分是一个路径，那么会新建一个ClassLoader实例，这个ClassLoader中又会递归的调用getInstance</span></span><br><span class="line">    <span class="comment">//这里之所以新建一个类，一是为了做缓存，二是为了在每个节点获取到的都是一个类的实例</span></span><br><span class="line">    instance = <span class="keyword">new</span> ClassLoader(&#123; ctx, <span class="attr">properties</span>: values &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="loadService的实现"><a href="#loadService的实现" class="headerlink" title="loadService的实现"></a>loadService的实现</h5><p>有了ContextLoader类，那实现loadService函数就非常容易了，如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//egg-core -&gt; loadService函数实现源码</span></span><br><span class="line"><span class="comment">//loadService函数调用loadToContext函数</span></span><br><span class="line">loadService(opt) &#123;</span><br><span class="line">    opt = <span class="built_in">Object</span>.assign(&#123;</span><br><span class="line">      call: <span class="literal">true</span>,</span><br><span class="line">      caseStyle: <span class="string">'lower'</span>,</span><br><span class="line">      fieldClass: <span class="string">'serviceClasses'</span>,</span><br><span class="line">      directory: <span class="keyword">this</span>.getLoadUnits().map(<span class="function"><span class="params">unit</span> =&gt;</span> path.join(unit.path, <span class="string">'app/service'</span>)), <span class="comment">//所有加载单元目录下的service</span></span><br><span class="line">    &#125;, opt);</span><br><span class="line">    <span class="keyword">const</span> servicePaths = opt.directory;</span><br><span class="line">    <span class="keyword">this</span>.loadToContext(servicePaths, <span class="string">'service'</span>, opt);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//loadToContext函数直接新建ContextLoader实例，调用load函数实现加载</span></span><br><span class="line">loadToContext(directory, property, opt) &#123;</span><br><span class="line">    opt = <span class="built_in">Object</span>.assign(&#123;&#125;, &#123;</span><br><span class="line">      directory,</span><br><span class="line">      property,</span><br><span class="line">      inject: <span class="keyword">this</span>.app,</span><br><span class="line">    &#125;, opt);</span><br><span class="line">    <span class="keyword">new</span> ContextLoader(opt).load();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="loadMiddleware函数"><a href="#loadMiddleware函数" class="headerlink" title="loadMiddleware函数"></a>loadMiddleware函数</h4><p>中间件是koa框架中很重要的一个环节，通过app.use引入中间件，使用洋葱圈模型，所以中间件加载的顺序很重要。</p><ul><li>如果在上文中的config中配置的中间件，系统会自动用app.use函数使用该中间件</li><li>所有的中间件我们都可以在app.middleware中通过中间件name获取到，便于在业务中动态使用</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//egg-core -&gt; loadMiddleware函数实现源码</span></span><br><span class="line"></span><br><span class="line">loadMiddleware(opt) &#123;</span><br><span class="line">    <span class="keyword">const</span> app = <span class="keyword">this</span>.app;</span><br><span class="line">    <span class="comment">// load middleware to app.middleware</span></span><br><span class="line">    opt = <span class="built_in">Object</span>.assign(&#123;</span><br><span class="line">      call: <span class="literal">false</span>,   <span class="comment">//call=false表示如果中间件导出是函数，不会主动调用函数做转换</span></span><br><span class="line">      override: <span class="literal">true</span>,</span><br><span class="line">      caseStyle: <span class="string">'lower'</span>,</span><br><span class="line">      directory: <span class="keyword">this</span>.getLoadUnits().map(<span class="function"><span class="params">unit</span> =&gt;</span> join(unit.path, <span class="string">'app/middleware'</span>)) <span class="comment">//所有加载单元目录下的middleware</span></span><br><span class="line">    &#125;, opt);</span><br><span class="line">    <span class="keyword">const</span> middlewarePaths = opt.directory;</span><br><span class="line">    <span class="comment">//将所有中间件middlewares挂载在app上，这个函数在loadController实现中也用到了，看下文的实现</span></span><br><span class="line">    <span class="keyword">this</span>.loadToApp(middlewarePaths, <span class="string">'middlewares'</span>, opt);</span><br><span class="line">    <span class="comment">//将app.middlewares中的每个中间件重新绑定在app.middleware上，每个中间件的属性不可配置，不可枚举</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> name <span class="keyword">in</span> app.middlewares) &#123;</span><br><span class="line">      <span class="built_in">Object</span>.defineProperty(app.middleware, name, &#123;</span><br><span class="line">        <span class="keyword">get</span>() &#123;</span><br><span class="line">          <span class="keyword">return</span> app.middlewares[name];</span><br><span class="line">        &#125;,</span><br><span class="line">        enumerable: <span class="literal">false</span>,</span><br><span class="line">        configurable: <span class="literal">false</span>,</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//只有在config中配置了appMiddleware和coreMiddleware才会直接在app.use中使用，其它中间件只是挂载在app上，开发人员可以动态使用</span></span><br><span class="line">    <span class="keyword">const</span> middlewareNames = <span class="keyword">this</span>.config.coreMiddleware.concat(<span class="keyword">this</span>.config.appMiddleware);</span><br><span class="line">    <span class="keyword">const</span> middlewaresMap = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> name <span class="keyword">of</span> middlewareNames) &#123;</span><br><span class="line">      <span class="comment">//如果config中定义middleware在app.middlewares中找不到或者重复定义，都会报错</span></span><br><span class="line">      <span class="keyword">if</span> (!app.middlewares[name]) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">`Middleware <span class="subst">$&#123;name&#125;</span> not found`</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (middlewaresMap.has(name)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">`Middleware <span class="subst">$&#123;name&#125;</span> redefined`</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      middlewaresMap.set(name, <span class="literal">true</span>);</span><br><span class="line">      <span class="keyword">const</span> options = <span class="keyword">this</span>.config[name] || &#123;&#125;;</span><br><span class="line">      <span class="keyword">let</span> mw = app.middlewares[name];</span><br><span class="line">      <span class="comment">//中间件的文件定义必须exports一个普通function，并且接受两个参数：</span></span><br><span class="line">      <span class="comment">//options: 中间件的配置项，框架会将 app.config[$&#123;middlewareName&#125;] 传递进来, app: 当前应用 Application 的实例</span></span><br><span class="line">      <span class="comment">//执行exports的函数，生成最终要的中间件</span></span><br><span class="line">      mw = mw(options, app);</span><br><span class="line">      mw._name = name;</span><br><span class="line">      <span class="comment">//包装中间件，最终转换成async function(ctx, next)形式</span></span><br><span class="line">      mw = wrapMiddleware(mw, options);</span><br><span class="line">      <span class="keyword">if</span> (mw) &#123;</span><br><span class="line">        app.use(mw);</span><br><span class="line">        <span class="keyword">this</span>.options.logger.info(<span class="string">'[egg:loader] Use middleware: %s'</span>, name);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.options.logger.info(<span class="string">'[egg:loader] Disable middleware: %s'</span>, name);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过FileLoader实例加载指定属性的所有文件并导出，然后将该属性挂载在app上</span></span><br><span class="line">loadToApp(directory, property, opt) &#123;</span><br><span class="line">    <span class="keyword">const</span> target = <span class="keyword">this</span>.app[property] = &#123;&#125;;</span><br><span class="line">    opt = <span class="built_in">Object</span>.assign(&#123;&#125;, &#123;</span><br><span class="line">      directory,</span><br><span class="line">      target,</span><br><span class="line">      inject: <span class="keyword">this</span>.app,</span><br><span class="line">    &#125;, opt);</span><br><span class="line">    <span class="keyword">new</span> FileLoader(opt).load();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="loadController函数"><a href="#loadController函数" class="headerlink" title="loadController函数"></a>loadController函数</h4><p>controller中生成的函数最终还是在router.js中当作一个中间件使用，所以我们需要将controller中内容转换为中间件形式async function(ctx, next)，其中initializer这个函数就是用来针对不同的情况将controller中的内容转换为中间件的，下面是loadController的实现逻辑：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//egg-core源码 -&gt; loadController函数实现源码</span></span><br><span class="line"></span><br><span class="line">loadController(opt) &#123;</span><br><span class="line">    opt = <span class="built_in">Object</span>.assign(&#123;</span><br><span class="line">      caseStyle: <span class="string">'lower'</span>,</span><br><span class="line">      directory: path.join(<span class="keyword">this</span>.options.baseDir, <span class="string">'app/controller'</span>),</span><br><span class="line">      <span class="comment">//这个配置，上文有提到，是为了对导出对象做预处理的函数</span></span><br><span class="line">      initializer: <span class="function">(<span class="params">obj, opt</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">//如果是普通函数，依然直接调用它生成新的对象</span></span><br><span class="line">        <span class="keyword">if</span> (is<span class="function">.<span class="keyword">function</span>(<span class="params">obj</span>) &amp;&amp; !<span class="title">is</span>.<span class="title">generatorFunction</span>(<span class="params">obj</span>) &amp;&amp; !<span class="title">is</span>.<span class="title">class</span>(<span class="params">obj</span>) &amp;&amp; !<span class="title">is</span>.<span class="title">asyncFunction</span>(<span class="params">obj</span>)) </span>&#123;</span><br><span class="line">          obj = obj(<span class="keyword">this</span>.app);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (is.class(obj)) &#123;</span><br><span class="line">          obj.prototype.pathName = opt.pathName;</span><br><span class="line">          obj.prototype.fullPath = opt.path;</span><br><span class="line">          <span class="comment">//如果是一个class，class中的函数转换成async function(ctx, next)中间件形式，并用ctx去初始化该class，所以在controller里我们也可以使用this.ctx.xxx形式</span></span><br><span class="line">          <span class="keyword">return</span> wrapClass(obj);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (is.object(obj)) &#123;</span><br><span class="line">          <span class="comment">//如果是一个Object，会递归的将该Object中每个属性对应的函数转换成async function(ctx, next)中间件形式形式</span></span><br><span class="line">          <span class="keyword">return</span> wrapObject(obj, opt.path);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// support generatorFunction for forward compatbility</span></span><br><span class="line">        <span class="keyword">if</span> (is.generatorFunction(obj) || is.asyncFunction(obj)) &#123;</span><br><span class="line">          <span class="keyword">return</span> wrapObject(&#123; <span class="string">'module.exports'</span>: obj &#125;, opt.path)[<span class="string">'module.exports'</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;, opt);</span><br><span class="line">    <span class="comment">//loadController函数同样是通过loadToApp函数将其导出对象挂载在app下，controller里的内容在loadRouter时会将其载入</span></span><br><span class="line">    <span class="keyword">const</span> controllerBase = opt.directory;</span><br><span class="line">    <span class="keyword">this</span>.loadToApp(controllerBase, <span class="string">'controller'</span>, opt);</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure><h4 id="loadRouter函数"><a href="#loadRouter函数" class="headerlink" title="loadRouter函数"></a>loadRouter函数</h4><p>loadRouter函数特别简单，只是require加载一下app/router目录下的文件而已，而所有的事情都交给了EggCore类上的router属性去实现</p><p>而router又是Router类的实例，Router类是基于koa-router实现的</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//egg-core源码 -&gt; loadRouter函数源码实现</span></span><br><span class="line"></span><br><span class="line">loadRouter() &#123;</span><br><span class="line">    <span class="keyword">this</span>.loadFile(<span class="keyword">this</span>.resolveModule(path.join(<span class="keyword">this</span>.options.baseDir, <span class="string">'app/router'</span>)));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置router属性的get方法</span></span><br><span class="line"><span class="keyword">get</span> router() &#123;</span><br><span class="line">    <span class="comment">//缓存设置</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>[ROUTER]) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>[ROUTER];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//新建Router实例，其中Router类是继承koa-router实现的</span></span><br><span class="line">    <span class="keyword">const</span> router = <span class="keyword">this</span>[ROUTER] = <span class="keyword">new</span> Router(&#123; <span class="attr">sensitive</span>: <span class="literal">true</span> &#125;, <span class="keyword">this</span>);</span><br><span class="line">    <span class="comment">//在启动前将router中间件载入引用</span></span><br><span class="line">    <span class="keyword">this</span>.beforeStart(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.use(router.middleware());</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> router;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="comment">//将router上所有的method函数代理到EggCore上，这样我们就可以通过app.get('/async', ...asyncMiddlewares, 'subController.subHome.async1')的方式配置路由</span></span><br><span class="line">utils.methods.concat([ <span class="string">'all'</span>, <span class="string">'resources'</span>, <span class="string">'register'</span>, <span class="string">'redirect'</span> ]).forEach(<span class="function"><span class="params">method</span> =&gt;</span> &#123;</span><br><span class="line">  EggCore.prototype[method] = <span class="function"><span class="keyword">function</span>(<span class="params">...args</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.router[method](...args);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>Router类继承了KoaRouter类，并对其的method相关函数做了扩展，解析controller的写法，同时提供了resources方法，为了兼容restAPI的方式</p><p>关于restAPI的使用方式和实现源码我们这里就不介绍了，可以看官方文档，有具体的格式要求，下面看一下Router类的部分实现逻辑：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//egg-core源码 -&gt; Router类实现源码</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Router</span> <span class="keyword">extends</span> <span class="title">KoaRouter</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(opts, app) &#123;</span><br><span class="line">    <span class="keyword">super</span>(opts);</span><br><span class="line">    <span class="keyword">this</span>.app = app;</span><br><span class="line">    <span class="comment">//对method方法进行扩展</span></span><br><span class="line">    <span class="keyword">this</span>.patchRouterMethod();</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  patchRouterMethod() &#123;</span><br><span class="line">    <span class="comment">//为了支持generator函数类型，以及获取controller类中导出的中间件</span></span><br><span class="line">    methods.concat([ <span class="string">'all'</span> ]).forEach(<span class="function"><span class="params">method</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>[method] = <span class="function">(<span class="params">...args</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">//spliteAndResolveRouterParams主要是为了拆分router.js中的路由规则，将其拆分成普通中间件和controller生成的中间件部分，请看下文源码</span></span><br><span class="line">        <span class="keyword">const</span> splited = spliteAndResolveRouterParams(&#123; args, <span class="attr">app</span>: <span class="keyword">this</span>.app &#125;);</span><br><span class="line">        args = splited.prefix.concat(splited.middlewares);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>[method](...args);</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//返回router里每个路由规则的前缀和中间件部分</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">spliteAndResolveRouterParams</span>(<span class="params">&#123; args, app &#125;</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> prefix;</span><br><span class="line">    <span class="keyword">let</span> middlewares;</span><br><span class="line">    <span class="keyword">if</span> (args.length &gt;= <span class="number">3</span> &amp;&amp; (is.string(args[<span class="number">1</span>]) || is.regExp(args[<span class="number">1</span>]))) &#123;</span><br><span class="line">        <span class="comment">// app.get(name, url, [...middleware], controller)的形式</span></span><br><span class="line">        prefix = args.slice(<span class="number">0</span>, <span class="number">2</span>);</span><br><span class="line">        middlewares = args.slice(<span class="number">2</span>);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// app.get(url, [...middleware], controller)的形式</span></span><br><span class="line">        prefix = args.slice(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">        middlewares = args.slice(<span class="number">1</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//controller部分肯定是最后一个</span></span><br><span class="line">      <span class="keyword">const</span> controller = middlewares.pop();</span><br><span class="line">      <span class="comment">//resolveController函数主要是为了处理router.js中关于controller的两种写法：</span></span><br><span class="line">      <span class="comment">//写法1：app.get('/async', ...asyncMiddlewares, 'subController.subHome.async1')</span></span><br><span class="line">      <span class="comment">//写法2：app.get('/async', ...asyncMiddlewares, subController.subHome.async1)</span></span><br><span class="line">      <span class="comment">//最终从app.controller上获取到真正的controller中间件，resolveController具体函数实现就不介绍了</span></span><br><span class="line">      middlewares.push(resolveController(controller, app));</span><br><span class="line">      <span class="keyword">return</span> &#123; prefix, middlewares &#125;;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>以上便是对EggCore的大部分源码的实现的学习总结，其中关于源码中一些debug代码以及timing运行时间记录的代码都删掉了，关于app的生命周期管理的那部分代码和loadUnits加载逻辑关系不大，所以没有讲到。EggCore的核心在于EggLoader，也就是plugin，config, extend, service, middleware, controller, router的加载函数，而这几个内容加载必须按照顺序进行加载，存在依赖关系，比如：</p><ul><li>加载middleware时会用到config关于应用中间件的配置</li><li>加载router时会用到关于controller的配置</li><li>而config，extend，service，middleware，controller的加载都必须依赖于plugin，通过plugin配置获取插件目录</li><li>service，middleware，controller，router的加载又必须依赖于extend（对app进行扩展），因为如果exports是函数的情况下，会将app作为参数执行函数</li></ul><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li><a href="https://www.npmjs.com/package/egg-cool-router" target="_blank" rel="noopener">https://www.npmjs.com/package/egg-cool-router</a></li><li>摘抄自：<a href="https://cnodejs.org/topic/5bc933129545eaf107b9cc84" target="_blank" rel="noopener">https://cnodejs.org/topic/5bc933129545eaf107b9cc84</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;最近在翻查&lt;a href=&quot;https://www.npmjs.com/package/egg-cool-router&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;egg-cool-router&lt;/a&gt;源码查看如何使用装饰器来注册egg路由，看到了一些很牛逼的操作，想知道为什么就查了一下关于源码讲解的文章，解惑了所以摘抄了下来。&lt;/p&gt;
    
    </summary>
    
      <category term="NodeJS" scheme="http://hackycy.github.io/categories/NodeJS/"/>
    
    
      <category term="NodeJS" scheme="http://hackycy.github.io/tags/NodeJS/"/>
    
      <category term="Egg" scheme="http://hackycy.github.io/tags/Egg/"/>
    
  </entry>
  
  <entry>
    <title>Typescript装饰器讲解</title>
    <link href="http://hackycy.github.io/2020/08/25/Typescript%E8%A3%85%E9%A5%B0%E5%99%A8%E8%AE%B2%E8%A7%A3/"/>
    <id>http://hackycy.github.io/2020/08/25/Typescript装饰器讲解/</id>
    <published>2020-08-25T12:22:26.000Z</published>
    <updated>2021-05-03T11:11:23.780Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>装饰器（Decorators）为我们在类的声明及成员上通过元编程语法添加标注提供了一种方式。 Javascript里的装饰器目前处在 <a href="https://github.com/tc39/proposal-decorators" target="_blank" rel="noopener">建议征集的第二阶段</a>，但在TypeScript里已做为一项实验性特性予以支持。</p><blockquote><p>注意  装饰器是一项实验性特性，在未来的版本中可能会发生改变。</p></blockquote><a id="more"></a><p>若要启用实验性的装饰器特性，你必须在命令行或<code>tsconfig.json</code>里启用<code>experimentalDecorators</code>编译器选项：</p><p><strong>命令行</strong>:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tsc --target ES5 --experimentalDecorators</span><br></pre></td></tr></table></figure><p><strong>tsconfig.json</strong>:</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"compilerOptions"</span>: &#123;</span><br><span class="line">        <span class="attr">"target"</span>: <span class="string">"ES5"</span>,</span><br><span class="line">    <span class="attr">"experimentalDecorators"</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">"emitDecoratorMetadata"</span>: <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><p>装饰器是一种特殊类型的声明，它能够被附加到类声明，方法， 访问符，属性或参数上，可以修改类的行为。 装饰器使用 <code>@expression</code>这种形式，<code>expression</code>求值后必须为一个函数，它会在运行时被调用，被装饰的声明信息做为参数传入。</p><p>例：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Path</span>(<span class="string">'/hello'</span>)</span><br><span class="line"><span class="keyword">class</span> HelloService &#123;&#125;</span><br></pre></td></tr></table></figure><h2 id="如何定义装饰器"><a href="#如何定义装饰器" class="headerlink" title="如何定义装饰器"></a>如何定义装饰器</h2><p>装饰器本身其实就是一个函数，理论上忽略参数的话，任何函数都可以当做装饰器使用。例：</p><p>demo.ts</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Path</span>(<span class="params">target:<span class="built_in">any</span></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"I am decorator."</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Path</span></span><br><span class="line"><span class="keyword">class</span> HelloService &#123;&#125;</span><br></pre></td></tr></table></figure><p>使用<code>tsc</code>编译后,执行命令<code>node demo.js</code>，输出结果如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">I am decorator.</span><br></pre></td></tr></table></figure><h2 id="装饰器执行时机"><a href="#装饰器执行时机" class="headerlink" title="装饰器执行时机"></a>装饰器执行时机</h2><p>修饰器对类的行为的改变，是代码编译时发生的（不是TypeScript编译，而是js在执行机中编译阶段），而不是在运行时。这意味着，修饰器能在编译阶段运行代码。也就是说，修饰器本质就是编译时执行的函数。<br>在Node.js环境中模块一加载时就会执行</p><h2 id="函数柯里化解决参数问题"><a href="#函数柯里化解决参数问题" class="headerlink" title="函数柯里化解决参数问题"></a>函数柯里化解决参数问题</h2><p>但是实际场景中，有时希望向装饰器传入一些参数, 如下：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Path</span>(<span class="string">"/hello"</span>, <span class="string">"world"</span>)</span><br><span class="line"><span class="keyword">class</span> HelloService &#123;&#125;</span><br></pre></td></tr></table></figure><p>此时上面装饰器方法就不满足了（VSCode编译报错），这是我们可以借助JavaScript中函数柯里化特性</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Path</span>(<span class="params">p1: <span class="built_in">string</span>, p2: <span class="built_in">string</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">target</span>) </span>&#123; <span class="comment">//  这才是真正装饰器</span></span><br><span class="line">        <span class="comment">// do something </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="五种装饰器"><a href="#五种装饰器" class="headerlink" title="五种装饰器"></a>五种装饰器</h2><p>在TypeScript中装饰器可以修饰四种语句：类，属性，访问器，方法以及方法参数。</p><h3 id="1-类装饰器"><a href="#1-类装饰器" class="headerlink" title="1 类装饰器"></a>1 类装饰器</h3><p>应用于类构造函数，其参数是类的构造函数。<br>注意<code>class</code>并不是像Java那种强类型语言中的类，而是JavaScript构造函数的语法糖。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Path</span>(<span class="params">path: <span class="built_in">string</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">target: <span class="built_in">Function</span></span>) </span>&#123;</span><br><span class="line">        !target.prototype.$Meta &amp;&amp; (target.prototype.$Meta = &#123;&#125;)</span><br><span class="line">        target.prototype.$Meta.baseUrl = path;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Path</span>(<span class="string">'/hello'</span>)</span><br><span class="line"><span class="keyword">class</span> HelloService &#123;</span><br><span class="line">    <span class="keyword">constructor</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(HelloService.prototype.$Meta);<span class="comment">// 输出：&#123; baseUrl: '/hello' &#125;</span></span><br><span class="line"><span class="keyword">let</span> hello = <span class="keyword">new</span> HelloService();</span><br><span class="line"><span class="built_in">console</span>.log(hello.$Meta) <span class="comment">// 输出：&#123; baseUrl: '/hello' &#125;</span></span><br></pre></td></tr></table></figure><h3 id="2-方法装饰器"><a href="#2-方法装饰器" class="headerlink" title="2 方法装饰器"></a>2 方法装饰器</h3><p>它会被应用到方法的 属性描述符上，可以用来监视，修改或者替换方法定义。<br>方法装饰会在运行时传入下列3个参数：</p><ul><li>1、对于静态成员来说是类的构造函数，对于实例成员是类的原型对象。</li><li>2、成员的名字。</li><li>3、成员的属性描述符。</li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">GET</span>(<span class="params">url: <span class="built_in">string</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">target, methodName: <span class="built_in">string</span>, descriptor: PropertyDescriptor</span>) </span>&#123;</span><br><span class="line">        !target.$Meta &amp;&amp; (target.$Meta = &#123;&#125;);</span><br><span class="line">        target.$Meta[methodName] = url;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> HelloService &#123;</span><br><span class="line">    <span class="keyword">constructor</span>(<span class="params"></span>) &#123; &#125;</span><br><span class="line">    <span class="meta">@GET</span>(<span class="string">"xx"</span>)</span><br><span class="line">    getUser() &#123; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log((&lt;<span class="built_in">any</span>&gt;HelloService).$Meta);</span><br></pre></td></tr></table></figure><p>注意：在vscode编辑时有时会报<code>作为表达式调用时，无法解析方法修饰器的签名。</code>错误，此时需要在tsconfig.json中增加target配置项：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">"compilerOptions"</span>: &#123;</span><br><span class="line">        <span class="string">"target"</span>: <span class="string">"es6"</span>,</span><br><span class="line">        <span class="string">"experimentalDecorators"</span>: <span class="literal">true</span>,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-方法参数装饰器"><a href="#3-方法参数装饰器" class="headerlink" title="3 方法参数装饰器"></a>3 方法参数装饰器</h3><p>参数装饰器表达式会在运行时当作函数被调用，传入下列3个参数：</p><ul><li>1、对于静态成员来说是类的构造函数，对于实例成员是类的原型对象。</li><li>2、参数的名字。</li><li>3、参数在函数参数列表中的索引。</li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">PathParam</span>(<span class="params">paramName: <span class="built_in">string</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">target, methodName: <span class="built_in">string</span>, paramIndex: <span class="built_in">number</span></span>) </span>&#123;</span><br><span class="line">        !target.$Meta &amp;&amp; (target.$Meta = &#123;&#125;);</span><br><span class="line">        target.$Meta[paramIndex] = paramName;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> HelloService &#123;</span><br><span class="line">    <span class="keyword">constructor</span>(<span class="params"></span>) &#123; &#125;</span><br><span class="line">    getUser( <span class="meta">@PathParam</span>(<span class="string">"userId"</span>) userId: <span class="built_in">string</span>) &#123; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log((&lt;<span class="built_in">any</span>&gt;HelloService).prototype.$Meta); <span class="comment">// &#123;'0':'userId'&#125;</span></span><br></pre></td></tr></table></figure><h3 id="4-属性装饰器"><a href="#4-属性装饰器" class="headerlink" title="4 属性装饰器"></a>4 属性装饰器</h3><p>属性装饰器表达式会在运行时当作函数被调用，传入下列2个参数：</p><ul><li>1、对于静态成员来说是类的构造函数，对于实例成员是类的原型对象。</li><li>2、成员的名字。</li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">DefaultValue</span>(<span class="params">value: <span class="built_in">string</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">target: <span class="built_in">any</span>, propertyName: <span class="built_in">string</span></span>) </span>&#123;</span><br><span class="line">        target[propertyName] = value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Hello &#123;</span><br><span class="line">    <span class="meta">@DefaultValue</span>(<span class="string">"world"</span>) greeting: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">new</span> Hello().greeting);<span class="comment">// 输出: world</span></span><br></pre></td></tr></table></figure><h3 id="装饰器加载顺序"><a href="#装饰器加载顺序" class="headerlink" title="装饰器加载顺序"></a>装饰器加载顺序</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ClassDecorator</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">target</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"I am class decorator"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MethodDecorator</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">target, methodName: <span class="built_in">string</span>, descriptor: PropertyDescriptor</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"I am method decorator"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Param1Decorator</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">target, methodName: <span class="built_in">string</span>, paramIndex: <span class="built_in">number</span></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"I am parameter1 decorator"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Param2Decorator</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">target, methodName: <span class="built_in">string</span>, paramIndex: <span class="built_in">number</span></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"I am parameter2 decorator"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">PropertyDecorator</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">target, propertyName: <span class="built_in">string</span></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"I am property decorator"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@ClassDecorator</span>()</span><br><span class="line"><span class="keyword">class</span> Hello &#123;</span><br><span class="line">    <span class="meta">@PropertyDecorator</span>()</span><br><span class="line">    greeting: <span class="built_in">string</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@MethodDecorator</span>()</span><br><span class="line">    greet( <span class="meta">@Param1Decorator</span>() p1: <span class="built_in">string</span>, <span class="meta">@Param2Decorator</span>() p2: <span class="built_in">string</span>) &#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">I am property decorator</span><br><span class="line">I am parameter2 decorator</span><br><span class="line">I am parameter1 decorator</span><br><span class="line">I am method decorator</span><br><span class="line">I am class decorator</span><br></pre></td></tr></table></figure><p>从上述例子得出如下结论：</p><p>1、有多个参数装饰器时：从最后一个参数依次向前执行</p><p>2、方法和方法参数中参数装饰器先执行。</p><p>3、类装饰器总是最后执行。</p><p>4、方法和属性装饰器，谁在前面谁先执行。因为参数属于方法一部分，所以参数会一直紧紧挨着方法执行。上述例子中属性和方法调换位置，输出如下结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">I am parameter2 decorator</span><br><span class="line">I am parameter1 decorator</span><br><span class="line">I am method decorator</span><br><span class="line">I am property decorator</span><br><span class="line">I am class decorator</span><br></pre></td></tr></table></figure><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li><p>摘抄自 - <a href="https://www.cnblogs.com/winfred/p/8216650.html" target="_blank" rel="noopener">https://www.cnblogs.com/winfred/p/8216650.html</a></p></li><li><p><a href="https://github.com/hackycy/practice-examples/tree/master/typescript/DecoratorDemo" target="_blank" rel="noopener">Github Sample</a></p></li><li><p><a href="https://www.tslang.cn/docs/handbook/decorators.html" target="_blank" rel="noopener">https://www.tslang.cn/docs/handbook/decorators.html</a></p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h1&gt;&lt;p&gt;装饰器（Decorators）为我们在类的声明及成员上通过元编程语法添加标注提供了一种方式。 Javascript里的装饰器目前处在 &lt;a href=&quot;https://github.com/tc39/proposal-decorators&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;建议征集的第二阶段&lt;/a&gt;，但在TypeScript里已做为一项实验性特性予以支持。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;注意  装饰器是一项实验性特性，在未来的版本中可能会发生改变。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="TypeScript" scheme="http://hackycy.github.io/categories/TypeScript/"/>
    
    
      <category term="TypeScript" scheme="http://hackycy.github.io/tags/TypeScript/"/>
    
  </entry>
  
  <entry>
    <title>重学Android之FileProvider</title>
    <link href="http://hackycy.github.io/2020/08/19/%E9%87%8D%E5%AD%A6Android%E4%B9%8BFileProvider/"/>
    <id>http://hackycy.github.io/2020/08/19/重学Android之FileProvider/</id>
    <published>2020-08-19T10:55:20.000Z</published>
    <updated>2021-05-03T11:11:23.988Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>项目之前使用了第三方库的时候，对于<code>FileProvider</code>的适配还不是很了解，因为使用时第三方库已经进行了适配。但是自己去覆写别人的第三方库的时候了解到了<code>FileProvider</code>的适配。</p><p>对于Android 7.0，提供了非常多的变化，详细的可以阅读官方文档<a href="https://developer.android.com/about/versions/nougat/android-7.0-changes.html" target="_blank" rel="noopener">Android 7.0 行为变更</a>，但是该文章主要叙述关于<code>FileProvider</code>的适配。</p><blockquote><p> 在官方7.0的以上的系统中，尝试传递 <code>file://URI</code>可能会触发<code>FileUriExposedException</code>。</p></blockquote><a id="more"></a><h1 id="出错案例"><a href="#出错案例" class="headerlink" title="出错案例"></a>出错案例</h1><p>先来一个常用的例子，大家应该对于手机拍照一定都不陌生，在希望得到一张高清拍照图的时候，我们通过Intent会传递一个File的Uri给相机应用。</p><p>大致代码如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> REQUEST_CODE_TAKE_PHOTO = <span class="number">0x110</span>;</span><br><span class="line">    <span class="keyword">private</span> String mCurrentPhotoPath;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">takePhotoNoCompress</span><span class="params">(View view)</span> </span>&#123;</span><br><span class="line">        Intent takePictureIntent = <span class="keyword">new</span> Intent(MediaStore.ACTION_IMAGE_CAPTURE);</span><br><span class="line">        <span class="keyword">if</span> (takePictureIntent.resolveActivity(getPackageManager()) != <span class="keyword">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">            String filename = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyyMMdd-HHmmss"</span>, Locale.CHINA)</span><br><span class="line">                    .format(<span class="keyword">new</span> Date()) + <span class="string">".png"</span>;</span><br><span class="line">            File file = <span class="keyword">new</span> File(Environment.getExternalStorageDirectory(), filename);</span><br><span class="line">            mCurrentPhotoPath = file.getAbsolutePath();</span><br><span class="line"><span class="comment">// File -&gt; Uri </span></span><br><span class="line">            takePictureIntent.putExtra(MediaStore.EXTRA_OUTPUT, Uri.fromFile(file));</span><br><span class="line">            startActivityForResult(takePictureIntent, REQUEST_CODE_TAKE_PHOTO);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onActivityResult</span><span class="params">(<span class="keyword">int</span> requestCode, <span class="keyword">int</span> resultCode, Intent data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onActivityResult(requestCode, resultCode, data);</span><br><span class="line">        <span class="keyword">if</span> (resultCode == RESULT_OK &amp;&amp; requestCode == REQUEST_CODE_TAKE_PHOTO) &#123;</span><br><span class="line">            mIvPhoto.setImageBitmap(BitmapFactory.decodeFile(mCurrentPhotoPath));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// else tip?</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>未处理6.0权限，有需要的自行处理下，nexus系列如果未处理，需要手动在设置页开启存储权限。</p></blockquote><p>此时如果我们使用Android 7.0或者以上的原生系统，再次运行一下，你会发现应用直接停止运行，抛出了<code>android.os.FileUriExposedException</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Caused by: android.os.FileUriExposedException: </span><br><span class="line">    file:///storage/emulated/0/20170601-030254.png </span><br><span class="line">        exposed beyond app through ClipData.Item.getUri()</span><br><span class="line">    at android.os.StrictMode.onFileUriExposed(StrictMode.java:1932)</span><br><span class="line">    at android.net.Uri.checkFileUriExposed(Uri.java:2348)</span><br></pre></td></tr></table></figure><p>原因在官网已经给了解释：</p><blockquote><p>对于面向 Android 7.0 的应用，Android 框架执行的 StrictMode API 政策禁止在您的应用外部公开 file:// URI。如果一项包含文件 URI 的 intent 离开您的应用，则应用出现故障，并出现 FileUriExposedException 异常。</p></blockquote><p>同样的，官网也给出了解决方案：</p><blockquote><p>要在应用间共享文件，您应发送一项 content:// URI，并授予 URI 临时访问权限。进行此授权的最简单方式是使用 FileProvider 类。如需了解有关权限和共享文件的详细信息，请参阅共享文件。<br><a href="https://developer.android.com/about/versions/nougat/android-7.0-changes.html#accessibility" target="_blank" rel="noopener">https://developer.android.com/about/versions/nougat/android-7.0-changes.html#accessibility</a></p></blockquote><h1 id="使用FileProvider"><a href="#使用FileProvider" class="headerlink" title="使用FileProvider"></a>使用FileProvider</h1><p><code>FileProvider</code>属于Android 7.0新增的一个类，该类位于v4或者androidx包下，详情可见<code>android.support.v4.content.FileProvider</code>或者<code>androidx.core.content.FileProvider</code>，使用方法类似与<code>ContentProvider</code>，简单概括为三个步骤，这里先以调用系统相机拍照并保存<strong>sdcard</strong>公共目录为例，演示使用过程：</p><ul><li>在资源文件夹<code>res/xml</code>下新建<code>file_paths.xml</code>文件，文件声明权限请求的路径，代码如下：</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">paths</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--3、对应外部内存卡根目录：Environment.getExternalStorageDirectory()--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">external-path</span> <span class="attr">name</span>=<span class="string">"external"</span> <span class="attr">path</span>=<span class="string">"/"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">paths</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>要使用<code>content://uri</code>替代<code>file://uri</code>，需要一个虚拟的路径对文件路径进行映射，所以需要编写个xml文件，通过path以及xml节点确定可访问的目录，通过name属性来映射真实的文件路径。</p></blockquote><ul><li>在<code>AndroidManifest.xml</code>添加组件<code>provider</code>相关信息，类似组件<code>activity</code>，指定<code>resource</code>属性引用上一步创建的xml文件（后面会详细介绍各个属性的用法），代码如下：</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 定义FileProvider --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">provider</span></span></span><br><span class="line"><span class="tag"><span class="attr">android:name</span>=<span class="string">"androidx.core.content.FileProvider"</span></span></span><br><span class="line"><span class="tag"><span class="attr">android:authorities</span>=<span class="string">"com.siyee.android7.fileprovider"</span></span></span><br><span class="line"><span class="tag"><span class="attr">android:exported</span>=<span class="string">"false"</span></span></span><br><span class="line"><span class="tag"><span class="attr">android:grantUriPermissions</span>=<span class="string">"true"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta-data</span></span></span><br><span class="line"><span class="tag"><span class="attr">android:name</span>=<span class="string">"android.support.FILE_PROVIDER_PATHS"</span></span></span><br><span class="line"><span class="tag"><span class="attr">android:resource</span>=<span class="string">"@xml/file_paths"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">provider</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>最后一步，Java代码申请权限，使用新增的方法<code>getUriForFile()</code>和<code>grantUriPermission()</code>，代码如下（后面会详细介绍方法对应参数的使用）：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">takePhotoNoCompress</span><span class="params">(View view)</span> </span>&#123;</span><br><span class="line">        Intent takePictureIntent = <span class="keyword">new</span> Intent(MediaStore.ACTION_IMAGE_CAPTURE);</span><br><span class="line">        <span class="keyword">if</span> (takePictureIntent.resolveActivity(getPackageManager()) != <span class="keyword">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">            String filename = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyyMMdd-HHmmss"</span>, Locale.CHINA)</span><br><span class="line">                    .format(<span class="keyword">new</span> Date()) + <span class="string">".png"</span>;</span><br><span class="line">            File file = <span class="keyword">new</span> File(Environment.getExternalStorageDirectory(), filename);</span><br><span class="line">            mCurrentPhotoPath = file.getAbsolutePath();</span><br><span class="line">          </span><br><span class="line"><span class="comment">// 核心就是这一行代码</span></span><br><span class="line">            Uri fileUri = FileProvider.getUriForFile(<span class="keyword">this</span>, <span class="string">"com.siyee.android7.fileprovider"</span>, file);</span><br><span class="line">            takePictureIntent.putExtra(MediaStore.EXTRA_OUTPUT, fileUri);</span><br><span class="line">            startActivityForResult(takePictureIntent, REQUEST_CODE_TAKE_PHOTO);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><blockquote><p>通过FileProvider把<code>file</code>转化为<code>content://uri</code>了</p></blockquote><p>核心代码就这一行了~</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FileProvider.getUriForFile(this, &quot;com.siyee.android7.fileprovider&quot;, file);</span><br></pre></td></tr></table></figure><p>第二个参数就是我们配置的<code>authorities</code>，这个很正常了，总得映射到确定的ContentProvider吧~所以需要这个参数。</p><p>然后再看一眼我们生成的uri：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">content:<span class="comment">//com.siyee.android7.fileprovider/external/20200819-041411.png</span></span><br></pre></td></tr></table></figure><p>可以看到格式为：<code>content://authorities/定义的name属性/文件的相对路径</code>，即<code>name</code>隐藏了可存储的文件夹路径。</p><h1 id="兼容"><a href="#兼容" class="headerlink" title="兼容"></a>兼容</h1><p>如果使用以上代码跑在7.0以上系统的手机没有问题，但是拿回到低版本的手机又会出现崩溃：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Caused by: java.lang.SecurityException: Permission Denial: opening provider androidx.core.content.FileProvider from ProcessRecord&#123;52b029b8 1670:com.android.camera/u0a36&#125; (pid=1670, uid=10036) that is not exported from uid 10052</span><br><span class="line">at android.os.Parcel.readException(Parcel.java:1465)</span><br><span class="line">at android.os.Parcel.readException(Parcel.java:1419)</span><br><span class="line">at android.app.ActivityManagerProxy.getContentProvider(ActivityManagerNative.java:2848)</span><br><span class="line">at android.app.ActivityThread.acquireProvider(ActivityThread.java:4399)</span><br></pre></td></tr></table></figure><p>因为低版本的系统，仅仅是把这个当成一个普通的Provider在使用，而我们没有授权，<code>contentprovider</code>的export设置的也是false；导致<code>Permission Denial</code>。</p><p>而解决的办法就是授权了。通过<code>grantUriPermission(String toPackage, Uri uri,int modeFlags)</code>和<code>revokeUriPermission(Uri uri, int modeFlags)</code>方法。</p><p>可以看到<code>grantUriPermission</code>需要传递一个包名，就是你给哪个应用授权，但是很多时候，比如分享，我们并不知道最终用户会选择哪个app，所以我们可以这样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">List&lt;ResolveInfo&gt; resInfoList = context.getPackageManager()</span><br><span class="line">            .queryIntentActivities(intent, PackageManager.MATCH_DEFAULT_ONLY);</span><br><span class="line"><span class="keyword">for</span> (ResolveInfo resolveInfo : resInfoList) &#123;</span><br><span class="line">    String packageName = resolveInfo.activityInfo.packageName;</span><br><span class="line">    context.grantUriPermission(packageName, uri, flag);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据Intent查询出的所以符合的应用，都给他们授权~~</p><p>恩，你可以在不需要的时候通过<code>revokeUriPermission</code>移除权限~</p><p>那么增加了授权后的代码是这样的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">takePhotoNoCompress</span><span class="params">(View view)</span> </span>&#123;</span><br><span class="line">    Intent takePictureIntent = <span class="keyword">new</span> Intent(MediaStore.ACTION_IMAGE_CAPTURE);</span><br><span class="line">    <span class="keyword">if</span> (takePictureIntent.resolveActivity(getPackageManager()) != <span class="keyword">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">        String filename = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyyMMdd-HHmmss"</span>, Locale.CHINA)</span><br><span class="line">                .format(<span class="keyword">new</span> Date()) + <span class="string">".png"</span>;</span><br><span class="line">        File file = <span class="keyword">new</span> File(Environment.getExternalStorageDirectory(), filename);</span><br><span class="line">        mCurrentPhotoPath = file.getAbsolutePath();</span><br><span class="line"></span><br><span class="line">        Uri fileUri = FileProvider.getUriForFile(<span class="keyword">this</span>, <span class="string">"com.siyee.android7.fileprovider"</span>, file);</span><br><span class="line"></span><br><span class="line">        List&lt;ResolveInfo&gt; resInfoList = getPackageManager()</span><br><span class="line">                .queryIntentActivities(takePictureIntent, PackageManager.MATCH_DEFAULT_ONLY);</span><br><span class="line">        <span class="keyword">for</span> (ResolveInfo resolveInfo : resInfoList) &#123;</span><br><span class="line">            String packageName = resolveInfo.activityInfo.packageName;</span><br><span class="line">            grantUriPermission(packageName, fileUri, Intent.FLAG_GRANT_READ_URI_PERMISSION</span><br><span class="line">                    | Intent.FLAG_GRANT_WRITE_URI_PERMISSION);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        takePictureIntent.putExtra(MediaStore.EXTRA_OUTPUT, fileUri);</span><br><span class="line">        startActivityForResult(takePictureIntent, REQUEST_CODE_TAKE_PHOTO);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是这样的做法相对麻烦，我们可以对系统版本进行判断高版本用<code>FileProvider.getUriForFile</code>，低版本继续使用<code>Uri.fromFile</code>即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Uri fileUri = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= <span class="number">24</span>) &#123;</span><br><span class="line">    fileUri = FileProvider.getUriForFile(<span class="keyword">this</span>, <span class="string">"com.siyee.android7.fileprovider"</span>, file);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    fileUri = Uri.fromFile(file);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="理解FileProvider"><a href="#理解FileProvider" class="headerlink" title="理解FileProvider"></a>理解FileProvider</h1><h2 id="定义FileProvider"><a href="#定义FileProvider" class="headerlink" title="定义FileProvider"></a>定义FileProvider</h2><p>直接使用<code>FileProvider</code>本身或者它的子类，需要在<code>AndroidManifest.xml</code>文件中声明组件的相关属性，包括：</p><ul><li><code>android:name</code>，对应属性值：<code>android.support.v4.content.FileProvider</code>或者子类完整路径</li><li><code>android:authorities</code>，对应属性值是一个常量，通常定义的方式<code>packagename.fileprovider</code>，例如：<code>cn.teachcourse.fileprovider</code></li><li><code>android:exported</code>，对应属性值是一个boolean变量，设置为<code>false</code></li><li><code>android:grantUriPermissions</code>，对应属性值也是一个boolean变量，设置为<code>true</code>，允许获得文件临时的访问权限</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">manifest</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="tag">&lt;<span class="name">application</span>&gt;</span></span><br><span class="line">        ...</span><br><span class="line">        <span class="tag">&lt;<span class="name">provider</span></span></span><br><span class="line"><span class="tag"><span class="attr">android:name</span>=<span class="string">"androidx.core.content.FileProvider"</span></span></span><br><span class="line"><span class="tag"><span class="attr">android:authorities</span>=<span class="string">"com.siyee.android7.fileprovider"</span></span></span><br><span class="line"><span class="tag"><span class="attr">android:exported</span>=<span class="string">"false"</span></span></span><br><span class="line"><span class="tag"><span class="attr">android:grantUriPermissions</span>=<span class="string">"true"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta-data</span></span></span><br><span class="line"><span class="tag"><span class="attr">android:name</span>=<span class="string">"android.support.FILE_PROVIDER_PATHS"</span></span></span><br><span class="line"><span class="tag"><span class="attr">android:resource</span>=<span class="string">"@xml/file_paths"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">provider</span>&gt;</span></span><br><span class="line">        ...</span><br><span class="line">    <span class="tag">&lt;/<span class="name">application</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">manifest</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="指定授予临时访问权限的文件目录"><a href="#指定授予临时访问权限的文件目录" class="headerlink" title="指定授予临时访问权限的文件目录"></a>指定授予临时访问权限的文件目录</h2><p>想要关联<code>res/xml</code>文件夹下创建的<code>file_paths.xml</code>文件，需要在<code>&lt;provider&gt;</code>标签内，添加<code>&lt;meta-data&gt;</code>子标签，设置<code>&lt;meta-data&gt;</code>标签的属性值，包括：</p><ul><li><code>android:name</code>，对应属性值是一个固定的系统常量<code>android.support.FILE_PROVIDER_PATHS</code></li><li><code>android:resource</code>，对应属性值指向我们的xml文件<code>@xml/file_paths</code></li></ul><p>在xml文件中指定文件存储的区块和区块的相对路径，在<code>&lt;paths&gt;</code>根标签中添加<code>&lt;files-path&gt;</code>子标签（稍后详细列出所有子标签），设置子标签的属性值，包括：</p><ul><li><code>name</code>，是一个虚设的文件名（可以自由命名），对外可见路径的一部分，隐藏真实文件目录</li><li><code>path</code>，是一个相对目录，相对于当前的子标签<code>&lt;files-path&gt;</code>根目录</li><li><code>&lt;files-path&gt;</code>，表示内部内存卡根目录，对应根目录等价于<code>Context.getFilesDir()</code>，查看完整路径：<br><code>/data/user/0/com.siyee.demos/files</code></li><li>代码如下：</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">paths</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">files-path</span> <span class="attr">name</span>=<span class="string">"my_images"</span> <span class="attr">path</span>=<span class="string">"images/"</span>/&gt;</span></span><br><span class="line">    ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">paths</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>&lt;paths&gt;</code>根标签下可以添加的子标签也是有限的，参考官网的开发文档，除了上述的提到的<code>&lt;files-path&gt;</code>这个子标签外，还包括下面几个：</p><ol><li><code>&lt;cache-path&gt;</code>，表示应用默认缓存根目录，对应根目录等价于<code>getCacheDir()</code>，查看完整路径：<code>/data/user/0/com.siyee.demos/cache</code></li><li><code>&lt;external-path&gt;</code>，表示外部内存卡根目录，对应根目录等价于<br><code>Environment.getExternalStorageDirectory()</code>，<br>查看完整路径：<code>/storage/emulated/0</code></li><li><code>&lt;external-files-path&gt;</code>，表示外部内存卡根目录下的APP公共目录，对应根目录等价于<br><code>Context#getExternalFilesDir(String) Context.getExternalFilesDir(null)</code>，<br>查看完整路径：<br><code>/storage/emulated/0/Android/data/com.siyee.demos/files/Download</code></li><li><code>&lt;external-cache-path&gt;</code>，表示外部内存卡根目录下的APP缓存目录，对应根目录等价于<code>Context.getExternalCacheDir()</code>，查看完整路径：<br><code>/storage/emulated/0/Android/data/com.siyee.demos/cache</code></li></ol><p>最终，在<code>file_provider.xml</code>文件中，添加上述5种类型的临时访问权限的文件目录，代码如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">paths</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">    1、name对应的属性值，开发者可以自由定义；</span></span><br><span class="line"><span class="comment">    2、path对应的属性值，当前external-path标签下的相对路径</span></span><br><span class="line"><span class="comment">    比如：/storage/emulated/0/92Recycle-release.apk</span></span><br><span class="line"><span class="comment">    sdcard路径：/storage/emulated/0(WriteToReadActivity.java:176)</span></span><br><span class="line"><span class="comment">                      at cn.teachcourse.nougat.WriteToReadActivity.onClick(WriteToReadActivity.java:97)</span></span><br><span class="line"><span class="comment">                      at android.view.View.performClick(View.java:5610)</span></span><br><span class="line"><span class="comment">                      at android.view.View$PerformClick.run(View.java:22265)</span></span><br><span class="line"><span class="comment">    相对路径：/</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--1、对应内部内存卡根目录：Context.getFileDir()--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">files-path</span></span></span><br><span class="line"><span class="tag">        <span class="attr">name</span>=<span class="string">"int_root"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">path</span>=<span class="string">"/"</span> /&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--2、对应应用默认缓存根目录：Context.getCacheDir()--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">cache-path</span></span></span><br><span class="line"><span class="tag">        <span class="attr">name</span>=<span class="string">"app_cache"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">path</span>=<span class="string">"/"</span> /&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--3、对应外部内存卡根目录：Environment.getExternalStorageDirectory()--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">external-path</span></span></span><br><span class="line"><span class="tag">        <span class="attr">name</span>=<span class="string">"ext_root"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">path</span>=<span class="string">"pictures/"</span> /&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--4、对应外部内存卡根目录下的APP公共目录：Context.getExternalFileDir(String)--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">external-files-path</span></span></span><br><span class="line"><span class="tag">        <span class="attr">name</span>=<span class="string">"ext_pub"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">path</span>=<span class="string">"/"</span> /&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--5、对应外部内存卡根目录下的APP缓存目录：Context.getExternalCacheDir()--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">external-cache-path</span></span></span><br><span class="line"><span class="tag">        <span class="attr">name</span>=<span class="string">"ext_cache"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">path</span>=<span class="string">"/"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">paths</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="生成指定文件的Content-URI"><a href="#生成指定文件的Content-URI" class="headerlink" title="生成指定文件的Content URI"></a>生成指定文件的Content URI</h2><p>Content URI方便与另一个APP应用程序共享同一个文件，共享的方式通过<code>ContentResolver.openFileDescriptor</code>获得一个<code>ParcelFileDescriptor</code>对象，读取文件内容。那么，如何生成一条完整的Content URI呢？TeachCourse总结后，概括为三个步骤，<strong>第一步：</strong>明确上述5种类型中的哪一种，<strong>第二步：</strong>明确指定文件的完整路径（包括目录、文件名），<strong>第三步：</strong>调用<code>getUriForFile()</code>方法生成URI</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">File imagePath = <span class="keyword">new</span> File(Environment.getExternalStorageDirectory(), <span class="string">"download"</span>);</span><br><span class="line">File newFile = <span class="keyword">new</span> File(imagePath, <span class="string">"default_image.jpg"</span>);</span><br><span class="line">Uri contentUri = getUriForFile(getContext(), <span class="string">"com.siyee.android7.fileprovider"</span>, newFile);</span><br></pre></td></tr></table></figure><h2 id="授予Content-URI临时访问权限"><a href="#授予Content-URI临时访问权限" class="headerlink" title="授予Content URI临时访问权限"></a>授予Content URI临时访问权限</h2><p>上一步获得的Content URI，并没有获得指定文件的读写权限，想要获得文件的读写权限需要调用<code>Context.grantUriPermission(package, Uri, mode_flags)</code>方法，该方法向指定包名的应用程序申请获得读取或者写入文件的权限，参数说明如下：</p><ul><li><code>package</code>，指定应用程序的包名，Android Studio真正的包名指<code>build.gradle</code>声明的<em>applicationId</em>属性值；<code>getPackageName()</code>指<code>AndroidManifest.xml</code>文件声明的<em>package</em>属性值，如果两者不一致，就不能提供<code>getPackageName()</code>获取包名，否则报错！</li><li><code>Uri</code>，指定请求授予临时权限的URI，例如：<code>contentUri</code></li><li><code>mode_flags</code>，指定授予临时权限的类型，选择其中一个常量或两个：<code>Intent.FLAG_GRANT_READ_URI_PERMISSION</code>，<code>Intent.FLAG_GRANT_WRITE_URI_PERMISSION</code></li></ul><p>授予文件的临时读取或写入权限，如果不再需要了，TeachCourse该如何撤销授予呢？撤销权限有两种方式：<strong>第一种：</strong>通过调用<code>revokeUriPermission()</code>撤销，<strong>第二种：</strong>重启系统后自动撤销</p><h1 id="使用FileProvider兼容安装apk"><a href="#使用FileProvider兼容安装apk" class="headerlink" title="使用FileProvider兼容安装apk"></a><a href="https://blog.csdn.net/lmj623565791/article/details/72859156" target="_blank" rel="noopener">使用FileProvider兼容安装apk</a></h1><p>正常我们在编写安装apk的时候，是这样的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">installApk</span><span class="params">(View view)</span> </span>&#123;</span><br><span class="line">    File file = <span class="keyword">new</span> File(Environment.getExternalStorageDirectory(), <span class="string">"testandroid7-debug.apk"</span>);</span><br><span class="line"></span><br><span class="line">    Intent intent = <span class="keyword">new</span> Intent(Intent.ACTION_VIEW);</span><br><span class="line">    intent.setDataAndType(Uri.fromFile(file),</span><br><span class="line">            <span class="string">"application/vnd.android.package-archive"</span>);</span><br><span class="line">    startActivity(intent);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>拿个7.0的原生手机跑一下，<code>android.os.FileUriExposedException</code>又来了~~</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">android.os.FileUriExposedException: file:///storage/emulated/0/testandroid7-debug.apk exposed beyond app through Intent.getData()</span><br></pre></td></tr></table></figure><p>好在有经验了，简单修改下uri的获取方式。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= <span class="number">24</span>) &#123;</span><br><span class="line">    fileUri = FileProvider.getUriForFile(<span class="keyword">this</span>, <span class="string">"com.zhy.android7.fileprovider"</span>, file);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    fileUri = Uri.fromFile(file);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再跑一次，没想到还是抛出了异常（警告，没有Crash）:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">java.lang.SecurityException: Permission Denial: </span><br><span class="line">opening provider android.support.v4.content.FileProvider </span><br><span class="line">        from ProcessRecord&#123;18570a 27107:com.google.android.packageinstaller/u0a26&#125; (pid=27107, uid=10026) that is not exported from UID 10004123</span><br></pre></td></tr></table></figure><p>可以看到是权限问题，对于权限我们刚说了一种方式为<code>grantUriPermission</code>，这种方式当然是没问题的啦~</p><p>加上后运行即可。</p><p>其实对于权限，还提供了一种方式，即：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">intent.addFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION | Intent.FLAG_GRANT_WRITE_URI_PERMISSION);</span><br></pre></td></tr></table></figure><p>我们可以在安装包之前加上上述代码，再次运行正常啦~</p><p>现在我有两个非常疑惑的问题：</p><ul><li>问题1：为什么刚才拍照的时候，Android 7的设备并没有遇到<code>Permission Denial</code>的问题？</li></ul><p>恩，之所以不需要权限，主要是因为Intent的action为<code>ACTION_IMAGE_CAPTURE</code>，当我们<code>startActivity</code>后，会辗转调用<code>Instrumentation的execStartActivity</code>方法，在该方法内部，会调用<code>intent.migrateExtraStreamToClipData();</code>方法。</p><p>该方法中包含：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (MediaStore.ACTION_IMAGE_CAPTURE.equals(action)</span><br><span class="line">        || MediaStore.ACTION_IMAGE_CAPTURE_SECURE.equals(action)</span><br><span class="line">        || MediaStore.ACTION_VIDEO_CAPTURE.equals(action)) &#123;</span><br><span class="line">    <span class="keyword">final</span> Uri output;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        output = getParcelableExtra(MediaStore.EXTRA_OUTPUT);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ClassCastException e) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (output != <span class="keyword">null</span>) &#123;</span><br><span class="line">        setClipData(ClipData.newRawUri(<span class="string">""</span>, output));</span><br><span class="line">        addFlags(FLAG_GRANT_WRITE_URI_PERMISSION|FLAG_GRANT_READ_URI_PERMISSION);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到将我们的<code>EXTRA_OUTPUT</code>，转为了<code>setClipData</code>，并直接给我们添加了<code>WRITE</code>和<code>READ</code>权限。</p><blockquote><p>注：该部分逻辑应该是21之后添加的。</p></blockquote><ul><li>问题2：为什么刚才拍照案例的时候，Android 4.4设备遇到权限问题，不通过addFlags这种方式解决？</li></ul><p>因为addFlags主要用于<code>setData</code>，<code>setDataAndType</code>以及<code>setClipData</code>（注意：4.4时，并没有将<code>ACTION_IMAGE_CAPTURE</code>转为<code>setClipData</code>实现）这种方式。</p><p>所以<code>addFlags</code>方式对于<code>ACTION_IMAGE_CAPTURE</code>在5.0以下是无效的，所以需要使用<code>grantUriPermission</code>，如果是正常的通过setData分享的uri，使用<code>addFlags</code>是没有问题的（可以写个简单的例子测试下，两个app交互，通过<code>content://</code>）。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>使用<code>content://</code>替代<code>file://</code>，主要需要<code>FileProvider</code>的支持，而因为<code>FileProvider</code>是<code>ContentProvider</code>的子类，所以需要在<code>AndroidManifest.xml</code>中注册；而又因为需要对真实的<code>filepath</code>进行映射，所以需要编写一个<code>xml</code>文档，用于描述可使用的文件夹目录，以及通过<code>name</code>去映射该文件夹目录。</p><p>对于权限，有两种方式：</p><ul><li>方式一为<code>Intent.addFlags</code>，该方式主要用于针对<code>intent.setData</code>，<code>setDataAndType</code>以及<code>setClipData</code>相关方式传递<code>uri</code>的。</li><li>方式二为<code>grantUriPermission</code>来进行授权</li></ul><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://blog.csdn.net/lmj623565791/article/details/72859156" target="_blank" rel="noopener">https://blog.csdn.net/lmj623565791/article/details/72859156</a></p><p><a href="https://www.cnblogs.com/dazhao/p/6547811.html" target="_blank" rel="noopener">https://www.cnblogs.com/dazhao/p/6547811.html</a></p><p><a href="https://www.jianshu.com/p/bce6a4c779dd" target="_blank" rel="noopener">https://www.jianshu.com/p/bce6a4c779dd</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;项目之前使用了第三方库的时候，对于&lt;code&gt;FileProvider&lt;/code&gt;的适配还不是很了解，因为使用时第三方库已经进行了适配。但是自己去覆写别人的第三方库的时候了解到了&lt;code&gt;FileProvider&lt;/code&gt;的适配。&lt;/p&gt;
&lt;p&gt;对于Android 7.0，提供了非常多的变化，详细的可以阅读官方文档&lt;a href=&quot;https://developer.android.com/about/versions/nougat/android-7.0-changes.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Android 7.0 行为变更&lt;/a&gt;，但是该文章主要叙述关于&lt;code&gt;FileProvider&lt;/code&gt;的适配。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt; 在官方7.0的以上的系统中，尝试传递 &lt;code&gt;file://URI&lt;/code&gt;可能会触发&lt;code&gt;FileUriExposedException&lt;/code&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Android" scheme="http://hackycy.github.io/categories/Android/"/>
    
    
      <category term="Android" scheme="http://hackycy.github.io/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>科学上网搭建</title>
    <link href="http://hackycy.github.io/2020/07/28/%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91%E6%90%AD%E5%BB%BA/"/>
    <id>http://hackycy.github.io/2020/07/28/科学上网搭建/</id>
    <published>2020-07-28T14:50:48.000Z</published>
    <updated>2021-05-03T11:11:23.948Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>最近某灯挂的厉害，导致Google Download的东西实在是太慢了。同事给了一些SSR的搭建方法。以此记录了下来。</p><a id="more"></a><h1 id="教程"><a href="#教程" class="headerlink" title="教程"></a>教程</h1><p><strong>选服务器</strong></p><p>我是使用<a href="https://www.vultr.com/" target="_blank" rel="noopener">vultr</a>，新建主机这里就不多详细叙述了。选择CentOS 7的即可。</p><p>新建主机后拿到IP地址查看下是否能够Ping通，Ping不同也无法使用SSH连接的。</p><p><strong>SSH连接后敲命令搭建好SSR的服务器环境：</strong></p><p><strong>CentOS:</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ yum install python-setuptools &amp;&amp; easy_install pip</span><br><span class="line">$ pip install shadowsocks</span><br></pre></td></tr></table></figure><p><strong>Debian / Ubuntu:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">apt-get install python-pip</span><br><span class="line">pip install shadowsocks</span><br></pre></td></tr></table></figure><p><strong>Windows:</strong></p><p>See <a href="https://github.com/shadowsocks/shadowsocks/wiki/Install-Shadowsocks-Server-on-Windows" target="_blank" rel="noopener">Install Server on Windows</a></p><p><strong>简单用法</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ssserver -p 443 -k password -m aes-256-cfb</span><br></pre></td></tr></table></figure><p><strong>后台运行</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo ssserver -p 443 -k password -m aes-256-cfb --user nobody -d start</span><br></pre></td></tr></table></figure><blockquote><p><code>-p</code>指定端口，<code>-k</code>指定密码，<code>-m</code>指定加密方式，客户端连接时都需要对应上</p></blockquote><p><strong>停止</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo ssserver -d stop</span><br></pre></td></tr></table></figure><p><strong>检查日志</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo less /var/<span class="built_in">log</span>/shadowsocks.log</span><br></pre></td></tr></table></figure><blockquote><p>通过检查所有选项-h。您也可以使用配置文件。</p></blockquote><h1 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h1><p><a href="https://github.com/shadowsocks/shadowsocks-windows" target="_blank" rel="noopener">Windows</a> | <a href="https://github.com/shadowsocks/ShadowsocksX-NG" target="_blank" rel="noopener">OS X</a></p><p>打开小飞机，点击服务器，增加配置，根据服务器配置的填写即可。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://github.com/shadowsocksr-backup/shadowsocksr" target="_blank" rel="noopener">https://github.com/shadowsocksr-backup/shadowsocksr</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;最近某灯挂的厉害，导致Google Download的东西实在是太慢了。同事给了一些SSR的搭建方法。以此记录了下来。&lt;/p&gt;
    
    </summary>
    
      <category term="程序人生" scheme="http://hackycy.github.io/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/"/>
    
    
  </entry>
  
  <entry>
    <title>深入理解Java泛型</title>
    <link href="http://hackycy.github.io/2020/07/23/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E6%B3%9B%E5%9E%8B/"/>
    <id>http://hackycy.github.io/2020/07/23/深入理解Java泛型/</id>
    <published>2020-07-23T13:21:29.000Z</published>
    <updated>2021-05-03T11:11:23.948Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="泛型的定义"><a href="#泛型的定义" class="headerlink" title="泛型的定义"></a>泛型的定义</h1><p><strong>泛型</strong>，即<code>参数化类型</code>。就是将类型由原来的具体的类型参数化，类似于方法中的变量参数，此时类型也定义成参数形式（可以称之为类型形参），然后在使用/调用时传入具体的类型（类型实参）。<br>例如：<code>GenericClass**&lt;T&gt;**{}</code></p><a id="more"></a><blockquote><p>一些常用的泛型类型变量：<br>E：元素（Element），多用于java集合框架<br>K：关键字（Key）<br>N：数字（Number）<br>T：类型（Type）<br>V：值（Value）</p></blockquote><p>先来看个简单的例子，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> ArrayList();</span><br><span class="line">list.add(<span class="string">"1"</span>);</span><br><span class="line">list.add(<span class="string">"2"</span>);</span><br><span class="line">list.add(<span class="number">2</span>);</span><br></pre></td></tr></table></figure><p>运行后会发现报了一个错误</p><p><img src="https://github.static.si-yee.com/posts/generic/1.png" alt></p><p>这里可以看出来在代码编写阶段就已经报错了，不能往string类型的集合中添加int类型的数据。</p><p>那可不可以往List集合中添加多个类型的数据呢，答案是可以的，其实我们可以把list集合当成普通的类也是没问题的，那么就有下面的代码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">List list = <span class="keyword">new</span> ArrayList();</span><br><span class="line">list.add(<span class="string">"1"</span>);</span><br><span class="line">list.add(<span class="string">"2"</span>);</span><br><span class="line">list.add(<span class="number">2</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; list.size(); i++) &#123;</span><br><span class="line">System.out.println(list.get(<span class="number">0</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从这里可以看出来，不定义泛型也是可以往集合中添加数据的，<strong>所以说泛型只是一种类型的规范，在代码编写阶段起一种限制。</strong></p><p>下面我们通过例子来介绍泛型背后数据是什么类型。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo01</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        BaseBean&lt;String&gt; bean = <span class="keyword">new</span> BaseBean&lt;&gt;();</span><br><span class="line">        bean.setValue(<span class="string">"China"</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Field value = bean.getClass().getDeclaredField(<span class="string">"value"</span>);</span><br><span class="line">            Class&lt;?&gt; type = value.getType();</span><br><span class="line">            String name = type.getName();</span><br><span class="line">            System.out.println(<span class="string">"type: "</span> + name);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 获取方法上的泛型类型</span></span><br><span class="line">            Method getValue = bean.getClass().getDeclaredMethod(<span class="string">"getValue"</span>);</span><br><span class="line">            Object invoke = getValue.invoke(bean);</span><br><span class="line">            String methodName = invoke.getClass().getName();</span><br><span class="line">            System.out.println(<span class="string">"methodName: "</span> + methodName);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BaseBean</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    T value;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setValue</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; Task :Demo01.main()</span><br><span class="line"><span class="built_in">type</span>: java.lang.Object</span><br><span class="line">methodName: java.lang.String</span><br></pre></td></tr></table></figure><p>从日志上看到通过反射获取到的属性是<code>Object</code>类型的，在方法中返回的是<code>String</code>类型，因此可以思考在<code>getValue</code>方法里面实际是做了个强转的动作，将<code>Object</code>类型的value强转成<code>String</code>类型。</p><p>因为泛型只是为了约束我们规范代码，而对于编译完之后的class交给虚拟机后，对于虚拟机它是没有泛型的说法的，所有的泛型在它看来都是<code>Object</code>类型，因此<strong>泛型擦除</strong>是对于虚拟机而言的。</p><p>下面我们再来看一种泛型结构：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BaseBean2</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">String</span>&gt; </span>&#123;</span><br><span class="line">    T value;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setValue</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将泛型加了个关键字<code>extends</code>，对于泛型写得多的伙伴们来说，<code>extends</code>是约束了泛型是向下继承的，最后我们通过反射获取value的类型是String类型的，因此这里也不难看出，加<code>extends</code>关键字其实最终目的是约束泛型是属于哪一类的。所以我们在编写代码的时候如果没有向下兼容类型，会警告错误的：</p><p><img src="https://github.static.si-yee.com/posts/generic/2.png" alt></p><p>既然说了泛型其实对于jvm来说都是Object类型的，那咱们直接将类型定义成<code>Object</code>不就是的了，这种做法是可以，但是在拿到<code>Object</code>类型值之后，自己还得强转，因此泛型减少了代码的强转工作，而将这些工作交给了虚拟机。</p><p>比如下面我们没有定义泛型的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BaseBean3</span> </span>&#123;</span><br><span class="line">    Object value;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setValue</span><span class="params">(Object value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>势必在getValue的时候代码有个强转的过程，因此在能用泛型的时候，尽量用泛型来写，而且我认为一个好的架构师，业务的抽取是离不开泛型的定义。</p><blockquote><p>常见的泛型主要有作用在普通类上面，作用在抽象类、接口、静态或非静态方法上。</p></blockquote><h1 id="类上面的泛型"><a href="#类上面的泛型" class="headerlink" title="类上面的泛型"></a><strong>类上面的泛型</strong></h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseBean</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String errMsg;</span><br><span class="line">    <span class="keyword">public</span> T data;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="抽象类或接口上的泛型"><a href="#抽象类或接口上的泛型" class="headerlink" title="抽象类或接口上的泛型"></a><strong>抽象类或接口上的泛型</strong></h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseAdapter</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    List&lt;T&gt; DATAS;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Factory</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function">T <span class="title">create</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">getData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="多元泛型"><a href="#多元泛型" class="headerlink" title="多元泛型"></a><strong>多元泛型</strong></h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Base</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setKey</span><span class="params">(K k)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">V <span class="title">getValue</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="多种泛型约束"><a href="#多种泛型约束" class="headerlink" title="多种泛型约束"></a>多种泛型约束</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends Comparable&lt;T&gt; &amp; Supplier&lt;R&gt;, R extends Number&gt; &#123;</span><br><span class="line">  <span class="function">R <span class="title">callMax</span><span class="params">(T a, R b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a.compareTo(b) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> a.get();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> b.get();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="泛型二级抽象类或接口"><a href="#泛型二级抽象类或接口" class="headerlink" title="泛型二级抽象类或接口"></a><strong>泛型二级抽象类或接口</strong></h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BaseCommon</span>&lt;<span class="title">K</span> <span class="keyword">extends</span> <span class="title">Common1</span>, <span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">Base</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseCommon</span>&lt;<span class="title">K</span> <span class="keyword">extends</span> <span class="title">Common1</span>, <span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Base</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="抽象里面包含抽象"><a href="#抽象里面包含抽象" class="headerlink" title="抽象里面包含抽象"></a><strong>抽象里面包含抽象</strong></h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Base</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">addNode</span><span class="params">(Map&lt;K, V&gt; map)</span></span>;</span><br><span class="line"></span><br><span class="line">   <span class="function">Map&lt;K, V&gt; <span class="title">getNode</span><span class="params">(<span class="keyword">int</span> index)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseCommon</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Base</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">   </span><br><span class="line">   LinkedList&lt;Map&lt;K, V&gt;&gt; DATAS = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addNode</span><span class="params">(Map&lt;K, V&gt; map)</span> </span>&#123;</span><br><span class="line">       DATAS.addLast(map);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> Map&lt;K, V&gt; <span class="title">getNode</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> DATAS.get(index);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="lt-gt-通配符"><a href="#lt-gt-通配符" class="headerlink" title="&lt;?&gt;通配符"></a><strong>&lt;?&gt;通配符</strong></h1><p><code>&lt;?&gt;通配符</code>和 <code>&lt;T&gt;</code> 区别是<code>&lt;?&gt;</code>在你不知道泛型类型的时候，可以用<code>&lt;?&gt;</code>通配符来定义，下面通过一个例子来看看<code>&lt;?&gt;</code>的用处：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BaseBean</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    T value;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setValue</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Common</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Common1</span> <span class="keyword">extends</span> <span class="title">Common</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://github.static.si-yee.com/posts/generic/3.png" alt></p><p>在定义的时候将<code>Common</code>的泛型指向<code>Common1</code>的泛型，可以看到直接提示有问题，这里可以想，虽然<code>Common1</code>是继承自<code>Common</code>的，但是并不代表<code>BaseBean</code>之间是等量的，在开篇也讲过，如果泛型传入的是什么类型，那么在<code>BaseBean</code>中的<code>getValue</code>返回的类型就是什么，因此可以想两个不同的泛型类肯定是不等价的，但是如果我这里写呢：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    BaseBean&lt;Common&gt; commonBaseBean = <span class="keyword">new</span> BaseBean&lt;&gt;();</span><br><span class="line">    </span><br><span class="line">    BaseBean&lt;?&gt; common1BaseBean = commonBaseBean;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        </span><br><span class="line">        Method setValue = common1BaseBean.getClass().getDeclaredMethod(<span class="string">"setValue"</span>, Object<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        setValue.invoke(common1BaseBean, <span class="string">"123"</span>);</span><br><span class="line">        Object value = common1BaseBean.getValue();</span><br><span class="line">        System.out.println(<span class="string">"result:"</span> + value);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (NoSuchMethodException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InvocationTargetException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面如果定义的泛型是通配符是可以等价的，因为此时的setValue的参数是Object类型，所以能直接将上面定义的泛型赋给通配符的BaseBean。</p><p><strong>通配符不能定义在类上面、接口或方法上，只能作用在方法的参数上</strong></p><p><img src="https://github.static.si-yee.com/posts/generic/4.png" alt></p><p>其他的几种情况自己去尝试，正确的使用通配符:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setClass</span><span class="params">(Class&lt;?&gt; class)</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure><h1 id="上限以及下限泛型"><a href="#上限以及下限泛型" class="headerlink" title="上限以及下限泛型"></a>上限以及下限泛型</h1><p><strong><code>&lt;T extends &gt;</code>、<code>&lt;T super &gt;</code>、<code>&lt;? extends &gt;</code>、<code>&lt;? super &gt;</code></strong></p><p><code>&lt;T extends **&gt;</code>表示上限泛型、<code>&lt;T super **&gt;</code>表示下限泛型<br>为了演示这两个通配符的作用，增加了一个类:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo01</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        BaseBean&lt;Common&gt; beanCommon = <span class="keyword">new</span> BaseBean();</span><br><span class="line">        BaseBean&lt;BaseCommon&gt; baseCommonBaseBean = beanCommon;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BaseBean</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">Common</span>&gt; </span>&#123;</span><br><span class="line">    T value;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setValue</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BaseCommon</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Common</span> <span class="keyword">extends</span> <span class="title">BaseCommon</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>会看到出现以下错误</p><p><code>Type parameter &#39;BaseCommon&#39; is not within its bound; should extend &#39;Common&#39;</code></p><p>第二个定义的泛型是不合法的，因为<code>BaseCommon</code>是<code>Common</code>的父类，超出了<code>Common</code>的类型范围。</p><p><strong><code>&lt;T super &gt;</code>不能作用在类、接口、方法上，只能通过方法传参来定义泛型</strong><br>在BaseBean里面定义了个方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo01</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        BaseBean&lt;Common&gt; beanCommon = <span class="keyword">new</span> BaseBean();</span><br><span class="line">        beanCommon.add(Common<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        beanCommon.add(Common1<span class="class">.<span class="keyword">class</span>)</span>; <span class="comment">//出现报错</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BaseBean</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">Common</span>&gt; </span>&#123;</span><br><span class="line">    T value;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setValue</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Class&lt;? <span class="keyword">super</span> Common&gt; clazz)</span> </span>&#123;</span><br><span class="line">      <span class="comment">// 增加的方法</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BaseCommon</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Common</span> <span class="keyword">extends</span> <span class="title">BaseCommon</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Common1</span> <span class="keyword">extends</span>  <span class="title">Common</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>可以看到当传进去的是<code>Common1.class</code>的时候是不合法的，因为在<code>add</code>方法中需要传入<code>Common</code>父类的字节码对象，而<code>Common1</code>是继承自<code>Common</code>，所以直接不合法。</p><blockquote><p>在实际开发中其实知道什么时候定义什么类型的泛型就ok，在mvp实际案例中泛型用得比较广泛，大家可以根据实际项目来找找泛型的感觉，只是面试的时候需要理解类型擦除是针对谁而言的。</p></blockquote><h1 id="类型擦除"><a href="#类型擦除" class="headerlink" title="类型擦除"></a>类型擦除</h1><p>其实在开篇的时候已经通过例子说明了，通过反射绕开泛型的定义，也说明了类中定义的泛型最终是以Object被jvm执行。</p><p>所有的泛型在jvm中执行的时候，都是以<code>Object</code>对象存在的，加泛型只是为了一种代码的规范，避免了开发过程中再次强转。<br><strong>泛型信息只存在于代码编译阶段，在进入 JVM 之前，与泛型相关的信息会被擦除掉，专业术语叫做类型擦除。</strong></p><p><strong>摘录自</strong>：</p><p><a href="http://www.jianshu.com/p/dd34211f2565" target="_blank" rel="noopener">www.jianshu.com/p/dd34211f2565</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;泛型的定义&quot;&gt;&lt;a href=&quot;#泛型的定义&quot; class=&quot;headerlink&quot; title=&quot;泛型的定义&quot;&gt;&lt;/a&gt;泛型的定义&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;泛型&lt;/strong&gt;，即&lt;code&gt;参数化类型&lt;/code&gt;。就是将类型由原来的具体的类型参数化，类似于方法中的变量参数，此时类型也定义成参数形式（可以称之为类型形参），然后在使用/调用时传入具体的类型（类型实参）。&lt;br&gt;例如：&lt;code&gt;GenericClass**&amp;lt;T&amp;gt;**{}&lt;/code&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="http://hackycy.github.io/categories/Java/"/>
    
    
      <category term="Java" scheme="http://hackycy.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Flutter引入第三方Icon图标</title>
    <link href="http://hackycy.github.io/2020/07/02/Flutter%E5%BC%95%E5%85%A5%E7%AC%AC%E4%B8%89%E6%96%B9Icon%E5%9B%BE%E6%A0%87/"/>
    <id>http://hackycy.github.io/2020/07/02/Flutter引入第三方Icon图标/</id>
    <published>2020-07-02T14:26:06.000Z</published>
    <updated>2021-05-03T11:11:23.416Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><strong>Flutter虽然内置了很多Icon图标，但是还是需要引入自己或第三方图标库提供的Icon。下面是解决办法。本文以<a href="http://iconfont.cn/" target="_blank" rel="noopener">阿里巴巴图标库</a>为例。</strong></p><a id="more"></a><p>1、在阿里图标库选好需要用的图标，添加进购物车将选好的图标打包下载到本地（下载代码），复制<code>iconfont.ttf</code>文件到项目中。</p><p>2、将该文件放置于你的flutter项目下的<code>assets/fonts/</code>下。</p><p>3、打开项目根目录中的pubspec.yaml文件，在flutter中增加配置</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># The following section is specific to Flutter.</span></span><br><span class="line"><span class="attr">flutter:</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># The following line ensures that the Material Icons font is</span></span><br><span class="line">  <span class="comment"># included with your application, so that you can use the icons in</span></span><br><span class="line">  <span class="comment"># the material Icons class.</span></span><br><span class="line">  <span class="attr">uses-material-design:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># An image asset can refer to one or more resolution-specific "variants", see</span></span><br><span class="line">  <span class="comment"># https://flutter.dev/assets-and-images/#resolution-aware.</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># For details regarding adding assets from package dependencies, see</span></span><br><span class="line">  <span class="comment"># https://flutter.dev/assets-and-images/#from-packages</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># To add custom fonts to your application, add a fonts section here,</span></span><br><span class="line">  <span class="comment"># in this "flutter" section. Each entry in this list should have a</span></span><br><span class="line">  <span class="comment"># "family" key with the font family name, and a "fonts" key with a</span></span><br><span class="line">  <span class="comment"># list giving the asset and other descriptors for the font. For</span></span><br><span class="line">  <span class="comment"># example:</span></span><br><span class="line">  <span class="attr">fonts:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">family:</span> <span class="string">Iconfont</span></span><br><span class="line">      <span class="attr">fonts:</span></span><br><span class="line">         <span class="bullet">-</span> <span class="attr">asset:</span> <span class="string">assets/fonts/iconfont.ttf</span></span><br></pre></td></tr></table></figure><p><code>Iconfont</code>为自定义名称，可自己定义。</p><p>4、在项目中使用：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Icon(IconData(<span class="number">0xe621</span>, fontFamily: <span class="string">'iconfont'</span>));</span><br></pre></td></tr></table></figure><p>其中：<code>IconData()</code>里面，第一个参数为codePoint，代表图标字体存储的<code>Unicode</code>，这个可以在打开阿里巴巴库标题的下载文件中的HTML文件查看，<strong>将 &amp;# 字符替换为 0 即可，fontFamily：后面跟自定义的字体图标名称，我这里是Iconfont</strong></p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://blog.csdn.net/shuaizi96/article/details/88550217" target="_blank" rel="noopener">https://blog.csdn.net/shuaizi96/article/details/88550217</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;Flutter虽然内置了很多Icon图标，但是还是需要引入自己或第三方图标库提供的Icon。下面是解决办法。本文以&lt;a href=&quot;http://iconfont.cn/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;阿里巴巴图标库&lt;/a&gt;为例。&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Flutter" scheme="http://hackycy.github.io/categories/Flutter/"/>
    
    
      <category term="Flutter" scheme="http://hackycy.github.io/tags/Flutter/"/>
    
  </entry>
  
  <entry>
    <title>解决Mac flutter run报错：FileSystemException</title>
    <link href="http://hackycy.github.io/2020/06/05/%E8%A7%A3%E5%86%B3Mac-flutter-run%E6%8A%A5%E9%94%99%EF%BC%9AFileSystemException/"/>
    <id>http://hackycy.github.io/2020/06/05/解决Mac-flutter-run报错：FileSystemException/</id>
    <published>2020-06-05T10:44:53.000Z</published>
    <updated>2021-05-03T11:11:23.984Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>在正式学习完Dart的路程下，兴奋的配置完成Flutter的环境后，想要跑一个demo的时候坑又来了一个。</p><a id="more"></a><h1 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h1><p><strong>flutter doctor</strong>无问题</p><p><img src="https://github.static.si-yee.com/posts/flutterrunFileSystemExceptionError/20200605104644.png" alt></p><p>但是在<strong>flutter run</strong>后出现了该错误：</p><p><img src="https://github.static.si-yee.com/posts/flutterrunFileSystemExceptionError/20200605104915.png" alt></p><p>出现这些问题，查看了Flutter的很多issues，有的说权限，有的说配置国内源。的确如此，但是先确认好步骤。</p><h1 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h1><p>如果安装好了SDK先删除重新配置吧。环境配置的变量可以不用删除。重复安装sdk的步骤就可以了。<strong>记得先配好环境变量再运行Flutter的相关命令</strong>。特别是配置国内源。<a href="https://flutter.dev/docs/get-started/install/macos" target="_blank" rel="noopener">官方教程</a></p><p>配置<code>.bash_profile</code>，如果是使用<code>zsh</code>下，每次都需要打开终端后输入<code>source ~/.bash_profile</code>，解决方法就是在<code>.zshrc</code>文件配置<code>source ~/.bash_profile</code>命令即可。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> PUB_HOSTED_URL=https://mirrors.tuna.tsinghua.edu.cn/dart-pub</span><br><span class="line"><span class="built_in">export</span> FLUTTER_STORAGE_BASE_URL=https://mirrors.tuna.tsinghua.edu.cn/flutter</span><br><span class="line"><span class="built_in">export</span> PATH=<span class="string">"<span class="variable">$PATH</span>:/Users/zjyzy/Library/Flutter/bin"</span></span><br></pre></td></tr></table></figure><blockquote><p>如果你有科学上网，可以配置代理：</p><p><code>export http_proxy=http://127.0.0.1:1087</code>和<code>export https_proxy=http://127.0.0.1:1087</code></p></blockquote><p>重新配置好SDK后，配置好<code>flutter precache</code>和<code>flutter doctor</code>无误后，配置Flutter SDK的目录权限。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo chmod -R 777 /Users/zjyzy/Library/Flutter/bin</span><br></pre></td></tr></table></figure><p>使用<code>flutter create</code>命令创建项目，<strong>这里要记住，一定不要使用sudo创建项目</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line">$ flutter create flutterdemo</span><br><span class="line">Creating project flutterdemo...</span><br><span class="line">  flutterdemo/ios/Runner.xcworkspace/contents.xcworkspacedata (created)</span><br><span class="line">  flutterdemo/ios/Runner.xcworkspace/xcshareddata/IDEWorkspaceChecks.plist (created)</span><br><span class="line">  flutterdemo/ios/Runner.xcworkspace/xcshareddata/WorkspaceSettings.xcsettings (created)</span><br><span class="line">  flutterdemo/ios/Runner/Info.plist (created)</span><br><span class="line">  flutterdemo/ios/Runner/Assets.xcassets/LaunchImage.imageset/LaunchImage@2x.png (created)</span><br><span class="line">  flutterdemo/ios/Runner/Assets.xcassets/LaunchImage.imageset/LaunchImage@3x.png (created)</span><br><span class="line">  flutterdemo/ios/Runner/Assets.xcassets/LaunchImage.imageset/README.md (created)</span><br><span class="line">  flutterdemo/ios/Runner/Assets.xcassets/LaunchImage.imageset/Contents.json (created)</span><br><span class="line">  flutterdemo/ios/Runner/Assets.xcassets/LaunchImage.imageset/LaunchImage.png (created)</span><br><span class="line">  flutterdemo/ios/Runner/Assets.xcassets/AppIcon.appiconset/Icon-App-76x76@2x.png (created)</span><br><span class="line">  flutterdemo/ios/Runner/Assets.xcassets/AppIcon.appiconset/Icon-App-29x29@1x.png (created)</span><br><span class="line">  flutterdemo/ios/Runner/Assets.xcassets/AppIcon.appiconset/Icon-App-40x40@1x.png (created)</span><br><span class="line">  flutterdemo/ios/Runner/Assets.xcassets/AppIcon.appiconset/Icon-App-20x20@1x.png (created)</span><br><span class="line">  flutterdemo/ios/Runner/Assets.xcassets/AppIcon.appiconset/Icon-App-1024x1024@1x.png (created)</span><br><span class="line">  flutterdemo/ios/Runner/Assets.xcassets/AppIcon.appiconset/Icon-App-83.5x83.5@2x.png (created)</span><br><span class="line">  flutterdemo/ios/Runner/Assets.xcassets/AppIcon.appiconset/Icon-App-20x20@3x.png (created)</span><br><span class="line">  flutterdemo/ios/Runner/Assets.xcassets/AppIcon.appiconset/Contents.json (created)</span><br><span class="line">  flutterdemo/ios/Runner/Assets.xcassets/AppIcon.appiconset/Icon-App-20x20@2x.png (created)</span><br><span class="line">  flutterdemo/ios/Runner/Assets.xcassets/AppIcon.appiconset/Icon-App-29x29@3x.png (created)</span><br><span class="line">  flutterdemo/ios/Runner/Assets.xcassets/AppIcon.appiconset/Icon-App-40x40@2x.png (created)</span><br><span class="line">  flutterdemo/ios/Runner/Assets.xcassets/AppIcon.appiconset/Icon-App-60x60@3x.png (created)</span><br><span class="line">  flutterdemo/ios/Runner/Assets.xcassets/AppIcon.appiconset/Icon-App-60x60@2x.png (created)</span><br><span class="line">  flutterdemo/ios/Runner/Assets.xcassets/AppIcon.appiconset/Icon-App-76x76@1x.png (created)</span><br><span class="line">  flutterdemo/ios/Runner/Assets.xcassets/AppIcon.appiconset/Icon-App-40x40@3x.png (created)</span><br><span class="line">  flutterdemo/ios/Runner/Assets.xcassets/AppIcon.appiconset/Icon-App-29x29@2x.png (created)</span><br><span class="line">  flutterdemo/ios/Runner/Base.lproj/LaunchScreen.storyboard (created)</span><br><span class="line">  flutterdemo/ios/Runner/Base.lproj/Main.storyboard (created)</span><br><span class="line">  flutterdemo/ios/Runner.xcodeproj/project.xcworkspace/contents.xcworkspacedata (created)</span><br><span class="line">  flutterdemo/ios/Runner.xcodeproj/project.xcworkspace/xcshareddata/IDEWorkspaceChecks.plist (created)</span><br><span class="line">  flutterdemo/ios/Runner.xcodeproj/project.xcworkspace/xcshareddata/WorkspaceSettings.xcsettings (created)</span><br><span class="line">  flutterdemo/ios/Runner.xcodeproj/xcshareddata/xcschemes/Runner.xcscheme (created)</span><br><span class="line">  flutterdemo/ios/Flutter/Debug.xcconfig (created)</span><br><span class="line">  flutterdemo/ios/Flutter/Release.xcconfig (created)</span><br><span class="line">  flutterdemo/ios/Flutter/AppFrameworkInfo.plist (created)</span><br><span class="line">  flutterdemo/ios/.gitignore (created)</span><br><span class="line">  flutterdemo/<span class="built_in">test</span>/widget_test.dart (created)</span><br><span class="line">  flutterdemo/flutterdemo.iml (created)</span><br><span class="line">  flutterdemo/.gitignore (created)</span><br><span class="line">  flutterdemo/.metadata (created)</span><br><span class="line">  flutterdemo/android/app/src/profile/AndroidManifest.xml (created)</span><br><span class="line">  flutterdemo/android/app/src/main/res/mipmap-mdpi/ic_launcher.png (created)</span><br><span class="line">  flutterdemo/android/app/src/main/res/mipmap-hdpi/ic_launcher.png (created)</span><br><span class="line">  flutterdemo/android/app/src/main/res/drawable/launch_background.xml (created)</span><br><span class="line">  flutterdemo/android/app/src/main/res/mipmap-xxxhdpi/ic_launcher.png (created)</span><br><span class="line">  flutterdemo/android/app/src/main/res/mipmap-xxhdpi/ic_launcher.png (created)</span><br><span class="line">  flutterdemo/android/app/src/main/res/values/styles.xml (created)</span><br><span class="line">  flutterdemo/android/app/src/main/res/mipmap-xhdpi/ic_launcher.png (created)</span><br><span class="line">  flutterdemo/android/app/src/main/AndroidManifest.xml (created)</span><br><span class="line">  flutterdemo/android/app/src/debug/AndroidManifest.xml (created)</span><br><span class="line">  flutterdemo/android/gradle/wrapper/gradle-wrapper.properties (created)</span><br><span class="line">  flutterdemo/android/gradle.properties (created)</span><br><span class="line">  flutterdemo/android/.gitignore (created)</span><br><span class="line">  flutterdemo/android/settings.gradle (created)</span><br><span class="line">  flutterdemo/android/app/build.gradle (created)</span><br><span class="line">  flutterdemo/android/app/src/main/kotlin/com/example/flutterdemo/MainActivity.kt (created)</span><br><span class="line">  flutterdemo/android/build.gradle (created)</span><br><span class="line">  flutterdemo/android/flutterdemo_android.iml (created)</span><br><span class="line">  flutterdemo/pubspec.yaml (created)</span><br><span class="line">  flutterdemo/README.md (created)</span><br><span class="line">  flutterdemo/ios/Runner/Runner-Bridging-Header.h (created)</span><br><span class="line">  flutterdemo/ios/Runner/AppDelegate.swift (created)</span><br><span class="line">  flutterdemo/ios/Runner.xcodeproj/project.pbxproj (created)</span><br><span class="line">  flutterdemo/lib/main.dart (created)</span><br><span class="line">  flutterdemo/.idea/runConfigurations/main_dart.xml (created)</span><br><span class="line">  flutterdemo/.idea/libraries/Flutter_for_Android.xml (created)</span><br><span class="line">  flutterdemo/.idea/libraries/Dart_SDK.xml (created)</span><br><span class="line">  flutterdemo/.idea/libraries/KotlinJavaRuntime.xml (created)</span><br><span class="line">  flutterdemo/.idea/modules.xml (created)</span><br><span class="line">  flutterdemo/.idea/workspace.xml (created)</span><br><span class="line">Running <span class="string">"flutter pub get"</span> <span class="keyword">in</span> flutterdemo...                         3.0s</span><br><span class="line">Wrote 72 files.</span><br><span class="line"></span><br><span class="line">All <span class="keyword">done</span>!</span><br><span class="line"></span><br><span class="line">[✓] Flutter: is fully installed. (Channel stable, v1.17.3, on Mac OS X 10.15.4 19E287, locale zh-Hans-CN)</span><br><span class="line">[✓] Android toolchain - develop <span class="keyword">for</span> Android devices: is fully installed. (Android SDK version 29.0.3)</span><br><span class="line">[✓] Xcode - develop <span class="keyword">for</span> iOS and macOS: is fully installed. (Xcode 11.4.1)</span><br><span class="line">[✓] Android Studio: is fully installed. (version 3.2)</span><br><span class="line">[!] Android Studio: is partially installed; more components are available. (version 3.0)</span><br><span class="line">[!] Android Studio: is partially installed; more components are available. (version 3.6)</span><br><span class="line">[!] IntelliJ IDEA Community Edition: is partially installed; more components are available. (version 2019.3.1)</span><br><span class="line">[✓] VS Code: is fully installed. (version 1.45.1)</span><br><span class="line">[✓] Connected device: is fully installed. (1 available)</span><br><span class="line"></span><br><span class="line">Run <span class="string">"flutter doctor"</span> <span class="keyword">for</span> information about installing additional components.</span><br><span class="line"></span><br><span class="line">In order to run your application, <span class="built_in">type</span>:</span><br><span class="line"></span><br><span class="line">  $ <span class="built_in">cd</span> flutterdemo</span><br><span class="line">  $ flutter run</span><br><span class="line"></span><br><span class="line">Your application code is <span class="keyword">in</span> flutterdemo/lib/main.dart.</span><br></pre></td></tr></table></figure><p>随后连接上模拟器，使用<code>flutter run</code>运行项目</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">$ flutter run</span><br><span class="line">Launching lib/main.dart on iPhone SE (2nd generation) <span class="keyword">in</span> debug mode...</span><br><span class="line">Running Xcode build...                                                  </span><br><span class="line">                                                   </span><br><span class="line"> └─Compiling, linking and signing...                         5.8s</span><br><span class="line">Xcode build <span class="keyword">done</span>.                                           17.3s</span><br><span class="line">Syncing files to device iPhone SE (2nd generation)...              135ms</span><br><span class="line"></span><br><span class="line">Flutter run key commands.</span><br><span class="line">r Hot reload. 🔥🔥🔥</span><br><span class="line">R Hot restart.</span><br><span class="line">h Repeat this <span class="built_in">help</span> message.</span><br><span class="line">d Detach (terminate <span class="string">"flutter run"</span> but leave application running).</span><br><span class="line">c Clear the screen</span><br><span class="line">q Quit (terminate the application on the device).</span><br><span class="line">An Observatory debugger and profiler on iPhone SE (2nd generation) is available at:</span><br><span class="line">http://127.0.0.1:50997/0_E-14-WAWg=/</span><br></pre></td></tr></table></figure><p>运行就完成啦！</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://book.flutterchina.club/chapter1/install_flutter.html" target="_blank" rel="noopener">https://book.flutterchina.club/chapter1/install_flutter.html</a></p><p><a href="https://blog.csdn.net/MugWorld/article/details/100033262" target="_blank" rel="noopener">https://blog.csdn.net/MugWorld/article/details/100033262</a></p><p><a href="https://github.com/flutter/flutter/issues/57744" target="_blank" rel="noopener">https://github.com/flutter/flutter/issues/57744</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在正式学习完Dart的路程下，兴奋的配置完成Flutter的环境后，想要跑一个demo的时候坑又来了一个。&lt;/p&gt;
    
    </summary>
    
      <category term="Flutter" scheme="http://hackycy.github.io/categories/Flutter/"/>
    
    
      <category term="Flutter" scheme="http://hackycy.github.io/tags/Flutter/"/>
    
  </entry>
  
  <entry>
    <title>解决Mac通过Brew安装Dart报错：Failed to download resource dart</title>
    <link href="http://hackycy.github.io/2020/06/03/%E8%A7%A3%E5%86%B3Mac%E9%80%9A%E8%BF%87Brew%E5%AE%89%E8%A3%85Dart%E6%8A%A5%E9%94%99%EF%BC%9AFailed-to-download-resource-dart/"/>
    <id>http://hackycy.github.io/2020/06/03/解决Mac通过Brew安装Dart报错：Failed-to-download-resource-dart/</id>
    <published>2020-06-03T12:12:35.000Z</published>
    <updated>2021-05-03T11:11:23.984Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>在学习Flutter的第一步从安装就开始踩坑了。安装Dart硬是安装不上。科学上网也有就是安不上。找了些资料，记录了一下解决方案。</p><a id="more"></a><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>首先是dart官网推荐使用brew命令安装dart，如下图：</p><p><img src="https://github.static.si-yee.com/posts/fixmacinstalldart/20200604141048.png" alt></p><p>但是出现了以下的错误：</p><p><img src="https://github.static.si-yee.com/posts/fixmacinstalldart/20200604141008.png" alt></p><p>详细报错如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ brew install dart</span><br><span class="line">Updating Homebrew...</span><br><span class="line">==&gt; Installing dart from dart-lang/dart</span><br><span class="line">==&gt; Downloading https://storage.googleapis.com/dart-archive/channels/stable/release/2.8.3/sdk/dartsdk-macos-x64-release.zip</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">-=O=-               <span class="comment">#    #     #     #                                        </span></span><br><span class="line">curl: (7) Failed to connect to storage.googleapis.com port 443: Operation timed out</span><br><span class="line">Error: An exception occurred within a child process:</span><br><span class="line">  DownloadError: Failed to download resource <span class="string">"dart"</span></span><br><span class="line">Download failed: https://storage.googleapis.com/dart-archive/channels/stable/release/2.8.3/sdk/dartsdk-macos-x64-release.zip</span><br></pre></td></tr></table></figure><h1 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h1><p>报错中有回显资源的地址链接，这时候我们可以通过自己浏览器或者迅雷去下载到本地。</p><p>然后使用终端查看Homebrew的缓存地址：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ brew --cache</span><br><span class="line">/Users/zjyzy/Library/Caches/Homebrew</span><br></pre></td></tr></table></figure><p>最后将下载下来的文件 拷贝到 上面缓存地址：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cp ~/Downloads/dartsdk-macos-x64-release.zip /Users/zjyzy/Library/Caches/Homebrew</span><br></pre></td></tr></table></figure><p>接着再执行命令就可以正常安装成功</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ brew install dart</span><br></pre></td></tr></table></figure><p>如果没有意外，那么就可以直接解决问题了。但是不幸，我还是不能解决问题。继续查找了一些资料：</p><p>安装时给命令加个 <code>-v</code> 打印命令的详细日志看看:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ brew install dart -v</span><br><span class="line">==&gt; Installing dart from dart-lang/dart</span><br><span class="line">/usr/bin/sandbox-exec -f /private/tmp/homebrew20200603-12459-1ulm7yo.sb nice ruby -W0 -I <span class="variable">$LOAD_PATH</span> -- /usr/<span class="built_in">local</span>/Homebrew/Library/Homebrew/build.rb /usr/<span class="built_in">local</span>/Homebrew/Library/Taps/dart-lang/homebrew-dart/dart.rb --verbose</span><br><span class="line">==&gt; Downloading https://storage.googleapis.com/dart-archive/channels/stable/release/2.8.3/sdk/dartsdk-macos-x64-release.zip</span><br><span class="line">/usr/bin/curl -q --globoff --show-error --user-agent Homebrew/2.2.2\ \(Macintosh\;\ Intel\ Mac\ OS\ X\ 10.15.4\)\ curl/7.64.1 --fail --location --remote-time --<span class="built_in">continue</span>-at 0 --output /Users/zjyzy/Library/Caches/Homebrew/downloads/a21b0f967308afab39b415842adf710f903b479ccb472feb7f13960160733911--dartsdk-macos-x64-release.zip.incomplete https://storage.googleapis.com/dart-archive/channels/stable/release/2.8.3/sdk/dartsdk-macos-x64-release.zip</span><br><span class="line">  % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current</span><br><span class="line">                                 Dload  Upload   Total   Spent    Left  Speed</span><br><span class="line">  0     0    0     0    0     0      0      0 --:--:--  0:01:15 --:--:--     0</span><br><span class="line">curl: (7) Failed to connect to storage.googleapis.com port 443: Operation timed out</span><br><span class="line">Error: An exception occurred within a child process:</span><br><span class="line">  DownloadError: Failed to download resource <span class="string">"dart"</span></span><br><span class="line">Download failed: https://storage.googleapis.com/dart-archive/channels/stable/release/2.8.3/sdk/dartsdk-macos-x64-release.zip</span><br></pre></td></tr></table></figure><p><strong>注意看这条信息</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/bin/curl -q --globoff --show-error --user-agent Homebrew/2.2.2\ \(Macintosh\;\ Intel\ Mac\ OS\ X\ 10.15.4\)\ curl/7.64.1 --fail --location --remote-time --<span class="built_in">continue</span>-at 0 --output /Users/zjyzy/Library/Caches/Homebrew/downloads/a21b0f967308afab39b415842adf710f903b479ccb472feb7f13960160733911--dartsdk-macos-x64-release.zip.incomplete https://storage.googleapis.com/dart-archive/channels/stable/release/2.8.3/sdk/dartsdk-macos-x64-release.zip</span><br></pre></td></tr></table></figure><p>我们看到 Homebrew 下载 dart 的缓存地址为:<code>/Users/zjyzy/Library/Caches/Homebrew/downloads/a21b0f967308afab39b415842adf710f903b479ccb472feb7f13960160733911--dartsdk-macos-x64-release.zip.incomplete</code></p><p><code>XXX.incomplete</code> 表示下载未完成，但这是 Homebrew 期望的下载文件路径。那么我们将从浏览器下载好的包放到该目录下，并去除<code>.incomplete</code>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cp ~/Downloads/dartsdk-macos-x64-release.zip /Users/zjyzy/Library/Caches/Homebrew/downloads/a21b0f967308afab39b415842adf710f903b479ccb472feb7f13960160733911--dartsdk-macos-x64-release.zip</span><br></pre></td></tr></table></figure><p><strong>先去下载文件路径删除掉未下载好的包</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> /Users/zjyzy/Library/Caches/Homebrew/downloads</span><br><span class="line">$ rm -rf a21b0f967308afab39b415842adf710f903b479ccb472feb7f13960160733911--dartsdk-macos-x64-release.zip.incomplete</span><br></pre></td></tr></table></figure><p>此时在安装查看</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">$ brew install dart -v</span><br><span class="line">Updating Homebrew...</span><br><span class="line">==&gt; Installing dart from dart-lang/dart</span><br><span class="line">/usr/bin/sandbox-exec -f /private/tmp/homebrew20200603-14161-iaxt0b.sb nice ruby -W0 -I <span class="variable">$LOAD_PATH</span> -- /usr/<span class="built_in">local</span>/Homebrew/Library/Homebrew/build.rb /usr/<span class="built_in">local</span>/Homebrew/Library/Taps/dart-lang/homebrew-dart/dart.rb --verbose</span><br><span class="line">==&gt; Downloading https://storage.googleapis.com/dart-archive/channels/stable/release/2.8.3/sdk/dartsdk-macos-x64-release.zip</span><br><span class="line">Already downloaded: /Users/zjyzy/Library/Caches/Homebrew/downloads/a21b0f967308afab39b415842adf710f903b479ccb472feb7f13960160733911--dartsdk-macos-x64-release.zip</span><br><span class="line">==&gt; Verifying a21b0f967308afab39b415842adf710f903b479ccb472feb7f13960160733911--dartsdk-macos-x64-release.zip checksum</span><br><span class="line">unzip -o /Users/zjyzy/Library/Caches/Homebrew/downloads/a21b0f967308afab39b415842adf710f903b479ccb472feb7f13960160733911--dartsdk-macos-x64-release.zip -d /private/tmp/d20200603-14162-sr2oas</span><br><span class="line">cp -pR /private/tmp/d20200603-14162-sr2oas/dart-sdk/. /private/tmp/dart-20200603-14162-bg4o22/dart-sdk</span><br><span class="line">chmod -Rf +w /private/tmp/d20200603-14162-sr2oas</span><br><span class="line">==&gt; Cleaning</span><br><span class="line">==&gt; Finishing up</span><br><span class="line">ln -s ../Cellar/dart/2.8.3/bin/dart dart</span><br><span class="line">ln -s ../Cellar/dart/2.8.3/bin/dart2js dart2js</span><br><span class="line">ln -s ../Cellar/dart/2.8.3/bin/dart2native dart2native</span><br><span class="line">ln -s ../Cellar/dart/2.8.3/bin/dartanalyzer dartanalyzer</span><br><span class="line">ln -s ../Cellar/dart/2.8.3/bin/dartaotruntime dartaotruntime</span><br><span class="line">ln -s ../Cellar/dart/2.8.3/bin/dartdevc dartdevc</span><br><span class="line">ln -s ../Cellar/dart/2.8.3/bin/dartdoc dartdoc</span><br><span class="line">ln -s ../Cellar/dart/2.8.3/bin/dartfmt dartfmt</span><br><span class="line">ln -s ../Cellar/dart/2.8.3/bin/pub pub</span><br><span class="line">/usr/bin/sandbox-exec -f /private/tmp/homebrew20200603-14268-12qkciz.sb nice ruby -W0 -I <span class="variable">$LOAD_PATH</span> -- /usr/<span class="built_in">local</span>/Homebrew/Library/Homebrew/postinstall.rb /usr/<span class="built_in">local</span>/Homebrew/Library/Taps/dart-lang/homebrew-dart/dart.rb -v</span><br><span class="line">==&gt; Caveats</span><br><span class="line">Please note the path to the Dart SDK:</span><br><span class="line">  /usr/<span class="built_in">local</span>/opt/dart/libexec</span><br><span class="line">==&gt; Summary</span><br><span class="line">🍺  /usr/<span class="built_in">local</span>/Cellar/dart/2.8.3: 502 files, 486MB, built <span class="keyword">in</span> 7 seconds</span><br><span class="line">==&gt; `brew cleanup` has not been run <span class="keyword">in</span> 30 days, running now...</span><br><span class="line">Removing: /Users/zjyzy/Library/Caches/Homebrew/openssl@1.1--1.1.1d.mojave.bottle.tar.gz... (5.2MB)</span><br><span class="line">Removing: /Users/zjyzy/Library/Caches/Homebrew/python--3.7.4_1.mojave.bottle.tar.gz... (14.6MB)</span><br><span class="line">Removing: /Users/zjyzy/Library/Caches/Homebrew/readline--8.0.1.mojave.bottle.tar.gz... (517.9KB)</span><br><span class="line">Removing: /Users/zjyzy/Library/Caches/Homebrew/sqlite--3.29.0.mojave.bottle.tar.gz... (1.9MB)</span><br><span class="line">Removing: /Users/zjyzy/Library/Caches/Homebrew/watchman--4.9.0_3.mojave.bottle.tar.gz... (536.8KB)</span><br><span class="line">Removing: /Users/zjyzy/Library/Caches/Homebrew/Cask/motrix--1.4.1.dmg... (63MB)</span><br><span class="line">rm /usr/<span class="built_in">local</span>/share/man/man5/npm-folders.5</span><br><span class="line">rm /usr/<span class="built_in">local</span>/share/man/man5/npm-global.5</span><br><span class="line">rm /usr/<span class="built_in">local</span>/share/man/man5/npm-json.5</span><br><span class="line">rm /usr/<span class="built_in">local</span>/share/man/man5/npm-package-locks.5</span><br><span class="line">rm /usr/<span class="built_in">local</span>/share/man/man5/npm-shrinkwrap.json.5</span><br><span class="line">rm /usr/<span class="built_in">local</span>/share/man/man5/package-lock.json.5</span><br><span class="line">rm /usr/<span class="built_in">local</span>/share/man/man5/package.json.5</span><br><span class="line">rm /usr/<span class="built_in">local</span>/share/man/man7/npm-coding-style.7</span><br><span class="line">rm /usr/<span class="built_in">local</span>/share/man/man7/npm-config.7</span><br><span class="line">rm /usr/<span class="built_in">local</span>/share/man/man7/npm-developers.7</span><br><span class="line">rm /usr/<span class="built_in">local</span>/share/man/man7/npm-disputes.7</span><br><span class="line">rm /usr/<span class="built_in">local</span>/share/man/man7/npm-index.7</span><br><span class="line">rm /usr/<span class="built_in">local</span>/share/man/man7/npm-orgs.7</span><br><span class="line">rm /usr/<span class="built_in">local</span>/share/man/man7/npm-registry.7</span><br><span class="line">rm /usr/<span class="built_in">local</span>/share/man/man7/npm-scope.7</span><br><span class="line">rm /usr/<span class="built_in">local</span>/share/man/man7/npm-scripts.7</span><br><span class="line">rm /usr/<span class="built_in">local</span>/share/man/man7/removing-npm.7</span><br><span class="line">rmdir /usr/<span class="built_in">local</span>/lib/node_modules/@vue/cli/node_modules/@apollo/protobufjs/cli/node_modules</span><br><span class="line">Pruned 17 symbolic links and 1 directories from /usr/<span class="built_in">local</span></span><br></pre></td></tr></table></figure><p>命令验证dart安装</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">$ brew info dart</span><br><span class="line">dart-lang/dart/dart: stable 2.8.3, devel 2.9.0-13.0.dev</span><br><span class="line">The Dart SDK</span><br><span class="line">https://dart.dev</span><br><span class="line">Conflicts with:</span><br><span class="line">  dart-beta (because dart-beta ships the same binaries)</span><br><span class="line">/usr/<span class="built_in">local</span>/Cellar/dart/2.8.3 (502 files, 486MB) *</span><br><span class="line">  Built from <span class="built_in">source</span> on 2020-06-03 at 13:04:47</span><br><span class="line">From: https://github.com/dart-lang/homebrew-dart/blob/master/dart.rb</span><br><span class="line">==&gt; Options</span><br><span class="line">--devel</span><br><span class="line">Install development version 2.9.0-13.0.dev</span><br><span class="line">==&gt; Caveats</span><br><span class="line">Please note the path to the Dart SDK:</span><br><span class="line">  /usr/<span class="built_in">local</span>/opt/dart/libexec</span><br></pre></td></tr></table></figure><p>至此，dartSDK已经安装成功。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://shockerli.net/post/homebrew-install-download-error/" target="_blank" rel="noopener">https://shockerli.net/post/homebrew-install-download-error/</a></p><p><a href="https://www.cnblogs.com/lmyupupblogs/p/12785753.html" target="_blank" rel="noopener">https://www.cnblogs.com/lmyupupblogs/p/12785753.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在学习Flutter的第一步从安装就开始踩坑了。安装Dart硬是安装不上。科学上网也有就是安不上。找了些资料，记录了一下解决方案。&lt;/p&gt;
    
    </summary>
    
      <category term="Flutter" scheme="http://hackycy.github.io/categories/Flutter/"/>
    
    
      <category term="Dart" scheme="http://hackycy.github.io/tags/Dart/"/>
    
  </entry>
  
</feed>
