<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>思忆技术</title>
  
  <subtitle>si-yee.com</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://hackycy.github.io/"/>
  <updated>2019-12-02T08:03:10.780Z</updated>
  <id>http://hackycy.github.io/</id>
  
  <author>
    <name>hackycy</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Docker入门（二）——容器</title>
    <link href="http://hackycy.github.io/2019/11/28/Docker%E5%85%A5%E9%97%A8%EF%BC%88%E4%BA%8C%EF%BC%89%E2%80%94%E2%80%94%E5%AE%B9%E5%99%A8/"/>
    <id>http://hackycy.github.io/2019/11/28/Docker入门（二）——容器/</id>
    <published>2019-11-28T05:30:20.000Z</published>
    <updated>2019-12-02T08:03:10.780Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Docker容器简介"><a href="#Docker容器简介" class="headerlink" title="Docker容器简介"></a>Docker容器简介</h1><p>容器是 Docker 是一核心概念。</p><p>简单的说，容器是独立运行的一个或一组应用，以及它们的运行态环境。对应的，虚拟机可以理解为模拟运行的一整套操作系统（提供了运行态环境和其他系统环境）和跑在上面的应用。</p><a id="more"></a><p>接下来看看容器的操作使用。</p><h1 id="容器操作"><a href="#容器操作" class="headerlink" title="容器操作"></a>容器操作</h1><h2 id="启动容器"><a href="#启动容器" class="headerlink" title="启动容器"></a>启动容器</h2><p>启动容器有两种方式，一种是基于镜像新建一个容器并启动，另外一个是将在终止状态（<code>stopped</code>）的容器重新启动。</p><h3 id="新建并启动"><a href="#新建并启动" class="headerlink" title="新建并启动"></a>新建并启动</h3><p>所需要的命令主要为 <code>docker run</code>。</p><p>例如，下面的命令输出一个 “Hello World”，之后终止容器。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ docker run ubuntu:18.04 /bin/<span class="built_in">echo</span> <span class="string">'Hello world'</span></span><br><span class="line">Unable to find image <span class="string">'ubuntu:18.04'</span> locally</span><br><span class="line">18.04: Pulling from library/ubuntu</span><br><span class="line">7ddbc47eeb70: Pull complete </span><br><span class="line">c1bbdc448b72: Pull complete </span><br><span class="line">8c3b70e39044: Pull complete </span><br><span class="line">45d437916d57: Pull complete </span><br><span class="line">Digest: sha256:6e9f67fa63b0323e9a1e587fd71c561ba48a034504fb804fd26fd8800039835d</span><br><span class="line">Status: Downloaded newer image <span class="keyword">for</span> ubuntu:18.04</span><br><span class="line">Hello world</span><br></pre></td></tr></table></figure><p>这跟在本地直接执行 <code>/bin/echo &#39;hello world&#39;</code> 几乎感觉不出任何区别。</p><h3 id="启动交互式终端"><a href="#启动交互式终端" class="headerlink" title="启动交互式终端"></a>启动交互式终端</h3><p>我们通过 docker 的两个参数 -i -t，让 docker 运行的容器实现<strong>“对话”</strong>的能力：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -t -i ubuntu:18.04 /bin/bash</span><br><span class="line">root@349a1edaa615:/<span class="comment">#</span></span><br></pre></td></tr></table></figure><p>各个参数解析：</p><ul><li><strong>-t:</strong> 选项让Docker分配一个伪终端（pseudo-tty）并绑定到容器的标准输入上</li><li><strong>-i:</strong> 则让容器的标准输入保持打开。</li><li><strong>ubuntu:18.04</strong>: ubuntu 镜像。</li><li><strong>/bin/bash</strong>：放在镜像名后的是命令，这里我们希望有个交互式 Shell，因此用的是 /bin/bash。</li></ul><p>在交互模式下，用户可以通过所创建的终端来输入命令，例如</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">root@349a1edaa615:/<span class="comment"># pwd</span></span><br><span class="line">/</span><br><span class="line">root@349a1edaa615:/<span class="comment"># ls</span></span><br><span class="line">bin  boot  dev  etc  home  lib  lib64  media  mnt  opt  proc  root  run  sbin  srv  sys  tmp  usr  var</span><br><span class="line">root@349a1edaa615:/<span class="comment"># exit</span></span><br><span class="line"><span class="built_in">exit</span></span><br></pre></td></tr></table></figure><blockquote><p>exit退出交互式 Shell</p></blockquote><p>当利用 <code>docker run</code> 来创建容器时，Docker 在后台运行的标准操作包括：</p><ul><li>检查本地是否存在指定的镜像，不存在就从公有仓库下载</li><li>利用镜像创建并启动一个容器</li><li>分配一个文件系统，并在只读的镜像层外面挂载一层可读写层</li><li>从宿主主机配置的网桥接口中桥接一个虚拟接口到容器中去</li><li>从地址池配置一个 ip 地址给容器</li><li>执行用户指定的应用程序</li><li>执行完毕后容器被终止</li></ul><h3 id="启动已终止容器"><a href="#启动已终止容器" class="headerlink" title="启动已终止容器"></a>启动已终止容器</h3><p>可以利用 <code>docker container start</code> 命令，直接将一个已经终止的容器启动运行。</p><p>容器的核心为所执行的应用程序，所需要的资源都是应用程序运行所必需的。除此之外，并没有其它的资源。可以在伪终端中利用 <code>ps</code> 或 <code>top</code> 来查看进程信息。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">root@181e9d1236d5:/<span class="comment"># ps</span></span><br><span class="line">  PID TTY          TIME CMD</span><br><span class="line">    1 pts/0    00:00:00 bash</span><br><span class="line">   11 pts/0    00:00:00 ps</span><br></pre></td></tr></table></figure><h2 id="守护态运行容器"><a href="#守护态运行容器" class="headerlink" title="守护态运行容器"></a>守护态运行容器</h2><p>如果需要让 Docker 在后台运行而不是直接把执行命令的结果输出在当前宿主机下。此时，可以通过添加 <code>-d</code> 参数来实现。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -d -i -t ubuntu:18.04 /bin/sh</span><br><span class="line">edae8d9d6311b344b3971bafc2a698625242bcf3300e2c850ba1e4ef51d88707</span><br></pre></td></tr></table></figure><p>此时容器启动后会进入后台。如果想要进入容器可以使用<code>docker exec</code>命令，后面会逐渐讲解到。</p><blockquote><p> <strong>注：</strong>容器是否会长久运行，是和 <code>docker run</code> 指定的命令有关，和 <code>-d</code> 参数无关。</p></blockquote><p>使用 <code>-d</code> 参数启动后会返回一个唯一的 id，也可以通过 <code>docker container ls</code> 命令来查看容器信息。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ docker container ls</span><br><span class="line">CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES</span><br><span class="line">edae8d9d6311        ubuntu:18.04        <span class="string">"/bin/sh"</span>           4 minutes ago       Up 4 minutes                            suspicious_pike</span><br></pre></td></tr></table></figure><blockquote><p>要获取容器的输出信息，可以通过 <code>docker container logs</code> 命令。如<code>docker container logs [container ID or NAMES]</code></p></blockquote><h2 id="终止容器"><a href="#终止容器" class="headerlink" title="终止容器"></a>终止容器</h2><p>可以使用 <code>docker container stop</code> 来终止一个运行中的容器。</p><p>此外，当 Docker 容器中指定的应用终结时，容器也自动终止。</p><p>例如对于上一章节中只启动了一个终端的容器，用户通过 <code>exit</code> 命令或 <code>Ctrl+d</code> 来退出终端时，所创建的容器立刻终止。</p><p>终止状态的容器可以用 <code>docker container ls -a</code> 命令看到。例如</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ docker container stop edae</span><br><span class="line">edae</span><br><span class="line">$ docker container ls -a</span><br><span class="line">CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS                        PORTS               NAMES</span><br><span class="line">edae8d9d6311        ubuntu:18.04        <span class="string">"/bin/sh"</span>                7 minutes ago       Exited (137) 36 seconds ago                       suspicious_pike</span><br><span class="line">181e9d1236d5        ubuntu:18.04        <span class="string">"/bin/bash"</span>              2 days ago          Exited (0) 2 days ago                             condescending_feistel</span><br><span class="line">349a1edaa615        ubuntu:18.04        <span class="string">"/bin/bash"</span>              2 days ago          Exited (0) 2 days ago                             suspicious_lehmann</span><br><span class="line">7d6482342da5        ubuntu:18.04        <span class="string">"/bin/echo 'Hello wo…"</span>   2 days ago          Exited (0) 2 days ago                             affectionate_knuth</span><br></pre></td></tr></table></figure><p>处于终止状态的容器，可以通过 <code>docker container start</code> 命令来重新启动。</p><p>此外，<code>docker container restart</code> 命令会将一个运行态的容器终止，然后再重新启动它。</p><blockquote><p>指定容器ID时可以不需要输入完整ID，可以输入ID前几位都可以，只要能够辨识到该容器即可。</p></blockquote><h2 id="进入容器"><a href="#进入容器" class="headerlink" title="进入容器"></a>进入容器</h2><p>在使用 <code>-d</code> 参数时，容器启动后会进入后台。</p><p>某些时候需要进入容器进行操作，包括使用 <code>docker attach</code> 命令或 <code>docker exec</code> 命令，推荐大家使用 <code>docker exec</code> 命令。</p><h3 id="attach命令"><a href="#attach命令" class="headerlink" title="attach命令"></a><code>attach</code>命令</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ docker container ls</span><br><span class="line">CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES</span><br><span class="line">edae8d9d6311        ubuntu:18.04        <span class="string">"/bin/sh"</span>           9 minutes ago       Up 4 seconds                            suspicious_pike</span><br><span class="line">$ docker attach 243c</span><br><span class="line"><span class="comment"># pwd</span></span><br><span class="line">/</span><br><span class="line"><span class="comment"># exit</span></span><br><span class="line">$ docker container ls</span><br><span class="line">CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES</span><br></pre></td></tr></table></figure><p><em>注意：</em> 如果从这个 stdin 中 exit，会导致容器的停止。</p><h3 id="exec命令"><a href="#exec命令" class="headerlink" title="exec命令"></a><code>exec</code>命令</h3><p><code>docker exec</code> 后边可以跟多个参数，这里主要说明 <code>-i</code> <code>-t</code> 参数。</p><p>只用 <code>-i</code> 参数时，由于没有分配伪终端，界面没有我们熟悉的 Linux 命令提示符，但命令执行结果仍然可以返回。</p><p>当 <code>-i</code> <code>-t</code> 参数一起使用时，则可以看到我们熟悉的 Linux 命令提示符。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">$ container ls</span><br><span class="line">CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES</span><br><span class="line">edae8d9d6311        ubuntu:18.04        <span class="string">"/bin/sh"</span>           13 minutes ago      Up 5 seconds                            suspicious_pike</span><br><span class="line">$ docker <span class="built_in">exec</span> -i edae bash</span><br><span class="line">ls</span><br><span class="line">bin</span><br><span class="line">boot</span><br><span class="line">dev</span><br><span class="line">etc</span><br><span class="line">home</span><br><span class="line">lib</span><br><span class="line">lib64</span><br><span class="line">media</span><br><span class="line">mnt</span><br><span class="line">opt</span><br><span class="line">proc</span><br><span class="line">root</span><br><span class="line">run</span><br><span class="line">sbin</span><br><span class="line">srv</span><br><span class="line">sys</span><br><span class="line">tmp</span><br><span class="line">usr</span><br><span class="line">va</span><br><span class="line">$ docker <span class="built_in">exec</span> -i -t edae bash</span><br><span class="line">root@edae8d9d6311:/<span class="comment"># ls</span></span><br><span class="line">bin  boot  dev  etc  home  lib  lib64  media  mnt  opt  proc  root  run  sbin  srv  sys  tmp  usr  var</span><br><span class="line">root@edae8d9d6311:/<span class="comment"># exit</span></span><br><span class="line"><span class="built_in">exit</span></span><br></pre></td></tr></table></figure><p>如果从这个 stdin 中 exit，不会导致容器的停止。这就是为什么推荐大家使用 <code>docker exec</code> 的原因。</p><p>更多参数说明请使用 <code>docker exec --help</code> 查看。</p><h2 id="导出和导入容器"><a href="#导出和导入容器" class="headerlink" title="导出和导入容器"></a>导出和导入容器</h2><h3 id="导出容器"><a href="#导出容器" class="headerlink" title="导出容器"></a>导出容器</h3><p>如果要导出本地某个容器，可以使用 <code>docker export</code> 命令。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ docker container ls -a</span><br><span class="line">CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS                            PORTS               NAMES</span><br><span class="line">edae8d9d6311        ubuntu:18.04        <span class="string">"/bin/sh"</span>                18 minutes ago      Exited (137) About a minute ago                       suspicious_pike</span><br><span class="line">181e9d1236d5        ubuntu:18.04        <span class="string">"/bin/bash"</span>              2 days ago          Exited (0) 2 days ago                                 condescending_feistel</span><br><span class="line">349a1edaa615        ubuntu:18.04        <span class="string">"/bin/bash"</span>              2 days ago          Exited (0) 2 days ago                                 suspicious_lehmann</span><br><span class="line">7d6482342da5        ubuntu:18.04        <span class="string">"/bin/echo 'Hello wo…"</span>   2 days ago          Exited (0) 2 days ago                                 affectionate_knuth</span><br><span class="line">$ docker <span class="built_in">export</span> edae &gt; ubuntu.zip</span><br></pre></td></tr></table></figure><h3 id="导入容器快照"><a href="#导入容器快照" class="headerlink" title="导入容器快照"></a>导入容器快照</h3><p>可以使用 <code>docker import</code> 从容器快照文件中再导入为镜像，例如</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ cat ubuntu.zip | docker import - <span class="built_in">test</span>/ubuntu:v1.0</span><br><span class="line">$ docker image ls</span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED              VIRTUAL SIZE</span><br><span class="line"><span class="built_in">test</span>/ubuntu         v1.0                9d37a6082e97        About a minute ago   171.3 MB</span><br></pre></td></tr></table></figure><p>此外，也可以通过指定 URL 或者某个目录来导入，例如</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker import http://example.com/exampleimage.tgz example/imagerepo</span><br></pre></td></tr></table></figure><blockquote><p><em>注：用户既可以使用 <code>docker load</code> 来导入镜像存储文件到本地镜像库，也可以使用 <code>docker import</code> 来导入一个容器快照到本地镜像库。这两者的区别在于容器快照文件将丢弃所有的历史记录和元数据信息（即仅保存容器当时的快照状态），而镜像存储文件将保存完整记录，体积也要大。此外，从容器快照文件导入时可以重新指定标签等元数据信息。</em></p></blockquote><h2 id="删除容器"><a href="#删除容器" class="headerlink" title="删除容器"></a>删除容器</h2><p>可以使用 <code>docker container rm</code> 来删除一个处于终止状态的容器。例如</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker container rm  edae</span><br><span class="line">edae</span><br></pre></td></tr></table></figure><p>如果要删除一个运行中的容器，可以添加 <code>-f</code> 参数。Docker 会发送 <code>SIGKILL</code> 信号给容器。</p><p><strong>清理所有处于终止状态的容器</strong></p><p>用 <code>docker container ls -a</code> 命令可以查看所有已经创建的包括终止状态的容器，如果数量太多要一个个删除可能会很麻烦，用命令<code>docker container prune</code>可以清理掉所有处于终止状态的容器。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">$ docker container ls -a</span><br><span class="line">CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS                  PORTS               NAMES</span><br><span class="line">181e9d1236d5        ubuntu:18.04        <span class="string">"/bin/bash"</span>              2 days ago          Exited (0) 2 days ago                       condescending_feistel</span><br><span class="line">349a1edaa615        ubuntu:18.04        <span class="string">"/bin/bash"</span>              2 days ago          Exited (0) 2 days ago                       suspicious_lehmann</span><br><span class="line">7d6482342da5        ubuntu:18.04        <span class="string">"/bin/echo 'Hello wo…"</span>   2 days ago          Exited (0) 2 days ago                       affectionate_knuth</span><br><span class="line">$ docker container prune</span><br><span class="line">WARNING! This will remove all stopped containers.</span><br><span class="line">Are you sure you want to <span class="built_in">continue</span>? [y/N] y</span><br><span class="line">Deleted Containers:</span><br><span class="line">181e9d1236d54ee898f8f0ebc5349dbcc0cd2368c34f427f7963c9014c9e1dc8</span><br><span class="line">349a1edaa61597acb426a0961059bf5a73ae0b23350774d5cd5c33963c8b2b12</span><br><span class="line">7d6482342da5f695a5351c15ef17acb521f893548db0891154b5c1268227ce7d</span><br><span class="line"></span><br><span class="line">Total reclaimed space: 20B</span><br><span class="line">$ docker container ls -a</span><br><span class="line">CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES</span><br></pre></td></tr></table></figure><h1 id="数据管理"><a href="#数据管理" class="headerlink" title="数据管理"></a>数据管理</h1><p>在容器中管理数据主要有两种方式：</p><ul><li>数据卷（Volumes）</li><li>挂载主机目录 (Bind mounts)</li></ul><h2 id="数据卷"><a href="#数据卷" class="headerlink" title="数据卷"></a>数据卷</h2><p><code>数据卷</code> 是一个可供一个或多个容器使用的特殊目录，它绕过 UFS，可以提供很多有用的特性：</p><ul><li><code>数据卷</code> 可以在容器之间共享和重用</li><li>对 <code>数据卷</code> 的修改会立马生效</li><li>对 <code>数据卷</code> 的更新，不会影响镜像</li><li><code>数据卷</code> 默认会一直存在，即使容器被删除</li></ul><blockquote><p>注意：<code>数据卷</code> 的使用，类似于 Linux 下对目录或文件进行 mount，镜像中的被指定为挂载点的目录中的文件会隐藏掉，能显示看的是挂载的 <code>数据卷</code>。</p></blockquote><h3 id="创建数据卷"><a href="#创建数据卷" class="headerlink" title="创建数据卷"></a>创建数据卷</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker volume create my-vol</span><br><span class="line">my-vol</span><br></pre></td></tr></table></figure><p>查看所有的 <code>数据卷</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ docker volume ls</span><br><span class="line">DRIVER              VOLUME NAME</span><br><span class="line"><span class="built_in">local</span>               my-vol</span><br></pre></td></tr></table></figure><p>在主机里使用以下命令可以查看指定 <code>数据卷</code> 的信息</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ docker volume inspect my-vol</span><br><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">"CreatedAt"</span>: <span class="string">"2019-12-02T03:25:01Z"</span>,</span><br><span class="line">        <span class="string">"Driver"</span>: <span class="string">"local"</span>,</span><br><span class="line">        <span class="string">"Labels"</span>: &#123;&#125;,</span><br><span class="line">        <span class="string">"Mountpoint"</span>: <span class="string">"/var/lib/docker/volumes/my-vol/_data"</span>,</span><br><span class="line">        <span class="string">"Name"</span>: <span class="string">"my-vol"</span>,</span><br><span class="line">        <span class="string">"Options"</span>: &#123;&#125;,</span><br><span class="line">        <span class="string">"Scope"</span>: <span class="string">"local"</span></span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h3 id="启动一个挂载数据卷的容器"><a href="#启动一个挂载数据卷的容器" class="headerlink" title="启动一个挂载数据卷的容器"></a>启动一个挂载数据卷的容器</h3><p>在用 <code>docker run</code> 命令的时候，使用 <code>--mount</code> 标记来将 <code>数据卷</code> 挂载到容器里。在一次 <code>docker run</code> 中可以挂载多个 <code>数据卷</code>。</p><p>下面创建一个名为 <code>web</code> 的容器，并加载一个 <code>数据卷</code> 到容器的 <code>/webapp</code> 目录。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -d -P \</span><br><span class="line">    --name web \</span><br><span class="line">    <span class="comment"># -v my-vol:/wepapp \</span></span><br><span class="line">    --mount <span class="built_in">source</span>=my-vol,target=/webapp \</span><br><span class="line">    training/webapp \</span><br><span class="line">    python app.py</span><br></pre></td></tr></table></figure><blockquote><p><strong>-P:</strong> 随机端口映射，容器内部端口<strong>随机</strong>映射到主机的高端口</p></blockquote><h3 id="查看数据卷的具体信息"><a href="#查看数据卷的具体信息" class="headerlink" title="查看数据卷的具体信息"></a>查看数据卷的具体信息</h3><p>在主机里使用以下命令可以查看 <code>web</code> 容器的信息</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker inspect web</span><br></pre></td></tr></table></figure><p><code>数据卷</code> 信息在 “Mounts” Key 下面</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">"Mounts": [</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">"Type"</span>: <span class="string">"volume"</span>,</span><br><span class="line">        <span class="attr">"Name"</span>: <span class="string">"my-vol"</span>,</span><br><span class="line">        <span class="attr">"Source"</span>: <span class="string">"/var/lib/docker/volumes/my-vol/_data"</span>,</span><br><span class="line">        <span class="attr">"Destination"</span>: <span class="string">"/app"</span>,</span><br><span class="line">        <span class="attr">"Driver"</span>: <span class="string">"local"</span>,</span><br><span class="line">        <span class="attr">"Mode"</span>: <span class="string">""</span>,</span><br><span class="line">        <span class="attr">"RW"</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="attr">"Propagation"</span>: <span class="string">""</span></span><br><span class="line">    &#125;</span><br><span class="line">],</span><br></pre></td></tr></table></figure><h3 id="删除数据卷"><a href="#删除数据卷" class="headerlink" title="删除数据卷"></a>删除数据卷</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker volume rm my-vol</span><br></pre></td></tr></table></figure><p><code>数据卷</code> 是被设计用来持久化数据的，它的生命周期独立于容器，Docker 不会在容器被删除后自动删除 <code>数据卷</code>，并且也不存在垃圾回收这样的机制来处理没有任何容器引用的 <code>数据卷</code>。如果需要在删除容器的同时移除数据卷。可以在删除容器的时候使用 <code>docker rm -v</code> 这个命令。</p><p>无主的数据卷可能会占据很多空间，要清理请使用以下命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker volume prune</span><br></pre></td></tr></table></figure><h2 id="挂载主机目录"><a href="#挂载主机目录" class="headerlink" title="挂载主机目录"></a>挂载主机目录</h2><h3 id="挂载一个主机目录作为数据卷"><a href="#挂载一个主机目录作为数据卷" class="headerlink" title="挂载一个主机目录作为数据卷"></a>挂载一个主机目录作为数据卷</h3><p>使用 <code>--mount</code> 标记可以指定挂载一个本地主机的目录到容器中去。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -d -P \</span><br><span class="line">    --name web \</span><br><span class="line">    <span class="comment"># -v /src/webapp:/opt/webapp \</span></span><br><span class="line">    --mount <span class="built_in">type</span>=<span class="built_in">bind</span>,<span class="built_in">source</span>=/src/webapp,target=/opt/webapp \</span><br><span class="line">    training/webapp \</span><br><span class="line">    python app.py</span><br></pre></td></tr></table></figure><p>上面的命令加载主机的 <code>/src/webapp</code> 目录到容器的 <code>/opt/webapp</code>目录。这个功能在进行测试的时候十分方便，比如用户可以放置一些程序到本地目录中，来查看容器是否正常工作。本地目录的路径必须是绝对路径，以前使用 <code>-v</code> 参数时如果本地目录不存在 Docker 会自动为你创建一个文件夹，现在使用 <code>--mount</code> 参数时如果本地目录不存在，Docker 会报错。</p><p>Docker 挂载主机目录的默认权限是 <code>读写</code>，用户也可以通过增加 <code>readonly</code> 指定为 <code>只读</code>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -d -P \</span><br><span class="line">    --name web \</span><br><span class="line">    <span class="comment"># -v /src/webapp:/opt/webapp:ro \</span></span><br><span class="line">    --mount <span class="built_in">type</span>=<span class="built_in">bind</span>,<span class="built_in">source</span>=/src/webapp,target=/opt/webapp,<span class="built_in">readonly</span> \</span><br><span class="line">    training/webapp \</span><br><span class="line">    python app.py</span><br></pre></td></tr></table></figure><p>加了 <code>readonly</code> 之后，就挂载为 <code>只读</code> 了。如果你在容器内 <code>/opt/webapp</code> 目录新建文件，会显示如下错误</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/opt/webapp <span class="comment"># touch new.txt</span></span><br><span class="line">touch: new.txt: Read-only file system</span><br></pre></td></tr></table></figure><h3 id="查看数据卷的具体信息-1"><a href="#查看数据卷的具体信息-1" class="headerlink" title="查看数据卷的具体信息"></a>查看数据卷的具体信息</h3><p>在主机里使用以下命令可以查看 <code>web</code> 容器的信息</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker inspect web</span><br></pre></td></tr></table></figure><p><code>挂载主机目录</code> 的配置信息在 “Mounts” Key 下面</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">"Mounts": [</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">"Type"</span>: <span class="string">"bind"</span>,</span><br><span class="line">        <span class="attr">"Source"</span>: <span class="string">"/src/webapp"</span>,</span><br><span class="line">        <span class="attr">"Destination"</span>: <span class="string">"/opt/webapp"</span>,</span><br><span class="line">        <span class="attr">"Mode"</span>: <span class="string">""</span>,</span><br><span class="line">        <span class="attr">"RW"</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="attr">"Propagation"</span>: <span class="string">"rprivate"</span></span><br><span class="line">    &#125;</span><br><span class="line">],</span><br></pre></td></tr></table></figure><h3 id="挂载一个本地主机文件作为数据卷"><a href="#挂载一个本地主机文件作为数据卷" class="headerlink" title="挂载一个本地主机文件作为数据卷"></a>挂载一个本地主机文件作为数据卷</h3><p><code>--mount</code> 标记也可以从主机挂载单个文件到容器中</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ docker run --rm -it \</span><br><span class="line">   <span class="comment"># -v $HOME/.bash_history:/root/.bash_history \</span></span><br><span class="line">   --mount <span class="built_in">type</span>=<span class="built_in">bind</span>,<span class="built_in">source</span>=<span class="variable">$HOME</span>/.bash_history,target=/root/.bash_history \</span><br><span class="line">   ubuntu:18.04 \</span><br><span class="line">   bash</span><br><span class="line"></span><br><span class="line">root@2affd44b4667:/<span class="comment"># history</span></span><br><span class="line">1  ls</span><br><span class="line">2  diskutil list</span><br></pre></td></tr></table></figure><p>这样就可以记录在容器输入过的命令了。</p><h2 id="选择-v-or-–mount-标志"><a href="#选择-v-or-–mount-标志" class="headerlink" title="选择 -v or –mount 标志"></a>选择 -v or –mount 标志</h2><p>最初，<code>-v</code>或<code>--volume</code>标志用于独立容器，而<code>--mount</code>标志用于群集服务。但是，从Docker 17.06开始，您也可以使用<code>--mount</code>独立的容器。一般来说，<code>--mount</code>更明确和详细。最大的区别在于-v语法将所有选项组合在一个字段中，而<code>--mount</code>语法将它们分开。建议新学者使用。</p><p><strong><code>v</code>或<code>- volume</code>:由三个字段组成，由冒号分隔(:)。字段必须按照正确的顺序书写，并且每个字段的含义都不是立刻确定。</strong></p><ul><li>在命名卷的情况下，第一个字段是卷的名称，在给定的主机上是惟一的。对于匿名卷，省略了第一个字段。</li><li>第二个字段是在容器中安装文件或目录的路径。</li><li>第三个字段是可选的，并且是一个逗号分隔的选项列表，如ro。下面讨论这些选项。</li></ul><p><strong><code>--mount</code>:由多个键-值对组成，由逗号分隔，每一对由<code>&lt; key&gt;= &lt;value&gt; tuple(元组）</code>组成。<code>--mount</code> 语法比<code>- v</code>或<code>—volume</code> 更详细，其中键对的顺序并不重要，而且标记的值更容易理解。</strong></p><ul><li>挂载的类型(type)，可以是绑定(bind)、卷(volume)或tmpfs。本主题讨论卷，因此类型将始终是卷。</li><li>挂载源（source)。对于命名卷，是卷的名称。对于匿名卷，该字段被省略。可以指定为source 或src。</li><li>挂在目标(destination)的值是将文件或目录安装在容器中的路径。可以指定为destination、dst或target。</li><li>如果存在readonly选项，则将绑定挂载安装到容器中作为只读。</li><li>可以使用键值对多次指定的volume-opt选项.</li></ul><p>与绑定挂载相反，所有的卷的选项对于<code>--mount</code> 和<code>-v</code>标志 都可以使用。当卷(volume)作为服务时，只支持<code>--mount</code>。</p><h1 id="容器网络"><a href="#容器网络" class="headerlink" title="容器网络"></a>容器网络</h1><p>Docker 允许通过外部访问容器或容器互联的方式来提供网络服务。</p><h2 id="外部访问容器"><a href="#外部访问容器" class="headerlink" title="外部访问容器"></a>外部访问容器</h2><p>容器中可以运行一些网络应用，要让外部也可以访问这些应用，可以通过 <code>-P</code> 或 <code>-p</code> 参数来指定端口映射。</p><p>当使用 <code>-P</code> 标记时，Docker 会随机映射一个 <code>49000~49900</code> 的端口到内部容器开放的网络端口。</p><p>使用 <code>docker container ls</code> 可以看到，本地主机的 49155 被映射到了容器的 5000 端口。此时访问本机的 49155 端口即可访问容器内 web 应用提供的界面。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -d -P training/webapp python app.py</span><br><span class="line">ea7fb3aa1ca874847d7469f62f7cdfcd557438453ad08c283416b5d229468db2</span><br><span class="line">$ docker container ls</span><br><span class="line">CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS                     NAMES</span><br><span class="line">ea7fb3aa1ca8        training/webapp     <span class="string">"python app.py"</span>     About an hour ago   Up About an hour    0.0.0.0:32768-&gt;5000/tcp   serene_buck</span><br></pre></td></tr></table></figure><p>同样的，可以通过 <code>docker logs</code> 命令来查看应用的信息。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ docker logs -f serene_buck</span><br><span class="line"> * Running on http://0.0.0.0:5000/ (Press CTRL+C to quit)</span><br><span class="line">172.17.0.1 - - [02/Dec/2019 06:27:22] <span class="string">"GET / HTTP/1.1"</span> 200 -</span><br><span class="line">172.17.0.1 - - [02/Dec/2019 06:27:23] <span class="string">"GET /favicon.ico HTTP/1.1"</span> 404 -</span><br></pre></td></tr></table></figure><p><code>-p</code> 则可以指定要映射的端口，并且，在一个指定端口上只可以绑定一个容器。支持的格式有 <code>ip:hostPort:containerPort | ip::containerPort | hostPort:containerPort</code>。</p><h3 id="映射所有接口地址"><a href="#映射所有接口地址" class="headerlink" title="映射所有接口地址"></a>映射所有接口地址</h3><p>使用 <code>hostPort:containerPort</code> 格式本地的 8000 端口映射到容器的 5000 端口，可以执行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -d -p 8000:5000 training/webapp python app.py</span><br></pre></td></tr></table></figure><p>此时默认会绑定本地所有接口上的所有地址。</p><h3 id="映射到指定地址的指定端口"><a href="#映射到指定地址的指定端口" class="headerlink" title="映射到指定地址的指定端口"></a>映射到指定地址的指定端口</h3><p>可以使用 <code>ip:hostPort:containerPort</code> 格式指定映射使用一个特定地址，比如 localhost 地址 127.0.0.1</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -d -p 127.0.0.1:5000:5000 training/webapp python app.py</span><br></pre></td></tr></table></figure><h3 id="映射到指定地址的任意端口"><a href="#映射到指定地址的任意端口" class="headerlink" title="映射到指定地址的任意端口"></a>映射到指定地址的任意端口</h3><p>使用 <code>ip::containerPort</code> 绑定 localhost 的任意端口到容器的 5000 端口，本地主机会自动分配一个端口。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -d -p 127.0.0.1::5000 training/webapp python app.py</span><br></pre></td></tr></table></figure><p>还可以使用 <code>udp</code> 标记来指定 <code>udp</code> 端口</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -d -p 127.0.0.1:5000:5000/udp training/webapp python app.py</span><br></pre></td></tr></table></figure><h3 id="查看映射端口配置"><a href="#查看映射端口配置" class="headerlink" title="查看映射端口配置"></a>查看映射端口配置</h3><p>使用 <code>docker port</code> 来查看当前映射的端口配置，也可以查看到绑定的地址</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker port 5f2b 5000</span><br><span class="line">0.0.0.0:8000</span><br></pre></td></tr></table></figure><blockquote><p>注意：</p><ul><li>容器有自己的内部网络和 ip 地址（使用 <code>docker inspect</code> 可以获取所有的变量，Docker 还可以有一个可变的网络配置。）</li><li><code>-p</code> 标记可以多次使用来绑定多个端口</li></ul><p>例如</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -d \</span><br><span class="line">    -p 5000:5000 \</span><br><span class="line">    -p 3000:80 \</span><br><span class="line">    training/webapp \</span><br><span class="line">    python app.py</span><br></pre></td></tr></table></figure><h2 id="容器互联"><a href="#容器互联" class="headerlink" title="容器互联"></a>容器互联</h2><h3 id="新建网络"><a href="#新建网络" class="headerlink" title="新建网络"></a>新建网络</h3><p>下面先创建一个新的 Docker 网络。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker network create -d bridge my-net</span><br><span class="line">cea6b6e901d97a319c537895587df6a1256ccc18fc1e6faccfa911ec843e2e64</span><br></pre></td></tr></table></figure><p><code>-d</code> 参数指定 Docker 网络类型，有 <code>bridge</code> <code>overlay</code>。其中 <code>overlay</code> 网络类型用于 Swarm mode，属于高级用法了。入门章节则不介绍了。</p><h3 id="连接容器"><a href="#连接容器" class="headerlink" title="连接容器"></a>连接容器</h3><p>运行一个容器并连接到新建的 <code>my-net</code> 网络</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -i -t --rm --name busybox1 --network my-net busybox sh</span><br></pre></td></tr></table></figure><p>打开新的终端，再运行一个容器并加入到 <code>my-net</code> 网络</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -i -t --rm --name busybox2 --network my-net busybox sh</span><br></pre></td></tr></table></figure><blockquote><p>Clean up (–rm) 指在容器运行完之后自动清除，<em>注意：–rm 和 -d不能共用！</em></p></blockquote><p>再打开一个新的终端查看容器信息。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ docker container ls       </span><br><span class="line">CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES</span><br><span class="line">4f37d2e62181        busybox             <span class="string">"sh"</span>                48 seconds ago      Up 47 seconds                           busybox2</span><br><span class="line">98b27738599c        busybox             <span class="string">"sh"</span>                2 minutes ago       Up About a minute                       busybox1</span><br></pre></td></tr></table></figure><p>下面通过 <code>ping</code> 来证明 <code>busybox1</code> 容器和 <code>busybox2</code> 容器建立了互联关系。</p><p>在 <code>busybox1</code> 容器输入以下命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/ <span class="comment"># ping busybox2</span></span><br><span class="line">PING busybox2 (172.18.0.3): 56 data bytes</span><br><span class="line">64 bytes from 172.18.0.3: seq=0 ttl=64 time=0.115 ms</span><br><span class="line">64 bytes from 172.18.0.3: seq=1 ttl=64 time=0.138 ms</span><br><span class="line">64 bytes from 172.18.0.3: seq=2 ttl=64 time=0.139 ms</span><br><span class="line">64 bytes from 172.18.0.3: seq=3 ttl=64 time=0.137 ms</span><br><span class="line">64 bytes from 172.18.0.3: seq=4 ttl=64 time=0.138 ms</span><br><span class="line">64 bytes from 172.18.0.3: seq=5 ttl=64 time=0.138 ms</span><br><span class="line">64 bytes from 172.18.0.3: seq=6 ttl=64 time=0.133 ms</span><br></pre></td></tr></table></figure><p>用 ping 来测试连接 <code>busybox2</code> 容器，它会解析成 <code>172.18.0.3</code>。</p><p>同理在 <code>busybox2</code> 容器执行 <code>ping busybox1</code>，也会成功连接到。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/ <span class="comment"># ping busybox1</span></span><br><span class="line">PING busybox1 (172.18.0.2): 56 data bytes</span><br><span class="line">64 bytes from 172.18.0.2: seq=0 ttl=64 time=0.091 ms</span><br><span class="line">64 bytes from 172.18.0.2: seq=1 ttl=64 time=0.137 ms</span><br></pre></td></tr></table></figure><p>这样，<code>busybox1</code> 容器和 <code>busybox2</code> 容器建立了互联关系。</p><blockquote><p>如果有多个容器需要互相连接，推荐使用Docker Compose。</p></blockquote><blockquote><p><code>BusyBox</code> 是一个集成了一百多个最常用 Linux 命令和工具（如 <code>cat</code>、<code>echo</code>、<code>grep</code>、<code>mount</code>、<code>telnet</code> 等）的精简工具箱，它只需要几 MB 的大小，很方便进行各种快速验证，被誉为“Linux 系统的瑞士军刀”。</p><p><code>BusyBox</code> 可运行于多款 <code>POSIX</code> 环境的操作系统中，如 <code>Linux</code>（包括 <code>Android</code>）、<code>Hurd</code>、<code>FreeBSD</code> 等。</p></blockquote><h2 id="配置DNS"><a href="#配置DNS" class="headerlink" title="配置DNS"></a>配置DNS</h2><p>Docker 利用虚拟文件来挂载容器的 3 个相关配置文件。</p><p>在容器中使用 <code>mount</code> 命令可以看到挂载信息：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ mount</span><br><span class="line">/dev/disk/by-uuid/1fec...ebdf on /etc/hostname <span class="built_in">type</span> ext4 ...</span><br><span class="line">/dev/disk/by-uuid/1fec...ebdf on /etc/hosts <span class="built_in">type</span> ext4 ...</span><br><span class="line">tmpfs on /etc/resolv.conf <span class="built_in">type</span> tmpfs ...</span><br></pre></td></tr></table></figure><p>这种机制可以让宿主主机 DNS 信息发生更新后，所有 Docker 容器的 DNS 配置通过 <code>/etc/resolv.conf</code> 文件立刻得到更新。</p><p>配置全部容器的 DNS ，也可以在 <code>/etc/docker/daemon.json</code> 文件中增加以下内容来设置。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"dns"</span> : [</span><br><span class="line">    <span class="string">"114.114.114.114"</span>,</span><br><span class="line">    <span class="string">"8.8.8.8"</span></span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样每次启动的容器 DNS 自动配置为 <code>114.114.114.114</code> 和 <code>8.8.8.8</code>。使用以下命令来证明其已经生效。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -it --rm ubuntu:18.04  cat etc/resolv.conf</span><br><span class="line">nameserver 114.114.114.114</span><br><span class="line">nameserver 8.8.8.8</span><br></pre></td></tr></table></figure><p>如果用户想要手动指定容器的配置，可以在使用 <code>docker run</code> 命令启动容器时加入如下参数：</p><blockquote><p><code>-h HOSTNAME</code> 或者 <code>--hostname=HOSTNAME</code> 设定容器的主机名，它会被写到容器内的 <code>/etc/hostname</code> 和 <code>/etc/hosts</code>。但它在容器外部看不到，既不会在 <code>docker container ls</code> 中显示，也不会在其他的容器的 <code>/etc/hosts</code> 看到。</p><p><code>--dns=IP_ADDRESS</code> 添加 DNS 服务器到容器的 <code>/etc/resolv.conf</code> 中，让容器用这个服务器来解析所有不在 <code>/etc/hosts</code> 中的主机名。</p><p><code>--dns-search=DOMAIN</code> 设定容器的搜索域，当设定搜索域为 <code>.example.com</code> 时，在搜索一个名为 host 的主机时，DNS 不仅搜索 host，还会搜索 <code>host.example.com</code>。</p><p>注意：如果在容器启动时没有指定最后两个参数，Docker 会默认用主机上的<code>/etc/resolv.conf</code> 来配置容器。</p></blockquote><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p>Docker 官网：<a href="https://www.docker.com/" target="_blank" rel="noopener">https://www.docker.com</a></p><p>Github Docker 源码：<a href="https://github.com/docker/docker-ce" target="_blank" rel="noopener">https://github.com/docker/docker-ce</a></p><p>Docker命令大全：<a href="https://www.runoob.com/docker/docker-command-manual.html" target="_blank" rel="noopener">https://www.runoob.com/docker/docker-command-manual.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Docker容器简介&quot;&gt;&lt;a href=&quot;#Docker容器简介&quot; class=&quot;headerlink&quot; title=&quot;Docker容器简介&quot;&gt;&lt;/a&gt;Docker容器简介&lt;/h1&gt;&lt;p&gt;容器是 Docker 是一核心概念。&lt;/p&gt;
&lt;p&gt;简单的说，容器是独立运行的一个或一组应用，以及它们的运行态环境。对应的，虚拟机可以理解为模拟运行的一整套操作系统（提供了运行态环境和其他系统环境）和跑在上面的应用。&lt;/p&gt;
    
    </summary>
    
      <category term="Docker" scheme="http://hackycy.github.io/categories/Docker/"/>
    
    
      <category term="Docker" scheme="http://hackycy.github.io/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>Docker入门（一）——基本概念与安装</title>
    <link href="http://hackycy.github.io/2019/11/27/Docker%E5%85%A5%E9%97%A8%EF%BC%88%E4%B8%80%EF%BC%89%E2%80%94%E2%80%94%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E4%B8%8E%E5%AE%89%E8%A3%85/"/>
    <id>http://hackycy.github.io/2019/11/27/Docker入门（一）——基本概念与安装/</id>
    <published>2019-11-27T09:35:51.000Z</published>
    <updated>2019-12-02T03:39:41.479Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Docker简介"><a href="#Docker简介" class="headerlink" title="Docker简介"></a>Docker简介</h1><p>Docker 是一个开源的应用容器引擎，基于 <a href="https://www.runoob.com/go/go-tutorial.html" target="_blank" rel="noopener">Go 语言</a> 并遵从 Apache2.0 协议开源。</p><p>Docker 可以让开发者打包他们的应用以及依赖包到一个轻量级、可移植的容器中，然后发布到任何流行的 Linux 机器上，也可以实现虚拟化。</p><p>容器是完全使用沙箱机制，相互之间不会有任何接口（类似 iPhone 的 app）,更重要的是容器性能开销极低。</p><p>Docker 从 17.03 版本之后分为 CE（Community Edition: 社区版） 和 EE（Enterprise Edition: 企业版）</p><a id="more"></a><p>Docker 使用 <code>Google</code> 公司推出的 <a href="https://golang.org/" target="_blank" rel="noopener">Go 语言</a> 进行开发实现，基于 <code>Linux</code> 内核的 <a href="https://zh.wikipedia.org/wiki/Cgroups" target="_blank" rel="noopener">cgroup</a>，<a href="https://en.wikipedia.org/wiki/Linux_namespaces" target="_blank" rel="noopener">namespace</a>，以及 <a href="https://en.wikipedia.org/wiki/Aufs" target="_blank" rel="noopener">AUFS</a> 类的 <a href="https://en.wikipedia.org/wiki/Union_mount" target="_blank" rel="noopener">Union FS</a> 等技术，对进程进行封装隔离，属于 <a href="https://en.wikipedia.org/wiki/Operating-system-level_virtualization" target="_blank" rel="noopener">操作系统层面的虚拟化技术</a>。由于隔离的进程独立于宿主和其它的隔离的进程，因此也称其为容器。最初实现是基于 <a href="https://linuxcontainers.org/lxc/introduction/" target="_blank" rel="noopener">LXC</a>，从 0.7 版本以后开始去除 <code>LXC</code>，转而使用自行开发的 <a href="https://github.com/docker/libcontainer" target="_blank" rel="noopener">libcontainer</a>，从 1.11 开始，则进一步演进为使用 <a href="https://github.com/opencontainers/runc" target="_blank" rel="noopener">runC</a> 和 <a href="https://github.com/containerd/containerd" target="_blank" rel="noopener">containerd</a>。</p><p><img src="docker-on-linux.png" alt></p><blockquote><p><code>runc</code> 是一个 Linux 命令行工具，用于根据 <a href="https://github.com/opencontainers/runtime-spec" target="_blank" rel="noopener">OCI容器运行时规范</a> 创建和运行容器。</p><p><code>containerd</code> 是一个守护程序，它管理容器生命周期，提供了在一个节点上执行容器和管理镜像的最小功能集。</p></blockquote><p>Docker在容器的基础上，进行了进一步的封装，从文件系统、网络互联到进程隔离等等，极大的简化了容器的创建和维护。使得 <code>Docker</code> 技术比虚拟机技术更为轻便、快捷。</p><p>下面的图片比较了 <strong>Docker</strong> 和传统虚拟化方式的不同之处。传统虚拟机技术是虚拟出一套硬件后，在其上运行一个完整操作系统，在该系统上再运行所需应用进程；而容器内的应用进程直接运行于宿主的内核，容器内没有自己的内核，而且也没有进行硬件虚拟。因此容器要比传统虚拟机更为轻便。</p><p><img src="virtualization.png" alt></p><p><img src="docker.png" alt></p><h1 id="Docker优点"><a href="#Docker优点" class="headerlink" title="Docker优点"></a>Docker优点</h1><p> Docker 是一个用于开发，交付和运行应用程序的开放平台。Docker 使您能够将应用程序与基础架构分开，从而可以快速交付软件。借助 Docker，您可以与管理应用程序相同的方式来管理基础架构。通过利用 Docker 的方法来快速交付，测试和部署代码，您可以大大减少编写代码和在生产环境中运行代码之间的延迟。 </p><h2 id="快速，一致地交付您的应用程序"><a href="#快速，一致地交付您的应用程序" class="headerlink" title="快速，一致地交付您的应用程序"></a>快速，一致地交付您的应用程序</h2><p>Docker 允许开发人员使用您提供的应用程序或服务的本地容器在标准化环境中工作，从而简化了开发的生命周期。</p><p>容器非常适合持续集成和持续交付（CI / CD）工作流程，请考虑以下示例方案：</p><ul><li>您的开发人员在本地编写代码，并使用 Docker 容器与同事共享他们的工作。</li><li>他们使用 Docker 将其应用程序推送到测试环境中，并执行自动或手动测试。</li><li>当开发人员发现错误时，他们可以在开发环境中对其进行修复，然后将其重新部署到测试环境中，以进行测试和验证。</li><li>测试完成后，将修补程序推送给生产环境，就像将更新的镜像推送到生产环境一样简单。</li></ul><h2 id="响应式部署和扩展"><a href="#响应式部署和扩展" class="headerlink" title="响应式部署和扩展"></a>响应式部署和扩展</h2><p>Docker 是基于容器的平台，允许高度可移植的工作负载。Docker 容器可以在开发人员的本机上，数据中心的物理或虚拟机上，云服务上或混合环境中运行。</p><p>Docker 的可移植性和轻量级的特性，还可以使您轻松地完成动态管理的工作负担，并根据业务需求指示，实时扩展或拆除应用程序和服务。</p><h2 id="更轻松的维护和扩展"><a href="#更轻松的维护和扩展" class="headerlink" title="更轻松的维护和扩展"></a>更轻松的维护和扩展</h2><p> Docker 使用的分层存储以及镜像的技术，使得应用重复部分的复用更为容易，也使得应用的维护更新更加简单，基于基础镜像进一步扩展镜像也变得非常简单。此外，<code>Docker</code> 团队同各个开源项目团队一起维护了一大批高质量的 <a href="https://hub.docker.com/search/?type=image&amp;image_filter=official" target="_blank" rel="noopener">官方镜像</a>，既可以直接在生产环境使用，又可以作为基础进一步定制，大大的降低了应用服务的镜像制作成本。 </p><h2 id="在同一硬件上运行更多工作负载"><a href="#在同一硬件上运行更多工作负载" class="headerlink" title="在同一硬件上运行更多工作负载"></a>在同一硬件上运行更多工作负载</h2><p> Docker 轻巧快速。它为基于虚拟机管理程序的虚拟机提供了可行、经济、高效的替代方案，因此您可以利用更多的计算能力来实现业务目标。Docker 非常适合于高密度环境以及中小型部署，而您可以用更少的资源做更多的事情。 </p><h2 id="对比传统虚拟机总结"><a href="#对比传统虚拟机总结" class="headerlink" title="对比传统虚拟机总结"></a>对比传统虚拟机总结</h2><table><thead><tr><th style="text-align:left">特性</th><th style="text-align:left">容器</th><th style="text-align:left">虚拟机</th></tr></thead><tbody><tr><td style="text-align:left">启动</td><td style="text-align:left">秒级</td><td style="text-align:left">分钟级</td></tr><tr><td style="text-align:left">硬盘使用</td><td style="text-align:left">一般为 <code>MB</code></td><td style="text-align:left">一般为 <code>GB</code></td></tr><tr><td style="text-align:left">性能</td><td style="text-align:left">接近原生</td><td style="text-align:left">弱于</td></tr><tr><td style="text-align:left">系统支持量</td><td style="text-align:left">单机支持上千个容器</td><td style="text-align:left">一般几十个</td></tr></tbody></table><h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><p>Docker 包括三个基本概念</p><ul><li>镜像（<code>Image</code>）</li><li>容器（<code>Container</code>）</li><li>仓库（<code>Repository</code>）</li></ul><h2 id="镜像"><a href="#镜像" class="headerlink" title="镜像"></a>镜像</h2><p>我们都知道，操作系统分为内核和用户空间。对于 Linux 而言，内核启动后，会挂载 <code>root</code> 文件系统为其提供用户空间支持。而 Docker 镜像（Image），就相当于是一个 <code>root</code> 文件系统。比如官方镜像 <code>ubuntu:18.04</code> 就包含了完整的一套 Ubuntu 18.04 最小系统的 <code>root</code> 文件系统。</p><p>Docker 镜像是一个特殊的文件系统，除了提供容器运行时所需的程序、库、资源、配置等文件外，还包含了一些为运行时准备的一些配置参数（如匿名卷、环境变量、用户等）。镜像不包含任何动态数据，其内容在构建之后也不会被改变。</p><h3 id="分层存储"><a href="#分层存储" class="headerlink" title="分层存储"></a>分层存储</h3><p>因为镜像包含操作系统完整的 <code>root</code> 文件系统，其体积往往是庞大的，因此在 Docker 设计时，就充分利用 <a href="https://en.wikipedia.org/wiki/Union_mount" target="_blank" rel="noopener">Union FS</a> 的技术，将其设计为分层存储的架构。所以严格来说，镜像并非是像一个 ISO 那样的打包文件，镜像只是一个虚拟的概念，其实际体现并非由一个文件组成，而是由一组文件系统组成，或者说，由多层文件系统联合组成。</p><p>镜像构建时，会一层层构建，前一层是后一层的基础。每一层构建完就不会再发生改变，后一层上的任何改变只发生在自己这一层。比如，删除前一层文件的操作，实际不是真的删除前一层的文件，而是仅在当前层标记为该文件已删除。在最终容器运行的时候，虽然不会看到这个文件，但是实际上该文件会一直跟随镜像。因此，在构建镜像的时候，需要额外小心，每一层尽量只包含该层需要添加的东西，任何额外的东西应该在该层构建结束前清理掉。</p><p>分层存储的特征还使得镜像的复用、定制变的更为容易。甚至可以用之前构建好的镜像作为基础层，然后进一步添加新的层，以定制自己所需的内容，构建新的镜像。</p><p>关于镜像构建，将会在后续相关章节中做进一步的讲解。</p><h2 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h2><p>镜像（<code>Image</code>）和容器（<code>Container</code>）的关系，就像是面向对象程序设计中的 <code>类</code> 和 <code>实例</code> 一样，镜像是静态的定义，容器是镜像运行时的实体。容器可以被创建、启动、停止、删除、暂停等。</p><p>容器的实质是进程，但与直接在宿主执行的进程不同，容器进程运行于属于自己的独立的 <a href="https://en.wikipedia.org/wiki/Linux_namespaces" target="_blank" rel="noopener">命名空间</a>。因此容器可以拥有自己的 <code>root</code> 文件系统、自己的网络配置、自己的进程空间，甚至自己的用户 ID 空间。容器内的进程是运行在一个隔离的环境里，使用起来，就好像是在一个独立于宿主的系统下操作一样。这种特性使得容器封装的应用比直接在宿主运行更加安全。也因为这种隔离的特性，很多人初学 Docker 时常常会混淆容器和虚拟机。</p><p>前面讲过镜像使用的是分层存储，容器也是如此。每一个容器运行时，是以镜像为基础层，在其上创建一个当前容器的存储层，我们可以称这个为容器运行时读写而准备的存储层为 <strong>容器存储层</strong>。</p><p>容器存储层的生存周期和容器一样，容器消亡时，容器存储层也随之消亡。因此，任何保存于容器存储层的信息都会随容器删除而丢失。</p><p>按照 Docker 最佳实践的要求，容器不应该向其存储层内写入任何数据，容器存储层要保持无状态化。所有的文件写入操作，都应该使用 <strong>数据卷（Volume）</strong>、或者绑定宿主目录，在这些位置的读写会跳过容器存储层，直接对宿主（或网络存储）发生读写，其性能和稳定性更高。</p><p>数据卷的生存周期独立于容器，容器消亡，数据卷不会消亡。因此，使用数据卷后，容器删除或者重新运行之后，数据却不会丢失。</p><h2 id="仓库"><a href="#仓库" class="headerlink" title="仓库"></a>仓库</h2><h3 id="Docker-Registry"><a href="#Docker-Registry" class="headerlink" title="Docker Registry"></a>Docker Registry</h3><p>镜像构建完成后，可以很容易的在当前宿主机上运行，但是，如果需要在其它服务器上使用这个镜像，我们就需要一个集中的存储、分发镜像的服务，<a href="https://yeasy.gitbooks.io/docker_practice/content/repository/registry.html" target="_blank" rel="noopener">Docker Registry</a> 就是这样的服务。</p><p>一个 <strong>Docker Registry</strong> 中可以包含多个 <strong>仓库</strong>（<code>Repository</code>）；每个仓库可以包含多个 <strong>标签</strong>（<code>Tag</code>）；每个标签对应一个镜像。</p><p>通常，一个仓库会包含同一个软件不同版本的镜像，而标签就常用于对应该软件的各个版本。我们可以通过 <code>&lt;仓库名&gt;:&lt;标签&gt;</code> 的格式来指定具体是这个软件哪个版本的镜像。如果不给出标签，将以 <code>latest</code> 作为默认标签。</p><p>以 <a href="https://hub.docker.com/_/ubuntu" target="_blank" rel="noopener">Ubuntu 镜像</a> 为例，<code>ubuntu</code> 是仓库的名字，其内包含有不同的版本标签，如，<code>16.04</code>, <code>18.04</code>。我们可以通过 <code>ubuntu:16.04</code>，或者 <code>ubuntu:18.04</code> 来具体指定所需哪个版本的镜像。如果忽略了标签，比如 <code>ubuntu</code>，那将视为 <code>ubuntu:latest</code>。</p><p>仓库名经常以 <em>两段式路径</em> 形式出现，比如 <code>jwilder/nginx-proxy</code>，前者往往意味着 Docker Registry 多用户环境下的用户名，后者则往往是对应的软件名。但这并非绝对，取决于所使用的具体 Docker Registry 的软件或服务。</p><h3 id="Docker-Registry-公开服务"><a href="#Docker-Registry-公开服务" class="headerlink" title="Docker Registry 公开服务"></a>Docker Registry 公开服务</h3><p>Docker Registry 公开服务是开放给用户使用、允许用户管理镜像的 Registry 服务。一般这类公开服务允许用户免费上传、下载公开的镜像，并可能提供收费服务供用户管理私有镜像。</p><p>最常使用的 Registry 公开服务是官方的 <a href="https://hub.docker.com/" target="_blank" rel="noopener">Docker Hub</a>，这也是默认的 Registry，并拥有大量的高质量的官方镜像。除此以外，还有 <a href="https://coreos.com/" target="_blank" rel="noopener">CoreOS</a> 的 <a href="https://quay.io/repository/" target="_blank" rel="noopener">Quay.io</a>，CoreOS 相关的镜像存储在这里；Google 的 <a href="https://cloud.google.com/container-registry/" target="_blank" rel="noopener">Google Container Registry</a>，<a href="https://kubernetes.io/" target="_blank" rel="noopener">Kubernetes</a> 的镜像使用的就是这个服务。</p><p>由于某些原因，在国内访问这些服务可能会比较慢。国内的一些云服务商提供了针对 Docker Hub 的镜像服务（<code>Registry Mirror</code>），这些镜像服务被称为<strong>加速器</strong>。常见的有 <a href="https://cr.console.aliyun.com/#/accelerator" target="_blank" rel="noopener">阿里云加速器</a>、<a href="https://www.daocloud.io/mirror#accelerator-doc" target="_blank" rel="noopener">DaoCloud 加速器</a> 等。使用加速器会直接从国内的地址下载 Docker Hub 的镜像，比直接从 Docker Hub 下载速度会提高很多。</p><p>国内也有一些云服务商提供类似于 Docker Hub 的公开服务。比如 <a href="https://hub.tenxcloud.com/" target="_blank" rel="noopener">时速云镜像仓库</a>、<a href="https://c.163.com/hub#/m/library/" target="_blank" rel="noopener">网易云镜像服务</a>、<a href="https://hub.daocloud.io/" target="_blank" rel="noopener">DaoCloud 镜像市场</a>、<a href="https://cr.console.aliyun.com/" target="_blank" rel="noopener">阿里云镜像库</a> 等。</p><h3 id="私有-Docker-Registry"><a href="#私有-Docker-Registry" class="headerlink" title="私有 Docker Registry"></a>私有 Docker Registry</h3><p>除了使用公开服务外，用户还可以在本地搭建私有 Docker Registry。Docker 官方提供了 <a href="https://hub.docker.com/_/registry/" target="_blank" rel="noopener">Docker Registry</a> 镜像，可以直接使用做为私有 Registry 服务。在 <a href="https://yeasy.gitbooks.io/docker_practice/content/repository/registry.html" target="_blank" rel="noopener">私有仓库</a> 一节中，会有进一步的搭建私有 Registry 服务的讲解。</p><p>开源的 Docker Registry 镜像只提供了 <a href="https://docs.docker.com/registry/spec/api/" target="_blank" rel="noopener">Docker Registry API</a> 的服务端实现，足以支持 <code>docker</code> 命令，不影响使用。但不包含图形界面，以及镜像维护、用户管理、访问控制等高级功能。在官方的商业化版本 <a href="https://docs.docker.com/datacenter/dtr/2.0/" target="_blank" rel="noopener">Docker Trusted Registry</a> 中，提供了这些高级功能。</p><p>除了官方的 Docker Registry 外，还有第三方软件实现了 Docker Registry API，甚至提供了用户界面以及一些高级功能。比如，<a href="https://github.com/goharbor/harbor" target="_blank" rel="noopener">Harbor</a> 和 <a href="https://yeasy.gitbooks.io/docker_practice/content/repository/nexus3_registry.html" target="_blank" rel="noopener">Sonatype Nexus</a>。</p><h1 id="Docker安装"><a href="#Docker安装" class="headerlink" title="Docker安装"></a>Docker安装</h1><p>Docker 分为 CE 和 EE 两大版本。CE 即社区版（免费，支持周期 7 个月），EE 即企业版，强调安全，付费使用，支持周期 24 个月。</p><p>Docker CE 分为 <code>stable</code> <code>test</code> 和 <code>nightly</code> 三个更新频道。每六个月发布一个 <code>stable</code> 版本 (<code>18.09</code>, <code>19.03</code>, <code>19.09</code>…)。</p><p>官方网站上有各种环境下的 <a href="https://docs.docker.com/install/" target="_blank" rel="noopener">安装指南</a>，这里主要介绍 Docker CE 在 <code>Linux</code> 、 <code>macOS</code> 上的安装。</p><h2 id="Linux—CentOS"><a href="#Linux—CentOS" class="headerlink" title="Linux—CentOS"></a>Linux—CentOS</h2><h3 id="系统要求"><a href="#系统要求" class="headerlink" title="系统要求"></a>系统要求</h3><p> Docker CE 支持 64 位版本 CentOS 7，并且要求内核版本不低于 3.10。 CentOS 7 满足最低内核的要求，但由于内核版本比较低，部分功能（如 <code>overlay2</code> 存储层驱动）无法使用，并且部分功能可能不太稳定。 </p><h3 id="卸载旧版本"><a href="#卸载旧版本" class="headerlink" title="卸载旧版本"></a>卸载旧版本</h3><p> 旧版本的 Docker 称为 <code>docker</code> 或者 <code>docker-engine</code>，使用以下命令卸载旧版本： </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ sudo yum remove docker \</span><br><span class="line">                  docker-client \</span><br><span class="line">                  docker-client-latest \</span><br><span class="line">                  docker-common \</span><br><span class="line">                  docker-latest \</span><br><span class="line">                  docker-latest-logrotate \</span><br><span class="line">                  docker-logrotate \</span><br><span class="line">                  docker-selinux \</span><br><span class="line">                  docker-engine-selinux \</span><br><span class="line">                  docker-engine</span><br></pre></td></tr></table></figure><h3 id="使用yum安装"><a href="#使用yum安装" class="headerlink" title="使用yum安装"></a>使用yum安装</h3><p> 执行以下命令安装依赖包： </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ sudo yum install -y yum-utils \</span><br><span class="line">           device-mapper-persistent-data \</span><br><span class="line">           lvm2</span><br></pre></td></tr></table></figure><p>鉴于国内网络问题，强烈建议使用国内源，官方源请在注释中查看。</p><p>执行下面的命令添加 <code>yum</code> 软件源：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ sudo yum-config-manager \</span><br><span class="line">    --add-repo \</span><br><span class="line">    https://mirrors.ustc.edu.cn/docker-ce/linux/centos/docker-ce.repo</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 官方源</span></span><br><span class="line"><span class="comment"># $ sudo yum-config-manager \</span></span><br><span class="line"><span class="comment">#     --add-repo \</span></span><br><span class="line"><span class="comment">#     https://download.docker.com/linux/centos/docker-ce.repo</span></span><br></pre></td></tr></table></figure><blockquote><p> 如果需要测试版本的 Docker CE 请使用以下命令： </p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo yum-config-manager --<span class="built_in">enable</span> docker-ce-test</span><br></pre></td></tr></table></figure><blockquote><p> 如果需要每日构建版本的 Docker CE 请使用以下命令： </p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo yum-config-manager --<span class="built_in">enable</span> docker-ce-nightly</span><br></pre></td></tr></table></figure><h3 id="安装Docker-CE"><a href="#安装Docker-CE" class="headerlink" title="安装Docker CE"></a>安装Docker CE</h3><p> 更新 <code>yum</code> 软件源缓存，并安装 <code>docker-ce</code>。 </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo yum makecache fast</span><br><span class="line">$ sudo yum install docker-ce</span><br></pre></td></tr></table></figure><h3 id="使用脚本自动安装"><a href="#使用脚本自动安装" class="headerlink" title="使用脚本自动安装"></a>使用脚本自动安装</h3><p> 在测试或开发环境中 Docker 官方为了简化安装流程，提供了一套便捷的安装脚本，CentOS 系统上可以使用这套脚本安装，另外可以通过 <code>--mirror</code> 选项使用国内源进行安装： </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ curl -fsSL get.docker.com -o get-docker.sh</span><br><span class="line">$ sudo sh get-docker.sh --mirror Aliyun</span><br><span class="line"><span class="comment"># $ sudo sh get-docker.sh --mirror AzureChinaCloud</span></span><br></pre></td></tr></table></figure><p> 执行这个命令后，脚本就会自动的将一切准备工作做好，并且把 Docker CE 的稳定(stable)版本安装在系统中。 </p><h3 id="启动Docker"><a href="#启动Docker" class="headerlink" title="启动Docker"></a>启动Docker</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo systemctl <span class="built_in">enable</span> docker</span><br><span class="line">$ sudo systemctl start docker</span><br></pre></td></tr></table></figure><h3 id="建立-docker-用户组"><a href="#建立-docker-用户组" class="headerlink" title="建立 docker 用户组"></a>建立 docker 用户组</h3><p>默认情况下，<code>docker</code> 命令会使用 <a href="https://en.wikipedia.org/wiki/Unix_domain_socket" target="_blank" rel="noopener">Unix socket</a> 与 Docker 引擎通讯。而只有 <code>root</code> 用户和 <code>docker</code> 组的用户才可以访问 Docker 引擎的 Unix socket。出于安全考虑，一般 Linux 系统上不会直接使用 <code>root</code> 用户。因此，更好地做法是将需要使用 <code>docker</code> 的用户加入 <code>docker</code> 用户组。</p><p>建立 <code>docker</code> 组：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo groupadd docker</span><br></pre></td></tr></table></figure><p> 将当前用户加入 <code>docker</code> 组： </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo usermod -aG docker <span class="variable">$USER</span></span><br></pre></td></tr></table></figure><p> 退出当前终端并重新登录，进行如下测试。 </p><h3 id="测试-Docker-是否安装正确"><a href="#测试-Docker-是否安装正确" class="headerlink" title="测试 Docker 是否安装正确"></a>测试 Docker 是否安装正确</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">$ docker run hello-world</span><br><span class="line"></span><br><span class="line">Unable to find image <span class="string">'hello-world:latest'</span> locally</span><br><span class="line">latest: Pulling from library/hello-world</span><br><span class="line">d1725b59e92d: Pull complete</span><br><span class="line">Digest: sha256:0add3ace90ecb4adbf7777e9aacf18357296e799f81cabc9fde470971e499788</span><br><span class="line">Status: Downloaded newer image <span class="keyword">for</span> hello-world:latest</span><br><span class="line"></span><br><span class="line">Hello from Docker!</span><br><span class="line">This message shows that your installation appears to be working correctly.</span><br><span class="line"></span><br><span class="line">To generate this message, Docker took the following steps:</span><br><span class="line"> 1. The Docker client contacted the Docker daemon.</span><br><span class="line"> 2. The Docker daemon pulled the <span class="string">"hello-world"</span> image from the Docker Hub.</span><br><span class="line">    (amd64)</span><br><span class="line"> 3. The Docker daemon created a new container from that image <span class="built_in">which</span> runs the</span><br><span class="line">    executable that produces the output you are currently reading.</span><br><span class="line"> 4. The Docker daemon streamed that output to the Docker client, <span class="built_in">which</span> sent it</span><br><span class="line">    to your terminal.</span><br><span class="line"></span><br><span class="line">To try something more ambitious, you can run an Ubuntu container with:</span><br><span class="line"> $ docker run -it ubuntu bash</span><br><span class="line"></span><br><span class="line">Share images, automate workflows, and more with a free Docker ID:</span><br><span class="line"> https://hub.docker.com/</span><br><span class="line"></span><br><span class="line">For more examples and ideas, visit:</span><br><span class="line"> https://docs.docker.com/get-started/</span><br></pre></td></tr></table></figure><p> 若能正常输出以上信息，则说明安装成功。 </p><blockquote><p>个人作为开发者，建议直接使用宝塔进行安装，bt.cn安装后可以查看软件商店找到docker直接进行安装。对于开发者而言更加方便使用。</p></blockquote><h2 id="macOS"><a href="#macOS" class="headerlink" title="macOS"></a>macOS</h2><h3 id="系统要求-1"><a href="#系统要求-1" class="headerlink" title="系统要求"></a>系统要求</h3><p> <a href="https://docs.docker.com/docker-for-mac/" target="_blank" rel="noopener">Docker Desktop for Mac</a> 要求系统最低为 macOS Sierra 10.12。 </p><h3 id="Homebrew-安装"><a href="#Homebrew-安装" class="headerlink" title="Homebrew 安装"></a>Homebrew 安装</h3><p> <a href="https://brew.sh/" target="_blank" rel="noopener">Homebrew</a> 的 <a href="https://caskroom.github.io/" target="_blank" rel="noopener">Cask</a> 已经支持 Docker Desktop for Mac，因此可以很方便的使用 Homebrew Cask 来进行安装： </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ brew cask install docker</span><br></pre></td></tr></table></figure><h3 id="手动下载安装"><a href="#手动下载安装" class="headerlink" title="手动下载安装"></a>手动下载安装</h3><p> <a href="https://hub.docker.com/editions/community/docker-ce-desktop-mac" target="_blank" rel="noopener">https://hub.docker.com/editions/community/docker-ce-desktop-mac</a> </p><p><a href="https://docs.docker.com/toolbox/overview/" target="_blank" rel="noopener">https://docs.docker.com/toolbox/overview/</a></p><p>也可以点击以下链接直接下载 <a href="https://download.docker.com/mac/stable/Docker.dmg" target="_blank" rel="noopener">Stable</a> 或 <a href="https://download.docker.com/mac/edge/Docker.dmg" target="_blank" rel="noopener">Edge</a> 版本的 Docker Desktop for Mac。</p><blockquote><p>点击链接注册Docker ID即可下载。傻瓜式安装。安装后点击图标运行即可。</p><p>可关掉开机自启。preference -&gt; general -&gt; start Docker Desktop when you log in</p></blockquote><p>启动终端后，通过命令可以检查安装后的 Docker 版本。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ docker --version</span><br><span class="line">Docker version 19.03.5, build 633a0ea</span><br><span class="line">$ docker-compose --version</span><br><span class="line">docker-compose version 1.24.1, build 4667896b</span><br><span class="line">$ docker-machine --version</span><br><span class="line">docker-machine version 0.16.2, build bd45ab13</span><br></pre></td></tr></table></figure><h2 id="镜像加速器"><a href="#镜像加速器" class="headerlink" title="镜像加速器"></a>镜像加速器</h2><p>国内从 Docker Hub 拉取镜像有时会遇到困难，此时可以配置镜像加速器。国内很多云服务商都提供了国内加速器服务，例如：</p><ul><li><a href="https://github.com/Azure/container-service-for-azure-china/blob/master/aks/README.md#22-container-registry-proxy" target="_blank" rel="noopener">Azure 中国镜像 <code>https://dockerhub.azk8s.cn</code></a></li><li><a href="https://cr.console.aliyun.com/cn-hangzhou/mirrors" target="_blank" rel="noopener">阿里云加速器(需登录账号获取)</a></li><li><a href="https://kirk-enterprise.github.io/hub-docs/#/user-guide/mirror" target="_blank" rel="noopener">七牛云加速器 <code>https://reg-mirror.qiniu.com</code></a></li></ul><blockquote><p>由于镜像服务可能出现宕机，建议同时配置多个镜像。</p><p>国内各大云服务商均提供了 Docker 镜像加速服务，建议根据运行 Docker 的云平台选择对应的镜像加速服务，具体请参考官方文档。</p></blockquote><p>这里以 Azure 中国镜像 <code>https://dockerhub.azk8s.cn</code> 为例进行介绍。</p><h3 id="Ubuntu-16-04-、Debian-8-、CentOS-7"><a href="#Ubuntu-16-04-、Debian-8-、CentOS-7" class="headerlink" title="Ubuntu 16.04+、Debian 8+、CentOS 7"></a>Ubuntu 16.04+、Debian 8+、CentOS 7</h3><p> 对于使用 <a href="https://www.freedesktop.org/wiki/Software/systemd/" target="_blank" rel="noopener">systemd</a> 的系统，请在 <code>/etc/docker/daemon.json</code> 中写入如下内容（如果文件不存在请新建该文件） </p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"registry-mirrors"</span>: [</span><br><span class="line">    <span class="string">"https://dockerhub.azk8s.cn"</span>,</span><br><span class="line">    <span class="string">"https://reg-mirror.qiniu.com"</span></span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p> 注意，一定要保证该文件符合 json 规范，否则 Docker 将不能启动。 </p></blockquote><p> 之后重新启动服务。 </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo systemctl daemon-reload</span><br><span class="line">$ sudo systemctl restart docker</span><br></pre></td></tr></table></figure><blockquote><p> 注意：如果您之前查看旧教程，修改了 <code>docker.service</code> 文件内容，请去掉您添加的内容（<code>--registry-mirror=https://dockerhub.azk8s.cn</code>）。 </p></blockquote><h3 id="macOS-1"><a href="#macOS-1" class="headerlink" title="macOS"></a>macOS</h3><p> 对于使用 macOS 的用户，在任务栏点击 Docker Desktop 应用图标 -&gt; <code>Perferences</code>，在左侧导航菜单选择 <code>Docker Engine</code>，在右侧像下边一样编辑 json 文件。修改完成之后，点击 <code>Apply &amp; Restart</code> 按钮，Docker 就会重启并应用配置的镜像地址了。 </p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"registry-mirrors"</span>: [</span><br><span class="line">    <span class="string">"https://dockerhub.azk8s.cn"</span>,</span><br><span class="line">    <span class="string">"https://reg-mirror.qiniu.com"</span></span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="检查加速器是否生效"><a href="#检查加速器是否生效" class="headerlink" title="检查加速器是否生效"></a>检查加速器是否生效</h3><p> 执行 <code>$ docker info</code>，如果从结果中看到了如下内容，说明配置成功。 </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Registry Mirrors:</span><br><span class="line"> https://dockerhub.azk8s.cn/</span><br></pre></td></tr></table></figure><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p>Docker 官网：<a href="https://www.docker.com/" target="_blank" rel="noopener">https://www.docker.com</a></p><p>Github Docker 源码：<a href="https://github.com/docker/docker-ce" target="_blank" rel="noopener">https://github.com/docker/docker-ce</a></p><p>Docker命令大全：<a href="https://www.runoob.com/docker/docker-command-manual.html" target="_blank" rel="noopener">https://www.runoob.com/docker/docker-command-manual.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Docker简介&quot;&gt;&lt;a href=&quot;#Docker简介&quot; class=&quot;headerlink&quot; title=&quot;Docker简介&quot;&gt;&lt;/a&gt;Docker简介&lt;/h1&gt;&lt;p&gt;Docker 是一个开源的应用容器引擎，基于 &lt;a href=&quot;https://www.runoob.com/go/go-tutorial.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Go 语言&lt;/a&gt; 并遵从 Apache2.0 协议开源。&lt;/p&gt;
&lt;p&gt;Docker 可以让开发者打包他们的应用以及依赖包到一个轻量级、可移植的容器中，然后发布到任何流行的 Linux 机器上，也可以实现虚拟化。&lt;/p&gt;
&lt;p&gt;容器是完全使用沙箱机制，相互之间不会有任何接口（类似 iPhone 的 app）,更重要的是容器性能开销极低。&lt;/p&gt;
&lt;p&gt;Docker 从 17.03 版本之后分为 CE（Community Edition: 社区版） 和 EE（Enterprise Edition: 企业版）&lt;/p&gt;
    
    </summary>
    
      <category term="Docker" scheme="http://hackycy.github.io/categories/Docker/"/>
    
    
      <category term="Docker" scheme="http://hackycy.github.io/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>了解JSON Web Token</title>
    <link href="http://hackycy.github.io/2019/11/11/%E4%BA%86%E8%A7%A3JSON-Web-Token/"/>
    <id>http://hackycy.github.io/2019/11/11/了解JSON-Web-Token/</id>
    <published>2019-11-11T04:19:51.000Z</published>
    <updated>2019-11-11T06:37:51.747Z</updated>
    
    <content type="html"><![CDATA[<p>JSON Web Token（缩写 JWT）是目前最流行的跨域认证解决方案。<a href="https://jwt.io" target="_blank" rel="noopener">JWT</a></p><a id="more"></a><h1 id="跨域认证问题"><a href="#跨域认证问题" class="headerlink" title="跨域认证问题"></a>跨域认证问题</h1><p>互联网服务离不开用户认证。一般流程是下面这样。</p><blockquote><p>1、用户向服务器发送用户名和密码。</p><p>2、服务器验证通过后，在当前对话（session）里面保存相关数据，比如用户角色、登录时间等等。</p><p>3、服务器向用户返回一个 session_id，写入用户的 Cookie。</p><p>4、用户随后的每一次请求，都会通过 Cookie，将 session_id 传回服务器。</p><p>5、服务器收到 session_id，找到前期保存的数据，由此得知用户的身份。</p></blockquote><p>这种模式的问题在于，扩展性（scaling）不好。单机当然没有问题，如果是服务器集群，或者是跨域的服务导向架构，就要求 session 数据共享，每台服务器都能够读取 session。</p><p>举例来说，A 网站和 B 网站是同一家公司的关联服务。现在要求，用户只要在其中一个网站登录，再访问另一个网站就会自动登录，请问怎么实现？</p><p>一种解决方案是 session 数据持久化，写入数据库或别的持久层。各种服务收到请求后，都向持久层请求数据。这种方案的优点是架构清晰，缺点是工程量比较大。另外，持久层万一挂了，就会单点失败。</p><p>另一种方案是服务器索性不保存 session 数据了，所有数据都保存在客户端，每次请求都发回服务器。JWT 就是这种方案的一个代表。</p><h1 id="JWT原理"><a href="#JWT原理" class="headerlink" title="JWT原理"></a>JWT原理</h1><p>JWT 的原理是，服务器认证以后，生成一个 JSON 对象，发回给用户，就像下面这样。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"username"</span>: <span class="string">"张三"</span>,</span><br><span class="line">  <span class="attr">"role"</span>: <span class="string">"管理员"</span>,</span><br><span class="line">  <span class="attr">"exp"</span>: <span class="string">"2018年7月1日0点0分"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以后，用户与服务端通信的时候，都要发回这个 JSON 对象。服务器完全只靠这个对象认定用户身份。为了防止用户篡改数据，服务器在生成这个对象的时候，会加上签名（详见后文）。</p><p>服务器就不保存任何 session 数据了，也就是说，服务器变成无状态了，从而比较容易实现扩展。</p><h1 id="JWT的数据结构"><a href="#JWT的数据结构" class="headerlink" title="JWT的数据结构"></a>JWT的数据结构</h1><p>实际的 JWT 大概就像下面这样。</p><p><img src="jsonwebtoken.png" alt></p><p>它是一个很长的字符串，中间用点（<code>.</code>）分隔成三个部分。注意，JWT 内部是没有换行的，这里只是为了便于展示，将它写成了几行。</p><p>JWT 的三个部分依次如下：</p><ul><li>Header（头部）</li><li>Payload（负载）</li><li>Signature（签名）</li></ul><p>写成一行，就是<code>Header.Payload.Signature</code>。</p><p><img src="jsonwebtoken1.jpg" alt></p><h2 id="Header"><a href="#Header" class="headerlink" title="Header"></a>Header</h2><p>Header 部分是一个 JSON 对象，描述 JWT 的元数据，通常是下面的样子。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"alg"</span>: <span class="string">"HS256"</span>,</span><br><span class="line">  <span class="attr">"typ"</span>: <span class="string">"JWT"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，<code>alg</code>属性表示签名的算法（algorithm），默认是 HMAC SHA256（写成 HS256）；<code>typ</code>属性表示这个令牌（token）的类型（type），JWT 令牌统一写为<code>JWT</code>。</p><p>最后，将上面的 JSON 对象使用 Base64URL 算法（详见后文）转成字符串。</p><h2 id="Payload"><a href="#Payload" class="headerlink" title="Payload"></a>Payload</h2><p>Payload 部分也是一个 JSON 对象，用来存放实际需要传递的数据。JWT 规定了7个官方字段，供选用。</p><ul><li>iss (issuer)：签发人</li><li>exp (expiration time)：过期时间</li><li>sub (subject)：主题</li><li>aud (audience)：受众</li><li>nbf (Not Before)：生效时间</li><li>iat (Issued At)：签发时间</li><li>jti (JWT ID)：编号</li></ul><p>除了官方字段，你还可以在这个部分定义私有字段，下面就是一个例子。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"sub"</span>: <span class="string">"1234567890"</span>,</span><br><span class="line">  <span class="attr">"name"</span>: <span class="string">"John Doe"</span>,</span><br><span class="line">  <span class="attr">"admin"</span>: <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，JWT 默认是不加密的，任何人都可以读到，所以不要把秘密信息放在这个部分。</p><p>这个 JSON 对象也要使用 Base64URL 算法转成字符串。</p><h2 id="Signature"><a href="#Signature" class="headerlink" title="Signature"></a>Signature</h2><p>Signature 部分是对前两部分的签名，防止数据篡改。</p><p>首先，需要指定一个密钥（secret）。这个密钥只有服务器才知道，不能泄露给用户。然后，使用 Header 里面指定的签名算法（默认是 HMAC SHA256），按照下面的公式产生签名。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">HMACSHA256(</span><br><span class="line">  base64UrlEncode(header) + &quot;.&quot; +</span><br><span class="line">  base64UrlEncode(payload),</span><br><span class="line">  secret)</span><br></pre></td></tr></table></figure><p>算出签名以后，把 Header、Payload、Signature 三个部分拼成一个字符串，每个部分之间用”点”（<code>.</code>）分隔，就可以返回给用户。</p><h2 id="Base64URL"><a href="#Base64URL" class="headerlink" title="Base64URL"></a>Base64URL</h2><p>前面提到，Header 和 Payload 串型化的算法是 Base64URL。这个算法跟 Base64 算法基本类似，但有一些小的不同。</p><p>JWT 作为一个令牌（token），有些场合可能会放到 URL（比如 api.example.com/?token=xxx）。Base64 有三个字符<code>+</code>、<code>/</code>和<code>=</code>，在 URL 里面有特殊含义，所以要被替换掉：<code>=</code>被省略、<code>+</code>替换成<code>-</code>，<code>/</code>替换成<code>_</code> 。这就是 Base64URL 算法。</p><h1 id="JWT-的使用方式"><a href="#JWT-的使用方式" class="headerlink" title="JWT 的使用方式"></a>JWT 的使用方式</h1><p>客户端收到服务器返回的 JWT，可以储存在 Cookie 里面，也可以储存在 localStorage。</p><p>此后，客户端每次与服务器通信，都要带上这个 JWT。你可以把它放在 Cookie 里面自动发送，但是这样不能跨域，所以更好的做法是放在 HTTP 请求的头信息<code>Authorization</code>字段里面。</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Authorization</span>: Bearer &lt;token&gt;</span><br></pre></td></tr></table></figure><p>另一种做法是，跨域的时候，JWT 就放在 POST 请求的数据体里面。</p><blockquote><p>在node中使用jwt：<a href="https://segmentfault.com/a/1190000009494020" target="_blank" rel="noopener">jsonwebtoken中文文档</a> ｜ <a href="https://www.npmjs.com/package/jsonwebtoken" target="_blank" rel="noopener">jsonwebtoken npm</a></p></blockquote><h1 id="JWT-的几个特点"><a href="#JWT-的几个特点" class="headerlink" title="JWT 的几个特点"></a>JWT 的几个特点</h1><p>（1）JWT 默认是不加密，但也是可以加密的。生成原始 Token 以后，可以用密钥再加密一次。</p><p>（2）JWT 不加密的情况下，不能将秘密数据写入 JWT。</p><p>（3）JWT 不仅可以用于认证，也可以用于交换信息。有效使用 JWT，可以降低服务器查询数据库的次数。</p><p>（4）JWT 的最大缺点是，由于服务器不保存 session 状态，因此无法在使用过程中废止某个 token，或者更改 token 的权限。也就是说，一旦 JWT 签发了，在到期之前就会始终有效，除非服务器部署额外的逻辑。</p><p>（5）JWT 本身包含了认证信息，一旦泄露，任何人都可以获得该令牌的所有权限。为了减少盗用，JWT 的有效期应该设置得比较短。对于一些比较重要的权限，使用时应该再次对用户进行认证。</p><p>（6）为了减少盗用，JWT 不应该使用 HTTP 协议明码传输，要使用 HTTPS 协议传输。</p><h1 id="JWT优点"><a href="#JWT优点" class="headerlink" title="JWT优点"></a>JWT优点</h1><p>使用 JSON Web Token 保护应用安全，你至少可以获得以下几个优势：</p><p>更少的数据库连接：因其基于算法来实现身份认证，在使用 JWT 时查询数据的次数更少(更少的数据连接不等于不连接数据库)，可以获得更快的系统响应时间。构建更简单：如果你的应用程序本身是无状态的，那么选择 JWT 可以加快系统构建过程。</p><p>跨服务调用：你可以构建一个认证中心来处理用户身份认证和发放签名的工作，其他应用服务在后续的用户请求中不需要(理论上)在询问认证中心，可使用自有的公钥对用户签名进行验证。</p><p>无状态：你不需要向传统的 Web 应用那样将用户状态保存于 Session 中。</p><h1 id="JWT弊端"><a href="#JWT弊端" class="headerlink" title="JWT弊端"></a>JWT弊端</h1><p>JWT 不是万能的，使用 JWT 也会带来诸多问题。就个人使用情况，使用 JWT 时可能会面临以下几个麻烦：</p><ul><li>严重依赖于秘钥：JWT 的生成与解析过程都需要依赖于秘钥(Secret)，且都以硬编码的方式存在于系统中(也有放在外部配置文件中的)。如果秘钥不小心泄露，系统的安全性将收到威胁。</li><li>服务端无法管理客户端的信息：如果用户身份发生异常(信息泄露，或者被攻击)，服务端很难向操作 Session 那样主动将异常用户进行隔离。</li><li>服务端无法主动推送消息：服务端由于是无状态的，他将无法使用像 Session 那样的方式推送消息到客户端，例如过期时间将至，服务端无法主动为用户续约，需要客户端向服务端发起续约请求。</li><li>冗余的数据开销：一个 JWT 签名的大小要远比一个 Session ID 长很多，如果你对有效载荷(payload)中的数据不做有效控制，其长度会成几何倍数增长，且在每一次请求时都需要负担额外的网络开销。</li><li>JSON Web Token 很流行，但是它相比于 Session,OIDC(OpenId Connect)等技术还比较新，支持 JSON Web Token 的库还比较少，而且 JWT 也并非比传统 Session 更安全，他们都没有解决 CSRF 和 XSS 的问题。因此，在决定使用 JWT 前，你需要仔细考虑其利弊。</li></ul><h1 id="安全隐患思考"><a href="#安全隐患思考" class="headerlink" title="安全隐患思考"></a>安全隐患思考</h1><p><strong>考虑这样一个问题：如果客户端的 JWT 令牌泄露或者被盗取，会发生什么严重的后果？有什么补救措施？</strong></p><ul><li>如果单纯的依靠 JSON Web Token 解决用户认证的所有问题，那么系统的安全性将是脆弱的。由于 JWT 令牌存储于客户端中，一旦客户端存储的令牌发生泄露事件或者被攻击，攻击者就可以轻而易举的伪造用户身份去修改/删除系统资源，岁如按 JWT 自带过期时间，但在过期之前，攻击者可以肆无忌惮的操作系统数据。通过算法来校验用户身份合法性是 JWT 的优势，同时也是最大的弊端——它太过于依赖算法。</li><li>反观传统的用户认证措施，通常会包含多种组合，如手机验证码，人脸识别，语音识别，指纹锁等。用户名和密码只做用户身份识别使用，当用户名和密码泄露后，在遇到敏感操作时(如新增，修改，删除，下载，上传)，都会采用另外的方式对用户的合法性进行验证(发送验证码，邮箱验证码，指纹信息等)以确保数据安全。</li><li>与传统的身份验证方式相比，JWT 过多的依赖于算法，缺乏灵活性，而且服务端往往是被动执行用户身份验证操作，无法及时对异常用户进行隔离。那是否有补救措施呢？答案是肯定的。接下来，将介绍在发生令牌泄露事件后，如何保证系统的安全。</li></ul><h1 id="防范手段"><a href="#防范手段" class="headerlink" title="防范手段"></a>防范手段</h1><p>不管是基于 Sessions 还是基于 JSON Web Token，一旦密令被盗取，都是一件棘手的事情。接下来，将讲述基于 JSON Web Token 的方式发生令牌泄露是该采取什么样的措施(解决方案包含但不局限与本文所涉及的内容)。</p><p>为了防止用户 JWT 令牌泄露而威胁系统安全，你可以在以下几个方面完善系统功能：</p><ol><li>清除已泄露的令牌：此方案最直接，也容易实现，你需将 JWT 令牌在服务端也存储一份，若发现有异常的令牌存在，则从服务端令牌列表中将此异常令牌清除。当用户发起请求时，强制用户重新进行身份验证，直至验证成功。对于服务端的令牌存储，可以借助 Redis 等缓存服务器进行管理，也可以使用 Ehcache 将令牌信息存储在内存中。</li><li>敏感操作保护：在涉及到诸如新增，修改，删除，上传，下载等敏感性操作时，定期(30分钟，15分钟甚至更短)检查用户身份，如手机验证码，扫描二维码等手段，确认操作者是用户本人。如果身份验证不通过，则终止请求，并要求重新验证用户身份信息。</li><li>地域检查：通常用户会在一个相对固定的地理范围内访问应用程序，可以将地理位置信息作为一个辅助来甄别用户的 JWT 令牌是否存在问题。如果发现用户A由经常所在的地区 1 变到了相对较远的地区 2 ，或者频繁在多个地区间切换，不管用户有没有可能在短时间内在多个地域活动(一般不可能)，都应当终止当前请求，强制用户重新进行验证身份，颁发新的 JWT 令牌，并提醒(或要求)用户重置密码。</li><li>监控请求频率：如果 JWT 密令被盗取，攻击者或通过某些工具伪造用户身份，高频次的对系统发送请求，以套取用户数据。针对这种情况，可以监控用户在单位时间内的请求次数，当单位时间内的请求次数超出预定阈值值，则判定该用户密令是有问题的。例如 1 秒内连续超过 5 次请求，则视为用户身份非法，服务端终止请求并强制将该用户的 JWT 密令清除，然后回跳到认证中心对用户身份进行验证。</li><li>客户端环境检查：对于一些移动端应用来说，可以将用户信息与设备(手机,平板)的机器码进行绑定，并存储于服务端中，当客户端发起请求时，可以先校验客户端的机器码与服务端的是否匹配，如果不匹配，则视为非法请求，并终止用户的后续请求。</li></ol><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://jwt.io/introduction/" target="_blank" rel="noopener">https://jwt.io/introduction/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;JSON Web Token（缩写 JWT）是目前最流行的跨域认证解决方案。&lt;a href=&quot;https://jwt.io&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;JWT&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="架构之路" scheme="http://hackycy.github.io/categories/%E6%9E%B6%E6%9E%84%E4%B9%8B%E8%B7%AF/"/>
    
    
      <category term="Json Web Token" scheme="http://hackycy.github.io/tags/Json-Web-Token/"/>
    
  </entry>
  
  <entry>
    <title>理解OAuth 2.0</title>
    <link href="http://hackycy.github.io/2019/10/25/%E7%90%86%E8%A7%A3OAuth-2-0/"/>
    <id>http://hackycy.github.io/2019/10/25/理解OAuth-2-0/</id>
    <published>2019-10-25T08:56:03.000Z</published>
    <updated>2019-10-25T09:17:02.347Z</updated>
    
    <content type="html"><![CDATA[<p>最近需要接入到第三方应用登陆接触到了这个<a href="http://en.wikipedia.org/wiki/OAuth" target="_blank" rel="noopener">OAuth</a>概念，它是一个关于授权（authorization）的开放网络标准，在全世界得到广泛应用（QQ，Github，微博等），目前的版本是2.0版。</p><p>所以记录下OAuth 2.0的设计思路和运行流程，做一个简明通俗的解释，主要参考材料为<a href="http://www.rfcreader.com/#rfc6749" target="_blank" rel="noopener">RFC 6749</a>。</p><a id="more"></a><h1 id="名词定义"><a href="#名词定义" class="headerlink" title="名词定义"></a>名词定义</h1><p>在详细讲解OAuth 2.0之前，需要了解几个专用名词。它们对读懂后面的讲解，尤其是几张图，至关重要。</p><ul><li><strong>Third-party application</strong>：第三方应用程序，本文中又称”客户端”（client），即上一节例子中的”云冲印”。</li><li><strong>HTTP service</strong>：HTTP服务提供商，本文中简称”服务提供商”。</li><li><strong>User Agent</strong>：用户代理，本文中就是指浏览器。</li><li><strong>Authorization server</strong>：认证服务器，即服务提供商专门用来处理认证的服务器。</li><li><strong>Resource server</strong>：资源服务器，即服务提供商存放用户生成的资源的服务器。它与认证服务器，可以是同一台服务器，也可以是不同的服务器。</li></ul><blockquote><p>OAuth的作用就是让”客户端”安全可控地获取”用户”的授权，与”服务商提供商”进行互动。</p></blockquote><h1 id="OAuth的思路"><a href="#OAuth的思路" class="headerlink" title="OAuth的思路"></a>OAuth的思路</h1><p>OAuth在”客户端”与”服务提供商”之间，设置了一个授权层（authorization layer）。”客户端”不能直接登录”服务提供商”，只能登录授权层，以此将用户与客户端区分开来。”客户端”登录授权层所用的令牌（token），与用户的密码不同。用户可以在登录的时候，指定授权层令牌的权限范围和有效期。</p><p>“客户端”登录授权层以后，”服务提供商”根据令牌的权限范围和有效期，向”客户端”开放用户储存的资料。</p><h1 id="运行流程"><a href="#运行流程" class="headerlink" title="运行流程"></a>运行流程</h1><p>OAuth 2.0的运行流程如下图，摘自RFC 6749。</p><p><img src="1.png" alt></p><blockquote><p>（A）用户打开客户端以后，客户端要求用户给予授权。</p><p>（B）用户同意给予客户端授权。</p><p>（C）客户端使用上一步获得的授权，向认证服务器申请令牌。</p><p>（D）认证服务器对客户端进行认证以后，确认无误，同意发放令牌。</p><p>（E）客户端使用令牌，向资源服务器申请获取资源。</p><p>（F）资源服务器确认令牌无误，同意向客户端开放资源。</p></blockquote><p>上面六个步骤之中，B是关键，即用户怎样才能给于客户端授权。有了这个授权以后，客户端就可以获取令牌，进而凭令牌获取资源。</p><p>下面讲解客户端获取授权的四种模式。</p><h1 id="客户端的授权模式"><a href="#客户端的授权模式" class="headerlink" title="客户端的授权模式"></a>客户端的授权模式</h1><p>客户端必须得到用户的授权（authorization grant），才能获得令牌（access token）。OAuth 2.0定义了四种授权方式。</p><ul><li>授权码模式（authorization code）</li><li>简化模式（implicit）</li><li>密码模式（resource owner password credentials）</li><li>客户端模式（client credentials）</li></ul><h2 id="授权码模式"><a href="#授权码模式" class="headerlink" title="授权码模式"></a>授权码模式</h2><p>授权码模式（authorization code）是功能最完整、流程最严密的授权模式。它的特点就是通过客户端的后台服务器，与”服务提供商”的认证服务器进行互动。</p><p><img src="authorizationcode.png" alt></p><p>它的步骤如下：</p><blockquote><p>（A）用户访问客户端，后者将前者导向认证服务器。</p><p>（B）用户选择是否给予客户端授权。</p><p>（C）假设用户给予授权，认证服务器将用户导向客户端事先指定的”重定向URI”（redirection URI），同时附上一个授权码。</p><p>（D）客户端收到授权码，附上早先的”重定向URI”，向认证服务器申请令牌。这一步是在客户端的后台的服务器上完成的，对用户不可见。</p><p>（E）认证服务器核对了授权码和重定向URI，确认无误后，向客户端发送访问令牌（access token）和更新令牌（refresh token）。</p></blockquote><p>下面是上面这些步骤所需要的参数。</p><p>A步骤中，客户端申请认证的URI，包含以下参数：</p><ul><li>response_type：表示授权类型，必选项，此处的值固定为”code”</li><li>client_id：表示客户端的ID，必选项</li><li>redirect_uri：表示重定向URI，可选项</li><li>scope：表示申请的权限范围，可选项</li><li>state：表示客户端的当前状态，可以指定任意值，认证服务器会原封不动地返回这个值。</li></ul><p>下面是一个例子。</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">GET /authorize?response_type=code&amp;client_id=s6BhdRkqt3&amp;state=xyz</span><br><span class="line">        &amp;redirect_uri=https%3A%2F%2Fclient%2Eexample%2Ecom%2Fcb HTTP/1.1</span><br><span class="line"><span class="attribute">Host</span>: server.example.com</span><br></pre></td></tr></table></figure><p>C步骤中，服务器回应客户端的URI，包含以下参数：</p><ul><li>code：表示授权码，必选项。该码的有效期应该很短，通常设为10分钟，客户端只能使用该码一次，否则会被授权服务器拒绝。该码与客户端ID和重定向URI，是一一对应关系。</li><li>state：如果客户端的请求中包含这个参数，认证服务器的回应也必须一模一样包含这个参数。</li></ul><p>下面是一个例子。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 <span class="number">302</span> Found</span><br><span class="line"><span class="attribute">Location</span>: https://client.example.com/cb?code=SplxlOBeZQQYbYS6WxSbIA</span><br><span class="line">          &amp;state=xyz</span><br></pre></td></tr></table></figure><p>D步骤中，客户端向认证服务器申请令牌的HTTP请求，包含以下参数：</p><ul><li>grant_type：表示使用的授权模式，必选项，此处的值固定为”authorization_code”。</li><li>code：表示上一步获得的授权码，必选项。</li><li>redirect_uri：表示重定向URI，必选项，且必须与A步骤中的该参数值保持一致。</li><li>client_id：表示客户端ID，必选项。</li></ul><p>下面是一个例子。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">POST</span> <span class="string">/token</span> HTTP/1.1</span><br><span class="line"><span class="attribute">Host</span>: server.example.com</span><br><span class="line"><span class="attribute">Authorization</span>: Basic czZCaGRSa3F0MzpnWDFmQmF0M2JW</span><br><span class="line"><span class="attribute">Content-Type</span>: application/x-www-form-urlencoded</span><br><span class="line"></span><br><span class="line">grant_type=authorization_code&amp;code=SplxlOBeZQQYbYS6WxSbIA</span><br><span class="line">&amp;redirect_uri=https%3A%2F%2Fclient%2Eexample%2Ecom%2Fcb</span><br></pre></td></tr></table></figure><p>E步骤中，认证服务器发送的HTTP回复，包含以下参数：</p><ul><li>access_token：表示访问令牌，必选项。</li><li>token_type：表示令牌类型，该值大小写不敏感，必选项，可以是bearer类型或mac类型。</li><li>expires_in：表示过期时间，单位为秒。如果省略该参数，必须其他方式设置过期时间。</li><li>refresh_token：表示更新令牌，用来获取下一次的访问令牌，可选项。</li><li>scope：表示权限范围，如果与客户端申请的范围一致，此项可省略。</li></ul><p>下面是一个例子。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 <span class="number">200</span> OK</span><br><span class="line"><span class="attribute">Content-Type</span>: application/json;charset=UTF-8</span><br><span class="line"><span class="attribute">Cache-Control</span>: no-store</span><br><span class="line"><span class="attribute">Pragma</span>: no-cache</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">"access_token":"2YotnFZFEjr1zCsicMWpAA",</span><br><span class="line">"token_type":"example",</span><br><span class="line">"expires_in":3600,</span><br><span class="line">"refresh_token":"tGzv3JOkF0XG5Qx2TlKWIA",</span><br><span class="line">"example_parameter":"example_value"</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面代码可以看到，相关参数使用JSON格式发送（Content-Type: application/json）。此外，HTTP头信息中明确指定不得缓存。</p><h2 id="简化模式"><a href="#简化模式" class="headerlink" title="简化模式"></a>简化模式</h2><p>简化模式（implicit grant type）不通过第三方应用程序的服务器，直接在浏览器中向认证服务器申请令牌，跳过了”授权码”这个步骤，因此得名。所有步骤在浏览器中完成，令牌对访问者是可见的，且客户端不需要认证。</p><p><img src="implicitgranttype.png" alt></p><p>它的步骤如下：</p><blockquote><p>（A）客户端将用户导向认证服务器。</p><p>（B）用户决定是否给于客户端授权。</p><p>（C）假设用户给予授权，认证服务器将用户导向客户端指定的”重定向URI”，并在URI的Hash部分包含了访问令牌。</p><p>（D）浏览器向资源服务器发出请求，其中不包括上一步收到的Hash值。</p><p>（E）资源服务器返回一个网页，其中包含的代码可以获取Hash值中的令牌。</p><p>（F）浏览器执行上一步获得的脚本，提取出令牌。</p><p>（G）浏览器将令牌发给客户端。</p></blockquote><p>下面是上面这些步骤所需要的参数。</p><p>A步骤中，客户端发出的HTTP请求，包含以下参数：</p><ul><li>response_type：表示授权类型，此处的值固定为”token”，必选项。</li><li>client_id：表示客户端的ID，必选项。</li><li>redirect_uri：表示重定向的URI，可选项。</li><li>scope：表示权限范围，可选项。</li><li>state：表示客户端的当前状态，可以指定任意值，认证服务器会原封不动地返回这个值。</li></ul><p>下面是一个例子。</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">GET /authorize?response_type=token&amp;client_id=s6BhdRkqt3&amp;state=xyz</span><br><span class="line">        &amp;redirect_uri=https%3A%2F%2Fclient%2Eexample%2Ecom%2Fcb HTTP/1.1</span><br><span class="line"><span class="attribute">Host</span>: server.example.com</span><br></pre></td></tr></table></figure><p>C步骤中，认证服务器回应客户端的URI，包含以下参数：</p><ul><li>access_token：表示访问令牌，必选项。</li><li>token_type：表示令牌类型，该值大小写不敏感，必选项。</li><li>expires_in：表示过期时间，单位为秒。如果省略该参数，必须其他方式设置过期时间。</li><li>scope：表示权限范围，如果与客户端申请的范围一致，此项可省略。</li><li>state：如果客户端的请求中包含这个参数，认证服务器的回应也必须一模一样包含这个参数。</li></ul><p>下面是一个例子。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 <span class="number">302</span> Found</span><br><span class="line"><span class="attribute">Location</span>: http://example.com/cb#access_token=2YotnFZFEjr1zCsicMWpAA</span><br><span class="line">               &amp;state=xyz&amp;token_type=example&amp;expires_in=3600</span><br></pre></td></tr></table></figure><p>在上面的例子中，认证服务器用HTTP头信息的Location栏，指定浏览器重定向的网址。注意，在这个网址的Hash部分包含了令牌。</p><p>根据上面的D步骤，下一步浏览器会访问Location指定的网址，但是Hash部分不会发送。接下来的E步骤，服务提供商的资源服务器发送过来的代码，会提取出Hash中的令牌。</p><h2 id="密码模式"><a href="#密码模式" class="headerlink" title="密码模式"></a>密码模式</h2><p>密码模式（Resource Owner Password Credentials Grant）中，用户向客户端提供自己的用户名和密码。客户端使用这些信息，向”服务商提供商”索要授权。</p><p>在这种模式中，用户必须把自己的密码给客户端，但是客户端不得储存密码。这通常用在用户对客户端高度信任的情况下，比如客户端是操作系统的一部分，或者由一个著名公司出品。而认证服务器只有在其他授权模式无法执行的情况下，才能考虑使用这种模式。</p><p><img src="ResourceOwnerPasswordCredentialsGrant.png" alt></p><p>它的步骤如下：</p><blockquote><p>（A）用户向客户端提供用户名和密码。</p><p>（B）客户端将用户名和密码发给认证服务器，向后者请求令牌。</p><p>（C）认证服务器确认无误后，向客户端提供访问令牌。</p></blockquote><p>B步骤中，客户端发出的HTTP请求，包含以下参数：</p><ul><li>grant_type：表示授权类型，此处的值固定为”password”，必选项。</li><li>username：表示用户名，必选项。</li><li>password：表示用户的密码，必选项。</li><li>scope：表示权限范围，可选项。</li></ul><p>下面是一个例子。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">POST</span> <span class="string">/token</span> HTTP/1.1</span><br><span class="line"><span class="attribute">Host</span>: server.example.com</span><br><span class="line"><span class="attribute">Authorization</span>: Basic czZCaGRSa3F0MzpnWDFmQmF0M2JW</span><br><span class="line"><span class="attribute">Content-Type</span>: application/x-www-form-urlencoded</span><br><span class="line"></span><br><span class="line">grant_type=password&amp;username=johndoe&amp;password=A3ddj3w</span><br></pre></td></tr></table></figure><p>C步骤中，认证服务器向客户端发送访问令牌，下面是一个例子。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 <span class="number">200</span> OK</span><br><span class="line"><span class="attribute">Content-Type</span>: application/json;charset=UTF-8</span><br><span class="line"><span class="attribute">Cache-Control</span>: no-store</span><br><span class="line"><span class="attribute">Pragma</span>: no-cache</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">   "access_token":"2YotnFZFEjr1zCsicMWpAA",</span><br><span class="line">   "token_type":"example",</span><br><span class="line">   "expires_in":3600,</span><br><span class="line">   "refresh_token":"tGzv3JOkF0XG5Qx2TlKWIA",</span><br><span class="line">   "example_parameter":"example_value"</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，各个参数的含义参见《授权码模式》一节。</p><p>整个过程中，客户端不得保存用户的密码。</p><blockquote><p>个人觉得这种模式对于用户来说，用户需要对你的系统需要有极大的信任度才会这样做，所以很少会有这种模式的授权方式。</p></blockquote><h2 id="客户端模式"><a href="#客户端模式" class="headerlink" title="客户端模式"></a>客户端模式</h2><p>客户端模式（Client Credentials Grant）指客户端以自己的名义，而不是以用户的名义，向”服务提供商”进行认证。严格地说，客户端模式并不属于OAuth框架所要解决的问题。在这种模式中，用户直接向客户端注册，客户端以自己的名义要求”服务提供商”提供服务，其实不存在授权问题。</p><p><img src="ClientCredentialsGrant.png" alt></p><p>它的步骤如下：</p><blockquote><p>（A）客户端向认证服务器进行身份认证，并要求一个访问令牌。</p><p>（B）认证服务器确认无误后，向客户端提供访问令牌。</p></blockquote><p>A步骤中，客户端发出的HTTP请求，包含以下参数：</p><ul><li>grant<em>type：表示授权类型，此处的值固定为”client</em>credentials”，必选项。</li><li>scope：表示权限范围，可选项。</li></ul><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">POST</span> <span class="string">/token</span> HTTP/1.1</span><br><span class="line"><span class="attribute">Host</span>: server.example.com</span><br><span class="line"><span class="attribute">Authorization</span>: Basic czZCaGRSa3F0MzpnWDFmQmF0M2JW</span><br><span class="line"><span class="attribute">Content-Type</span>: application/x-www-form-urlencoded</span><br><span class="line"></span><br><span class="line">grant_type=client_credentials</span><br></pre></td></tr></table></figure><p>认证服务器必须以某种方式，验证客户端身份。</p><p>B步骤中，认证服务器向客户端发送访问令牌，下面是一个例子。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 <span class="number">200</span> OK</span><br><span class="line"><span class="attribute">Content-Type</span>: application/json;charset=UTF-8</span><br><span class="line"><span class="attribute">Cache-Control</span>: no-store</span><br><span class="line"><span class="attribute">Pragma</span>: no-cache</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">   "access_token":"2YotnFZFEjr1zCsicMWpAA",</span><br><span class="line">   "token_type":"example",</span><br><span class="line">   "expires_in":3600,</span><br><span class="line">   "example_parameter":"example_value"</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，各个参数的含义参见《授权码模式》一节。</p><h1 id="更新令牌"><a href="#更新令牌" class="headerlink" title="更新令牌"></a>更新令牌</h1><p>如果用户访问的时候，客户端的”访问令牌”已经过期，则需要使用”更新令牌”申请一个新的访问令牌。</p><p>客户端发出更新令牌的HTTP请求，包含以下参数：</p><ul><li>grant<em>type：表示使用的授权模式，此处的值固定为”refresh</em>token”，必选项。</li><li>refresh_token：表示早前收到的更新令牌，必选项。</li><li>scope：表示申请的授权范围，不可以超出上一次申请的范围，如果省略该参数，则表示与上一次一致。</li></ul><p>下面是一个例子。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">POST</span> <span class="string">/token</span> HTTP/1.1</span><br><span class="line"><span class="attribute">Host</span>: server.example.com</span><br><span class="line"><span class="attribute">Authorization</span>: Basic czZCaGRSa3F0MzpnWDFmQmF0M2JW</span><br><span class="line"><span class="attribute">Content-Type</span>: application/x-www-form-urlencoded</span><br><span class="line"></span><br><span class="line">grant_type=refresh_token&amp;refresh_token=tGzv3JOkF0XG5Qx2TlKWIA</span><br></pre></td></tr></table></figure><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="http://www.ruanyifeng.com/blog/2014/05/oauth_2_0.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2014/05/oauth_2_0.html</a></p><p><a href="https://www.bilibili.com/video/av35979732?from=search&amp;seid=13491637330338351260" target="_blank" rel="noopener">https://www.bilibili.com/video/av35979732?from=search&amp;seid=13491637330338351260</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近需要接入到第三方应用登陆接触到了这个&lt;a href=&quot;http://en.wikipedia.org/wiki/OAuth&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;OAuth&lt;/a&gt;概念，它是一个关于授权（authorization）的开放网络标准，在全世界得到广泛应用（QQ，Github，微博等），目前的版本是2.0版。&lt;/p&gt;
&lt;p&gt;所以记录下OAuth 2.0的设计思路和运行流程，做一个简明通俗的解释，主要参考材料为&lt;a href=&quot;http://www.rfcreader.com/#rfc6749&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;RFC 6749&lt;/a&gt;。&lt;/p&gt;
    
    </summary>
    
      <category term="架构之路" scheme="http://hackycy.github.io/categories/%E6%9E%B6%E6%9E%84%E4%B9%8B%E8%B7%AF/"/>
    
    
      <category term="OAuth 2.0" scheme="http://hackycy.github.io/tags/OAuth-2-0/"/>
    
  </entry>
  
  <entry>
    <title>Gradle构建脚本</title>
    <link href="http://hackycy.github.io/2019/10/17/Gradle%E6%9E%84%E5%BB%BA%E8%84%9A%E6%9C%AC/"/>
    <id>http://hackycy.github.io/2019/10/17/Gradle构建脚本/</id>
    <published>2019-10-17T02:47:40.000Z</published>
    <updated>2019-10-17T03:08:50.348Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>Gradle提供了一种领域特定语言，目前同时支持 Groovy 和 Kotlin 。在 Groovy 构建脚本中（.gradle) 你可以使用任何 Groovy 元素。</p><p>在 Kotlin 构建脚本中 (.gradle.kts) 你可以使用任何 Kotlin 元素。</p><a id="more"></a><h1 id="项目（Project）和任务（Task）"><a href="#项目（Project）和任务（Task）" class="headerlink" title="项目（Project）和任务（Task）"></a>项目（Project）和任务（Task）</h1><p>Gradle 构建的一切都是基于两个概念 ：项目和任务；</p><p>一个构建是由一个或多个项目组成的。</p><p>项目的概念比较抽象，你可以创建一个 Project 用于生成一个 jar,也可以定义个项目用于生成 war 包，还可以定义一个项目用于发布上传你的 war等。</p><p>一个项目就是在你的业务范围内，被你抽象出来的一个独立的模块，你可以根据工程的实际情况抽象归类，最后这一个个的项目组成了整个 Gradle 构建。</p><p>一个项目又包含很多个任务，每个项目是由一个或多个任务组成的。</p><p>任务就是一个操作，一个原子性的操作。比如打个 jar 包，复制一份文件，编译一次 java 代码等，这就是一个任务。</p><h1 id="build-gradle-amp-Project-API"><a href="#build-gradle-amp-Project-API" class="headerlink" title="build.gradle &amp; Project API"></a>build.gradle &amp; Project API</h1><p>每个项目都有一个 build.gradle 文件，该文件是该项目的构建入口，可以在这这个文件里对该项目进行配置，比如配置版本，需要哪些插件，依赖哪些库等。</p><p>我们通过配置这个文件描述我们的构建，这其实就是一个配置脚本。</p><p>每一个脚本在执行的时候都会被关联到一个 Project 实例上。</p><p>在构建生命周期的初始化阶段，Gradle 会为每个项目创建一个 Project 实例，并根据 build.gradle的内容配置这个实例。</p><p>也就是说每个 build.gradle 的配置都会被配置到 Project 实例上。</p><p>实际上，build.gradle 中几乎所有的顶级属性和代码块都是 Project 类的 API，</p><p>下面通过访问 Project.name 属性验证一下。</p><p>在 <code>build.gradle</code></p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">println <span class="string">"name is $name"</span></span><br><span class="line">println <span class="string">"project.name is $&#123;project.name&#125;"</span></span><br></pre></td></tr></table></figure><blockquote><p>执行 build 任务，你将会得到下面的输出,输出的值都是 项目的名字</p></blockquote><p>第一条语句使用的是Project的顶级属性。</p><p>第二条语句使用的 project 属性 可以在脚本的任何地方访问，它代表的是当前脚本的Project对象。</p><p>只有在你定义了和Project的成员（方法，属性）同名的时候才需要使用 project ，其他时候直接使用 名称即可访问，例如第一条语句。</p><p><strong>一个构建是由多个Project组成的，是通过项目树的形式表示的。</strong></p><p>可以在项目树的根项目对所有的项目统一配置一些配置。例如，应用的插件，依赖的 Maven 中心库等。</p><p>为所有子项目配置仓库为 jcenter</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">subprojects&#123;</span><br><span class="line">    repositories &#123;</span><br><span class="line">        jcenter()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也可以为所有子项目配置 使用 Java 插件</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">subprojects&#123;</span><br><span class="line">    apply <span class="string">plugin:</span><span class="string">'java'</span></span><br><span class="line">    repositories &#123;</span><br><span class="line">        jcenter()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除了 subprojects 还有 allprojects ,从名字就可以看出来这不仅是对子项目的配置而是对所有项目的配置。</p><p>这两个配置其实是两个方法，接受一个闭包参数，对项目进行遍历，遍历的过程中调用我们自定义的闭包，所以我们可以在闭包里配置，打印，输出或者修改 Project 的属性。</p><h1 id="Project的属性"><a href="#Project的属性" class="headerlink" title="Project的属性"></a>Project的属性</h1><p>Project 对象的属性在 脚本全局都是可以使用的。</p><p>下面列出一些常用的属性，更全的属性可以在 Project API 中查询。</p><table><thead><tr><th>名字</th><th>类型</th><th>默认值</th></tr></thead><tbody><tr><td>project</td><td>Project</td><td>Project 实例</td></tr><tr><td>name</td><td>String</td><td>项目名字</td></tr><tr><td>path</td><td>String</td><td>项目的绝对路径</td></tr><tr><td>description</td><td>String</td><td>项目描述</td></tr><tr><td>projectDir</td><td>File</td><td>配置脚本所在的目录</td></tr><tr><td>buildDir</td><td>File</td><td>projectDir/build 输出目录</td></tr><tr><td>group</td><td>Object</td><td>未指定</td></tr><tr><td>version</td><td>Object</td><td>未指定</td></tr><tr><td>ant</td><td>AntBuilder</td><td>AntBuilder 实例</td></tr></tbody></table><h1 id="settings-gradle"><a href="#settings-gradle" class="headerlink" title="settings.gradle"></a>settings.gradle</h1><p>这个文件是由 Gradle 约定命名的，默认名为 settings.gradle ，在初始化阶段被执行。</p><p>对于多项目构建，必须在这里声明要参与构建的所有项目。对于单项目构建就是可选的了，可有可无。</p><p>Gradle 是如何寻找 settings.gradle 的？</p><p>1.在当前目录寻找2.没有找到的话就去父目录寻找3.仍然没有找到就是是单项目构建了4.如果找到了就是确定其中的项目，如果当前执行的项目在 settings.gradle 有定义就执行多项目构建，否则就执行单项目构建。</p><p>一个脚本的属性访问和方法调用是委托给 Project 类的实例的，</p><p>类似的 settings.gradle 的属性访问和方法调用是委托给 Settings 类的实例对象的。</p><h1 id="script-API"><a href="#script-API" class="headerlink" title="script API"></a>script API</h1><p>当 Gradle 执行 Groovy 脚本(.gradle)时，会编译脚本到实现了 <code>Script</code> 的类中。也就是说，Script 接口中的所有属性和方法都可以在脚本中使用。</p><p>当 Gradle 执行 Kotlin 脚本(.gradle.kts)时,会编译脚本到 <code>KotlinBuildScript</code>的子类中。</p><p>也就是说 KotlinBuildScript 类中的所有属性和方法都可以在脚本中使用。</p><p>更详细的可以参考 KotlinSettingsScript 和 KotlinInitScript 类，分别用于设置脚本和init脚本。</p><p>写的确实是脚本，但不是简单的脚本。在脚本里可以定义 Class ，内部类，导入包，定义方法、常量、接口等。</p><p>不要把它当作简单的脚本，我们可以灵活的使用 Java ，Groovy ，Kotlin 和 Gradle.</p><p>例如 定义一个获取当前日期的方法</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> buildTime()&#123;</span><br><span class="line">     <span class="keyword">def</span> date = <span class="keyword">new</span> Date()</span><br><span class="line">     <span class="keyword">def</span> formattedDate = date.format(<span class="string">'yyyyMMdd'</span>)</span><br><span class="line">     <span class="keyword">return</span> formattedDate</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h1 id="变量-amp-额外的自定义属性"><a href="#变量-amp-额外的自定义属性" class="headerlink" title="变量 &amp; 额外的自定义属性"></a>变量 &amp; 额外的自定义属性</h1><p>Gradle 支持两种变量 ：</p><ul><li>局部变量</li><li>自定义属性</li></ul><h2 id="局部变量"><a href="#局部变量" class="headerlink" title="局部变量"></a>局部变量</h2><p>局部变量使用 def 关键字声明，局部变量只能在声明的范围内可见。</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> myName = <span class="string">'local var'</span></span><br></pre></td></tr></table></figure><h1 id="额外的自定义属性"><a href="#额外的自定义属性" class="headerlink" title="额外的自定义属性"></a>额外的自定义属性</h1><p>Gradle 领域模型中 所有的对象 都可以添加额外的自定义属性。</p><p>通过对象的 ext 属性实现对自定义属性的添加，访问，设置值的操作。</p><p>添加之后可以通过 ext 属性对自定义属性读取和设置，也可以同时添加多个自定义属性。</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//为 project 添加一个 age 属性 并赋值 20</span></span><br><span class="line"> ext.age = <span class="number">20</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">//为 project 添加两个属性</span></span><br><span class="line"> ext&#123;</span><br><span class="line">     phone =<span class="number">110</span></span><br><span class="line">     address = <span class="string">'404'</span></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> task myTask &#123;</span><br><span class="line">     <span class="comment">//为 myTask 任务添加属性</span></span><br><span class="line">     ext.myProperty = <span class="string">"myValue"</span></span><br><span class="line"> &#125;</span><br><span class="line"> task extra&#123;</span><br><span class="line">      doLast&#123;</span><br><span class="line">          println <span class="string">"project : age= $&#123;project.ext.age&#125;,phone= $&#123;project.ext.phone&#125; , address = $&#123;project.ext.address&#125;"</span></span><br><span class="line">          println <span class="string">"myTask :  $&#123;myTask.myProperty&#125;"</span></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h1 id="创建一个任务"><a href="#创建一个任务" class="headerlink" title="创建一个任务"></a>创建一个任务</h1><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">task hello &#123;</span><br><span class="line">     doLast &#123;</span><br><span class="line">         println <span class="string">'Hello world!'</span></span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>这里的 task 看着像一个关键字，实际上是一个方法，这个方法的原型是 TaskContainer.create(）</p><p>任务的创建就是使用这个方法给 Project 添加一个 Task 类型的属性；</p><p>所以才能使用任务名字引用一些API，例如为任务添加额外的属性。</p><h1 id="任务依赖和任务排序"><a href="#任务依赖和任务排序" class="headerlink" title="任务依赖和任务排序"></a>任务依赖和任务排序</h1><p>一个任务可以依赖其他任务或者在其他任务执行后再执行。</p><p>Gradle 确保在执行任务时遵守所有任务依赖性和排序规则，以便在所有依赖项和任何 “必须运行” 的任务执行之后再执行任务。</p><p>Gradle 为我们提供了几个方法用来控制任务的依赖和排序，就是下面这几个</p><ul><li>Task.dependsOn(java.lang.Object[])</li><li>Task.setDependsOn(java.lang.Iterable)</li><li>Task.mustRunAfter(java.lang.Object[])</li><li>Task.setMustRunAfter(java.lang.Iterable)</li><li>Task.shouldRunAfter(java.lang.Object[])</li><li>Task.setShouldRunAfter(java.lang.Iterable)</li></ul><p>这些方法可以接收 任务，任务名字，路径等，具体参数可以在 <a href="https://docs.gradle.org/current/userguide/more_about_tasks.html" target="_blank" rel="noopener">Task文档</a> 里查看</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">task hello &#123;</span><br><span class="line">     doLast &#123;</span><br><span class="line">         println <span class="string">'Hello world!'</span></span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> task taskX &#123;</span><br><span class="line">     dependsOn hello</span><br><span class="line">     doLast&#123;</span><br><span class="line">         println <span class="string">"I'm  $name."</span></span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> task taskY &#123;</span><br><span class="line">     doFirst &#123;</span><br><span class="line">         println <span class="string">"I'm $name."</span></span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>如果 taskX 要依赖 taskY 的话，并不能直接引用，因为 taskY 是在 taskX 之后定义的。</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">task taskX &#123;</span><br><span class="line">     dependsOn <span class="string">'taskY'</span></span><br><span class="line">     doLast&#123;</span><br><span class="line">         println <span class="string">"I'm  $name."</span></span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h1 id="默认任务"><a href="#默认任务" class="headerlink" title="默认任务"></a>默认任务</h1><p>在没有指定执行任务的时候，可以在脚本中定义默认任务，使用 defaultTasks 方法</p><p>这个方法接收 字符串参数，传入任务的名称即可</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">defaultTasks <span class="string">'hello'</span>,<span class="string">'taskY'</span></span><br></pre></td></tr></table></figure><h1 id="外部依赖"><a href="#外部依赖" class="headerlink" title="外部依赖"></a>外部依赖</h1><p>用添加外部依赖，必须添加依赖所在仓库。例如 jcenter,maven，google等</p><p>添加 google 仓库</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">allprojects &#123;</span><br><span class="line">    repositories &#123;</span><br><span class="line">        mavenCentral()</span><br><span class="line">        google()</span><br><span class="line">        jcenter()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 Android 的项目中，这都是放在根项目里的 allprojects 方法里，对所有项目统一配置</p><p>添加外部依赖</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    implementation <span class="string">'io.reactivex.rxjava2:rxjava:2.1.2'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 Android 中依赖的添加放在了各个module 中，按需添加，哪个模块需要在哪个模块的构建脚本里添加。</p><p>依赖属性分为三部分</p><ul><li>group：这个属性用来标识一个组织、公司或者项目，可以用点号分隔，例如上面的 io.reactivex.rxjava2</li><li>name：name属性唯一的描述了这个依赖，例如上面的 rxjava</li><li>version：一个库可以有很多个版本。例如上面的 2.1.2</li></ul><p>其中 implementation 为配置项，配置也有很多种类型，</p><table><thead><tr><th>新配置(3.0后)</th><th>弃用配置(3.0前)</th><th>说明</th><th>作用</th></tr></thead><tbody><tr><td><code>implementation</code></td><td><code>compile</code></td><td>依赖项在编译时对模块可用，并且仅在运行时对模块的消费者可用。 对于大型多项目构建，使用<code>implementation</code>而不是<code>api/compile</code>可以显著缩短构建时间，因为它可以减少构建系统需要重新编译的项目量。 大多数应用和测试模块都应使用此配置。</td><td>使用<code>implementation</code>方式来依赖项目或库，该库在编译时，只对当前的module可见，对其他的module不可见。</td></tr><tr><td><code>api</code></td><td><code>compile</code></td><td>依赖项在编译时对模块可用，并且在编译时和运行时还对模块的消费者可用。 此配置的行为类似于<code>compile</code>（现在已弃用），一般情况下，您应当仅在库模块中使用它。 应用模块应使用<code>implementation</code>，除非您想要将其 API 公开给单独的测试模块。</td><td>使用<code>api</code>方式来依赖项目或库，该库在编译和运行时都可以对其他module可见。</td></tr><tr><td><code>compileOnly</code></td><td><code>provided</code></td><td>依赖项仅在编译时对模块可用，并且在编译或运行时对其消费者不可用。 此配置的行为类似于<code>provided</code>（现在已弃用）。</td><td>使用<code>compileOnly</code>方式来依赖项目或库，该库仅在编译时有效可用。</td></tr><tr><td><code>runtimeOnly</code></td><td><code>apk</code></td><td>依赖项仅在运行时对模块及其消费者可用。 此配置的行为类似于<code>apk</code>（现在已弃用）。</td><td>使用<code>runtimeOnly</code>方式来依赖项目或库，该库仅在运行时有效可用。</td></tr></tbody></table><blockquote><p>最后留个 DSL 的查询地址：<a href="https://docs.gradle.org/current/dsl/index.html" target="_blank" rel="noopener">https://docs.gradle.org/current/dsl/index.html</a></p></blockquote><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://www.cnblogs.com/skymxc/p/buildscript.html" target="_blank" rel="noopener">https://www.cnblogs.com/skymxc/p/buildscript.html</a></p><p><a href="https://www.jianshu.com/p/d183c3b554e5" target="_blank" rel="noopener">https://www.jianshu.com/p/d183c3b554e5</a></p><p><a href="https://docs.gradle.org/" target="_blank" rel="noopener">https://docs.gradle.org/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;Gradle提供了一种领域特定语言，目前同时支持 Groovy 和 Kotlin 。在 Groovy 构建脚本中（.gradle) 你可以使用任何 Groovy 元素。&lt;/p&gt;
&lt;p&gt;在 Kotlin 构建脚本中 (.gradle.kts) 你可以使用任何 Kotlin 元素。&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="http://hackycy.github.io/categories/Android/"/>
    
    
      <category term="Android" scheme="http://hackycy.github.io/tags/Android/"/>
    
      <category term="Gradle" scheme="http://hackycy.github.io/tags/Gradle/"/>
    
  </entry>
  
  <entry>
    <title>图解TCP/IP协议</title>
    <link href="http://hackycy.github.io/2019/10/16/%E5%9B%BE%E8%A7%A3TCP-IP%E5%8D%8F%E8%AE%AE/"/>
    <id>http://hackycy.github.io/2019/10/16/图解TCP-IP协议/</id>
    <published>2019-10-16T02:48:15.000Z</published>
    <updated>2019-10-16T03:04:15.610Z</updated>
    
    <content type="html"><![CDATA[<h1 id="TCP-IP-协议族"><a href="#TCP-IP-协议族" class="headerlink" title="TCP/IP 协议族"></a>TCP/IP 协议族</h1><p>Internet 的核心协议就是 TCP/IP，广泛应用于局域网和广域网，目前已有20+年发展史，是现用国际通行标准。TCP/IP 是个协议族，包含有多种协议，网络模型及分层如图所示</p><a id="more"></a><p><img src="1.jpg" alt></p><h1 id="TCP-IP-五层网络模型"><a href="#TCP-IP-五层网络模型" class="headerlink" title="TCP/IP 五层网络模型"></a>TCP/IP 五层网络模型</h1><p><strong>应用层：</strong>应用程序通过TCP/IP互联网络后发送、接受数据。选择所需服务类型，按照传输层要求组织数据，向下传递报文序列或字节流2种类型。</p><p><strong>传输层：</strong>提供应用层间通信服务，又称端到端通信。提供可靠的数据传输服务，确保数据准确、有序送达目的地。数据发送后需对方回送确认信息，有丢失的数据需发送方重发分组。传输的对象是传输层分组。</p><p><strong>网络层：</strong>又称<strong>IP层</strong>，负责机器间通信，接收到传输层请求后，向目的地传送信息分组。此分组会被封装进IP数据报中，由路由选择算法决定直送目的地或发给路由，然后将数据向下传递给网络接口层。接收到数据报时，检验正确性，由路由选择算法决定本地处理或转发，若目的地属于本机所在网络，就把数据报的报头剥去，选择适当的传输层协议向上传递分组。</p><p><strong>连接层：</strong>又称<strong>数据链路层</strong>，处于TCP/IP协议层之下，负责接收IP数据报并将数据报通过选定网络发送出去</p><p><strong>硬件层：</strong>处理连接网络的硬件部分。包括控制操作系统、硬件的设备驱动、NIC（Network Interface Card，网络适配器，即网卡），及光纤等 物理可见部分（还包括连接器等一切传输媒介）</p><h1 id="TCP-IP-内含协议职责"><a href="#TCP-IP-内含协议职责" class="headerlink" title="TCP/IP 内含协议职责"></a>TCP/IP 内含协议职责</h1><p><img src="2.jpg" alt></p><h1 id="TCP-IP-协议传输数据流程"><a href="#TCP-IP-协议传输数据流程" class="headerlink" title="TCP/IP 协议传输数据流程"></a>TCP/IP 协议传输数据流程</h1><p>传输控制协议（Transmission Control Protocol,TCP）是 Internet 传输层协议，提供面向连接的可靠传输服务，可靠性由重发技术保证。TCP 报文首部的大小一定是4字节的倍数，其中固定首部大小为20字节且不变</p><p><img src="3.jpg" alt></p><p>TCP 数据包示意图</p><p>ACK：确认位，当它的值为1时，确认号才是有效的<br>SYN：同步请求，TCP连接中连接双方协商初始的序号<br>RST：复位，TCP连接中数据传输发生异常需要重新发送<br>FIN ：通信结束后，当它的值为1时拆除连接</p><p><strong>TCP 三次握手建立连接</strong></p><p>第一次握手：建立连接时，客户端发送SYN包（syn=i）到服务器，并进入SYN_SEND状态，等待服务器确认。SYN表示同步序列编码（Synchronize Sequence Numbers）</p><p>第二次握手：服务器收到syn包，必须确认客户的SYN（ack=i+1），同时自己也发送一个SYN包（seq=j），即SYN+ACK包，此时服务器进入SYN_RECV状态</p><p>第三次握手：客户端收到服务器的SYN+ACK的包后，向服务器发送确认包ACK(j+1)，此包发送完毕，客户端与服务器进入ESTABLISHED状态，完成三次握手</p><p><img src="4.jpg" alt></p><p><strong>TCP 正常数据传输过程</strong></p><p>本图表示传输2个数据报的过程。主机A向B发送第一个 N 字节的数据包，SEQ为 i ，主机B收到后需要立即向主机A发送确认ACK包，ACK = i + N +1 ，这样主机A才可确认数据传输成功。第二个数据包传输时，SEQ数值 = R，主机B收到后立即回传ACK，此时ACK = R + N + 1，之后数据包传输的过程持续此流程，需要注意的是发送方只有收到目标方的确认包后才会清除缓冲区中的数据</p><p>ACK确认位 = SEQ数据编号 + 传递的字节数N + 1。第一个字节的SEQ编号由本地随机产生，SEQ+N的作用是为了让主机A确认发送给主机B的数据是否全部接收 / 是否出现丢失</p><p><img src="5.jpg" alt></p><p><strong>TCP 数据重传与快重传</strong></p><ul><li><strong>数据重传</strong>：主机A向主机B传送数据，但中间发生错误，主机B未能收到。经过一段时间后，主机A未收到主机B的ACK确认包，故主机A再次重传此数据包。主机A每次发送数据时都会启动一个定时器，规定时间没收到响应包则启动重传</li><li><strong>快重传</strong>：重传发生在超时之后，但当主机A收到3个以上重复的ACK，其实就说明有数据丢失，也需要重传，此时重传定时器还没有结束，所以叫快速重传</li></ul><p><img src="6.jpg" alt></p><p><strong>TCP 四次挥手结束连接</strong></p><p>第一次挥手：客户端发送一个FIN，用来关闭客户端到服务器的数据传送，客户端进入FIN_WAIT_1状态</p><p>第二次挥手：服务端收到FIN后，发送一个ACK给客户端，确认序号为收到序号+1（与SYN相同，一个FIN占用一个序号），服务端进入CLOSE_WAIT状态</p><p>第三次挥手：服务端发送一个FIN，用来关闭服务端到客户端的数据传送，服务端进入LAST_ACK状态</p><p>第四次挥手：客户端收到FIN后，客户端进入TIME_WAIT状态，接着发送一个ACK给服务端，确认序号为收到序号+1，服务端进入CLOSED状态，完成四次挥手</p><p><img src="7.jpg" alt></p><h1 id="IP-协议数据传输流程"><a href="#IP-协议数据传输流程" class="headerlink" title="IP 协议数据传输流程"></a>IP 协议数据传输流程</h1><p>网络协议（Internet Protocol,IP）通常被认为提供的是无连接和不可靠的，但实际上，在网络性能良好的情况下，IP传送的数据能够完好无损的到达目的地</p><p>无连接是指没有确定目标系统是否已做好接收数据的准备之前就发送数据。不可靠是指目的系统不对成功完成接收到的分组进行确认</p><p><img src="8.jpg" alt></p><p><strong>IP 发送数据</strong></p><p>发送数据时，源计算机上的IP协议需要确定目的地是否在同一网络，若目的地在同一网络，使用直达通信，若不在同一网络，则需要通过网关或路由器完成通信：</p><p>主机A组装目的IP地址为主机B的数据报，之后进行路由选择，再将次数据报发送至默认路由器（由APR地址解析确定路由器，得到下一默认路由器IP地址与MAC地址的映射关系，然后以该MAC地址为帧的目的地址形成一个帧，并将IP数据报封装在帧的数据区，最后由具体的物理网络（以太网）完成数据报的真正传输）</p><p><strong>IP 转发数据</strong></p><p>路由器接收到主机A的数据帧后，去掉帧头并对其进行处理，发现此数据报的目的地非本地，需要将其转发，由路由选择算法及本地路由表确定下一跳路由器地址，通过ARP地址解析确定下一跳路由的IP地址与MAC地址的映射关系后，将该MAC地址作为数据帧的目的地将数据报封装为数据帧，通过以太网完成数据转发。重复此步骤直到第N个路由器与目的地直连，通过ARP地址解析确定目的主机的IP地址与MAC地址的映射关系，利用该MAC地址作为帧的目的地址，将IP数据报封装成帧，并由以太网实现数据的真正传递</p><p><strong>IP 接收数据</strong></p><p>主机B接收到数据帧后，解封该帧并对其进行处理，确定本机即为目的地址后，将数据报中封装的数据交由上层协议进行处理，随即逐层处理并上交直到应用层，完成此次通信</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p><strong>TCP/IP 五大重要特性</strong></p><p><strong>逻辑编址</strong>：通过IP地址+主机ID，确保计算机可寻</p><p><strong>路由选择</strong>：通过网络路径选择协议，确保数据包到达目的地</p><p><strong>域名解析</strong>：将域名映射为IP地址，使用域名一是便于记忆，二是域名相对固定不变</p><p><strong>错误检测</strong>：确保分组交换的可靠性传递，确认数据正常接收</p><p><strong>流量控制</strong>：监测网络流量，防止网络拥塞出现</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;TCP-IP-协议族&quot;&gt;&lt;a href=&quot;#TCP-IP-协议族&quot; class=&quot;headerlink&quot; title=&quot;TCP/IP 协议族&quot;&gt;&lt;/a&gt;TCP/IP 协议族&lt;/h1&gt;&lt;p&gt;Internet 的核心协议就是 TCP/IP，广泛应用于局域网和广域网，目前已有20+年发展史，是现用国际通行标准。TCP/IP 是个协议族，包含有多种协议，网络模型及分层如图所示&lt;/p&gt;
    
    </summary>
    
      <category term="程序人生" scheme="http://hackycy.github.io/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/"/>
    
    
      <category term="TCP/IP" scheme="http://hackycy.github.io/tags/TCP-IP/"/>
    
  </entry>
  
  <entry>
    <title>软件工程之瀑布模型</title>
    <link href="http://hackycy.github.io/2019/10/03/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E4%B9%8B%E7%80%91%E5%B8%83%E6%A8%A1%E5%9E%8B/"/>
    <id>http://hackycy.github.io/2019/10/03/软件工程之瀑布模型/</id>
    <published>2019-10-03T02:44:40.000Z</published>
    <updated>2019-10-03T03:16:33.594Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>软件工程（software engineering）的本质：用工程化的方法去规范软件开发，让项目可以按时完成、成本可控、质量有保障。</p><p>而瀑布模型则算是现代工程软件的起源，软件工程的发展，很多都是构建于瀑布模型基础之上的。</p><a id="more"></a><h1 id="瀑布模型的诞生"><a href="#瀑布模型的诞生" class="headerlink" title="瀑布模型的诞生"></a>瀑布模型的诞生</h1><p>为了解决软件危机中的这些问题，在 1970 年，Winston Royce 博士借鉴了其他工程领域的思想，比如建筑工程，提出了瀑布开发模型，指出软件开发应有完整之周期，并将软件开发过程分成了若干阶段。像瀑布一样，从上往下，完成一个阶段继续下一个阶段。</p><p><img src="pubumoxing.jpeg" alt></p><p>瀑布模型把整个项目过程分成了六个主要阶段：</p><ul><li><p>一、问题的定义及规划</p><p>这个阶段是需求方和开发方共同确定软件开发目标，同时还要做可行性研究，以确定项目可行。这个阶段会产生需求文档和可行性研究报告。</p></li><li><p>二、需求分析</p><p>对需求方提出的所有需求，进行详细的分析。这个阶段需要和客户反复确认，以保证能充分理解客户需求。最终形成需求分析文档。</p></li><li><p>三、软件设计</p><p>根据需求分析的结果，对整个软件系统进行抽象和设计，如系统框架设计，数据库设计等等。最终行程架构设计文档。</p></li><li><p>四、程序编码</p><p>将架构设计和界面设计的结果转换成计算机能运行的程序代码。</p></li><li><p>五、软件测试</p><p>在编码完成后，对可运行的结果对照需求分析文档进行严密的测试。如果测试发现问题，需要进行修复。最终测试完成后，形成测试报告。</p></li><li><p>六、运行维护</p><p>在软件开发完成，正式运行上线后，需要继续维护，修复错误和增加功能，交付时要提供说明文档。</p></li></ul><blockquote><p>瀑布模型在提出后，因为其简单可行，切实有效，马上就在很多软件项目中应用起来，一直到 2000 年前后，都是最主流的软件开发模型，即使到现在，你也能在很多软件项目中看到它的影子。</p><p><strong>也是从那时开始，有了“软件生命周期”(Software Life Cycle,SLC) 的概念。</strong></p></blockquote><h1 id="瀑布模型进行开发项目"><a href="#瀑布模型进行开发项目" class="headerlink" title="瀑布模型进行开发项目"></a>瀑布模型进行开发项目</h1><p>虽然现在瀑布模型已经不是最主流的开发模式。</p><p><strong>但是不管什么软件项目，不管采用什么开发模式，有四种活动是必不可少的，那就是需求、设计、编码和测试。而这四项活动，都是起源自瀑布模型，也是瀑布模型中核心的部分。</strong></p><p>这里使用案例来直观理解一下用瀑布模型进行开发整个软件的过程。</p><p><strong>问题的定义及项目规划阶段</strong></p><p>公司老板打算做一个游戏领域的社交网站，问题很明确，就是一个社交网站，并且用户能按照游戏来交友。至于可行性分析，总多社交是已经很火的事情了，似乎是可行的。那么就立项了。</p><p>然后老板就问项目经理，这样的一个网站，大概需要多久做得出来？项目经理回答，如此复杂的网站大概需要半年出来一个版本，老板说半年太久了，给你三个月吧，最后讨价还价，决定四个月上线。</p><p>于是项目经理按照四个月开始了倒推项目计划：</p><blockquote><p>需求分析——2周</p><p>软件设计——4周</p><p>程序编码——6周</p><p>软件测试——4周</p></blockquote><p><strong>需求分析的阶段</strong></p><p>在项目立项后，产品经理首先和老板充分的沟通，了解老板的想法是什么，要做一个什么样的网站。在了解老板的想法后，产品经理对市场上同类的社交网站进行了调研，然后用原型工具设计了网站的原型。原型虽然很简陋，但是从原型可以看出来，项目要做成什么样子，便于确认需求。</p><p>原型拿给老板看后，老板再根据自己的想法提一些反馈，这样反复沟通确认，在原型设计确认清楚后，产品经理开始撰写产品设计文档，将原型设计落实到文档，将整个网站划分成不同的功能模块，例如用户注册、登录、添加好友等，确定每个功能模块需要哪些功能。</p><p>这个阶段产品经理是最忙的，那这时候其他人在干嘛呢？其他人都还挺轻松的，架构师研究网上流行的社交网站都采用什么架构，程序员、测试看看技术文档。</p><p>虽然最终确定了产品设计文档，但是因为中间反复确认的时间过长，原定 2 周能完成的需求分析，最后拖到了 3 周。项目经理一看，最终上线时间点没法延，那就只好压缩编码时间了，不行加加班！</p><p>项目计划变成了：</p><blockquote><p>需求分析——3周</p><p>软件设计——4周</p><p>程序编码——5周</p><p>软件测试——4周</p></blockquote><p><strong>软件设计</strong></p><p>产品经理的产品设计文档确定后，架构师开始做架构设计，UI 设计师开始设计 UI，测试经理开始针对产品设计文档写测试用例，产品经理还要进一步设计交互。</p><p>由于前期原型设计工作做的好，所以 UI 设计还是很顺利的，主风格定下来以后，各个界面就是细节的确认了。</p><p>因为产品设计文档写的详细，输入输出很清楚，测试用例也进展顺利。</p><p>至于架构设计这边，架构师很有经验，先把整体架构确定，写了个技术方案文档，和大家一起开会讨论，几次后确认了整体技术方案。按照功能模块一拆分，把其中一个功能模块做了一个样板，然后把各个子模块分给开发人员，大家一起协助做详细设计，然后再分别确认。</p><p>大家都如火如荼地忙起来了。如果一切顺利的话，软件设计 4 周应该能完成，可以进入编码阶段了。但是软件设计进行到第 3 周的时候，老板的想法发生了一些变化。</p><p>因为市场上已经有了游戏社交的网站，而且运营结果不算太好，而网页游戏正流行，如果我们的平台能接入网页游戏，这会是个不错的机会。</p><p>于是需求变更了，我们要能和其他网页游戏的用户系统对接，这个需求最开始是没有提出来，也没有考虑的。</p><p>项目经理考虑再三，决定还是接受这个需求变更，但是希望能多一些时间，老板没同意，认为时间点很重要，哪怕砍一点功能，牺牲一点质量也要如期上线。但就算这时候砍功能，设计工作还是少不了多少。</p><p>于是产品经理重新修改相应原型，再确认，再重新修改产品设计文档。变更完后，UI 设计的相关页面重新修改设计、测试人员修改测试用例，最苦的是架构师，当初没有考虑到要和其他用户系统对接，现在用户系统的设计都要重新考虑了。</p><p>于是为了赶进度，项目组开始加班，即使如此，软件设计阶段也推迟到了第 5 周才勉强完成。</p><p>项目计划又变了：</p><blockquote><p>需求分析——3周</p><p>软件设计——5周</p><p>程序编码——5周</p><p>软件测试——3周</p></blockquote><p><strong>程序编码</strong></p><p>于进入编码阶段了，为了保证进度，加班还在继续，哪怕前期做了大量的设计，真到编码的时候还是有好多没有考虑到的，同时各个模块之间还存在相互依赖，有时候虽然自己功能开发完成，还需要等待其他人的功能完成才能调试，所以 5 周时间很快就过去了，而程序还不能完整地跑起来。</p><p>其实中间还有个小插曲，老板觉得还要加上支付的功能，但是项目经理觉得这个阶段改需求已经不可能了，以辞职为威胁总算顶回去了，打算放在下个版本加上。</p><p>终于到第 6 周的时候，有了一个勉强可以测试的版本。</p><p>项目计划现在变成了：</p><blockquote><p>需求分析——3周</p><p>软件设计——5周</p><p>程序编码——6周</p><p>软件测试——2周</p></blockquote><p><strong>软件测试</strong></p><p>留给测试的时间只有两周了，但是前期实在 bug 太多，两周测试时间过去，软件质量还是很糟糕，完全无法正常使用，于是项目不得不延期，一直延期了 4 周后，才算具备上线条件。</p><p>所以最终的项目计划差不多是：</p><blockquote><p>需求分析——3周</p><p>软件设计——5周</p><p>程序编码——6周</p><p>软件测试——6周</p></blockquote><p>与原定计划延迟了4周。</p><p><strong>运行维护</strong></p><p>网站上线后，好在前期并没有多少用户，但是线上 Bug 还是不少，需要继续修复线上发现的 Bug。</p><h1 id="瀑布模型的优缺点"><a href="#瀑布模型的优缺点" class="headerlink" title="瀑布模型的优缺点"></a>瀑布模型的优缺点</h1><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ul><li>简单易行。</li><li>可以按照阶段检查，能及时发现问题。</li><li>前一个阶段完成后，就可以重点关注下一个阶段。</li><li>有很好的分工协作。</li><li>对质量有保障。</li></ul><h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><ul><li>难以响应需求的变更，当需求发生改变时，越到后期代价越大。</li><li>工作量分布不均衡。例如前期开发、测试人员无法参与，而后期开发、测试人员又特别忙碌。</li><li>前期进度受阻，会一直压缩后续阶段时间，导致延期或影响质量。</li><li>一直到最后阶段才能看到结果。</li></ul><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>瀑布模型的出现，也解决了软件项目开发中的几个重要问题。</p><ul><li><strong>让软件开发过程有序可控。</strong>瀑布模型的每个阶段都有明确的任务，每个阶段都有明确的交付产物，都有相应的里程碑。这些让整个过程更可控，而且能及早发现问题。</li><li><strong>让分工协作变成可能。</strong>瀑布模型的六个阶段，也让软件开发产生相应的基础分工：项目经理、产品经理、架构师、软件工程师、测试工程师、运维工程师。</li><li><strong>质量有保障。</strong>瀑布模型每个阶段都需要交付相应的文档，而文档的撰写和评审，可以帮助在动手之前把问题沟通清楚，想清楚。瀑布模型在编码结束后，会有严密的测试，只有测试验收通过后，才能上线发布。这些措施都让软件的质量更有保障。</li></ul><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>极客时间 ——《软件工程之美》</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;软件工程（software engineering）的本质：用工程化的方法去规范软件开发，让项目可以按时完成、成本可控、质量有保障。&lt;/p&gt;
&lt;p&gt;而瀑布模型则算是现代工程软件的起源，软件工程的发展，很多都是构建于瀑布模型基础之上的。&lt;/p&gt;
    
    </summary>
    
      <category term="程序人生" scheme="http://hackycy.github.io/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/"/>
    
    
      <category term="软件工程" scheme="http://hackycy.github.io/tags/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>github和git基操</title>
    <link href="http://hackycy.github.io/2019/09/25/github%E5%92%8Cgit%E5%9F%BA%E6%93%8D/"/>
    <id>http://hackycy.github.io/2019/09/25/github和git基操/</id>
    <published>2019-09-25T02:50:31.000Z</published>
    <updated>2019-09-25T03:07:35.327Z</updated>
    
    <content type="html"><![CDATA[<p>一些Git 和 GitHub基操。</p><a id="more"></a><h1 id="Github"><a href="#Github" class="headerlink" title="Github"></a>Github</h1><h2 id="快捷键-t-和-w"><a href="#快捷键-t-和-w" class="headerlink" title="快捷键: t 和 w"></a>快捷键: t 和 w</h2><p>在你的源码浏览页面，按 <strong>t</strong> 可以快速进入模糊文件名搜索模式：</p><p><img src="1.png" alt></p><p>在你仓库主页，按 <strong>w</strong> 可以快速进行分支过滤：</p><p><img src="2.png" alt></p><p>在任意 GitHub 页面中，按 <strong>?</strong> 展示当前页面可用的快捷键：</p><p><img src="3.png" alt></p><h2 id="忽略空格-w-1"><a href="#忽略空格-w-1" class="headerlink" title="忽略空格: ?w=1"></a>忽略空格: ?w=1</h2><p>在任意的 diff URL 添加 <strong>?w=1</strong> 用来整理缩进:</p><p><img src="4.jpg" alt></p><h2 id="按范围过滤提交记录-master-time-master"><a href="#按范围过滤提交记录-master-time-master" class="headerlink" title="按范围过滤提交记录: master@{time}..master"></a>按范围过滤提交记录: master@{time}..master</h2><p>你可以创建一个对比页面通过使用 URL github.com/user/repo/compare/{range}。范围 (range) 可以是两个 SHA 例如 sha1…sha2 或者两个分支名称例如 master…my-branch。范围同时也非常智能的支持使用时间作为关注点。你可以通过 master@{1.day.ago}…master 过滤从昨天开始的提交。例如：链接，<a href="https://github.com/rails/rails/compare/master@{1.day.ago}…master" target="_blank" rel="noopener">https://github.com/rails/rails/compare/master@{1.day.ago}…master</a> 显示 Rails 项目中全部昨天开始的提交记录和变化：</p><p><img src="5.jpg" alt></p><p>##按作者过滤提交记录: ?author=github_handle</p><p>你可以通过在对比页面URL中增加 ?author=github_handle 来按作者过滤提交记录。例如：链接 <a href="https://github.com/dynjs/dynjs/commits/master?author=jingweno" target="_blank" rel="noopener">https://github.com/dynjs/dynjs/commits/master?author=jingweno</a> 显示 jingweno 对 <strong>Dynjs</strong> 的提交记录：</p><p><img src="6.jpg" alt></p><h2 id="diff-和-patch"><a href="#diff-和-patch" class="headerlink" title=".diff 和 .patch"></a>.diff 和 .patch</h2><p>在比较页面、合并请求页面或者评论页面的URL后增加 .diff 或者 .patch，可以得到 diff 或者 patch 的文本格式。例如：链接 <a href="https://github.com/rails/rails/compare/master@{1.day.ago}…master.patch" target="_blank" rel="noopener">https://github.com/rails/rails/compare/master@{1.day.ago}…master.patch</a> 显示Rails项目中全部昨天开始的提交记录和变化的文本格式：</p><p><img src="7.jpg" alt></p><h2 id="链接行"><a href="#链接行" class="headerlink" title="链接行"></a>链接行</h2><p>在文件展示页面，点击某行或者通过按 SHIFT 选择多行，URL 会有相应的改变。如果你要给你的队友分享一段代码是非常方便的：</p><p><img src="8.jpg" alt></p><h2 id="自动链接"><a href="#自动链接" class="headerlink" title="自动链接"></a>自动链接</h2><p>在合并请求、问题、或者任何评论中，sha和问题码(例如：#1)会被自动链接。并且，你也可以链接其它仓库的 sha 或者问题码，格式：<code>user/repo@sha1</code> 或者 <code>user/repo#1</code>。下面是一个评论中通过sha自动链接的例子：</p><p><img src="9.jpg" alt></p><h2 id="hub"><a href="#hub" class="headerlink" title="hub"></a>hub</h2><p>Hub 是 GitHub的命令行。它提供了Git和Github之间的集成。一个最有用的命令就是在命令行输入 hub pull-request 创建pull request。详见 <strong>readme.</strong>（<a href="https://github.com/defunkt/hub#commands）。" target="_blank" rel="noopener">https://github.com/defunkt/hub#commands）。</a></p><h1 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h1><h2 id="git-log-p-FILE"><a href="#git-log-p-FILE" class="headerlink" title="git log -p FILE"></a><strong>git log -p FILE</strong></h2><p>查看 README.md 的修改历史，例如：</p><blockquote><p>> git log -p README.md</p></blockquote><h2 id="git-log-S’PATTERN’"><a href="#git-log-S’PATTERN’" class="headerlink" title="git log -S’PATTERN’"></a><strong>git log -S’PATTERN’</strong></h2><p>例如，搜索修改符合 stupid 的历史：</p><blockquote><p>> git log -S’stupid’</p></blockquote><h2 id="git-add-p"><a href="#git-add-p" class="headerlink" title="git add -p"></a><strong>git add -p</strong></h2><p>交互式的保存和取消保存变化，使用：</p><blockquote><p>> git add -p</p></blockquote><h2 id="git-rm-–cached-FILE"><a href="#git-rm-–cached-FILE" class="headerlink" title="git rm –cached FILE"></a><strong>git rm –cached FILE</strong></h2><p>这个命令只删除远程文件，例如：</p><blockquote><p>> git rm –cached database.yml</p></blockquote><p>删除 database.yml 被保存的记录，但是不影响本地文件。这对删除已经推送过的忽略文件记录而且不影响本地文件是非常的方便的。</p><h2 id="git-log-BRANCH"><a href="#git-log-BRANCH" class="headerlink" title="git log ..BRANCH"></a><strong>git log ..BRANCH</strong></h2><p>这个命令返回某个非 HEAD 分支的提交记录。假如你在一个功能分支，输入：</p><blockquote><p>> git log ..master</p></blockquote><p>返回全部 master 分支的历史记录，包括未被合并到当前分支的提交记录。</p><h2 id="git-branch-–merged-amp-git-branch-–no-merged"><a href="#git-branch-–merged-amp-git-branch-–no-merged" class="headerlink" title="git branch –merged &amp; git branch –no-merged"></a><strong>git branch –merged &amp; git branch –no-merged</strong></h2><p>Git操作常用的命令都在这里了，点击<a href="http://mp.weixin.qq.com/s?__biz=MzI3ODcxMzQzMw==&amp;mid=2247484898&amp;idx=1&amp;sn=2a4501d890d48c1e867ff306f7cfbdfe&amp;chksm=eb5380d4dc2409c2ea105b01db1129d3bc1dcc17fb05f0daca94ca018f8b6fa9dc336071c46f&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">这里</a>查看。这个命令返回已合并分支列表或未合并的分支列表。这个命令对合并前检查非常有用。例如，在一个功能分支，输入</p><blockquote><p>> git branch –no-merged</p></blockquote><p>返回未合并到该分支的分支列表。</p><h2 id="git-branch-–contains-SHA"><a href="#git-branch-–contains-SHA" class="headerlink" title="git branch –contains SHA"></a><strong>git branch –contains SHA</strong></h2><p>返回包含某个指定 sha 的分支列表。例如：</p><blockquote><p>> git branch –contains 2f8e2b</p></blockquote><p>显示全部包含提交 2f832b 的分支。这个命令对于验证 git cherry-pick 完成非常有帮助。</p><h2 id="git-status-s"><a href="#git-status-s" class="headerlink" title="git status -s"></a><strong>git status -s</strong></h2><p>返回一个简单版的 git status。我设置这个命令为默认 git status 来减少噪音。</p><h2 id="git-reflog"><a href="#git-reflog" class="headerlink" title="git reflog"></a><strong>git reflog</strong></h2><p>显示你在本地已完成的操作列表。</p><h2 id="git-shortlog-sn"><a href="#git-shortlog-sn" class="headerlink" title="git shortlog -sn"></a><strong>git shortlog -sn</strong></h2><p>显示提交记录的参与者列表。和GitHub的参与者列表相同。</p><h2 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a><strong>Summary</strong></h2><p>Git 是一个设计良好的工具。Git操作常用的命令都在这里了。了解它可以直接让你更有效率并成为一个更有才华的程序员。GitHub，在另一个方面，在 Git 基础上提供便利的团队合作特性。有能力使用 GitHub 也会提高你日常效率。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一些Git 和 GitHub基操。&lt;/p&gt;
    
    </summary>
    
      <category term="程序人生" scheme="http://hackycy.github.io/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/"/>
    
    
      <category term="Git" scheme="http://hackycy.github.io/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>IOS之安装服务器上的IPA包</title>
    <link href="http://hackycy.github.io/2019/09/11/IOS%E4%B9%8B%E5%AE%89%E8%A3%85%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8A%E7%9A%84IPA%E5%8C%85/"/>
    <id>http://hackycy.github.io/2019/09/11/IOS之安装服务器上的IPA包/</id>
    <published>2019-09-11T04:20:59.000Z</published>
    <updated>2019-09-11T09:56:23.842Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>如果想要将导出的ad-hoc包或者企业级别开发者账号才能够打包的in-house的ipa包通过自己服务器上下载安装的话，还需要一些简单的配置。</p><a id="more"></a><h1 id="部署准备"><a href="#部署准备" class="headerlink" title="部署准备"></a>部署准备</h1><p>准备文件：一个plist文件，ipa安装包，网页下载页面（可不需要），<code>57*57</code>像素icon与<code>512*512</code>像素icon。</p><p>这里利用github来进行测试打包发布应用。github仓库测试完就会删除，需要自行进行准备。</p><p>由于本人没有企业级别的开发者账号，只能通过打包ad-hoc包来进行测试。ad-hoc包如果profile签名文件中没有安装在已有的测试设备上是无法安装使用的。而企业级别的in-house包只需要信任即可。</p><blockquote><p>plist文件在IOS7之后仅支持部署在https。</p></blockquote><h2 id="plist文件"><a href="#plist文件" class="headerlink" title="plist文件"></a>plist文件</h2><p>一个plist模版：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd"&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">plist</span> <span class="attr">version</span>=<span class="string">"1.0"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dict</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">key</span>&gt;</span>items<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">array</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dict</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">key</span>&gt;</span>assets<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">array</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dict</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">key</span>&gt;</span>kind<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">string</span>&gt;</span>software-package<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">key</span>&gt;</span>url<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">string</span>&gt;</span>ipa安装包路径<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dict</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dict</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">key</span>&gt;</span>kind<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">string</span>&gt;</span>display-image<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">key</span>&gt;</span>url<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">string</span>&gt;</span>57*57像素icon路径<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dict</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dict</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">key</span>&gt;</span>kind<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">string</span>&gt;</span>full-size-image<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">key</span>&gt;</span>url<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">string</span>&gt;</span>512*512像素icon路径<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dict</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">array</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">key</span>&gt;</span>metadata<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dict</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">key</span>&gt;</span>bundle-identifier<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">string</span>&gt;</span>cn.sweetlover.jytools<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">key</span>&gt;</span>bundle-version<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">string</span>&gt;</span>1.2<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">key</span>&gt;</span>kind<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">string</span>&gt;</span>software<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">key</span>&gt;</span>title<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">string</span>&gt;</span>jytools<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dict</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dict</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">array</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dict</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plist</span>&gt;</span></span><br></pre></td></tr></table></figure><p>或者在打包的时候一并使用xcode生成</p><p><img src="plist.png" alt></p><p>next后，填写完即可。</p><p><img src="plist2.png" alt></p><p>导出后会看到一个manifest.plist文件就是所需要用到的文件。</p><blockquote><p>在生成的时候可以随便填写一些https的域名即可，但是真正发布时候还是需要修改好配置。</p></blockquote><h1 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h1><p><strong>可以先上传ipa包和icon文件上传到github，获取到下载路径之后填写到plist文件当中，然后再将plist文件上传到github。</strong></p><p>Demo完整plist文件配置</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd"&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">plist</span> <span class="attr">version</span>=<span class="string">"1.0"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dict</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">key</span>&gt;</span>items<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">array</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dict</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">key</span>&gt;</span>assets<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">array</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dict</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">key</span>&gt;</span>kind<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">string</span>&gt;</span>software-package<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">key</span>&gt;</span>url<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">string</span>&gt;</span>https://github.com/hackycy/mitaoquan/raw/master/jytools.ipa<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dict</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dict</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">key</span>&gt;</span>kind<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">string</span>&gt;</span>display-image<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">key</span>&gt;</span>url<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">string</span>&gt;</span>https://github.com/hackycy/mitaoquan/raw/master/icon-57.png<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dict</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dict</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">key</span>&gt;</span>kind<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">string</span>&gt;</span>full-size-image<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">key</span>&gt;</span>url<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">string</span>&gt;</span>https://github.com/hackycy/mitaoquan/raw/master/icon-512.png<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dict</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">array</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">key</span>&gt;</span>metadata<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dict</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">key</span>&gt;</span>bundle-identifier<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">string</span>&gt;</span>net.cn.sweetlover.mitaoquan<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">key</span>&gt;</span>bundle-version<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">string</span>&gt;</span>1.5<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">key</span>&gt;</span>kind<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">string</span>&gt;</span>software<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">key</span>&gt;</span>title<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">string</span>&gt;</span>mitao<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dict</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dict</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">array</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dict</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plist</span>&gt;</span></span><br></pre></td></tr></table></figure><p>github目录：</p><p><img src="public.png" alt></p><p>获取plist文件的路径，通过</p><p><img src="public2.png" alt></p><p>案例中获取的plist文件路径为<code>https://raw.githubusercontent.com/hackycy/mitaoquan/master/manifest.plist</code></p><p>最后通过<code>itms-services://?action=download-manifest&amp;url=</code>后面拼接上plist的url即可。</p><p><strong>demo中为<code>itms-services://?action=download-manifest&amp;url=https://raw.githubusercontent.com/hackycy/mitaoquan/master/manifest.plist</code></strong></p><blockquote><p>前端可以直接通过location.href或者a标签等跳转该链接即可安装。本地测试可以直接用safari打开上面的地址即可安装</p></blockquote><p>这里直接本地测试，复制该链接到safari直接打开安装。</p><p><img src="public3.png" alt></p><p><img src="public4.png" alt></p><h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><p>通过<code>itms-services</code>协议，在safari浏览器可以直接在ios设备上安装应用程序。<code>itms-services</code>协议需要一个plist配置文件。<code>itms-services://?action=download-manifest&amp;url=</code>是固定不变的，url根据环境变化。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;如果想要将导出的ad-hoc包或者企业级别开发者账号才能够打包的in-house的ipa包通过自己服务器上下载安装的话，还需要一些简单的配置。&lt;/p&gt;
    
    </summary>
    
      <category term="Ios" scheme="http://hackycy.github.io/categories/Ios/"/>
    
    
      <category term="Ios" scheme="http://hackycy.github.io/tags/Ios/"/>
    
  </entry>
  
  <entry>
    <title>IOS之App Store完整上架流程</title>
    <link href="http://hackycy.github.io/2019/08/20/IOS%E4%B9%8BApp-Store%E5%AE%8C%E6%95%B4%E4%B8%8A%E6%9E%B6%E6%B5%81%E7%A8%8B/"/>
    <id>http://hackycy.github.io/2019/08/20/IOS之App-Store完整上架流程/</id>
    <published>2019-08-20T08:59:20.000Z</published>
    <updated>2019-08-21T07:54:55.657Z</updated>
    
    <content type="html"><![CDATA[<p>最近在处理App Store上架的问题，和Android的打包流程比起来的确比较棘手些，因为涉及到很多的一些概念，现在也完整的梳理并记录一下。</p><a id="more"></a><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>发布上架都需要一个苹果开发者账号，免费的账号是有诸多限制的。</p><p><strong>苹果开发者帐号体系</strong></p><p><strong>Apple Developer：</strong>直接在<a href="https://link.juejin.im/?target=https%3A%2F%2Fdeveloper.apple.com%2F" target="_blank" rel="noopener">Apple Developer</a>登录，同意Apple Developer协议后的账号，免费，只可以使用Xcode进行真机调试，Xcode 7之后苹果推出的功能</p><p><strong>Apple Developer Program：</strong>分个人和组织类型，费用都是每年 99 美元，可以使用Xcode进行真机调试，打包Ad-Hoc测试，在App Store发布App</p><p><strong>Apple Developer Enterprise Program：</strong>企业账号，费用是每年 299 美元，可以使用Xcode进行真机调试，打包Ad-Hoc测试，打包In-House App，但不能在App Store发布App</p><p>不同安装方式对应的证书类型</p><ul><li>非App Store<ul><li>Development（真机调试）：iOS App Development</li><li>Ad Hoc：iOS Distribution (App Store and Ad Hoc)</li><li>Enterprise：iOS Distribution (In-House and Ad Hoc)</li></ul></li><li>App Store：iOS Distribution (App Store and Ad Hoc)</li></ul><p>在iOS的项目中，只要不是运行在模拟器上，都会涉及到开发者帐号、证书、<code>Provisioning Profile</code>这些概念。</p><p><strong>免费账号的限制：</strong></p><ul><li>创建的<code>Provisioning Profile</code>有效期只有7天</li><li>在7天内最多注册10个Bundle Id</li><li>只能同时注册3台iOS设备</li><li>在同一台iOS设备上，只能同时安装3个使用免费账号签名的App。当该设备上已经存在3个App，则无法安装任何免费账号签名的任何App，就算是那3个App其中一个也不行，只能先把其中一个删除</li></ul><blockquote><p>以下介绍是以我的Apple Developer Program个人账号来进行演示</p></blockquote><h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><p>证书、加密等原理这里不作介绍，主要讲解一些IOS所必要的概念。</p><h2 id="certSigningRequest"><a href="#certSigningRequest" class="headerlink" title=".certSigningRequest"></a>.certSigningRequest</h2><p>在<code>Mac</code>中的<code>钥匙串访问</code>里的 <code>证书助理 -&gt; 从证书颁发机构请求证书</code>：</p><p><img src="certSigningRequest.png" alt></p><p>最后会创建出一个<code>.certSigningRequest</code>文件，其实这个过程就是创建了一对公私钥</p><p><img src="certSigningRequest2.png" alt></p><ul><li>其中<code>.certSigningRequest</code>文件保存着<ul><li>申请者信息申请者的公钥</li><li>摘要算法</li><li>公钥加密算法</li></ul></li><li>私钥保存在 <code>keychain</code>中</li></ul><h2 id="AppleWWDRCA证书"><a href="#AppleWWDRCA证书" class="headerlink" title="AppleWWDRCA证书"></a>AppleWWDRCA证书</h2><p><code>iOS</code>以及 <code>mac OS</code>（在安装 Xcode 时）将自动安装 <code>AppleWWDRCA.cer</code>这个中间证书（Intermediate Certificates），它实际上就是 iOS（开发）证书的证书，即根证书（Apple Root Certificate）。</p><h2 id="iOS-App-Development证书"><a href="#iOS-App-Development证书" class="headerlink" title="iOS App Development证书"></a>iOS App Development证书</h2><p>iOS的开发证书，在开发阶段进行真机测试时需要用到的证书。可以在苹果开发网站上手动创建，需要上传<code>.certSigningRequest</code>文件；或者使用Xcode自动创建。</p><h2 id="iOS-Distribution证书"><a href="#iOS-Distribution证书" class="headerlink" title="iOS Distribution证书"></a>iOS Distribution证书</h2><p>iOS的发布证书，可以用于进行 <code>Ad Hoc</code> 测试、打包上传到 <code>App Store</code> 或者打包成 <code>Enterprisee（In-House）</code> 类型供企业内部使用。可以在苹果开发网站上手动创建，需要上传<code>.certSigningRequest</code>文件；或者使用Xcode自动创建。</p><h2 id="p12"><a href="#p12" class="headerlink" title=".p12"></a>.p12</h2><p>在<code>Mac</code>的<code>钥匙串访问</code>里选择一张证书，右击该证书，选择<code>导出&quot;xxxxx&quot;</code>，然后设置密码，可以导出该证书对应的<code>.p12</code>文件。<code>.p12</code>文件包含个人信息、公钥和私钥，也就是<code>证书 + 私钥</code>。iOS类型的每种证书同时存在数量有限制，而证书是依靠<code>mac OS</code>上的<code>.certSigningRequest</code>文件创建的，所以正常情况下，每种类型的证书只能在有限的Mac电脑上使用，如果需要在更多不同的Mac电脑上进行App开发、测试、签名，可以导出对应<code>.p12</code>文件代替证书来使用。</p><p><img src="p12.png" alt></p><h2 id="Provisioning-Profile"><a href="#Provisioning-Profile" class="headerlink" title="Provisioning Profile"></a>Provisioning Profile</h2><p><code>Provisioning Profile</code>的文件格式为<code>.mobileprovision</code>，里面包含着</p><ul><li>可以使用的证书</li><li>App ID，由 TeamID 和 BundleID 组合而成，类似于 <code>A1B2C3D4.com.domain.appName</code>形式</li><li>可安装该App的设备列表的UDID</li><li>Entitlements，授权文件，列出了App可以进行哪些行为</li><li>以上信息的签名</li></ul><p>在苹果开发网站上手动创建，或者使用Xcode自动创建。</p><h2 id="ipa"><a href="#ipa" class="headerlink" title=".ipa"></a>.ipa</h2><p><code>.ipa</code>文件是iOS上的App安装文件，其实它只是一个压缩包，等同于<code>.zip</code>格式，用<code>mac OS</code>自带的<code>归档实用工具</code>可以直接对它解压，可以看到里面的内容</p><p><img src="ipa.png" alt></p><h2 id="app"><a href="#app" class="headerlink" title=".app"></a>.app</h2><p>右击<code>.app</code>文件，选择<code>显示包内容</code>，可以看到里面的内容</p><p><img src="app.png" alt></p><p><code>.app</code>文件主要包含三部分：</p><ul><li><code>Mach-O</code>格式的二进制可执行文件，这个是一个App最重要的文件，我们编写的<code>Objective-C</code>、<code>Swift</code>代码都被编译在里面</li><li>资源文件，包括：<code>.bundle</code>文件，<code>.framework</code>文件，<code>.dylib</code>文件，<code>.nib</code>文件，图片文件，音视频文件，字体文件等所有项目用到的文件</li><li><code>CodeResources</code>，签名信息</li><li><code>embedded.mobileprovision</code>文件，或者<code>entitlements</code>文件<ul><li>对于没有上传App Store的<code>.app</code>文件，里面会包含<code>embedded.mobileprovision</code>文件，没有<code>entitlements</code>文件</li><li>App Store下载的<code>.app</code>文件，里面会包含<code>.entitlements</code>文件，没有<code>embedded.mobileprovision</code>文件</li></ul></li></ul><h1 id="Automatic-signing"><a href="#Automatic-signing" class="headerlink" title="Automatic signing"></a>Automatic signing</h1><p>在Xcode 7之前，只有加入到Apple Developer Program（即付费）才能进行真机调试，Xcode 7之后苹果推出了<code>Automatic signing</code>功能，只要在Xcode上登陆Apple ID，就会自动管理证书和Provisioning Profile，同时没有加入Apple Developer Program的账号也能进行真机调试。</p><p><img src="automanagesigning.png" alt></p><p>勾选Xcode中的<code>AutoMatically manager signing</code>，选择对应的<code>Team</code>后，无论是加入Apple Developer Program的账号（即付费账号）还是Apple Developer的账号（即免费账号）：</p><ul><li>如果Xcode没有帮该账号自动生成过<code>iOS App Development</code>类型的证书， 无论在苹果后台是否已经存在其他<code>iOS App Development</code>类型的证书，都会生成一张新的<code>iOS App Development</code>类型证书，证书名称的格式是：开发者账号名称(当前Mac电脑名称)， 如：Brian Hui (Daniels的MacBook Pro)，同时会保存在当前Mac电脑的<code>keychain</code>中</li><li>免费账号无法进入苹果的管理证书后台，但可以猜测出在苹果后台也会存在该证书</li><li>如果Xcode没有帮该App的Bundle ID自动生成过对应的<code>Provisioning Profile</code>，就会使用上面那张证书生成一个<code>Provisioning Profile</code>，保存在<code>~/Library/MobileDevice/Provisioning Profiles</code>，但在苹果后台则不会存在这个<code>Provisioning Profile</code></li><li>如果在<code>钥匙串访问</code>中删除了那张证书，Xcode会提示你的账号有<code>iOS App Development</code>类型的证书，但这台电脑没有安装，需要先把那张证书<code>Revoke</code>，<code>Revoke</code>后会再次重复前面的步骤，生成新的证书和<code>Provisioning Profile</code></li><li>如果在<code>~/Library/MobileDevice/Provisioning Profiles</code>里面，删除了该<code>Provisioning Profile</code>文件，Xcode会马上重新生成<code>Provisioning Profile</code></li></ul><p>在使用Xcode的<code>Automatic signing</code>功能的前提下，进行<code>Archive</code>，然后<code>Distribute App</code>的时候，选择非<code>Development</code>的选项，再选择AutoMatically manager signing</p><ul><li>如果本地存在<code>iOS Distribution</code>类型的证书，则会直接进行重签名</li><li>如果没有存在<code>iOS Distribution</code>类型的证书，而苹果的后台有，则会告诉你，该账号存在<code>iOS Distribution</code>类型的证书，但这台电脑没有安装，请联系创建人拿到备份（.p12文件）进行安装，当你安装了该证书（或者.p12文件），则会直接进行重签名</li><li>如果没有存在<code>iOS Distribution</code>类型的证书，而苹果的后台也没有，则Xcode会询问你是否需要生成<code>iOS Distribution</code>类型的证书，如果选择需要，则会自动生成<code>iOS Distribution</code>类型的证书，并且建议你保存在本地，证书名称的格式是：Team Name， 如：Hutchison Telephone (Macau) Company Limited，同时使用这张证书生成一个<code>Provisioning Profile</code>，保存在<code>~/Library/MobileDevice/Provisioning Profiles</code>，但在苹果后台则不会存在这个`Provisioning Profile。</li></ul><h2 id="Xcode对Provisioning-Profile的验证"><a href="#Xcode对Provisioning-Profile的验证" class="headerlink" title="Xcode对Provisioning Profile的验证"></a>Xcode对Provisioning Profile的验证</h2><p>Xcode怎么把App和证书、<code>Provisioning Profile</code>绑定在一起呢？什么时候需要一张新的证书，什么时候需要一个新的<code>Provisioning Profile</code>？</p><p>Bundle ID是App的唯一标识，App和证书、<code>Provisioning Profile</code>绑定在一起，其实就是Bundle ID和证书、<code>Provisioning Profile</code>绑定在一起，两种情况：</p><h3 id="Automatic-signing-1"><a href="#Automatic-signing-1" class="headerlink" title="Automatic signing"></a>Automatic signing</h3><p>Bundle ID与开发者账号绑定。使用<code>Automatic signing</code>时，选择开发者账号（Team）后，Xcode会根据开发者账号去本地检索是否存在该账号对应的<code>Provisioning Profile</code>，再验证是否存在与该Bundle ID匹配的<code>Provisioning Profile</code>，再根据<code>Provisioning Profile</code>去本地检索是否存在对应的证书，都验证通过，则会设置成功。如果不存在<code>Provisioning Profile</code>，则会判断该Bundle ID是否已经被其他账号注册，如果已经被其他账号注册，则整个流程失败，需要选择对应的账号。如果该Bundle ID没有被其他账号注册或者账号已经对应上，则按照文章前面所说的步骤，最后生成<code>Provisioning Profile</code>。</p><h3 id="没有使用Automatic-signing"><a href="#没有使用Automatic-signing" class="headerlink" title="没有使用Automatic signing"></a>没有使用Automatic signing</h3><p>需要手动选择<code>Provisioning Profile</code>，当选择了其中一个<code>Provisioning Profile</code>时，则会分别验证Bundle ID是否对应、<code>Provisioning Profile</code>是否过期、是否存在对应的证书、App的权限是否对应、证书的类型和<code>Code Signing Identity</code>设置是否对应，如果都通过验证，则会设置成功。</p><h1 id="App-Store上架打包流程"><a href="#App-Store上架打包流程" class="headerlink" title="App Store上架打包流程"></a>App Store上架打包流程</h1><p>xcode构建好一个bundle id为<code>cn.sweetlover.uploadstore</code>的项目，假设已为一个正常的项目APP。</p><blockquote><p>空demo的APP是无法构建成功的。</p></blockquote><p>准备好一个开发者账号，并登陆<a href="https://developer.apple.com/" target="_blank" rel="noopener">苹果开发者官网</a>，选择<code>Certificates, IDs &amp; Profiles</code>：</p><p><img src="appstore2.png" alt></p><h2 id="创建APP-ID"><a href="#创建APP-ID" class="headerlink" title="创建APP ID"></a>创建APP ID</h2><p>选择<code>Identifiers</code>，创建一个APP ID：</p><p><img src="appstore5.png" alt></p><p>这里创建一个BundleID为<code>cn.sweetlover.uploadstore</code>，BundleID格式这里不细讲了。</p><p><img src="appstore3.png" alt></p><p>下面的选择是想要让你APP所接入的能力，例如常用的推送功能</p><p><img src="appstore4.png" alt></p><p>选择继续，并注册后，会看到<code>Identifiers</code>会出现你刚刚创建的APP ID：</p><p><img src="appstore6.png" alt></p><h2 id="注册测试设备"><a href="#注册测试设备" class="headerlink" title="注册测试设备"></a>注册测试设备</h2><p>选择<code>Devices</code>，添加</p><p><img src="appstore7.png" alt></p><p>填写设备名称和UDID即可，UDID可以使用ITunes查看。</p><p><img src="appstore8.png" alt></p><h2 id="创建CSR"><a href="#创建CSR" class="headerlink" title="创建CSR"></a>创建CSR</h2><p>打开<code>Mac</code>-&gt;<code>钥匙串访问</code>-&gt;<code>证书助理</code>-&gt;<code>从证书颁发机构请求证书..</code>，填写，并选择存储到磁盘</p><p><img src="appstore10.png" alt></p><p><img src="appstore11.png" alt></p><h2 id="创建证书"><a href="#创建证书" class="headerlink" title="创建证书"></a>创建证书</h2><p>选择<code>Certificates</code>，添加</p><h3 id="创建开发证书"><a href="#创建开发证书" class="headerlink" title="创建开发证书"></a>创建开发证书</h3><p>选择<code>IOS App Development</code>，并继续</p><p><img src="appstore9.png" alt></p><p>上传CSR文件，即选择我们刚刚创建好的CSR文件。并继续</p><p><img src="appstore12.png" alt></p><p>创建好后，选择下载证书，双击安装：</p><p><img src="appstore13.png" alt></p><p>打开钥匙串访问即可看到我们刚刚安装好的证书</p><p><img src="appstore14.png" alt></p><p>发布证书就创建完毕了。</p><h3 id="创建发布证书"><a href="#创建发布证书" class="headerlink" title="创建发布证书"></a>创建发布证书</h3><p>重复上述创建开发证书的步骤，只不过选项发生变化：</p><p><img src="appstore15.png" alt></p><p>最后下载安装，看到钥匙串访问出现证书即可</p><p><img src="appstore16.png" alt></p><h2 id="创建Profiles"><a href="#创建Profiles" class="headerlink" title="创建Profiles"></a>创建Profiles</h2><p>选择<code>Profiles</code></p><h3 id="创建开发Provisioning-Profile"><a href="#创建开发Provisioning-Profile" class="headerlink" title="创建开发Provisioning Profile"></a>创建开发Provisioning Profile</h3><p>选择<code>IOS App Development</code>，并继续</p><p><img src="appstore17.png" alt></p><p>选择好我们之前创建的APP ID，如<code>cn.sweetlover.uploadstore</code>，并继续</p><p><img src="appstore18.png" alt></p><p>选择开发证书，并继续</p><p><img src="appstore19.png" alt></p><p>选择测试设备，并继续</p><p><img src="appstore20.png" alt></p><p>填写Provisioning Profile Name，并选择生成</p><p><img src="appstore21.png" alt></p><p>下载并双击安装：</p><p><img src="appstore22.png" alt></p><p><img src="appstore24.png" alt></p><p>xcode签名方式选择手动以便查看：</p><p><img src="appstore23.png" alt></p><h3 id="创建发布Provisioning-Profile"><a href="#创建发布Provisioning-Profile" class="headerlink" title="创建发布Provisioning Profile"></a>创建发布Provisioning Profile</h3><p>重复上述创建开发证书的步骤，只不过选项发生变化：</p><p><img src="appstore25.png" alt></p><p>xcode：</p><p><img src="appstore26.png" alt></p><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><p>如果不安装证书，选择profile，xcode会报错缺少证书文件：</p><p><img src="appstore27.png" alt></p><h2 id="App-Store-Connect发布"><a href="#App-Store-Connect发布" class="headerlink" title="App Store Connect发布"></a>App Store Connect发布</h2><h3 id="APP创建"><a href="#APP创建" class="headerlink" title="APP创建"></a>APP创建</h3><p>点击<code>Account</code>登陆后点击<code>App Store Connect</code>，选择<code>我的App</code></p><p><img src="appstore1.png" alt></p><p>新建APP，填写好资料，并创建，创建后进入APP，编辑APP应用信息和定价情况</p><p><img src="appstore28.png" alt></p><p><img src="appstore30.png" alt></p><h3 id="版本提交"><a href="#版本提交" class="headerlink" title="版本提交"></a>版本提交</h3><p>首次提交会出现以下界面，填写好里面所需要的资料，里面都可按照提示进行编写。</p><p><img src="appstore32.png" alt></p><p>如果已经发布了，需要继续发版本，则点击</p><p><img src="appstore33.png" alt></p><p>由于首次提交还未上架过，所以按钮是置灰的状态，无法点击。</p><h2 id="Xcode-Archive构建版本"><a href="#Xcode-Archive构建版本" class="headerlink" title="Xcode Archive构建版本"></a>Xcode Archive构建版本</h2><p>进入<code>Xcode</code>选择<code>Product</code>-&gt;<code>Archive</code>，注意不要选中到模拟器，要选中<code>Generic IOS Device</code>。因为上架的包不是针对某种设备来进行Archive的。</p><p><img src="appstore34.png" alt></p><p>出现以下界面，选择Distrubite App，如果Archive过多次版本也会出现以往的版本。</p><p><img src="appstore35.png" alt></p><p>选择IOS App Store</p><p><img src="appstore36.png" alt></p><p>这里直接选择上传，也可以选择导出成IPA，使用Application Loader进行发布。</p><p><img src="appstore37.png" alt></p><p>next~</p><p><img src="appstore38.png" alt></p><p>选择好发布的证书和profile文件</p><p><img src="appstore39.png" alt></p><p>选择上传即可。</p><p><img src="appstore40.png" alt></p><p>经过一段漫长的时间等待后，回到App Store Connect的页面中，可能需要一段时间等到，建置版本后出现按钮即可选择构建好的版本。</p><p><img src="appstore41.png" alt></p><p>填写好所需要的资料就可以提交审核了。</p><h1 id="关于Application-Loader"><a href="#关于Application-Loader" class="headerlink" title="关于Application Loader"></a>关于Application Loader</h1><p>打开<code>Xcode</code> -&gt; <code>Open Developer Tool</code> -&gt; <code>Application Loader</code>，登陆你的APP ID。</p><p><img src="applicationloader.png" alt></p><p>密码登陆非APPLE ID的密码，需要登录appleid.apple.com上，输入AppleID密码后会产生一个密码，去<code>Application Loader</code>中输入产生的密码即可。</p><p><img src="applicationloader2.png" alt></p><h1 id="关于TestFlight"><a href="#关于TestFlight" class="headerlink" title="关于TestFlight"></a>关于TestFlight</h1><p>等上传构建版本处理完成后，一般会显示缺少出口合规证明。点击黄色提示那，在弹出的页面选择否，点击开始内部测试。</p><p><img src="testflight.png" alt></p><p>选择App Store connect用户选项，点击测试员旁边+号，选择测试的苹果账号！</p><p><img src="testflight2.png" alt></p><p>然后手机端下载TestFlight后，兑换邀请码即可。</p><h1 id="App审核指南"><a href="#App审核指南" class="headerlink" title="App审核指南"></a>App审核指南</h1><p>App Store Review Guidelines：<a href="https://developer.apple.com/app-store/review/guidelines/" target="_blank" rel="noopener">https://developer.apple.com/app-store/review/guidelines/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近在处理App Store上架的问题，和Android的打包流程比起来的确比较棘手些，因为涉及到很多的一些概念，现在也完整的梳理并记录一下。&lt;/p&gt;
    
    </summary>
    
      <category term="Ios" scheme="http://hackycy.github.io/categories/Ios/"/>
    
    
      <category term="Ios" scheme="http://hackycy.github.io/tags/Ios/"/>
    
  </entry>
  
  <entry>
    <title>QPS、TPS、PV、UV、GMV、IP、RPS概念解释</title>
    <link href="http://hackycy.github.io/2019/08/20/QPS%E3%80%81TPS%E3%80%81PV%E3%80%81UV%E3%80%81GMV%E3%80%81IP%E3%80%81RPS%E6%A6%82%E5%BF%B5%E8%A7%A3%E9%87%8A/"/>
    <id>http://hackycy.github.io/2019/08/20/QPS、TPS、PV、UV、GMV、IP、RPS概念解释/</id>
    <published>2019-08-20T02:36:54.000Z</published>
    <updated>2019-08-20T02:42:10.205Z</updated>
    
    <content type="html"><![CDATA[<p>之前看到一些QPS、TPS、PV等的一些名词，也还没清楚它们的意思，查了一下资料并记录一下。</p><a id="more"></a><h1 id="QPS"><a href="#QPS" class="headerlink" title="QPS"></a><strong>QPS</strong></h1><p>Queries Per Second，每秒查询数。每秒能够响应的查询次数。</p><p>QPS是对一个特定的查询服务器在规定时间内所处理流量多少的衡量标准，在因特网上，作为域名系统服务器的机器的性能经常用每秒查询率来衡量。每秒的响应请求数，也即是最大吞吐能力。</p><h1 id="TPS"><a href="#TPS" class="headerlink" title="TPS"></a><strong>TPS</strong></h1><p>Transactions Per Second 的缩写，每秒处理的事务数目。一个事务是指一个客户机向服务器发送请求然后服务器做出反应的过程。客户机在发送请求时开始计时，收到服务器响应后结束计时，以此来计算使用的时间和完成的事务个数，最终利用这些信息作出的评估分。</p><p>TPS 的过程包括：客户端请求服务端、服务端内部处理、服务端返回客户端。</p><p>例如，访问一个 Index 页面会请求服务器 3 次，包括一次 html，一次 css，一次 js，那么访问这一个页面就会产生一个“T”，产生三个“Q”。</p><h1 id="PV"><a href="#PV" class="headerlink" title="PV"></a><strong>PV</strong></h1><p>（page view）即页面浏览量，通常是衡量一个网络新闻频道或网站甚至一条网络新闻的主要指标。户每一次对网站中的每个页面访问均被记录 1 次。用户对同一页面的多次刷新，访问量累计。</p><p>根据这个特性，刷网站的 PV 就很好刷了。</p><p>与 PV 相关的还有 <strong>RV</strong>，即重复访问者数量（repeat visitors）。</p><h1 id="UV"><a href="#UV" class="headerlink" title="UV"></a><strong>UV</strong></h1><p>访问数（Unique Visitor）指独立访客访问数，统计1天内访问某站点的用户数(以 cookie 为依据)，一台电脑终端为一个访客。</p><h1 id="IP"><a href="#IP" class="headerlink" title="IP"></a><strong>IP</strong></h1><p>（Internet Protocol）独立 IP 数，是指 1 天内多少个独立的 IP 浏览了页面，即统计不同的 IP 浏览用户数量。同一 IP 不管访问了几个页面，独立 IP 数均为 1；不同的 IP 浏览页面，计数会加 1。IP 是基于用户广域网 IP 地址来区分不同的访问者的，所以，多个用户（多个局域网 IP）在同一个路由器（同一个广域网 IP）内上网，可能被记录为一个独立 IP 访问者。如果用户不断更换 IP，则有可能被多次统计。</p><h1 id="GMV"><a href="#GMV" class="headerlink" title="GMV"></a><strong>GMV</strong></h1><p>是 Gross Merchandise Volume 的简称。只要是订单，不管消费者是否付款、卖家是否发货、是否退货，都可放进 GMV 。</p><h1 id="RPS"><a href="#RPS" class="headerlink" title="RPS"></a><strong>RPS</strong></h1><p>代表吞吐率，即 Requests Per Second 的缩写。吞吐率是服务器并发处理能力的量化描述，单位是 reqs/s，指的是某个并发用户数下单位时间内处理的请求数。<br>某个并发用户数下单位时间内能处理的最大的请求数，称之为最大吞吐率。</p><blockquote><p>有人把 RPS 说等效于 QPS。其实可以看作同一个统计方式，只是叫法不同而已。RPS/QPS，可以使用 apche ab 工具进行测量。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;之前看到一些QPS、TPS、PV等的一些名词，也还没清楚它们的意思，查了一下资料并记录一下。&lt;/p&gt;
    
    </summary>
    
      <category term="程序人生" scheme="http://hackycy.github.io/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/"/>
    
    
      <category term="QPS、TPS、PV、UV、GMV、IP、RPS" scheme="http://hackycy.github.io/tags/QPS%E3%80%81TPS%E3%80%81PV%E3%80%81UV%E3%80%81GMV%E3%80%81IP%E3%80%81RPS/"/>
    
  </entry>
  
  <entry>
    <title>Android SharedPreferences使用</title>
    <link href="http://hackycy.github.io/2019/08/13/Android-SharedPreferences%E4%BD%BF%E7%94%A8/"/>
    <id>http://hackycy.github.io/2019/08/13/Android-SharedPreferences使用/</id>
    <published>2019-08-13T05:57:52.000Z</published>
    <updated>2019-08-13T08:46:52.767Z</updated>
    
    <content type="html"><![CDATA[<p>Sharedpreferences是Android平台上一个轻量级的存储类，用来保存应用程序的各种配置信息，其本质是一个以“键-值”对的方式保存数据的xml文件，其文件保存在<code>/data/data/${pkg}/shared_prefs</code>目录下。在全局变量上看，其优点是不会产生Application 、 静态变量的OOM（out of memory）和空指针问题，其缺点是效率没有上面的两种方法高。<strong>SharedPreferences实现是线程安全的，但不是进程安全的。</strong></p><a id="more"></a><h1 id="获取SharedPreferences"><a href="#获取SharedPreferences" class="headerlink" title="获取SharedPreferences"></a>获取SharedPreferences</h1><p>使用 SharedPreferences 来存储数据，首先需要获取到 SharedPreferences 对象。Android中主要提供了两种方法用于得到 SharedPreferences 对象。</p><h2 id="Context-类中的-getSharedPreferences-方法："><a href="#Context-类中的-getSharedPreferences-方法：" class="headerlink" title="Context 类中的 getSharedPreferences()方法："></a>Context 类中的 getSharedPreferences()方法：</h2><p>此方法接收两个参数，第一个参数用于指定 SharedPreferences 文件的名称，如果指定的文件不存在则会创建一个，第二个参数用于指定操作模式，主要有以下几种模式可以选择。<code>MODE_PRIVATE</code> 是默认的操作模式，和直接传入 0 效果是相同的。<br><code>MODE_WORLD_READABLE</code> 和 <code>MODE_WORLD_WRITEABLE</code> 这两种模式已在 Android 4.2 版本中被废弃。</p><ul><li><strong>Context.MODE_PRIVATE：</strong>为默认操作模式,代表该文件是私有数据,只能被应用本身访问,在该模式下,写入的内容会覆盖原文件的内容；</li><li><strong>Context.MODE_APPEND：</strong>模式会检查文件是否存在,存在就往文件追加内容,否则就创建新文件；</li><li><strong>Context.MODE_WORLD_READABLE：</strong>表示当前文件可以被其他应用读取；</li><li><strong>Context.MODE_WORLD_WRITEABLE：</strong>表示当前文件可以被其他应用写入；</li></ul><h2 id="PreferenceManager-类中的-getDefaultSharedPreferences-方法："><a href="#PreferenceManager-类中的-getDefaultSharedPreferences-方法：" class="headerlink" title="PreferenceManager 类中的 getDefaultSharedPreferences()方法："></a>PreferenceManager 类中的 getDefaultSharedPreferences()方法：</h2><p>这是一个静态方法，它接收一个 Context 参数，并自动使用当前应用程序的包名作为前缀来命名 SharedPreferences 文件。<del>[已废弃]</del></p><h1 id="SharedPreferences的使用"><a href="#SharedPreferences的使用" class="headerlink" title="SharedPreferences的使用"></a>SharedPreferences的使用</h1><p>SharedPreferences对象本身只能获取数据而不支持存储和修改,存储修改是通过SharedPreferences.edit()获取的内部接口Editor对象实现。</p><h2 id="存储数据"><a href="#存储数据" class="headerlink" title="存储数据"></a>存储数据</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SharedPreferences sp = getSharedPreferences(<span class="string">"user"</span>, Context.MODE_PRIVATE);</span><br><span class="line">SharedPreferences.Editor editor = sp.edit();</span><br><span class="line">editor.putBoolean(<span class="string">"isBoy"</span>, <span class="keyword">true</span>);</span><br><span class="line">editor.putString(<span class="string">"username"</span>, <span class="string">"xiaohong"</span>);</span><br><span class="line">editor.putInt(<span class="string">"wage"</span>, <span class="number">6000</span>);</span><br><span class="line">editor.commit();</span><br></pre></td></tr></table></figure><h2 id="读取数据"><a href="#读取数据" class="headerlink" title="读取数据"></a>读取数据</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SharedPreferences sp = getSharedPreferences(<span class="string">"user"</span>, Context.MODE_PRIVATE);</span><br><span class="line">String username = sp.getString(<span class="string">"username"</span>, <span class="string">""</span>);</span><br><span class="line"><span class="keyword">boolean</span> isBoy = sp.getBoolean(<span class="string">"isBoy"</span>, <span class="keyword">false</span>);</span><br><span class="line"><span class="keyword">int</span> wage = sp.getInt(<span class="string">"wage"</span>, <span class="number">0</span>);</span><br></pre></td></tr></table></figure><h2 id="删除指定数据"><a href="#删除指定数据" class="headerlink" title="删除指定数据"></a>删除指定数据</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SharedPreferences sp = getSharedPreferences(<span class="string">"user"</span>, Context.MODE_PRIVATE);</span><br><span class="line">SharedPreferences.Editor editor = sp.edit();</span><br><span class="line">editor.remove(<span class="string">"wage"</span>);</span><br><span class="line">editor.commit();</span><br></pre></td></tr></table></figure><h2 id="清空数据"><a href="#清空数据" class="headerlink" title="清空数据"></a>清空数据</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SharedPreferences sp = getSharedPreferences(<span class="string">"user"</span>, Context.MODE_PRIVATE);</span><br><span class="line">SharedPreferences.Editor editor = sp.edit();</span><br><span class="line">editor.clear();</span><br><span class="line">editor.commit();</span><br></pre></td></tr></table></figure><p><strong>注意</strong>：如果在 Fragment 中使用SharedPreferences 时，需要放在onAttach(Activity activity)里面进行SharedPreferences的初始化，否则会报空指针 即 getActivity()会可能返回null ！</p><h2 id="读写其他应用的SharedPreferences"><a href="#读写其他应用的SharedPreferences" class="headerlink" title="读写其他应用的SharedPreferences"></a>读写其他应用的SharedPreferences</h2><p> 1. 在创建SharedPreferences时，指定MODE_WORLD_READABLE模式，表明该SharedPreferences数据可以被其他程序读取；<br> 2. 创建其他应用程序对应的Context；<br> 3. 使用其他程序的Context获取对应的SharedPreferences；<br> 4. 如果是写入数据，使用Editor接口即可，所有其他操作均和前面一致；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">//这里的com.example.mpreferences 就是应用的包名</span></span><br><span class="line">  Context mcontext = createPackageContext(<span class="string">"com.example.mpreferences"</span>, CONTEXT_IGNORE_SECURITY);</span><br><span class="line">  SharedPreferences msharedpreferences = mcontext.getSharedPreferences(<span class="string">"name_preference"</span>, MODE_PRIVATE);</span><br><span class="line">  <span class="keyword">int</span> count = msharedpreferences.getInt(<span class="string">"count"</span>, <span class="number">0</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (PackageManager.NameNotFoundException e) &#123;</span><br><span class="line">  e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="SharedPreferences-Editor对象中commit和apply的区别"><a href="#SharedPreferences-Editor对象中commit和apply的区别" class="headerlink" title="SharedPreferences.Editor对象中commit和apply的区别"></a>SharedPreferences.Editor对象中commit和apply的区别</h1><ul><li>apply没有返回值而commit返回boolean表明修改是否提交成功 ；</li><li>commit是把内容同步提交到硬盘的，而apply先立即把修改提交到内存，然后开启一个异步的线程提交到硬盘，并且如果提交失败，你不会收到任何通知。</li><li>所有commit提交是同步过程，效率会比apply异步提交的速度慢，在不关心提交结果是否成功的情况下，优先考虑apply方法。</li><li>apply是使用异步线程写入磁盘，commit是同步写入磁盘。所以我们在主线程使用的commit的时候，需要考虑是否会出现ANR问题。（不适合大量数据存储）</li></ul><h1 id="查看Sharedpreferencesd-保存数据的xml文件"><a href="#查看Sharedpreferencesd-保存数据的xml文件" class="headerlink" title="查看Sharedpreferencesd 保存数据的xml文件"></a>查看Sharedpreferencesd 保存数据的xml文件</h1><p>模拟器下直接打开打开AS，找到窗口右下角的<code>Device File Explorer</code>进行查看：</p><p><img src="file.png" alt></p><blockquote><p>真机环境下需要root。</p></blockquote><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://juejin.im/post/5adc444df265da0b886d00bc" target="_blank" rel="noopener">https://juejin.im/post/5adc444df265da0b886d00bc</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Sharedpreferences是Android平台上一个轻量级的存储类，用来保存应用程序的各种配置信息，其本质是一个以“键-值”对的方式保存数据的xml文件，其文件保存在&lt;code&gt;/data/data/${pkg}/shared_prefs&lt;/code&gt;目录下。在全局变量上看，其优点是不会产生Application 、 静态变量的OOM（out of memory）和空指针问题，其缺点是效率没有上面的两种方法高。&lt;strong&gt;SharedPreferences实现是线程安全的，但不是进程安全的。&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="http://hackycy.github.io/categories/Android/"/>
    
    
      <category term="Android" scheme="http://hackycy.github.io/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>IOS之NSUserDefaults</title>
    <link href="http://hackycy.github.io/2019/08/12/IOS%E4%B9%8BNSUserDefaults/"/>
    <id>http://hackycy.github.io/2019/08/12/IOS之NSUserDefaults/</id>
    <published>2019-08-12T07:27:44.000Z</published>
    <updated>2019-08-13T04:38:11.928Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h1><p><code>NSUserDefaults</code>类提供了一个与默认系统交互的编程接口。默认系统允许应用程序自定义其行为以匹配用户的首选项。例如，您可以允许用户指定其首选的测量单位或媒体播放速度。应用程序通过为用户默认数据库中的一组参数指定值来存储这些首选项。这些参数被称为默认值，因为它们通常用于确定应用程序启动时的默认状态或默认情况下的行为方式。在运行时，使用<code>NSUserDefaults</code>对象从用户的默认数据库中读取应用程序使用的默认值。nsUserDefaults缓存信息，以避免每次需要默认值时都必须打开用户的默认数据库。当您设置默认值时，它会在您的进程内同步更改，并异步更改为持久存储和其他进程。</p><a id="more"></a><p><img src="overview.png" alt></p><p>如果是一些大型数据，毫无疑问是用一些SQLite或者FMDB等来存储大量数据。但是又一些轻量级别的数据，例如用户的信息、用户的偏好设置，使用该类是最为简单方便的。它通过键值对的方式来来存储一系列的偏好设置来把对象存储/读取相应的<code>plist</code>文件中。那么既然是一个<code>plist</code>，则NSUserDefaults能够存储的数据类型有<a href="https://developer.apple.com/documentation/foundation/nsdata?language=objc" target="_blank" rel="noopener"><code>NSData</code></a>, <a href="https://developer.apple.com/documentation/foundation/nsstring?language=objc" target="_blank" rel="noopener"><code>NSString</code></a>, <a href="https://developer.apple.com/documentation/foundation/nsnumber?language=objc" target="_blank" rel="noopener"><code>NSNumber</code></a>, <a href="https://developer.apple.com/documentation/foundation/nsdate?language=objc" target="_blank" rel="noopener"><code>NSDate</code></a>, <a href="https://developer.apple.com/documentation/foundation/nsarray?language=objc" target="_blank" rel="noopener"><code>NSArray</code></a>, 和<a href="https://developer.apple.com/documentation/foundation/nsdictionary?language=objc" target="_blank" rel="noopener"><code>NSDictionary</code></a>。如果需要存储某些不支持的类型，可以先将其归档为NSData类型再进行存储。</p><p><strong>NSUserDefaults</strong>是一个单例类，在整个程序运行过程中只有一个实例对象，同时也是线程安全的。获取方式：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSUserDefaults</span> *defaults = [<span class="built_in">NSUserDefaults</span> standardUserDefaults];</span><br></pre></td></tr></table></figure><h1 id="存储数据"><a href="#存储数据" class="headerlink" title="存储数据"></a>存储数据</h1><p>存储一些默认支持的数据类型：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//存储数据</span></span><br><span class="line">[defaults setObject:<span class="string">@"hackycy"</span> forKey:<span class="string">@"username"</span>];</span><br><span class="line">[defaults setInteger:<span class="number">22</span> forKey:<span class="string">@"age"</span>];</span><br><span class="line">[defaults setBool:<span class="literal">YES</span> forKey:<span class="string">@"isBoy"</span>];</span><br><span class="line">[defaults setFloat:<span class="number">1.73</span> forKey:<span class="string">@"mmForHeight"</span>];</span><br><span class="line">[defaults setURL:[<span class="built_in">NSURL</span> URLWithString:<span class="string">@"https://hackycy.github.io"</span>] forKey:<span class="string">@"blog"</span>];</span><br><span class="line">[defaults setDouble:<span class="number">7500</span> forKey:<span class="string">@"wage"</span>];</span><br></pre></td></tr></table></figure><p><strong>更多方法</strong></p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Setting Default Values</span></span><br><span class="line">- setObject:forKey:</span><br><span class="line"><span class="comment">//Sets the value of the specified default key.</span></span><br><span class="line"></span><br><span class="line">- setFloat:forKey:</span><br><span class="line"><span class="comment">//Sets the value of the specified default key to the specified float value.</span></span><br><span class="line"></span><br><span class="line">- setDouble:forKey:</span><br><span class="line"><span class="comment">//Sets the value of the specified default key to the double value.</span></span><br><span class="line"></span><br><span class="line">- setInteger:forKey:</span><br><span class="line"><span class="comment">//Sets the value of the specified default key to the specified integer value.</span></span><br><span class="line"></span><br><span class="line">- setBool:forKey:</span><br><span class="line"><span class="comment">//Sets the value of the specified default key to the specified Boolean value.</span></span><br><span class="line"></span><br><span class="line">- setURL:forKey:</span><br><span class="line"><span class="comment">//Sets the value of the specified default key to the specified URL.</span></span><br></pre></td></tr></table></figure><h1 id="读取数据"><a href="#读取数据" class="headerlink" title="读取数据"></a>读取数据</h1><p>从上面存储的数据中读取并打印：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取数据   </span></span><br><span class="line"><span class="built_in">NSString</span> *username = [defaults stringForKey:<span class="string">@"username"</span>];</span><br><span class="line"><span class="built_in">NSInteger</span> age = [defaults integerForKey:<span class="string">@"age"</span>];</span><br><span class="line"><span class="built_in">BOOL</span> isBoy = [defaults boolForKey:<span class="string">@"isBoy"</span>];</span><br><span class="line"><span class="keyword">float</span> mmForHeight = [defaults floatForKey:<span class="string">@"mmForHeight"</span>];</span><br><span class="line"><span class="built_in">NSURL</span> *blog = [defaults URLForKey:<span class="string">@"blog"</span>];</span><br><span class="line"><span class="keyword">double</span> wage = [defaults doubleForKey:<span class="string">@"wage"</span>];</span><br><span class="line"><span class="built_in">NSData</span> *imageData = [defaults objectForKey:<span class="string">@"avatar"</span>];</span><br><span class="line"><span class="keyword">self</span>.imageView.image = [<span class="built_in">UIImage</span> imageWithData:imageData];</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"username : %@, age : %lu, isBoy : %@, mmForHeight : %f, blog : %@, wage : %f"</span>, username, (<span class="keyword">unsigned</span> <span class="keyword">long</span>)age, isBoy ? <span class="string">@"boy"</span> : <span class="string">@"girl"</span>, mmForHeight, blog, wage);</span><br></pre></td></tr></table></figure><p><strong>更多方法</strong></p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Getting Default Values</span></span><br><span class="line">- objectForKey:</span><br><span class="line"><span class="comment">//Returns the object associated with the specified key.</span></span><br><span class="line"></span><br><span class="line">- URLForKey:</span><br><span class="line"><span class="comment">//Returns the URL associated with the specified key.</span></span><br><span class="line"></span><br><span class="line">- arrayForKey:</span><br><span class="line"><span class="comment">//Returns the array associated with the specified key.</span></span><br><span class="line"></span><br><span class="line">- dictionaryForKey:</span><br><span class="line"><span class="comment">//Returns the dictionary object associated with the specified key.</span></span><br><span class="line"></span><br><span class="line">- stringForKey:</span><br><span class="line"><span class="comment">//Returns the string associated with the specified key.</span></span><br><span class="line"></span><br><span class="line">- stringArrayForKey:</span><br><span class="line"><span class="comment">//Returns the array of strings associated with the specified key.</span></span><br><span class="line"></span><br><span class="line">- dataForKey:</span><br><span class="line"><span class="comment">//Returns the data object associated with the specified key.</span></span><br><span class="line"></span><br><span class="line">- boolForKey:</span><br><span class="line"><span class="comment">//Returns the Boolean value associated with the specified key.</span></span><br><span class="line"></span><br><span class="line">- integerForKey:</span><br><span class="line"><span class="comment">//Returns the integer value associated with the specified key.</span></span><br><span class="line"></span><br><span class="line">- floatForKey:</span><br><span class="line"><span class="comment">//Returns the float value associated with the specified key.</span></span><br><span class="line"></span><br><span class="line">- doubleForKey:</span><br><span class="line"><span class="comment">//Returns the double value associated with the specified key.</span></span><br><span class="line"></span><br><span class="line">- dictionaryRepresentation</span><br><span class="line"><span class="comment">//Returns a dictionary that contains a union of all key-value pairs in the domains in the search list.</span></span><br></pre></td></tr></table></figure><h1 id="registerDefaults"><a href="#registerDefaults" class="headerlink" title="registerDefaults"></a>registerDefaults</h1><p>先让我们来看一种情况：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">BOOL</span> isNeedShowGuide = [defaults boolForKey:<span class="string">@"isNeedShowGuide"</span>];</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, isNeedShowGuide ? <span class="string">@"YES"</span> : <span class="string">@"NO"</span>);</span><br></pre></td></tr></table></figure><p>LOG：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2019</span><span class="number">-08</span><span class="number">-13</span> <span class="number">11</span>:<span class="number">54</span>:<span class="number">29.402946</span>+<span class="number">0800</span> nsuserdefaultdemo[<span class="number">4616</span>:<span class="number">174076</span>] <span class="literal">NO</span></span><br></pre></td></tr></table></figure><p>当我们APP首次启动时需要进入一个引导页，通过该<code>isNeedShowGuide</code>来判断是否进入引导页，而首次进入是需要YES的情况下进入引导页，后续将值设置为NO。但是通过打印该值时获取到的不是我们想要的值，因为该值如果设置过才会运行正确。但是没有设置过该值也没有该默认值则默认返回的是NO。</p><p>那么这里就需要用到<code>registerDefaults</code>方法了：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[[<span class="built_in">NSUserDefaults</span> standardUserDefaults] registerDefaults:@&#123;</span><br><span class="line">    <span class="string">@"isNeedShowGuide"</span> : @YES</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><p>我们在获取<code>isNeedShowGuide</code>之前先调用了<code>registerDefaults</code>方法设置了它的默认值，后面获取的时候即使没有再设置值也会获取到默认设置的值，就不会出现上述获取默认值尴尬的情况了。</p><p>当然我们也可以先默认保存一个plist文件在项目目录中来设置默认值来方便读取，来减少代码量：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSURL</span> *plistUrl = [[<span class="built_in">NSBundle</span> mainBundle] URLForResource:<span class="string">@"DefaultPreferences"</span> withExtension:<span class="string">@"plist"</span>];</span><br><span class="line"><span class="built_in">NSDictionary</span> *defaultPreferences = [<span class="built_in">NSDictionary</span> dictionaryWithContentsOfURL:plistUrl];</span><br><span class="line">[[<span class="built_in">NSUserDefaults</span> standardUserDefaults] registerDefaults:defaultPreferences];</span><br></pre></td></tr></table></figure><p><strong>注意：</strong><code>registerDefaults</code> 设置的默认值是不会持久化存储的，也就是说我们每次启动 APP 的时候，都需要这样设置一遍。所以<code>application:didFinishLaunchingWithOptions</code>是最合适的地方。</p><h1 id="NSUserDefaults域"><a href="#NSUserDefaults域" class="headerlink" title="NSUserDefaults域"></a>NSUserDefaults域</h1><p>NSUserDefaults 还有一个 Domain 的概念，当我们调用 <code>[NSUserDefaults standardUserDefaults]</code>方法时，就会初始化 <code>NSUserDefaults</code>， 并且它默认会包含 5 个 Domain， 分别是：</p><ul><li><strong>NSArgumentDomain</strong>：最高优先权</li><li><strong>Application</strong>：它存储着你app通过<code>NSUserDefaults set...forKey</code>添加的设置</li><li><strong>NSGlobalDomain</strong>：存储着系统的设置</li><li><strong>Languages</strong>：包括地区、日期等</li><li><strong>NSRegistrationDomain</strong>：仅有较低的优先权，只有在应用域没有找到值时才从注册域去寻找。</li></ul><p>来解释一下，比如调用了下面的一个方法：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[[<span class="built_in">NSUserDefaults</span> standardUserDefaults] setBool:<span class="literal">NO</span> forKey:<span class="string">@"isNeedShowGuide"</span>];</span><br></pre></td></tr></table></figure><p>这句话会将设置的key和值存储在了<code>Application</code>域中，但 <code>NSUserDefaults</code> 还包括了其他 4 个域，如果我们每次调用读取数据的方法的时候，例如：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[[<span class="built_in">NSUserDefaults</span> standardUserDefaults] boolForKey:<span class="string">@"isNeedShowGuide"</span>]</span><br></pre></td></tr></table></figure><p>那么其实底层的就会进行一次搜索，搜索顺序为：</p><p><code>NSArgumentDomain</code> -&gt; <code>Application</code> -&gt; <code>NSGlobalDomain</code> -&gt; <code>Languages</code> -&gt; <code>NSRegistrationDomain</code></p><p>而之前举的例子来说，我们并没有通过<code>setBool:forkey:</code>方法来设置该值，所以<code>Application</code>域中并没有该值，但是我们使用了<code>registerDefaults</code>将它设置到了<code>NSRegistrationDomain</code>域中。</p><p>所以按照<code>NSUserDefaults</code> 的默认搜索顺序，就会找到最后 <code>NSRegistrationDomain</code> 域中的那个 <code>isNeedShowGuide</code>， 也就是我们所谓的默认值 YES 了。</p><h1 id="存储路径"><a href="#存储路径" class="headerlink" title="存储路径"></a>存储路径</h1><p>NSUserDefaults 数据存放在沙盒 <code>Library/Preferences/</code> 目录下，一个以你包名命名的<code>.plist</code>文件。</p><p>通过代码获取路径后：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSString</span> *path = <span class="built_in">NSHomeDirectory</span>();</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"path : %@"</span>, path);</span><br></pre></td></tr></table></figure><p>将路径复制到Finder中，前往：</p><p><img src="cunchu.png" alt></p><h1 id="关于synchronize方法"><a href="#关于synchronize方法" class="headerlink" title="关于synchronize方法"></a>关于synchronize方法</h1><p>该方法是为了强制存储，但其实是没有必要的，该方法系统会默认调用。</p><blockquote><p>Waits for any pending asynchronous updates to the defaults database and returns; this method is unnecessary and shouldn’t be used.</p><p>等待默认数据库的任何挂起的异步更新并返回; 此方法是不必要的，不应使用。</p></blockquote><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="https://developer.apple.com/documentation/foundation/nsuserdefaults?language=objc" target="_blank" rel="noopener">https://developer.apple.com/documentation/foundation/nsuserdefaults?language=objc</a></p><p><a href="http://swiftcafe.io/post/nsuserdefaults" target="_blank" rel="noopener">http://swiftcafe.io/post/nsuserdefaults</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;概览&quot;&gt;&lt;a href=&quot;#概览&quot; class=&quot;headerlink&quot; title=&quot;概览&quot;&gt;&lt;/a&gt;概览&lt;/h1&gt;&lt;p&gt;&lt;code&gt;NSUserDefaults&lt;/code&gt;类提供了一个与默认系统交互的编程接口。默认系统允许应用程序自定义其行为以匹配用户的首选项。例如，您可以允许用户指定其首选的测量单位或媒体播放速度。应用程序通过为用户默认数据库中的一组参数指定值来存储这些首选项。这些参数被称为默认值，因为它们通常用于确定应用程序启动时的默认状态或默认情况下的行为方式。在运行时，使用&lt;code&gt;NSUserDefaults&lt;/code&gt;对象从用户的默认数据库中读取应用程序使用的默认值。nsUserDefaults缓存信息，以避免每次需要默认值时都必须打开用户的默认数据库。当您设置默认值时，它会在您的进程内同步更改，并异步更改为持久存储和其他进程。&lt;/p&gt;
    
    </summary>
    
      <category term="Ios" scheme="http://hackycy.github.io/categories/Ios/"/>
    
    
      <category term="Ios" scheme="http://hackycy.github.io/tags/Ios/"/>
    
  </entry>
  
  <entry>
    <title>Android TextView更换字体</title>
    <link href="http://hackycy.github.io/2019/08/07/Android-TextView%E6%9B%B4%E6%8D%A2%E5%AD%97%E4%BD%93/"/>
    <id>http://hackycy.github.io/2019/08/07/Android-TextView更换字体/</id>
    <published>2019-08-07T06:52:47.000Z</published>
    <updated>2019-08-07T08:04:45.021Z</updated>
    
    <content type="html"><![CDATA[<p>在开发UI时有时会涉及到TextView设置字体样式，TextView中在xml下仅可以设置自带的字体样式：</p><a id="more"></a><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">android:typeface="monospace"</span><br></pre></td></tr></table></figure><p>自带有四种文字类型，分别是：</p><ul><li>monospace</li><li>normal</li><li>sans</li><li>serif</li></ul><p>看看运行效果后的样式：</p><p><img src="systtf.png" alt></p><p>有时候UI需要设定特定字体的时候，我们可以给在代码中TextView设置特定的字体。</p><p>比如我们随便下载一些字体：<a href="https://www.sentyfont.com/download.htm" target="_blank" rel="noopener">https://www.sentyfont.com/download.htm</a></p><p>放在Assets目录下：</p><p><img src="demo1.png" alt></p><blockquote><p>注意留意目录结构，demo将字体文件放在了fonts目录下</p></blockquote><p>然后在代码中设置：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">TextView tv = findViewById(R.id.tv);</span><br><span class="line">Typeface tf = Typeface.createFromAsset(<span class="keyword">this</span>.getAssets(), <span class="string">"fonts/HanyiSentyVimalkirti.ttf"</span>);</span><br><span class="line">tv.setTypeface(tf);</span><br></pre></td></tr></table></figure><p>运行效果：</p><p><img src="demo2.png" alt></p><blockquote><p>字体文件otf等都支持。</p><p>字体包过大可以将使用到的字提取出来，不用将所有字体都打包成一个ttf。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在开发UI时有时会涉及到TextView设置字体样式，TextView中在xml下仅可以设置自带的字体样式：&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="http://hackycy.github.io/categories/Android/"/>
    
    
      <category term="Android" scheme="http://hackycy.github.io/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Android 软键盘imeOptions事件响应</title>
    <link href="http://hackycy.github.io/2019/07/31/Android-%E8%BD%AF%E9%94%AE%E7%9B%98imeOptions%E4%BA%8B%E4%BB%B6%E5%93%8D%E5%BA%94/"/>
    <id>http://hackycy.github.io/2019/07/31/Android-软键盘imeOptions事件响应/</id>
    <published>2019-07-31T04:17:22.000Z</published>
    <updated>2019-07-31T07:41:26.883Z</updated>
    
    <content type="html"><![CDATA[<p>在一些登陆，搜索的过程中，输入框在用户输入完后点击软键盘的回车、搜索等的按钮即可完成登陆或者搜索的功能，不必要再让用户再次点击页面上的登陆或者搜索按钮才能够进行操作。</p><a id="more"></a><h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>用图来说话吧，下图是一个高德地图的一个搜索框：</p><p><img src="demo.png" alt></p><p>你们会发现并没有搜索按钮，而是在键盘的右下角有一个小图标(放大镜图标或者搜索字样)，这代表的是搜索的动作，点击后就可以进行搜索。</p><p>而在一个浏览器下的一个输入框时，软键盘也会有相对应的变化，如下图：</p><p><img src="demo2.png" alt></p><p>填写网址后点击软键盘的转到即可到达输入的网页。</p><h1 id="imeOptions"><a href="#imeOptions" class="headerlink" title="imeOptions"></a>imeOptions</h1><p>上面概述上的两个功能使得EditText拥有图标变化的能力就是<code>android:imeOptions</code>属性。</p><p>而EditorInfo类源码中一共提供了以下属性供我们选择</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> IME_ACTION_DONE = <span class="number">6</span>; <span class="comment">//对应actionDone</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> IME_ACTION_GO = <span class="number">2</span>;  <span class="comment">//对应actionGo</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> IME_ACTION_NEXT = <span class="number">5</span>;  <span class="comment">//对应actionNext</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> IME_ACTION_NONE = <span class="number">1</span>;  <span class="comment">//对应actionNone</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> IME_ACTION_PREVIOUS = <span class="number">7</span>;  <span class="comment">//对应actionPrevious</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> IME_ACTION_SEARCH = <span class="number">3</span>;  <span class="comment">//对应actionSearch</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> IME_ACTION_SEND = <span class="number">4</span>;  <span class="comment">//对应actionSearch</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> IME_ACTION_UNSPECIFIED = <span class="number">0</span>;  <span class="comment">//对应actionUnspecified</span></span><br></pre></td></tr></table></figure><p>我们在xml中编写对应的EditText，来直接演示下理解它们的实用意义：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ScrollView</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:app</span>=<span class="string">"http://schemas.android.com/apk/res-auto"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:tools</span>=<span class="string">"http://schemas.android.com/tools"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">tools:context</span>=<span class="string">".MainActivity"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">LinearLayout</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:orientation</span>=<span class="string">"vertical"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">EditText</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:id</span>=<span class="string">"@+id/actionGo"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:imeOptions</span>=<span class="string">"actionGo"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:hint</span>=<span class="string">"actionGo"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:singleLine</span>=<span class="string">"true"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_height</span>=<span class="string">"45dp"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">EditText</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:id</span>=<span class="string">"@+id/actionSearch"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:imeOptions</span>=<span class="string">"actionSearch"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:hint</span>=<span class="string">"actionSearch"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:singleLine</span>=<span class="string">"true"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_height</span>=<span class="string">"45dp"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">EditText</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:id</span>=<span class="string">"@+id/actionNext"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:imeOptions</span>=<span class="string">"actionNext"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:hint</span>=<span class="string">"actionNext"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:singleLine</span>=<span class="string">"true"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_height</span>=<span class="string">"45dp"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">EditText</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:id</span>=<span class="string">"@+id/actionNone"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:imeOptions</span>=<span class="string">"actionNone"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:hint</span>=<span class="string">"actionNone"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:singleLine</span>=<span class="string">"true"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_height</span>=<span class="string">"45dp"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">EditText</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:id</span>=<span class="string">"@+id/actionDone"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:imeOptions</span>=<span class="string">"actionDone"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:hint</span>=<span class="string">"actionDone"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:singleLine</span>=<span class="string">"true"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_height</span>=<span class="string">"45dp"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">EditText</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:id</span>=<span class="string">"@+id/actionSend"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:imeOptions</span>=<span class="string">"actionSend"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:hint</span>=<span class="string">"actionSend"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:singleLine</span>=<span class="string">"true"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_height</span>=<span class="string">"45dp"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">EditText</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:id</span>=<span class="string">"@+id/actionPrevious"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:imeOptions</span>=<span class="string">"actionPrevious"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:hint</span>=<span class="string">"actionPrevious"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:singleLine</span>=<span class="string">"true"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_height</span>=<span class="string">"45dp"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">EditText</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:id</span>=<span class="string">"@+id/actionUnspecified"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:imeOptions</span>=<span class="string">"actionUnspecified"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:hint</span>=<span class="string">"actionUnspecified"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:singleLine</span>=<span class="string">"true"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_height</span>=<span class="string">"45dp"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ScrollView</span>&gt;</span></span><br></pre></td></tr></table></figure><p>运行效果：</p><p><img src="demo3.png" alt></p><blockquote><p><strong>注意：该属性必须配置<code>android:singleLine=&quot;true&quot;</code>属性或者配合<code>android:maxLines=&quot;1&quot;</code>与<code>android:inputType=&quot;number&quot;</code>结合使用。缺一不可。即便singleLine已经被废弃，又或者单纯使用maxLines是无效的。</strong></p></blockquote><p>对EditText指定不同的imeOptions之后，就需要实现OnEditorActionListener 中的onEditorAction()方法，然后根据不同的动作执行进行响应。 </p><p>对于actionDone、actionNext和actionPrevious，系统都自己进行了部分处理。 </p><ul><li>actionDone：隐藏输入法 </li><li>actionNext：跳到下一个EditText </li><li>actionPrevious：跳到上一个EditText</li></ul><p>我们使用案例中实现以一个搜索的例子实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> EditText actionSearch;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">        actionSearch = findViewById(R.id.actionSearch);</span><br><span class="line"></span><br><span class="line">        actionSearch.setOnEditorActionListener(<span class="keyword">new</span> TextView.OnEditorActionListener() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onEditorAction</span><span class="params">(TextView textView, <span class="keyword">int</span> actionId, KeyEvent keyEvent)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(actionId == EditorInfo.IME_ACTION_SEARCH) &#123;</span><br><span class="line">                    <span class="keyword">if</span>(actionSearch.getText().toString().isEmpty()) &#123;</span><br><span class="line">                        Toast.makeText(MainActivity.<span class="keyword">this</span>, <span class="string">"内容不能为空"</span>, Toast.LENGTH_SHORT).show();</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        Toast.makeText(MainActivity.<span class="keyword">this</span>, <span class="string">"您搜索的内容是："</span> + actionSearch.getText().toString(), Toast.LENGTH_SHORT).show();</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//只负责搜索事件处理，其他处理交回到系统的默认处理</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行效果：</p><p><img src="demo4.png" alt></p><blockquote><p>部分第三方的输入法，对EditorInfo支持的不一样，有的功能实现了，但是对应的图标没有修改过来，有的干脆功能就没有实现。</p></blockquote><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p><code>actionDone</code>  - 完成 - 对应 <code>EditorInfo.IME_ACTION_DONE</code><br><code>actionGo</code> - 前进 - 对应 <code>EditorInfo.IME_ACTION_GO</code><br><code>actionNext</code> - 下一项 - 对应 <code>EditorInfo.IME_ACTION_NEXT</code><br><code>actionNone</code> - 无动作 - 对应 <code>EditorInfo.IME_ACTION_NONE</code><br><code>actionPrevious</code> - 上一项 - 对应 <code>EditorInfo.IME_ACTION_PREVIOUS</code><br><code>actionSearch</code> - 搜索 - 对应 <code>EditorInfo.IME_ACTION_SEARCH</code><br><code>actionUnspecified</code> - 未指定 - <code>对应 EditorInfo.IME_ACTION_UNSPECIFIED</code><br><code>actionSend</code> - 发送 - 对应 <code>EditorInfo.IME_ACTION_SEND</code></p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://blog.csdn.net/liuweiballack/article/details/46708697" target="_blank" rel="noopener">https://blog.csdn.net/liuweiballack/article/details/46708697</a></p><p><a href="https://www.jianshu.com/p/d5c419bb4e19" target="_blank" rel="noopener">https://www.jianshu.com/p/d5c419bb4e19</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在一些登陆，搜索的过程中，输入框在用户输入完后点击软键盘的回车、搜索等的按钮即可完成登陆或者搜索的功能，不必要再让用户再次点击页面上的登陆或者搜索按钮才能够进行操作。&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="http://hackycy.github.io/categories/Android/"/>
    
    
      <category term="Android" scheme="http://hackycy.github.io/tags/Android/"/>
    
      <category term="EditText" scheme="http://hackycy.github.io/tags/EditText/"/>
    
  </entry>
  
  <entry>
    <title>IOS之UITableView使用</title>
    <link href="http://hackycy.github.io/2019/07/18/IOS%E4%B9%8BUITableView%E4%BD%BF%E7%94%A8/"/>
    <id>http://hackycy.github.io/2019/07/18/IOS之UITableView使用/</id>
    <published>2019-07-18T08:05:35.000Z</published>
    <updated>2019-08-21T09:08:34.262Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h1><p>iOS的<code>UITableView</code>显示单列垂直滚动内容。表格中的每一行都包含一段应用内容。例如，“联系人”应用程序在单独的行中显示每个联系人的姓名，“设置”应用程序的主页面显示可用的设置组。您可以将表配置为显示单个长行列表，也可以将相关行分组为多个部分，以便更轻松地导航内容。</p><a id="more"></a><p><img src="tableviewpreview.png" alt></p><h1 id="UITableView"><a href="#UITableView" class="headerlink" title="UITableView"></a><a href="https://developer.apple.com/documentation/uikit/uitableview" target="_blank" rel="noopener">UITableView</a></h1><p><code>UITableView</code>管理表的基本外观，提供显示实际内容的单元格（对象）。标准单元格配置显示文本和图像的简单组合，但您可以定义显示所需内容的自定义单元格。您还可以提供页眉和页脚视图，以便为单元格组提供其他信息。</p><p><code>UITableView</code>有两种风格：<code>UITableViewStylePlain</code>和<code>UITableViewStyleGrouped</code>。这两者操作起来其实并没有本质区别，只是后者按分组样式显示前者按照普通样式显示而已。大家先看一下两者的应用：</p><p><img src="groupandnonggroup.png" alt></p><p><strong>UITableView的层次结构</strong></p><p><img src="tableviewintro.png" alt></p><h2 id="类方法"><a href="#类方法" class="headerlink" title="类方法"></a>类方法</h2><h3 id="创建表视图"><a href="#创建表视图" class="headerlink" title="创建表视图"></a>创建表视图</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">init</span>(frame: <span class="type">CGRect</span>, style: <span class="type">UITableView</span>.<span class="type">Style</span>)</span><br><span class="line"><span class="comment">//初始化并返回具有给定框架和样式的表视图对象。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">init</span>?(coder: <span class="type">NSCoder</span>)</span><br></pre></td></tr></table></figure><h3 id="提供表格的数据和单元格"><a href="#提供表格的数据和单元格" class="headerlink" title="提供表格的数据和单元格"></a>提供表格的数据和单元格</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> dataSource: <span class="type">UITableViewDataSource?</span></span><br><span class="line"><span class="comment">//充当表视图数据源的对象。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> prefetchDataSource: <span class="type">UITableViewDataSourcePrefetching?</span></span><br><span class="line"><span class="comment">//充当表视图的预取数据源的对象，接收即将到来的单元数据要求的通知。</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">UITableViewDataSource</span></span></span><br><span class="line"><span class="class">//您用于管理数据并为表视图提供单元格的对象采用的方法。</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">protocol</span> <span class="title">UITableViewDataSourcePrefetching</span></span></span><br><span class="line"><span class="class">//一种协议，提供表视图数据要求的预先警告，允许您尽早启动可能长时间运行的数据操作。</span></span><br></pre></td></tr></table></figure><h3 id="重用表视图单元格"><a href="#重用表视图单元格" class="headerlink" title="重用表视图单元格"></a>重用表视图单元格</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">register</span><span class="params">(UINib?, forCellReuseIdentifier: String)</span></span></span><br><span class="line"><span class="comment">//注册包含具有指定标识符下的表视图的单元格的nib对象。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">register</span><span class="params">(AnyClass?, forCellReuseIdentifier: String)</span></span></span><br><span class="line"><span class="comment">//注册用于创建新表格单元格的类。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">dequeueReusableCell</span><span class="params">(withIdentifier: String, <span class="keyword">for</span>: IndexPath)</span></span> -&gt; <span class="type">UITableViewCell</span></span><br><span class="line"><span class="comment">//返回指定重用标识符的可重用表视图单元对象，并将其添加到表中。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">dequeueReusableCell</span><span class="params">(withIdentifier: String)</span></span> -&gt; <span class="type">UITableViewCell?</span></span><br><span class="line"><span class="comment">//返回按其标识符定位的可重用表视图单元对象。</span></span><br></pre></td></tr></table></figure><h3 id="重用部分页眉和页脚"><a href="#重用部分页眉和页脚" class="headerlink" title="重用部分页眉和页脚"></a>重用部分页眉和页脚</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">register</span><span class="params">(UINib?, forHeaderFooterViewReuseIdentifier: String)</span></span></span><br><span class="line"><span class="comment">//使用指定标识符下的表视图注册包含页眉或页脚的nib对象。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">register</span><span class="params">(AnyClass?, forHeaderFooterViewReuseIdentifier: String)</span></span></span><br><span class="line"><span class="comment">//注册一个类，用于创建新的表头或页脚视图。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">dequeueReusableHeaderFooterView</span><span class="params">(withIdentifier: String)</span></span> -&gt; <span class="type">UITableViewHeaderFooterView?</span></span><br><span class="line"><span class="comment">//返回由其标识符定位的可重用页眉或页脚视图。</span></span><br></pre></td></tr></table></figure><h3 id="管理与表的交互"><a href="#管理与表的交互" class="headerlink" title="管理与表的交互"></a>管理与表的交互</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> delegate: <span class="type">UITableViewDelegate?</span></span><br><span class="line"><span class="comment">//充当表视图委托的对象。</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">UITableViewDelegate</span></span></span><br><span class="line"><span class="class">//管理选择，配置节页眉和页脚，删除和重新排序单元格以及在表格视图中执行其他操作的方法。</span></span><br></pre></td></tr></table></figure><h3 id="配置表的外观"><a href="#配置表的外观" class="headerlink" title="配置表的外观"></a>配置表的外观</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> style: <span class="type">UITableView</span>.<span class="type">Style</span></span><br><span class="line"><span class="comment">//表格视图的样式。</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">UITableView</span>.<span class="title">Style</span></span></span><br><span class="line"><span class="class">//表视图样式的常量。</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">var</span> <span class="title">tableHeaderView</span>: <span class="title">UIView</span>?</span></span><br><span class="line"><span class="class">//显示在表格内容上方的视图。</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">var</span> <span class="title">tableFooterView</span>: <span class="title">UIView</span>?</span></span><br><span class="line"><span class="class">//显示在表格内容下方的视图。</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">var</span> <span class="title">backgroundView</span>: <span class="title">UIView</span>?</span></span><br><span class="line"><span class="class">//表视图的背景视图。</span></span><br></pre></td></tr></table></figure><h3 id="配置单元格高度和布局"><a href="#配置单元格高度和布局" class="headerlink" title="配置单元格高度和布局"></a>配置单元格高度和布局</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> rowHeight: <span class="type">CGFloat</span></span><br><span class="line"><span class="comment">//表视图中每行的默认高度（以磅为单位）。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> estimatedRowHeight: <span class="type">CGFloat</span></span><br><span class="line"><span class="comment">//表视图中行的估计高度。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> cellLayoutMarginsFollowReadableWidth: <span class="type">Bool</span></span><br><span class="line"><span class="comment">//一个布尔值，指示单元格边距是否从可读内容指南的宽度派生。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> insetsContentViewsToSafeArea: <span class="type">Bool</span></span><br><span class="line"><span class="comment">//一个布尔值，指示表视图是否将其内容视图重新定位在当前安全区域内。</span></span><br></pre></td></tr></table></figure><h3 id="配置页眉和页脚高度"><a href="#配置页眉和页脚高度" class="headerlink" title="配置页眉和页脚高度"></a>配置页眉和页脚高度</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> sectionHeaderHeight: <span class="type">CGFloat</span></span><br><span class="line"><span class="comment">//表视图中节标题的高度。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> sectionFooterHeight: <span class="type">CGFloat</span></span><br><span class="line"><span class="comment">//表格视图中部分页脚的高度。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> estimatedSectionHeaderHeight: <span class="type">CGFloat</span></span><br><span class="line"><span class="comment">//表视图中节标题的估计高度。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> estimatedSectionFooterHeight: <span class="type">CGFloat</span></span><br><span class="line"><span class="comment">//表格视图中部分页脚的估计高度。</span></span><br></pre></td></tr></table></figure><h3 id="自定义分隔符外观"><a href="#自定义分隔符外观" class="headerlink" title="自定义分隔符外观"></a>自定义分隔符外观</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> separatorStyle: <span class="type">UITableViewCell</span>.<span class="type">SeparatorStyle</span></span><br><span class="line"><span class="comment">//用作分隔符的表格单元格的样式。</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">UITableViewCell</span>.<span class="title">SeparatorStyle</span></span></span><br><span class="line"><span class="class">//用作分隔符的单元格样式。</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">var</span> <span class="title">separatorColor</span>: <span class="title">UIColor</span>?</span></span><br><span class="line"><span class="class">//表视图中分隔符行的颜色。</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">var</span> <span class="title">separatorEffect</span>: <span class="title">UIVisualEffect</span>?</span></span><br><span class="line"><span class="class">//应用于表分隔符的效果。</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">var</span> <span class="title">separatorInset</span>: <span class="title">UIEdgeInsets</span></span></span><br><span class="line"><span class="class">//单元格分隔符的默认插入。</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">var</span> <span class="title">separatorInsetReference</span>: <span class="title">UITableView</span>.<span class="title">SeparatorInsetReference</span></span></span><br><span class="line"><span class="class">//应该如何解释分隔符插入值的指示符。</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">enum</span> <span class="title">UITableView</span>.<span class="title">SeparatorInsetReference</span></span></span><br><span class="line"><span class="class">//指示如何解释表视图的分隔符插入值的常量。</span></span><br></pre></td></tr></table></figure><h3 id="获取行数和节数"><a href="#获取行数和节数" class="headerlink" title="获取行数和节数"></a>获取行数和节数</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">numberOfRows</span><span class="params">(inSection: Int)</span></span> -&gt; <span class="type">Int</span></span><br><span class="line"><span class="comment">//返回指定节中的行数（表格单元格）。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> numberOfSections: <span class="type">Int</span></span><br><span class="line"><span class="comment">//表视图中的节数。</span></span><br></pre></td></tr></table></figure><h3 id="获取单元格和基于节的视图"><a href="#获取单元格和基于节的视图" class="headerlink" title="获取单元格和基于节的视图"></a>获取单元格和基于节的视图</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">cellForRow</span><span class="params">(at: IndexPath)</span></span> -&gt; <span class="type">UITableViewCell?</span></span><br><span class="line"><span class="comment">//返回指定索引路径的表格单元格。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">headerView</span><span class="params">(forSection: Int)</span></span> -&gt; <span class="type">UITableViewHeaderFooterView?</span></span><br><span class="line"><span class="comment">//返回与指定节相关联的标题视图。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">footerView</span><span class="params">(forSection: Int)</span></span> -&gt; <span class="type">UITableViewHeaderFooterView?</span></span><br><span class="line"><span class="comment">//返回与指定节相关联的页脚视图。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">indexPath</span><span class="params">(<span class="keyword">for</span>: UITableViewCell)</span></span> -&gt; <span class="type">IndexPath?</span></span><br><span class="line"><span class="comment">//返回表示给定表视图单元格的行和部分的索引路径。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">indexPathForRow</span><span class="params">(at: CGPoint)</span></span> -&gt; <span class="type">IndexPath?</span></span><br><span class="line"><span class="comment">//返回标识给定点处的行和节的索引路径。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">indexPathsForRows</span><span class="params">(<span class="keyword">in</span>: CGRect)</span></span> -&gt; [<span class="type">IndexPath</span>]?</span><br><span class="line"><span class="comment">//索引路径数组，每个索引路径表示由给定矩形包围的行。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> visibleCells: [<span class="type">UITableViewCell</span>]</span><br><span class="line"><span class="comment">//表视图中可见的表格单元格。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> indexPathsForVisibleRows: [<span class="type">IndexPath</span>]?</span><br><span class="line"><span class="comment">//索引路径数组，每个索引路径标识表视图中的可见行。</span></span><br></pre></td></tr></table></figure><h3 id="选择行"><a href="#选择行" class="headerlink" title="选择行"></a>选择行</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> indexPathForSelectedRow: <span class="type">IndexPath?</span></span><br><span class="line"><span class="comment">//标识所选行的行和部分的索引路径。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> indexPathsForSelectedRows: [<span class="type">IndexPath</span>]?</span><br><span class="line"><span class="comment">//表示所选行的索引路径。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">selectRow</span><span class="params">(at: IndexPath?, animated: Bool, scrollPosition: UITableView.ScrollPosition)</span></span></span><br><span class="line"><span class="comment">//选择由索引路径标识的表视图中的行，可选择将行滚动到表视图中的某个位置。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">deselectRow</span><span class="params">(at: IndexPath, animated: Bool)</span></span></span><br><span class="line"><span class="comment">//取消选择由索引路径标识的给定行，并选择为取消选择设置动画。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> allowsSelection: <span class="type">Bool</span></span><br><span class="line"><span class="comment">//一个布尔值，用于确定用户是否可以选择行。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> allowsMultipleSelection: <span class="type">Bool</span></span><br><span class="line"><span class="comment">//一个布尔值，用于确定用户是否可以在编辑模式之外选择多个行。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> allowsSelectionDuringEditing: <span class="type">Bool</span></span><br><span class="line"><span class="comment">//一个布尔值，用于确定用户在表视图处于编辑模式时是否可以选择单元格。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> allowsMultipleSelectionDuringEditing: <span class="type">Bool</span></span><br><span class="line"><span class="comment">//一个布尔值，控制用户是否可以在编辑模式下同时选择多个单元格。</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">let</span> <span class="title">selectionDidChangeNotification</span>: <span class="title">NSNotification</span>.<span class="title">Name</span></span></span><br><span class="line"><span class="class">//发布表视图中的选定行发生更改时发布。</span></span><br></pre></td></tr></table></figure><h3 id="插入，删除和移动行和节"><a href="#插入，删除和移动行和节" class="headerlink" title="插入，删除和移动行和节"></a>插入，删除和移动行和节</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">insertRows</span><span class="params">(at: [IndexPath], with: UITableView.RowAnimation)</span></span></span><br><span class="line"><span class="comment">//在表视图中插入由索引路径数组标识的位置的行，并提供动画插入的选项。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">deleteRows</span><span class="params">(at: [IndexPath], with: UITableView.RowAnimation)</span></span></span><br><span class="line"><span class="comment">//删除索引路径数组指定的行，并带有为删除设置动画的选项。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">insertSections</span><span class="params">(IndexSet, with: UITableView.RowAnimation)</span></span></span><br><span class="line"><span class="comment">//在表视图中插入一个或多个部分，并提供动画插入的选项。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">deleteSections</span><span class="params">(IndexSet, with: UITableView.RowAnimation)</span></span></span><br><span class="line"><span class="comment">//删除表视图中的一个或多个部分，并带有为删除设置动画的选项。</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">UITableView</span>.<span class="title">RowAnimation</span></span></span><br><span class="line"><span class="class">//插入或删除行时使用的动画类型。</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">func</span> <span class="title">moveRow</span>(<span class="title">at</span>: <span class="title">IndexPath</span>, <span class="title">to</span>: <span class="title">IndexPath</span>)</span></span><br><span class="line"><span class="class">//将指定位置的行移动到目标位置。</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">func</span> <span class="title">moveSection</span>(<span class="title">Int</span>, <span class="title">toSection</span>: <span class="title">Int</span>)</span></span><br><span class="line"><span class="class">//将节移动到表视图中的新位置。</span></span><br></pre></td></tr></table></figure><h3 id="对行和节执行批量更新"><a href="#对行和节执行批量更新" class="headerlink" title="对行和节执行批量更新"></a>对行和节执行批量更新</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">performBatchUpdates</span><span class="params">(<span class="params">(<span class="params">()</span></span></span></span> -&gt; <span class="type">Void</span>)?, completion: ((<span class="type">Bool</span>) -&gt; <span class="type">Void</span>)?)</span><br><span class="line"><span class="comment">//动画多个插入，删除，重新加载和移动操作作为一组。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">beginUpdates</span><span class="params">()</span></span></span><br><span class="line"><span class="comment">//开始一系列方法调用，插入，删除或选择表视图的行和部分。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">endUpdates</span><span class="params">()</span></span></span><br><span class="line"><span class="comment">//结束一系列方法调用，插入，删除，选择或重新加载表视图的行和部分。</span></span><br></pre></td></tr></table></figure><h3 id="配置表索引"><a href="#配置表索引" class="headerlink" title="配置表索引"></a>配置表索引</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> sectionIndexMinimumDisplayRowCount: <span class="type">Int</span></span><br><span class="line"><span class="comment">//用于在表的右边缘显示索引列表的表行数。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> sectionIndexColor: <span class="type">UIColor?</span></span><br><span class="line"><span class="comment">//用于表视图索引文本的颜色。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> sectionIndexBackgroundColor: <span class="type">UIColor?</span></span><br><span class="line"><span class="comment">//用于表视图的节索引背景的颜色。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> sectionIndexTrackingBackgroundColor: <span class="type">UIColor?</span></span><br><span class="line"><span class="comment">//用于表视图的索引背景区域的颜色。</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">let</span> <span class="title">indexSearch</span>: <span class="title">String</span></span></span><br><span class="line"><span class="class">//用于将放大镜图标添加到表视图的节索引的常量。</span></span><br></pre></td></tr></table></figure><h3 id="重新加载表视图"><a href="#重新加载表视图" class="headerlink" title="重新加载表视图"></a>重新加载表视图</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> hasUncommittedUpdates: <span class="type">Bool</span></span><br><span class="line"><span class="comment">//一个布尔值，指示表视图的外观是否包含未在其数据源中反映的更改。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reloadData</span><span class="params">()</span></span></span><br><span class="line"><span class="comment">//重新加载表视图的行和部分。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reloadRows</span><span class="params">(at: [IndexPath], with: UITableView.RowAnimation)</span></span></span><br><span class="line"><span class="comment">//使用给定的动画效果重新加载指定的行。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reloadSections</span><span class="params">(IndexSet, with: UITableView.RowAnimation)</span></span></span><br><span class="line"><span class="comment">//使用给定的动画效果重新加载指定的部分。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reloadSectionIndexTitles</span><span class="params">()</span></span></span><br><span class="line"><span class="comment">//重新加载表视图右侧索引栏中的项目。</span></span><br></pre></td></tr></table></figure><h3 id="管理拖动交互"><a href="#管理拖动交互" class="headerlink" title="管理拖动交互"></a>管理拖动交互</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> dragDelegate: <span class="type">UITableViewDragDelegate?</span></span><br><span class="line"><span class="comment">//委托对象管理从表视图中拖动项目。</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">UITableViewDragDelegate</span></span></span><br><span class="line"><span class="class">//用于从表视图启动拖动的界面。</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">var</span> <span class="title">hasActiveDrag</span>: <span class="title">Bool</span></span></span><br><span class="line"><span class="class">//一个布尔值，指示是否从表视图中提升行并且尚未删除。</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">var</span> <span class="title">dragInteractionEnabled</span>: <span class="title">Bool</span></span></span><br><span class="line"><span class="class">//一个布尔值，指示表视图是否支持应用之间的拖放。</span></span><br></pre></td></tr></table></figure><h3 id="管理丢弃交互"><a href="#管理丢弃交互" class="headerlink" title="管理丢弃交互"></a>管理丢弃交互</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> dropDelegate: <span class="type">UITableViewDropDelegate?</span></span><br><span class="line"><span class="comment">//管理将内容删除到表视图中的委托对象。</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">UITableViewDropDelegate</span></span></span><br><span class="line"><span class="class">//用于处理的接口在表视图中丢弃。</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">var</span> <span class="title">hasActiveDrop</span>: <span class="title">Bool</span></span></span><br><span class="line"><span class="class">//一个布尔值，指示表视图当前是否正在跟踪放置会话。</span></span><br></pre></td></tr></table></figure><h3 id="滚动表视图"><a href="#滚动表视图" class="headerlink" title="滚动表视图"></a>滚动表视图</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">scrollToRow</span><span class="params">(at: IndexPath, at: UITableView.ScrollPosition, animated: Bool)</span></span></span><br><span class="line"><span class="comment">//滚动表视图，直到索引路径标识的行位于屏幕上的特定位置。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">scrollToNearestSelectedRow</span><span class="params">(at: UITableView.ScrollPosition, animated: Bool)</span></span></span><br><span class="line"><span class="comment">//滚动表格视图，以便最接近表格视图中指定位置的选定行位于该位置。</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">UITableView</span>.<span class="title">ScrollPosition</span></span></span><br><span class="line"><span class="class">//表格视图中的位置（顶部，中间，底部），滚动给定行。</span></span><br></pre></td></tr></table></figure><h3 id="将表置于编辑模式"><a href="#将表置于编辑模式" class="headerlink" title="将表置于编辑模式"></a>将表置于编辑模式</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">setEditing</span><span class="params">(Bool, animated: Bool)</span></span></span><br><span class="line"><span class="comment">//切换表格视图进出编辑模式。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> isEditing: <span class="type">Bool</span></span><br><span class="line"><span class="comment">//一个布尔值，用于确定表视图是否处于编辑模式。</span></span><br></pre></td></tr></table></figure><h3 id="获取表格的绘图区域"><a href="#获取表格的绘图区域" class="headerlink" title="获取表格的绘图区域"></a>获取表格的绘图区域</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">rect</span><span class="params">(forSection: Int)</span></span> -&gt; <span class="type">CGRect</span></span><br><span class="line"><span class="comment">//返回表视图的指定部分的绘图区域。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">rectForRow</span><span class="params">(at: IndexPath)</span></span> -&gt; <span class="type">CGRect</span></span><br><span class="line"><span class="comment">//返回由索引路径标识的行的绘图区域。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">rectForFooter</span><span class="params">(inSection: Int)</span></span> -&gt; <span class="type">CGRect</span></span><br><span class="line"><span class="comment">//返回指定节的页脚的绘图区域。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">rectForHeader</span><span class="params">(inSection: Int)</span></span> -&gt; <span class="type">CGRect</span></span><br><span class="line"><span class="comment">//返回指定节的标题的绘图区域。</span></span><br></pre></td></tr></table></figure><h3 id="记住最后一个聚焦的单元格"><a href="#记住最后一个聚焦的单元格" class="headerlink" title="记住最后一个聚焦的单元格"></a>记住最后一个聚焦的单元格</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> remembersLastFocusedIndexPath: <span class="type">Bool</span></span><br><span class="line"><span class="comment">//一个布尔值，指示表视图是否应自动将焦点返回到上一个焦点索引路径处的单元格。</span></span><br></pre></td></tr></table></figure><h1 id="UITableViewCell"><a href="#UITableViewCell" class="headerlink" title="UITableViewCell"></a><a href="https://developer.apple.com/documentation/uikit/uitableviewcell" target="_blank" rel="noopener">UITableViewCell</a></h1><p>UITableViewCell对象是管理单个表行内容的专用视图类型。您主要使用单元格来组织和显示应用程序的自定义内容，但UITableViewCell提供了一些特定的自定义以支持与表相关的行为：</p><ul><li><p>将选定内容或突出显示颜色应用于单元格。</p></li><li><p>添加标准附件视图，如详细信息或披露控制。</p></li><li><p>将单元格置于可编辑状态。</p></li><li><p>缩进单元格内容以在表中创建可视层次结构。</p></li></ul><blockquote><p>A <code>UITableViewCell</code> object is a specialized type of view that manages the content of a single table row. You use cells primarily to organize and present your app’s custom content, but <code>UITableViewCell</code> provides some specific customizations to support table-related behaviors, including:</p><ul><li>Applying a selection or highlight color to the cell.</li><li>Adding standard accessory views, such as a detail or disclosure control.</li><li>Putting the cell into an editable state.</li><li>Indenting the cell’s content to create a visual hierarchy in your table.</li></ul><p>Your app’s content occupies most of the cell’s bounds, but the cell may adjust that space to make room for other content. Cells display accessory views on the trailing edge of their content area. When you put your table into edit mode, the cell adds a delete control to the leading edge of its content area, and optionally swaps out an accessory view for a reorder control.</p></blockquote><p><strong>UITableViewCellStyle/UITableViewCell.CellStyle</strong></p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">UITableViewCell</span> </span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">CellStyle</span> : <span class="title">Int</span> </span>&#123;</span><br><span class="line">        <span class="keyword">case</span> `<span class="keyword">default</span>`  <span class="comment">//具有文本标签（黑色和左对齐）和可选图像视图的单元格的简单样式。</span></span><br><span class="line">        <span class="keyword">case</span> value1<span class="comment">//单元格样式，单元格左侧带有标签，左对齐和黑色文本; 在右侧是一个标签，蓝色文字较小，右对齐。“设置”应用程序使用此样式的单元格。</span></span><br><span class="line">        <span class="keyword">case</span> value2<span class="comment">//单元格样式，单元格左侧带有标签，文本右对齐，蓝色; 在单元格的右侧是另一个标签，其中较小的文本是左对齐和黑色。电话/联系人应用程序使用此样式的单元格。</span></span><br><span class="line">        <span class="keyword">case</span> subtitle <span class="comment">//单元格的样式，顶部带有左对齐标签，下面带有左对齐标签，带有较小的灰色文本。</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="built_in">NS_ENUM</span>(<span class="built_in">NSInteger</span>, <span class="built_in">UITableViewCellStyle</span>) &#123;</span><br><span class="line">    <span class="built_in">UITableViewCellStyleDefault</span>,    </span><br><span class="line">    <span class="built_in">UITableViewCellStyleValue1</span>,        </span><br><span class="line">    <span class="built_in">UITableViewCellStyleValue2</span>,        </span><br><span class="line">    <span class="built_in">UITableViewCellStyleSubtitle</span>    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src="cellstyle.png" alt></p><p><strong>Cell的层次结构</strong></p><p><img src="cellintro.png" alt></p><h2 id="类方法-1"><a href="#类方法-1" class="headerlink" title="类方法"></a>类方法</h2><h3 id="创建表视图单元格"><a href="#创建表视图单元格" class="headerlink" title="创建表视图单元格"></a>创建表视图单元格</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">init</span>(style: <span class="type">UITableViewCell</span>.<span class="type">CellStyle</span>, reuseIdentifier: <span class="type">String?</span>)</span><br><span class="line"><span class="comment">//使用样式和重用标识符初始化表格单元格并将其返回给调用者。</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">UITableViewCell</span>.<span class="title">CellStyle</span></span></span><br><span class="line"><span class="class">//各种样式细胞的枚举。</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">init</span>?(<span class="title">coder</span>: <span class="title">NSCoder</span>)</span></span><br></pre></td></tr></table></figure><h3 id="重用"><a href="#重用" class="headerlink" title="重用"></a>重用</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> reuseIdentifier: <span class="type">String?</span></span><br><span class="line"><span class="comment">//用于标识可重用单元的字符串。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">prepareForReuse</span><span class="params">()</span></span></span><br><span class="line"><span class="comment">//准备一个可重用的单元格以供表视图委托重用。</span></span><br></pre></td></tr></table></figure><h3 id="指定标准单元格样式的内容"><a href="#指定标准单元格样式的内容" class="headerlink" title="指定标准单元格样式的内容"></a>指定标准单元格样式的内容</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> textLabel: <span class="type">UILabel?</span></span><br><span class="line"><span class="comment">//用于表格单元格主要文本内容的标签。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> detailTextLabel: <span class="type">UILabel?</span></span><br><span class="line"><span class="comment">//表格单元格的辅助标签（如果存在）。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> imageView: <span class="type">UIImageView?</span></span><br><span class="line"><span class="comment">//表格单元格的图像视图。</span></span><br></pre></td></tr></table></figure><h3 id="访问单元格对象的视图"><a href="#访问单元格对象的视图" class="headerlink" title="访问单元格对象的视图"></a>访问单元格对象的视图</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> contentView: <span class="type">UIView</span></span><br><span class="line"><span class="comment">//单元格对象的内容视图。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> backgroundView: <span class="type">UIView?</span></span><br><span class="line"><span class="comment">//该视图用作单元格的背景。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> selectedBackgroundView: <span class="type">UIView?</span></span><br><span class="line"><span class="comment">//视图在选中时用作单元格的背景。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> multipleSelectionBackgroundView: <span class="type">UIView?</span></span><br><span class="line"><span class="comment">//当表视图允许多行选择时，用于选定单元格的背景视图。</span></span><br></pre></td></tr></table></figure><h3 id="管理附件视图"><a href="#管理附件视图" class="headerlink" title="管理附件视图"></a>管理附件视图</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> accessoryType: <span class="type">UITableViewCell</span>.<span class="type">AccessoryType</span></span><br><span class="line"><span class="comment">//单元应使用的标准附件视图的类型（正常状态）。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> accessoryView: <span class="type">UIView?</span></span><br><span class="line"><span class="comment">//在单元格的右侧（正常状态）使用的视图，通常用作控件。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> editingAccessoryType: <span class="type">UITableViewCell</span>.<span class="type">AccessoryType</span></span><br><span class="line"><span class="comment">//单元格应在表格视图的编辑状态中使用的标准附件视图的类型。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> editingAccessoryView: <span class="type">UIView?</span></span><br><span class="line"><span class="comment">//在编辑模式下，通常用作单元格右侧控件的视图。</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">UITableViewCell</span>.<span class="title">AccessoryType</span></span></span><br><span class="line"><span class="class">//单元使用的标准附件控件的类型。</span></span><br></pre></td></tr></table></figure><h3 id="管理单元格选择和突出显示"><a href="#管理单元格选择和突出显示" class="headerlink" title="管理单元格选择和突出显示"></a>管理单元格选择和突出显示</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> selectionStyle: <span class="type">UITableViewCell</span>.<span class="type">SelectionStyle</span></span><br><span class="line"><span class="comment">//细胞的选择方式。</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">UITableViewCell</span>.<span class="title">SelectionStyle</span></span></span><br><span class="line"><span class="class">//选定单元格的样式。</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">var</span> <span class="title">isSelected</span>: <span class="title">Bool</span></span></span><br><span class="line"><span class="class">//一个布尔值，指示是否选择了单元格。</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">func</span> <span class="title">setSelected</span>(<span class="title">Bool</span>, <span class="title">animated</span>: <span class="title">Bool</span>)</span></span><br><span class="line"><span class="class">//设置单元格的选定状态，可选地为状态之间的过渡设置动画。</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">var</span> <span class="title">isHighlighted</span>: <span class="title">Bool</span></span></span><br><span class="line"><span class="class">//一个布尔值，指示单元格是否突出显示。</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">func</span> <span class="title">setHighlighted</span>(<span class="title">Bool</span>, <span class="title">animated</span>: <span class="title">Bool</span>)</span></span><br><span class="line"><span class="class">//设置单元格的突出显示状态，可选地为状态之间的过渡设置动画。</span></span><br></pre></td></tr></table></figure><h3 id="编辑单元格"><a href="#编辑单元格" class="headerlink" title="编辑单元格"></a>编辑单元格</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> isEditing: <span class="type">Bool</span></span><br><span class="line"><span class="comment">//一个布尔值，指示单元格是否处于可编辑状态。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">setEditing</span><span class="params">(Bool, animated: Bool)</span></span></span><br><span class="line"><span class="comment">//切换接收器进入和退出编辑模式。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> editingStyle: <span class="type">UITableViewCell</span>.<span class="type">EditingStyle</span></span><br><span class="line"><span class="comment">//单元格的编辑样式。</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">UITableViewCell</span>.<span class="title">EditingStyle</span></span></span><br><span class="line"><span class="class">//单元格使用的编辑控件。</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">var</span> <span class="title">showingDeleteConfirmation</span>: <span class="title">Bool</span></span></span><br><span class="line"><span class="class">//一个布尔值，指示单元格当前是否显示删除确认按钮。</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">var</span> <span class="title">showsReorderControl</span>: <span class="title">Bool</span></span></span><br><span class="line"><span class="class">//一个布尔值，用于确定单元格是否显示重新排序控件。</span></span><br></pre></td></tr></table></figure><h3 id="拖动行"><a href="#拖动行" class="headerlink" title="拖动行"></a>拖动行</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> userInteractionEnabledWhileDragging: <span class="type">Bool</span></span><br><span class="line"><span class="comment">//一个布尔值，指示用户在拖动单元格时是否可以与单元格进行交互。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">dragStateDidChange</span><span class="params">(UITableViewCell.DragState)</span></span></span><br><span class="line"><span class="comment">//通知单元格其拖动状态已更改。</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">UITableViewCell</span>.<span class="title">DragState</span></span></span><br><span class="line"><span class="class">//指示拖动操作中涉及的行的当前状态的常量。</span></span><br></pre></td></tr></table></figure><h3 id="适应状态转变"><a href="#适应状态转变" class="headerlink" title="适应状态转变"></a>适应状态转变</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">willTransition</span><span class="params">(to: UITableViewCell.StateMask)</span></span></span><br><span class="line"><span class="comment">//被调用以通知单元格它将要转换到新的单元状态。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">didTransition</span><span class="params">(to: UITableViewCell.StateMask)</span></span></span><br><span class="line"><span class="comment">//被调用以通知单元格它已转换到新的单元状态。</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">UITableViewCell</span>.<span class="title">StateMask</span></span></span><br><span class="line"><span class="class">//常量用于在状态之间转换时确定单元格的新状态。</span></span><br></pre></td></tr></table></figure><h3 id="管理内容缩进"><a href="#管理内容缩进" class="headerlink" title="管理内容缩进"></a>管理内容缩进</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> indentationLevel: <span class="type">Int</span></span><br><span class="line"><span class="comment">//单元格内容的缩进级别。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> indentationWidth: <span class="type">CGFloat</span></span><br><span class="line"><span class="comment">//单元格内容的每个缩进级别的宽度。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> shouldIndentWhileEditing: <span class="type">Bool</span></span><br><span class="line"><span class="comment">//一个布尔值，用于控制表视图处于编辑模式时是否缩进单元格背景。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> separatorInset: <span class="type">UIEdgeInsets</span></span><br><span class="line"><span class="comment">//在单元格下方绘制的分隔线的插入值。</span></span><br></pre></td></tr></table></figure><h3 id="管理焦点"><a href="#管理焦点" class="headerlink" title="管理焦点"></a>管理焦点</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> focusStyle: <span class="type">UITableViewCell</span>.<span class="type">FocusStyle</span></span><br><span class="line"><span class="comment">//聚焦时的外观。</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">UITableViewCell</span>.<span class="title">FocusStyle</span></span></span><br><span class="line"><span class="class">//聚焦的风格。</span></span><br></pre></td></tr></table></figure><h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">UITableViewCell</span>.<span class="title">SeparatorStyle</span></span></span><br><span class="line"><span class="class">用作分隔符的单元格样式。</span></span><br></pre></td></tr></table></figure><h1 id="UITableViewDelegate"><a href="#UITableViewDelegate" class="headerlink" title="UITableViewDelegate"></a><a href="https://developer.apple.com/documentation/uikit/uitableviewdelegate" target="_blank" rel="noopener">UITableViewDelegate</a></h1><p><code>UITableViewDelegate</code>用来管理选择，配置节页眉和页脚，删除和重新排序单元格以及在表格视图中执行其他操作的方法。例如：</p><ul><li>创建和管理自定义页眉和页脚视图。</li><li>指定行，页眉和页脚的自定义高度。</li><li>提供高度估计以获得更好的滚动支持。</li><li>缩进行内容。</li><li>响应行选择。</li><li>响应表行中的滑动和其他操作。</li><li>支持编辑表格的内容。</li></ul><h2 id="协议方法："><a href="#协议方法：" class="headerlink" title="协议方法："></a><strong>协议方法：</strong></h2><h3 id="配置表视图行"><a href="#配置表视图行" class="headerlink" title="配置表视图行"></a>配置表视图行</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">tableView</span><span class="params">(UITableView, willDisplay: UITableViewCell, forRowAt: IndexPath)</span></span></span><br><span class="line"><span class="comment">//告诉委托表视图是否要为特定行绘制单元格。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">tableView</span><span class="params">(UITableView, indentationLevelForRowAt: IndexPath)</span></span> -&gt; <span class="type">Int</span></span><br><span class="line"><span class="comment">//要求委托者返回给定部分中某行的缩进级别。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">tableView</span><span class="params">(UITableView, shouldSpringLoadRowAt: IndexPath, with: UISpringLoadedInteractionContext)</span></span> -&gt; <span class="type">Bool</span></span><br><span class="line"><span class="comment">//被调用以允许您微调表中行的弹簧加载行为。</span></span><br></pre></td></tr></table></figure><h3 id="响应行选择"><a href="#响应行选择" class="headerlink" title="响应行选择"></a>响应行选择</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">tableView</span><span class="params">(UITableView, willSelectRowAt: IndexPath)</span></span> -&gt; <span class="type">IndexPath?</span></span><br><span class="line"><span class="comment">//告诉委托者即将选择指定的行。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">tableView</span><span class="params">(UITableView, didSelectRowAt: IndexPath)</span></span></span><br><span class="line"><span class="comment">//告诉委托者现在选择了指定的行。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">tableView</span><span class="params">(UITableView, willDeselectRowAt: IndexPath)</span></span> -&gt; <span class="type">IndexPath?</span></span><br><span class="line"><span class="comment">//告诉委托者即将取消选择指定的行。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">tableView</span><span class="params">(UITableView, didDeselectRowAt: IndexPath)</span></span></span><br><span class="line"><span class="comment">//告诉代理现在取消选择指定的行。</span></span><br></pre></td></tr></table></figure><h3 id="提供自定义页眉和页脚视图"><a href="#提供自定义页眉和页脚视图" class="headerlink" title="提供自定义页眉和页脚视图"></a>提供自定义页眉和页脚视图</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">tableView</span><span class="params">(UITableView, viewForHeaderInSection: Int)</span></span> -&gt; <span class="type">UIView?</span></span><br><span class="line"><span class="comment">//要求委托使视图对象显示在表视图的指定部分的标题中。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">tableView</span><span class="params">(UITableView, viewForFooterInSection: Int)</span></span> -&gt; <span class="type">UIView?</span></span><br><span class="line"><span class="comment">//要求委托使视图对象显示在表视图的指定部分的页脚中。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">tableView</span><span class="params">(UITableView, willDisplayHeaderView: UIView, forSection: Int)</span></span></span><br><span class="line"><span class="comment">//告诉委托表该表即将显示指定节的标题视图。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">tableView</span><span class="params">(UITableView, willDisplayFooterView: UIView, forSection: Int)</span></span></span><br><span class="line"><span class="comment">//告诉代理该表即将显示指定部分的页脚视图。</span></span><br></pre></td></tr></table></figure><h3 id="提供页眉，页脚和行高"><a href="#提供页眉，页脚和行高" class="headerlink" title="提供页眉，页脚和行高"></a>提供页眉，页脚和行高</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">tableView</span><span class="params">(UITableView, heightForRowAt: IndexPath)</span></span> -&gt; <span class="type">CGFloat</span></span><br><span class="line"><span class="comment">//询问代理用于指定位置的行的高度。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">tableView</span><span class="params">(UITableView, heightForHeaderInSection: Int)</span></span> -&gt; <span class="type">CGFloat</span></span><br><span class="line"><span class="comment">//询问代理用于特定部分标题的高度。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">tableView</span><span class="params">(UITableView, heightForFooterInSection: Int)</span></span> -&gt; <span class="type">CGFloat</span></span><br><span class="line"><span class="comment">//询问代理用于特定部分的页脚的高度。</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">let</span> <span class="title">automaticDimension</span>: <span class="title">CGFloat</span></span></span><br><span class="line"><span class="class">//表示给定维度的默认值的常量。</span></span><br></pre></td></tr></table></figure><h3 id="估计表格内容的高度"><a href="#估计表格内容的高度" class="headerlink" title="估计表格内容的高度"></a>估计表格内容的高度</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">tableView</span><span class="params">(UITableView, estimatedHeightForRowAt: IndexPath)</span></span> -&gt; <span class="type">CGFloat</span></span><br><span class="line"><span class="comment">//询问代理指定位置中行的估计高度。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">tableView</span><span class="params">(UITableView, estimatedHeightForHeaderInSection: Int)</span></span> -&gt; <span class="type">CGFloat</span></span><br><span class="line"><span class="comment">//询问代理特定部分标题的估计高度。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">tableView</span><span class="params">(UITableView, estimatedHeightForFooterInSection: Int)</span></span> -&gt; <span class="type">CGFloat</span></span><br><span class="line"><span class="comment">//询问代理特定部分的页脚估计高度。</span></span><br></pre></td></tr></table></figure><h3 id="管理附件视图-1"><a href="#管理附件视图-1" class="headerlink" title="管理附件视图"></a>管理附件视图</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">tableView</span><span class="params">(UITableView, accessoryButtonTappedForRowWith: IndexPath)</span></span></span><br><span class="line"><span class="comment">//告诉代理用户点击了指定行的详细信息按钮。</span></span><br></pre></td></tr></table></figure><h3 id="响应行动作"><a href="#响应行动作" class="headerlink" title="响应行动作"></a>响应行动作</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">tableView</span><span class="params">(UITableView, leadingSwipeActionsConfigurationForRowAt: IndexPath)</span></span> -&gt; <span class="type">UISwipeActionsConfiguration?</span></span><br><span class="line"><span class="comment">//返回要在行的前沿显示的滑动操作。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">tableView</span><span class="params">(UITableView, trailingSwipeActionsConfigurationForRowAt: IndexPath)</span></span> -&gt; <span class="type">UISwipeActionsConfiguration?</span></span><br><span class="line"><span class="comment">//返回要在行的后缘显示的滑动操作。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">tableView</span><span class="params">(UITableView, shouldShowMenuForRowAt: IndexPath)</span></span> -&gt; <span class="type">Bool</span></span><br><span class="line"><span class="comment">//询问代理是否应该为某一行显示编辑菜单。 --弃用</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">tableView</span><span class="params">(UITableView, canPerformAction: Selector, forRowAt: IndexPath, withSender: <span class="keyword">Any</span>?)</span></span> -&gt; <span class="type">Bool</span></span><br><span class="line"><span class="comment">//询问代理是否编辑菜单应省略给定行的复制或粘贴命令。-- 弃用</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">tableView</span><span class="params">(UITableView, performAction: Selector, forRowAt: IndexPath, withSender: <span class="keyword">Any</span>?)</span></span></span><br><span class="line"><span class="comment">//告知委托对给定行的内容执行复制或粘贴操作。-- 弃用</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">tableView</span><span class="params">(UITableView, editActionsForRowAt: IndexPath)</span></span> -&gt; [<span class="type">UITableViewRowAction</span>]?</span><br><span class="line"><span class="comment">//询问代理是否响应指定行中的滑动而显示的操作。</span></span><br></pre></td></tr></table></figure><h3 id="管理表格视图亮点"><a href="#管理表格视图亮点" class="headerlink" title="管理表格视图亮点"></a>管理表格视图亮点</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">tableView</span><span class="params">(UITableView, shouldHighlightRowAt: IndexPath)</span></span> -&gt; <span class="type">Bool</span></span><br><span class="line"><span class="comment">//询问代理是否应突出显示指定的行。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">tableView</span><span class="params">(UITableView, didHighlightRowAt: IndexPath)</span></span></span><br><span class="line"><span class="comment">//告诉代理指出的行已突出显示。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">tableView</span><span class="params">(UITableView, didUnhighlightRowAt: IndexPath)</span></span></span><br><span class="line"><span class="comment">//告诉委托，突出显示已从指定索引路径的行中删除。</span></span><br></pre></td></tr></table></figure><h3 id="编辑表行"><a href="#编辑表行" class="headerlink" title="编辑表行"></a>编辑表行</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">tableView</span><span class="params">(UITableView, willBeginEditingRowAt: IndexPath)</span></span></span><br><span class="line"><span class="comment">//告诉代理表视图即将进入编辑模式。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">tableView</span><span class="params">(UITableView, didEndEditingRowAt: IndexPath?)</span></span></span><br><span class="line"><span class="comment">//告诉代理表视图已离开编辑模式。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">tableView</span><span class="params">(UITableView, editingStyleForRowAt: IndexPath)</span></span> -&gt; <span class="type">UITableViewCell</span>.<span class="type">EditingStyle</span></span><br><span class="line"><span class="comment">//向代表询问表视图中特定位置的行的编辑样式。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">tableView</span><span class="params">(UITableView, titleForDeleteConfirmationButtonForRowAt: IndexPath)</span></span> -&gt; <span class="type">String?</span></span><br><span class="line"><span class="comment">//更改删除确认按钮的默认标题。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">tableView</span><span class="params">(UITableView, shouldIndentWhileEditingRowAt: IndexPath)</span></span> -&gt; <span class="type">Bool</span></span><br><span class="line"><span class="comment">//询问代理在表视图处于编辑模式时是否应缩进指定行的背景。</span></span><br></pre></td></tr></table></figure><h3 id="重新排序表行"><a href="#重新排序表行" class="headerlink" title="重新排序表行"></a>重新排序表行</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">tableView</span><span class="params">(UITableView, targetIndexPathForMoveFromRowAt: IndexPath, toProposedIndexPath: IndexPath)</span></span> -&gt; <span class="type">IndexPath</span></span><br><span class="line"><span class="comment">//要求委托者返回一个新的索引路径以重新定位建议的行移动。</span></span><br></pre></td></tr></table></figure><h3 id="跟踪删除视图"><a href="#跟踪删除视图" class="headerlink" title="跟踪删除视图"></a>跟踪删除视图</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">tableView</span><span class="params">(UITableView, canFocusRowAt: IndexPath)</span></span> -&gt; <span class="type">Bool</span></span><br><span class="line"><span class="comment">//询问代理是否指定索引路径的单元格本身是可聚焦的。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">tableView</span><span class="params">(UITableView, shouldUpdateFocusIn: UITableViewFocusUpdateContext)</span></span> -&gt; <span class="type">Bool</span></span><br><span class="line"><span class="comment">//询问代理是否允许发生上下文指定的焦点更新。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">tableView</span><span class="params">(UITableView, didUpdateFocusIn: UITableViewFocusUpdateContext, with: UIFocusAnimationCoordinator)</span></span></span><br><span class="line"><span class="comment">//告诉委托者刚刚发生了上下文指定的焦点更新。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">indexPathForPreferredFocusedView</span><span class="params">(<span class="keyword">in</span>: UITableView)</span></span> -&gt; <span class="type">IndexPath?</span></span><br><span class="line"><span class="comment">//向委托询问首选焦点视图的表视图的索引路径。</span></span><br></pre></td></tr></table></figure><h1 id="UITableViewDataSource"><a href="#UITableViewDataSource" class="headerlink" title="UITableViewDataSource"></a>UITableViewDataSource</h1><p><code>UITableViewDataSource</code>用于管理数据并为表视图提供单元格的对象采用的方法。</p><p><code>UITableView</code>仅管理其数据的表示; 他们不管理数据本身。要管理数据，请为表提供数据源对象，即实现协议的对象。数据源对象响应来自表的与数据相关的请求。它还可以直接管理表格的数据，或与应用程序的其他部分协调以管理该数据。</p><ul><li>指定表中的节和行数。</li><li>为表的每一行提供单元格。</li><li>为节标题和页脚提供标题。</li><li>配置表的索引（如果有）。</li><li>响应需要更改基础数据的用户或表启动的更新。</li></ul><p><strong>指定行和节的位置</strong></p><p><code>UITableView</code>使用<code>NSIndexPath</code>对象的<code>row</code>和<code>section</code>属性来进行单元格的位置定位。行索引和节索引是从零开始的，所以第一节位于索引0，第二节位于索引1，依此类推。同样，每个节的第一行位于索引0处，这意味着您需要节值和行值来唯一标识行。如果表没有节，则只需要行值。</p><p><img src="rowandsection.png" alt></p><p><strong>该协议必须实现两个方法</strong></p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Return the number of rows for the table.     </span></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">tableView</span><span class="params">(<span class="number">_</span> tableView: UITableView, numberOfRowsInSection section: Int)</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Provide a cell object for each row.</span></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">tableView</span><span class="params">(<span class="number">_</span> tableView: UITableView, cellForRowAt indexPath: IndexPath)</span></span> -&gt; <span class="type">UITableViewCell</span> &#123;</span><br><span class="line">   <span class="comment">// Fetch a cell of the appropriate type.</span></span><br><span class="line">   <span class="keyword">let</span> cell = tableView.dequeueReusableCell(withIdentifier: <span class="string">"cellTypeIdentifier"</span>, <span class="keyword">for</span>: indexPath)</span><br><span class="line">   </span><br><span class="line">   <span class="comment">// Configure the cell’s contents.</span></span><br><span class="line">   cell.textLabel!.text = <span class="string">"Cell text"</span></span><br><span class="line">       </span><br><span class="line">   <span class="keyword">return</span> cell</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>使用此协议的其他方法为表启用特定功能。例如，您必须实现该方法以启用行的滑动到删除功能。<a href="https://developer.apple.com/documentation/uikit/uitableviewdatasource/1614871-tableview" target="_blank" rel="noopener"><code>tableView(_:commit:forRowAt:)</code></a></p></blockquote><h2 id="协议方法"><a href="#协议方法" class="headerlink" title="协议方法"></a><strong>协议方法</strong></h2><h3 id="提供行数和节数"><a href="#提供行数和节数" class="headerlink" title="提供行数和节数"></a>提供行数和节数</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">tableView</span><span class="params">(UITableView, numberOfRowsInSection: Int)</span></span> -&gt; <span class="type">Int</span></span><br><span class="line"><span class="comment">//告诉数据源返回表视图的给定部分中的行数。-- 需要。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">numberOfSections</span><span class="params">(<span class="keyword">in</span>: UITableView)</span></span> -&gt; <span class="type">Int</span></span><br><span class="line"><span class="comment">//要求数据源返回表视图中的节数。</span></span><br></pre></td></tr></table></figure><h3 id="提供单元格，页眉和页脚"><a href="#提供单元格，页眉和页脚" class="headerlink" title="提供单元格，页眉和页脚"></a>提供单元格，页眉和页脚</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">tableView</span><span class="params">(UITableView, cellForRowAt: IndexPath)</span></span> -&gt; <span class="type">UITableViewCell</span></span><br><span class="line"><span class="comment">//要求单元格的数据源插入表视图的特定位置。-- 需要。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">tableView</span><span class="params">(UITableView, titleForHeaderInSection: Int)</span></span> -&gt; <span class="type">String?</span></span><br><span class="line"><span class="comment">//向数据源询问表视图的指定部分的标题的标题。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">tableView</span><span class="params">(UITableView, titleForFooterInSection: Int)</span></span> -&gt; <span class="type">String?</span></span><br><span class="line"><span class="comment">//向数据源询问表视图的指定部分的页脚标题。</span></span><br></pre></td></tr></table></figure><h3 id="插入或删除表格行"><a href="#插入或删除表格行" class="headerlink" title="插入或删除表格行"></a>插入或删除表格行</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">tableView</span><span class="params">(UITableView, commit: UITableViewCell.EditingStyle, forRowAt: IndexPath)</span></span></span><br><span class="line"><span class="comment">//要求数据源提交插入或删除接收器中的指定行。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">tableView</span><span class="params">(UITableView, canEditRowAt: IndexPath)</span></span> -&gt; <span class="type">Bool</span></span><br><span class="line"><span class="comment">//要求数据源验证给定行是否可编辑。</span></span><br></pre></td></tr></table></figure><h3 id="重新排序表行-1"><a href="#重新排序表行-1" class="headerlink" title="重新排序表行"></a>重新排序表行</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">tableView</span><span class="params">(UITableView, canMoveRowAt: IndexPath)</span></span> -&gt; <span class="type">Bool</span></span><br><span class="line"><span class="comment">//询问数据源是否可以将给定行移动到表视图中的另一个位置。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">tableView</span><span class="params">(UITableView, moveRowAt: IndexPath, to: IndexPath)</span></span></span><br><span class="line"><span class="comment">//告知数据源将表视图中特定位置的行移动到另一个位置。</span></span><br></pre></td></tr></table></figure><h3 id="配置索引"><a href="#配置索引" class="headerlink" title="配置索引"></a>配置索引</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sectionIndexTitles</span><span class="params">(<span class="keyword">for</span>: UITableView)</span></span> -&gt; [<span class="type">String</span>]?</span><br><span class="line"><span class="comment">//要求数据源返回表视图部分的标题。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">tableView</span><span class="params">(UITableView, sectionForSectionIndexTitle: String, at: Int)</span></span> -&gt; <span class="type">Int</span></span><br><span class="line"><span class="comment">//要求数据源返回具有给定标题和节标题索引的节的索引。</span></span><br></pre></td></tr></table></figure><h1 id="UITableViewController"><a href="#UITableViewController" class="headerlink" title="UITableViewController"></a>UITableViewController</h1><p>一个用于专门管理UITableView的控制器。</p><p>当接口由表视图和很少或没有其他内容组成时，子类UITableViewController。表视图控制器已经采用了管理表视图内容和响应更改所需的协议。此外，UITableViewController实现以下行为：</p><ul><li>它自动加载存档在故事板或NIB文件中的表视图。使用TableView属性访问表视图。</li><li>它将表视图的数据源和委托设置为self。</li><li>它实现了<code>viewWillAppear(_:)</code>方法，并在第一次出现时自动为其表视图重新加载数据。每次显示表视图时，它都会清除其选择（有动画或无动画，具体取决于请求）；您可以通过更改<code>ClearSSelectionOnView</code>将显示属性中的值来禁用此行为。</li><li>它实现了<code>viewDidAppear(_:)</code>，并在表视图第一次出现时自动闪烁滚动指示器。</li><li>它实现<code>setEditing(_:animated:)</code>方法，并在用户点击导航栏中的编辑完成按钮时自动切换表的编辑模式。</li><li>它会自动调整其表视图的大小，以适应屏幕键盘的外观或消失。</li></ul><p>为所管理的每个表视图创建UITableViewController的自定义子类。初始化表视图控制器时，必须指定表视图的样式（普通或分组）。您还必须重写数据源和委托方法，以便用数据填充表。您可以重写<code>loadView()</code>或任何其他超类方法，但如果这样做，请确保调用该方法的超类实现，通常作为第一个方法调用。</p><h1 id="UITableView的静态单元格"><a href="#UITableView的静态单元格" class="headerlink" title="UITableView的静态单元格"></a>UITableView的静态单元格</h1><p>静态单元格：不会随数据的改变而改变，当在storyboard中创建好后，显示的数据内容和模板样式都固定不变。需要修改，只能在storyboard中修改。</p><p><strong>在storyboard文件中配置静态表：</strong></p><ol><li>将<a href="https://developer.apple.com/documentation/uikit/uitableviewcontroller" target="_blank" rel="noopener"><code>UITableViewController</code></a>对象添加到故事板。</li><li>选择表视图控制器的表视图。</li><li>将表视图的“内容”属性（在“属性”检查器中）更改为<code>Static Cells</code>。</li><li>使用表视图的Sections属性指定表的节数。</li><li>将每个部分的Row属性设置为所需的行数。</li><li>使用所需的视图和内容配置每个单元格。</li></ol><p><strong>注意</strong>：不能通过在UIView中拖拽UITableView的方式来使用静态单元格，需要创建新的UITableViewController，并在属性中将content改为Static Cells。否则会报该错误：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">error: Static table views are only valid when embedded <span class="keyword">in</span> UITableViewController instances [12]</span><br></pre></td></tr></table></figure><p>使用静态数据的表视图需要一个<a href="https://developer.apple.com/documentation/uikit/uitableviewcontroller" target="_blank" rel="noopener"><code>UITableViewController</code></a>对象来管理该数据。</p><p><strong>单元格Cell的Accessory属性</strong></p><p>通过设置单元格的Accessory属性来改变单元格右侧的图标样式，该属性名称为accessoryType，它是一个UITableViewCellAccessoryType类型的枚举，枚举量主要有以下几种：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">UITableViewCellAccessoryNone</span></span><br><span class="line">  <span class="comment">//单元格右侧没有标志</span></span><br><span class="line"><span class="built_in">UITableViewCellAccessoryDisclosureIndicator</span></span><br><span class="line">  <span class="comment">//单元格右侧有向右的小箭头标志</span></span><br><span class="line"><span class="built_in">UITableViewCellAccessoryDetailDisclosureButton</span></span><br><span class="line">  <span class="comment">//单元格右侧有一个详细信息标志和一个向右小箭头标志</span></span><br><span class="line"><span class="built_in">UITableViewCellAccessoryCheckmark</span></span><br><span class="line">  <span class="comment">//单元格右侧有一个对勾标志</span></span><br><span class="line"><span class="built_in">UITableViewCellAccessoryDetailButton</span></span><br><span class="line">  <span class="comment">//单元格右侧有一个详细信息标志</span></span><br></pre></td></tr></table></figure><blockquote><p>通过cell的<code>accessoryView</code>属性来自定义辅助指示视图,优先级比<code>accessoryType</code>高</p><p>关于它的使用：如果某个界面从加载完毕后就始终不会变化，则可以使用静态单元格。否则应使用动态单元格。静态单元格是在storyboard中创建的，但是它仍然是可以交互的。</p></blockquote><h2 id="案例1：仿一下微信我的"><a href="#案例1：仿一下微信我的" class="headerlink" title="案例1：仿一下微信我的"></a>案例1：仿一下微信我的</h2><p><img src="wechatme.jpeg" alt></p><p>在storyboard中创建一个UItableViewController，并将TableView的类型设置为<code>static cells</code>,并设置节数：</p><p><img src="staticlizi1.png" alt></p><p>将TableVIew的样式设置为Group：</p><p><img src="staticlizi6.png" alt></p><p>添加<code>TableViewCell</code>：</p><p><img src="staticlizi2.png" alt></p><p>设置<code>TableViewCell</code>的样式，案例设置为Basic即可。</p><p><img src="staticlizi3.png" alt></p><p>设置标题，图片，配置每节中的行数。设置完后的样式：</p><p><img src="staticlizi4.png" alt></p><p>也可以配置一下section header的高度</p><p><img src="staticlizi5.png" alt></p><p>如果需要设置小箭头则可以选择Accessory属性</p><p><img src="staticlizi8.png" alt></p><p>运行效果：</p><p><img src="staticlizi7.png" alt></p><h2 id="案例2：仿设置"><a href="#案例2：仿设置" class="headerlink" title="案例2：仿设置"></a>案例2：仿设置</h2><p>我们通常会在一些app中看到一些设置界面，一般都会使用静态单元格来实现，但是来看下面一个例子，</p><p><img src="staticlizi22.png" alt></p><p>可以看到推送按钮是经过一些动态变化的，那么如何用静态单元格实现呢，来仿造一下。</p><p>在storyboard中，使用UITableViewController进行图中的设置</p><p><img src="staticlizi23.png" alt></p><p>然后新建一个SettingTableViewController，在storyboard中将controller指向该类，实现代码：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> UIKit</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SettingTableViewController</span>: <span class="title">UITableViewController</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@IBOutlet</span> <span class="keyword">var</span> cell: <span class="type">UITableViewCell!</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.viewDidLoad()</span><br><span class="line">        <span class="keyword">let</span> settingswitch = <span class="type">UISwitch</span>(frame: .zero)</span><br><span class="line">        settingswitch.isOn = <span class="literal">true</span></span><br><span class="line">        cell.detailTextLabel?.isHidden = settingswitch.isOn</span><br><span class="line">        settingswitch.addTarget(<span class="keyword">self</span>, action: #selector(onSwitch(sender:)), <span class="keyword">for</span>: <span class="type">UIControl</span>.<span class="type">Event</span>.valueChanged)</span><br><span class="line">        cell.accessoryView = settingswitch</span><br><span class="line">        <span class="comment">// Uncomment the following line to preserve selection between presentations</span></span><br><span class="line">        <span class="comment">// self.clearsSelectionOnViewWillAppear = false</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Uncomment the following line to display an Edit button in the navigation bar for this view controller.</span></span><br><span class="line">        <span class="comment">// self.navigationItem.rightBarButtonItem = self.editButtonItem</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@objc</span> <span class="function"><span class="keyword">func</span> <span class="title">onSwitch</span><span class="params">(sender: UISwitch)</span></span> &#123;</span><br><span class="line">        cell.detailTextLabel?.isHidden = sender.isOn</span><br><span class="line">        <span class="keyword">if</span> sender.isOn &#123;</span><br><span class="line">            cell.detailTextLabel?.text = <span class="literal">nil</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            cell.detailTextLabel?.text = <span class="string">"你可能错过重要通知，点击打开"</span></span><br><span class="line">        &#125;</span><br><span class="line">        cell.layoutSubviews()</span><br><span class="line"><span class="comment">//        print(cell.detailTextLabel?.text)</span></span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src="staticlizi24.png" alt></p><h1 id="UITableView的动态单元格"><a href="#UITableView的动态单元格" class="headerlink" title="UITableView的动态单元格"></a>UITableView的动态单元格</h1><p>使用表格（<strong>UITableView</strong>）时，我们可以选择其采用静态单元格（<strong>Static Cell</strong>）还是动态单元格（<strong>Dynamic Cell</strong>）。前者使用方便，但是后者更加灵活。上面已经把一些需要用到的协议，类已经介绍了一遍。这里我们用案例来实战一遍。</p><p>假如这里我们有一批英雄联盟英雄的数据，存放在项目里，是一个plist文件。</p><p><img src="dataplist.png" alt></p><p>建立一个模型Hero类</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hero</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> name: <span class="type">String?</span></span><br><span class="line">    <span class="keyword">var</span> icon: <span class="type">String?</span></span><br><span class="line">    <span class="keyword">var</span> intro: <span class="type">String?</span></span><br><span class="line">    <span class="keyword">var</span> url: <span class="type">String?</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">init</span>(dict: [<span class="type">String</span>: <span class="type">AnyObject</span>]) &#123;</span><br><span class="line">        <span class="keyword">self</span>.name = dict[<span class="string">"name"</span>] <span class="keyword">as</span>? <span class="type">String</span></span><br><span class="line">        <span class="keyword">self</span>.icon = dict[<span class="string">"icon"</span>] <span class="keyword">as</span>? <span class="type">String</span></span><br><span class="line">        <span class="keyword">self</span>.intro = dict[<span class="string">"intro"</span>] <span class="keyword">as</span>? <span class="type">String</span></span><br><span class="line">        <span class="keyword">self</span>.url = dict[<span class="string">"url"</span>] <span class="keyword">as</span>? <span class="type">String</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里不使用<code>UITableViewController</code>，我们使用<code>UIViewController</code>来建立一个<code>UITableViewController</code>。并实现<code>UITableViewDelegate</code>, <code>UITableViewDataSource</code>协议。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DymViewController</span>: <span class="title">UIViewController</span>, <span class="title">UITableViewDelegate</span>, <span class="title">UITableViewDataSource</span></span></span><br></pre></td></tr></table></figure><p>新建一个<code>UITableView</code>成员变量，并在viewDIdLoad初始化。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">open</span> <span class="keyword">var</span> tableview: <span class="type">UITableView!</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">super</span>.viewDidLoad()</span><br><span class="line">  <span class="comment">//如果不指定tableView的样式，则默认使用UITableViewStylePlain样式。</span></span><br><span class="line">  <span class="keyword">self</span>.tableview = <span class="type">UITableView</span>(frame: <span class="keyword">self</span>.view.frame, style: <span class="type">UITableView</span>.<span class="type">Style</span>.plain);</span><br><span class="line">  <span class="keyword">self</span>.tableview.delegate = <span class="keyword">self</span>;</span><br><span class="line">  <span class="keyword">self</span>.tableview.dataSource = <span class="keyword">self</span>;</span><br><span class="line">  <span class="keyword">self</span>.view.addSubview(<span class="keyword">self</span>.tableview)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>新建一个data类来管理用于展示UITableView的数据类</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> data: [<span class="type">Hero</span>] &#123;</span><br><span class="line">  <span class="keyword">let</span> plistdata = <span class="type">NSArray</span>(contentsOfFile: <span class="type">Bundle</span>.main.path(forResource: <span class="string">"heros"</span>, ofType: <span class="string">"plist"</span>)!)!</span><br><span class="line">  <span class="keyword">var</span> heros: [<span class="type">Hero</span>] = [<span class="type">Hero</span>]()</span><br><span class="line">  <span class="keyword">var</span> hero: <span class="type">Hero</span></span><br><span class="line">  <span class="keyword">for</span> item <span class="keyword">in</span> plistdata &#123;</span><br><span class="line">    hero = <span class="type">Hero</span>(dict: item <span class="keyword">as</span>! [<span class="type">String</span>: <span class="type">AnyObject</span>])</span><br><span class="line">    heros.append(hero)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> heros</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现UITableVIewDataSource重要的两个协议方法：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">tableView</span><span class="params">(<span class="number">_</span> tableView: UITableView, numberOfRowsInSection section: Int)</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> data.<span class="built_in">count</span>;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">tableView</span><span class="params">(<span class="number">_</span> tableView: UITableView, cellForRowAt indexPath: IndexPath)</span></span> -&gt; <span class="type">UITableViewCell</span> &#123;</span><br><span class="line">  <span class="comment">//创建样式为Basic的UItableViewCell</span></span><br><span class="line">  <span class="keyword">let</span> cell = <span class="type">UITableViewCell</span>(style: <span class="type">UITableViewCell</span>.<span class="type">CellStyle</span>.subtitle, reuseIdentifier: <span class="literal">nil</span>)</span><br><span class="line">  cell.imageView?.image = <span class="type">UIImage</span>(named: data[indexPath.row].icon!)</span><br><span class="line">  cell.textLabel?.text = data[indexPath.row].name</span><br><span class="line">  cell.detailTextLabel?.text = data[indexPath.row].intro</span><br><span class="line">  <span class="keyword">return</span> cell;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行效果：</p><p><img src="dymlizi1.png" alt></p><blockquote><p>性能优化在这里不考虑</p></blockquote><p><strong>但是英雄也有分类，比如有战士、法师、射手等的分类，我们再修改一下plist的文件。</strong></p><p><img src="dymlizi2.png" alt></p><p>再新建一个plist存放归类的译文。</p><p><img src="dymlizi3.png" alt></p><p>新建一个DymGroupViewController，这里不在原来代码修改。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DymGroupViewController</span>: <span class="title">UIViewController</span>, <span class="title">UITableViewDelegate</span>, <span class="title">UITableViewDataSource</span></span></span><br></pre></td></tr></table></figure><p>新建一个<code>UITableView</code>成员变量，并在viewDIdLoad初始化。这里注意，TableView的样式要做改变。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">open</span> <span class="keyword">var</span> tableview: <span class="type">UITableView!</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">super</span>.viewDidLoad()</span><br><span class="line">  <span class="comment">//如果不指定tableView的样式，则默认使用UITableViewStylePlain样式。</span></span><br><span class="line">  <span class="keyword">self</span>.tableview = <span class="type">UITableView</span>(frame: <span class="keyword">self</span>.view.frame, style: <span class="type">UITableView</span>.<span class="type">Style</span>.grouped);</span><br><span class="line">  <span class="keyword">self</span>.tableview.delegate = <span class="keyword">self</span>;</span><br><span class="line">  <span class="keyword">self</span>.tableview.dataSource = <span class="keyword">self</span>;</span><br><span class="line">  <span class="keyword">self</span>.view.addSubview(<span class="keyword">self</span>.tableview)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的数据获取也有很大的改动</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//分类key数组：例如Support、Tank</span></span><br><span class="line"><span class="keyword">var</span> categoryname: [<span class="type">String</span>] &#123;</span><br><span class="line">  <span class="keyword">let</span> plistdata = <span class="type">NSDictionary</span>(contentsOfFile: <span class="type">Bundle</span>.main.path(forResource: <span class="string">"category"</span>, ofType: <span class="string">"plist"</span>)!)!</span><br><span class="line">  <span class="keyword">return</span> plistdata.allKeys <span class="keyword">as</span>! [<span class="type">String</span>]</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="comment">//对应分类key数组的译文：例如Support对应辅助，Tank对应坦克</span></span><br><span class="line"><span class="keyword">var</span> categoryvalue: [<span class="type">String</span>] &#123;</span><br><span class="line">  <span class="keyword">let</span> plistdata = <span class="type">NSDictionary</span>(contentsOfFile: <span class="type">Bundle</span>.main.path(forResource: <span class="string">"category"</span>, ofType: <span class="string">"plist"</span>)!)!</span><br><span class="line">  <span class="keyword">return</span> plistdata.allValues <span class="keyword">as</span>! [<span class="type">String</span>]</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="comment">//所有英雄数据的存放，并分类存放了英雄的分类，即用key来存放对应一个英雄的列表数组</span></span><br><span class="line"><span class="keyword">var</span> data: [<span class="type">String</span>: <span class="type">Array</span>&lt;<span class="type">Hero</span>&gt;] &#123;</span><br><span class="line">  <span class="keyword">let</span> plistdata = <span class="type">NSDictionary</span>(contentsOfFile: <span class="type">Bundle</span>.main.path(forResource: <span class="string">"herosgroup"</span>, ofType: <span class="string">"plist"</span>)!)!</span><br><span class="line">  <span class="keyword">var</span> rd: [<span class="type">String</span>: <span class="type">Array</span>&lt;<span class="type">Hero</span>&gt;] = [<span class="type">String</span>: <span class="type">Array</span>&lt;<span class="type">Hero</span>&gt;]()</span><br><span class="line">  <span class="keyword">var</span> heros: [<span class="type">Hero</span>]</span><br><span class="line">  <span class="keyword">for</span> (items,value) <span class="keyword">in</span> plistdata &#123;</span><br><span class="line">    heros = [<span class="type">Hero</span>]()</span><br><span class="line">    <span class="keyword">var</span> hero: <span class="type">Hero</span></span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> value <span class="keyword">as</span>! [[<span class="type">String</span>: <span class="type">AnyObject</span>]] &#123;</span><br><span class="line">      hero = <span class="type">Hero</span>(dict: item)</span><br><span class="line">      heros.append(hero)</span><br><span class="line">    &#125;</span><br><span class="line">    rd[items <span class="keyword">as</span>! <span class="type">String</span>] = heros</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> rd</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>设置好对应的section数和对应section数的行数，并设置section header的标题。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//对数据进行分组展示</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">numberOfSections</span><span class="params">(<span class="keyword">in</span> tableView: UITableView)</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> categoryname.<span class="built_in">count</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//对应每个分组下的英雄列表数量</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">tableView</span><span class="params">(<span class="number">_</span> tableView: UITableView, numberOfRowsInSection section: Int)</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> data[categoryname[section]]!.<span class="built_in">count</span></span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="comment">//列表的展示</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">tableView</span><span class="params">(<span class="number">_</span> tableView: UITableView, cellForRowAt indexPath: IndexPath)</span></span> -&gt; <span class="type">UITableViewCell</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> cell: <span class="type">UITableViewCell</span> = <span class="type">UITableViewCell</span>(style: <span class="type">UITableViewCell</span>.<span class="type">CellStyle</span>.subtitle, reuseIdentifier: <span class="literal">nil</span>)</span><br><span class="line">  <span class="keyword">let</span> hero = data[categoryname[indexPath.section]]![indexPath.row]</span><br><span class="line">  cell.imageView?.image = <span class="type">UIImage</span>(named: hero.icon!)</span><br><span class="line">  cell.textLabel?.text = hero.name</span><br><span class="line">  cell.detailTextLabel?.text = hero.intro</span><br><span class="line">  <span class="keyword">return</span> cell</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">tableView</span><span class="params">(<span class="number">_</span> tableView: UITableView, titleForHeaderInSection section: Int)</span></span> -&gt; <span class="type">String?</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> categoryvalue[section]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行效果：</p><p><img src="dymlizi4.png" alt></p><p>到这一步后，我们会发现点击列表没有反应，我们来实现一下跳转到网页，英雄数据里面有一个url属性就是跳转的地址。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">tableView</span><span class="params">(<span class="number">_</span> tableView: UITableView, didSelectRowAt indexPath: IndexPath)</span></span> &#123;</span><br><span class="line">  <span class="built_in">print</span>(indexPath.row, indexPath.section)</span><br><span class="line">  <span class="keyword">let</span> url = <span class="type">URL</span>(string: data[categoryname[indexPath.section]]![indexPath.row].url!)!</span><br><span class="line">  <span class="type">UIApplication</span>.shared.openURL(url)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>跳转后效果：</p><p><img src="dymlizi5.png" alt></p><h1 id="自定义UITableViewCell"><a href="#自定义UITableViewCell" class="headerlink" title="自定义UITableViewCell"></a>自定义UITableViewCell</h1><h2 id="静态单元格中使用自定义Cell"><a href="#静态单元格中使用自定义Cell" class="headerlink" title="静态单元格中使用自定义Cell"></a>静态单元格中使用自定义Cell</h2><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://developer.apple.com/documentation/uikit/uitableview" target="_blank" rel="noopener">https://developer.apple.com/documentation/uikit/uitableview</a></p><p><a href="https://developer.apple.com/documentation/uikit/uitableviewdatasource" target="_blank" rel="noopener">https://developer.apple.com/documentation/uikit/uitableviewdatasource</a></p><p><a href="https://developer.apple.com/documentation/uikit/uitableviewdelegate" target="_blank" rel="noopener">https://developer.apple.com/documentation/uikit/uitableviewdelegate</a></p><p><a href="https://developer.apple.com/documentation/uikit/uitableviewcell" target="_blank" rel="noopener">https://developer.apple.com/documentation/uikit/uitableviewcell</a></p><p><a href="https://developer.apple.com/documentation/uikit/views_and_controls/table_views/filling_a_table_with_data" target="_blank" rel="noopener">https://developer.apple.com/documentation/uikit/views_and_controls/table_views/filling_a_table_with_data</a></p><p><a href="https://developer.apple.com/documentation/uikit/views_and_controls/table_views/configuring_the_cells_for_your_table" target="_blank" rel="noopener">https://developer.apple.com/documentation/uikit/views_and_controls/table_views/configuring_the_cells_for_your_table</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;简述&quot;&gt;&lt;a href=&quot;#简述&quot; class=&quot;headerlink&quot; title=&quot;简述&quot;&gt;&lt;/a&gt;简述&lt;/h1&gt;&lt;p&gt;iOS的&lt;code&gt;UITableView&lt;/code&gt;显示单列垂直滚动内容。表格中的每一行都包含一段应用内容。例如，“联系人”应用程序在单独的行中显示每个联系人的姓名，“设置”应用程序的主页面显示可用的设置组。您可以将表配置为显示单个长行列表，也可以将相关行分组为多个部分，以便更轻松地导航内容。&lt;/p&gt;
    
    </summary>
    
      <category term="Ios" scheme="http://hackycy.github.io/categories/Ios/"/>
    
    
      <category term="Ios" scheme="http://hackycy.github.io/tags/Ios/"/>
    
      <category term="Swift" scheme="http://hackycy.github.io/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title>Xcode报错修复Multiple commands produce</title>
    <link href="http://hackycy.github.io/2019/07/13/Xcode%E6%8A%A5%E9%94%99%E4%BF%AE%E5%A4%8DMultiple-commands-produce/"/>
    <id>http://hackycy.github.io/2019/07/13/Xcode报错修复Multiple-commands-produce/</id>
    <published>2019-07-13T09:17:38.000Z</published>
    <updated>2019-07-13T09:41:01.209Z</updated>
    
    <content type="html"><![CDATA[<p><strong>Xcode版本：10.2.1</strong></p><p>今天导入了一个Demo项目，出现了<strong>Multiple commands produce</strong>错误，记录下解决办法。</p><a id="more"></a><p>Xcode10使用了一个的新创建系统，比之前的提供更好的可靠性与创建性能，而且可以获取项目配置问题（默认设置新创建系统）</p><blockquote><p>Build System</p><p>Again, Xcode 10 uses a new build system. The new build system provides improved reliability and build performance, and it catches project configuration problems that the legacy build system does not.<br>The legacy build system is still available in Xcode 10. To use the legacy build system, select it in the File &gt; Project/Workspace Settings sheet. Projects configured to use the legacy build system will display an orange hammer icon in the Activity View.</p></blockquote><p>在苹果文档中，提及Xcode10中的关于旧项目New Build System更改适配中提及到以下两点</p><blockquote><p>The new build system has stricter checks for cycles between elements in the build in order to prevent unnecessary rebuilds.</p><p>It is an error for any individual file in the build to be produced by more than one build command. For example, if two targets each declare the same output file from a shell script phase, factor out the declaration of the output file into a single target.</p></blockquote><p>New Build System会对构建中的元素循环进行严格的检查，避免不必要的重建，这个也是错误出现的原因。</p><p><strong>错误信息</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">error: Multiple commands produce <span class="string">'/Users/zjyzy/Library/Developer/Xcode/DerivedData/UMengComDemo-eisszriydfvwtlgnymkievxxjndx/Build/Products/Debug-iphonesimulator/UMengComDemo.app/Info.plist'</span>:</span><br><span class="line">1) Target <span class="string">'UMengComDemo'</span> (project <span class="string">'UMengComDemo'</span>) has copy <span class="built_in">command</span> from <span class="string">'/Users/zjyzy/WorkPlace/xcode/AllDemo/test/MultiFunctioniOSDemo/UMengComDemo/Info.plist'</span> to <span class="string">'/Users/zjyzy/Library/Developer/Xcode/DerivedData/UMengComDemo-eisszriydfvwtlgnymkievxxjndx/Build/Products/Debug-iphonesimulator/UMengComDemo.app/Info.plist'</span></span><br><span class="line">2) Target <span class="string">'UMengComDemo'</span> (project <span class="string">'UMengComDemo'</span>) has process <span class="built_in">command</span> with output <span class="string">'/Users/zjyzy/Library/Developer/Xcode/DerivedData/UMengComDemo-eisszriydfvwtlgnymkievxxjndx/Build/Products/Debug-iphonesimulator/UMengComDemo.app/Info.plist'</span></span><br></pre></td></tr></table></figure><p><strong>解决方案</strong></p><ul><li><p>不使用<code>New Build System</code></p><p>打开<code>Xcode</code> &gt; <code>File</code> &gt; <code>Project Setting</code></p><p><img src="fix1.png" alt></p><p>将<code>Build System</code>选项选择为<code>Legacy Build System</code>即可。</p></li><li><p>根据出错信息，在新创建系统模式下，去除多余的引用重建</p><p><img src="fix2.png" alt></p><p>在<code>target</code> -&gt; <code>Build phase</code> &gt; <code>Copy Bundle Resource</code> 中找到<code>info.plist</code>，移除掉<code>info.plist</code>即可。</p></li></ul><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://www.jianshu.com/p/fdb1421f3c8b" target="_blank" rel="noopener">https://www.jianshu.com/p/fdb1421f3c8b</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;Xcode版本：10.2.1&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;今天导入了一个Demo项目，出现了&lt;strong&gt;Multiple commands produce&lt;/strong&gt;错误，记录下解决办法。&lt;/p&gt;
    
    </summary>
    
      <category term="Ios" scheme="http://hackycy.github.io/categories/Ios/"/>
    
    
      <category term="Ios" scheme="http://hackycy.github.io/tags/Ios/"/>
    
  </entry>
  
  <entry>
    <title>Xcode报错修复SWIFT_VERSION &#39;3.0&#39; is unsupported, supported versions are:4.0,4.2,5.0</title>
    <link href="http://hackycy.github.io/2019/07/13/Xcode%E6%8A%A5%E9%94%99%E4%BF%AE%E5%A4%8DSWIFT-VERSION-3-0-is-unsupported-supported-versions-are-4-0-4-2-5-0/"/>
    <id>http://hackycy.github.io/2019/07/13/Xcode报错修复SWIFT-VERSION-3-0-is-unsupported-supported-versions-are-4-0-4-2-5-0/</id>
    <published>2019-07-13T09:01:35.000Z</published>
    <updated>2019-07-13T09:40:57.411Z</updated>
    
    <content type="html"><![CDATA[<p><strong>Xcode版本：10.2.1</strong></p><p>今天导入了一个Demo项目，出现了SWIFT_VERSION ‘3.0’ is unsupported, supported versions are: 4.0, 4.2, 5.0.错误，记录下解决办法。</p><a id="more"></a><p><img src="errorpic.png" alt></p><p><img src="errorpic2.png" alt></p><p><strong>解决方法：</strong></p><p>找到发生错误的Target：</p><p><img src="fix1.png" alt></p><p><img src="fix2.png" alt></p><p>步骤： <code>${Target}</code> &gt;<code>Build Settings</code> &gt; <code>Swift Compiler - Language</code> &gt; <code>Swift Language Version</code>选择支持的版本即可。</p><p><img src="fix3.png" alt></p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://www.jianshu.com/p/bdfcb8759dee" target="_blank" rel="noopener">https://www.jianshu.com/p/bdfcb8759dee</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;Xcode版本：10.2.1&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;今天导入了一个Demo项目，出现了SWIFT_VERSION ‘3.0’ is unsupported, supported versions are: 4.0, 4.2, 5.0.错误，记录下解决办法。&lt;/p&gt;
    
    </summary>
    
      <category term="Ios" scheme="http://hackycy.github.io/categories/Ios/"/>
    
    
      <category term="Ios" scheme="http://hackycy.github.io/tags/Ios/"/>
    
  </entry>
  
  <entry>
    <title>Android O应用图标适配</title>
    <link href="http://hackycy.github.io/2019/07/13/Android-O%E5%BA%94%E7%94%A8%E5%9B%BE%E6%A0%87%E9%80%82%E9%85%8D/"/>
    <id>http://hackycy.github.io/2019/07/13/Android-O应用图标适配/</id>
    <published>2019-07-13T02:58:52.000Z</published>
    <updated>2019-07-14T07:49:03.600Z</updated>
    
    <content type="html"><![CDATA[<p>Android 8.0现在已经很普及了，甚至有的厂商已经开始升级到Android P，至少我的三星上个星期也是7月初就开始推送Android P让我更新自己的手机系统了，那么应用图标的适配就肯定是板上钉钉的事情了。</p><a id="more"></a><h1 id="前景"><a href="#前景" class="headerlink" title="前景"></a>前景</h1><p><strong>手机应用图标的历史</strong>：其实要从苹果开始讲起。在上世纪80年代，苹果还在设计Lisa和Macintosh电脑的时候，乔布斯就是个圆角矩形的狂热支持者。当时苹果的工程师写出了一套绝妙的算法，可以在电脑上绘制出圆和椭圆，所有观看者都被震惊了，除了乔布斯，因为乔布斯觉得圆和椭圆虽然也不错，但是如果能绘制出带圆角的矩形就更好了。当时那位工程师觉得这是不可能实现的，而且也完全用不着圆角矩形，能满足基本的绘图需求就可以了。乔布斯愤怒地拉着他走了3条街，指出大街上各种应用圆角矩形的例子，最后那位工程师第二天就做出了绘制圆角矩形的功能。</p><p>因此，在2007年一代iPhone诞生的时候，所有应用程序的图标都毫不出乎意料地使用了圆角矩形图标，即使是第三方应用也被强制要求使用圆角矩形图标，并且这一规则一直延续到了今天的iOS 11当中，如下图所示：</p><p><img src="iosicon.jpg" alt></p><p>相反，Android系统在设计的时候就不喜欢苹果这样的封闭与强制，而是选择了自由与开放，对应用图标的形状不做任何强制要求，开发者们可以自由进行选择：</p><p><img src="androidicon.jpg" alt></p><p>可以看到，在Android上，应用图标可以是方形、圆形、圆角矩形、或者是其他任意不规则图形。</p><p>本来就是两家公司不同的设计理念，也说不上孰高孰低。但由于Android操作系统是开源的，国内一些手机厂商在定制操作系统的时候就把这一特性给改了。比如小米手机，就选择了向苹果靠拢，强制要求应用图标圆角化。如果某些应用的图标不是圆角矩形的呢？小米系统会自动给它加上一个圆角的效果，如下图所示：</p><p><img src="miicon.jpg" alt></p><p>小米的这种做法看上去是向苹果学习，但实际上是相当恶心的。因为谁都可以看出来，这种自动添加的圆角矩形非常丑，因此很多公司就索性直接将应用的图标都设计成圆角矩形的，正好Android和iOS都用同一套图标还省事了。</p><p>但是这就让Google不开心了，这不是变向强制要求开发者必须将图标设计成圆角矩形吗？于是在去年的Google I/O大会上，Google点名批评了小米的这种做法，说其违反了Android自由和开放的理念。</p><p>除了变向强制要求应用图标圆角化，小米的这种处理方式还有一个弊端，就是如果应用图标的圆角弧度和小米系统要求的不同，那么会出现异常丑陋的效果。</p><p><img src="miicon2.webp" alt></p><p>该问题也存在了非常之久，Google多年来对此也是睁一只眼闭一只眼。终于在Android 8.0系统中，Google下定决心要好好整治一下Android应用图标的规范性了。</p><blockquote><p>原文来自郭林</p></blockquote><h1 id="8-0系统的应用图标适配"><a href="#8-0系统的应用图标适配" class="headerlink" title="8.0系统的应用图标适配"></a>8.0系统的应用图标适配</h1><p>这个问题对于Google来说还是挺难解决的。因为Google一直在强调自由与开放，那么小米强制要求所有应用图标都必须圆角化也是人家的自由呀，你不准人家这么干是不是本身就违背了自由和开放的理念呢？当然我们在这里讨论这个，有点像讨论先有鸡还是先有蛋的感觉，不过Google还是想出了一套完美的解决方案。</p><p>从Android 8.0系统开始，应用程序的图标被分为了两层：前景层和背景层。也就是说，我们在设计应用图标的时候，需要将前景和背景部分分离，前景用来展示应用图标的Logo，背景用来衬托应用图标的Logo。需要注意的是，背景层在设计的时候只允许定义颜色和纹理，但是不能定义形状。</p><p>那么应用图标的形状由谁来定义呢？Google将这个权利就交给手机厂商了。不是有些手机厂商喜欢学习苹果的圆角图标吗？没问题，由于应用图标的设计分为了两层，手机厂商只需要在这两层之上再盖上一层mask，这个mask可以是圆角矩形、圆形或者是方形等等，视具体手机厂商而定，就可以瞬间让手机上的所有应用图标都变成相同的规范。原理示意图如下：</p><p><img src="oicon.gif" alt></p><p>可以看到，这里背景层是一张蓝色的网格图，前景层是一张Android机器人Logo图，然后盖上一层圆形的mask，最终就裁剪出了一张圆形的应用图标。</p><p>官方命名为Adaptive Icons。</p><blockquote><p>如果你的APP中的targetSdkVersion是低于26的，那么就可以不用进行应用图标适配，Android 8.0系统仍然是向下兼容的。但是如果你将targetSdkVersion指定到了26或者更高，那么Android系统就会认为你的APP已经做好了8.0系统的适配工作，当然包括了应用图标的适配。(图标会有点丑)</p></blockquote><h1 id="适配方案"><a href="#适配方案" class="headerlink" title="适配方案"></a>适配方案</h1><p>Android Studio 3.0以上的版本中已经内置了8.0系统应用图标适配的功能。</p><p>新建一个项目，并查看app的gradle是否已经将targetSdkVersion设置为26。</p><p>在查看一下AndroidManifest.xml文件</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">application</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:icon</span>=<span class="string">"@mipmap/ic_launcher"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:label</span>=<span class="string">"IconDemo"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:roundIcon</span>=<span class="string">"@mipmap/ic_launcher_round"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:theme</span>=<span class="string">"@style/AppTheme"</span>&gt;</span></span><br><span class="line">  //.....</span><br><span class="line"><span class="tag">&lt;/<span class="name">application</span>&gt;</span></span><br></pre></td></tr></table></figure><p>我们需要关注的点是android:icon这个属性，通过这个属性，我们将应用的图标指定为了mipmap目录下的ic_launcher文件。</p><blockquote><p>还有一个android:roundIcon属性，这是一个只适用在Android 7.1系统上的过渡版本，很快就被8.0系统的应用图标适配所替代了，我们不用去管它。</p></blockquote><p><img src="shipei1.png" alt></p><p>在和以前版本不一样的地方就在于多了一个<code>mipmap-anydpi-v26</code>的目录，该目录会使得Android 8.0或以上系统的手机，都会使用这个目录下的ic_launcher来作为图标。</p><p>mipmap-anydpi-v26目录下的ic_launcher并不是一张图片，而是一个XML文件，我们打开这个文件看一下，代码如下所示：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">adaptive-icon</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">background</span> <span class="attr">android:drawable</span>=<span class="string">"@drawable/ic_launcher_background"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">foreground</span> <span class="attr">android:drawable</span>=<span class="string">"@drawable/ic_launcher_foreground"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">adaptive-icon</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这是一个8.0系统应用图标适配的标准写法，在<code>&lt;adaptive-icon&gt;</code>标签中定义一个<code>&lt;background&gt;</code>标签用于指定图标的背景层，定义一个<code>&lt;foreground&gt;</code>标签用于指定图标的前景层。</p><p>再打开ic_launcher_background和ic_launcher_foreground后，发现他们只是一个使用SVG格式绘制出来的带纹理的底图。</p><blockquote><p>SVG格式的图片都是使用AI、PS等图像编辑软件制作之后导出的，基本没有人可以手工编写SVG图片。</p></blockquote><p>一般项目中也可以使用PNG、JPG等格式的图片，或者是一个背景色也可以。</p><p><img src="runprev.png" alt></p><p>这就是一个前景层盖在背景层上，然后再被圆形mask进行裁剪之后的效果。</p><h1 id="开始适配"><a href="#开始适配" class="headerlink" title="开始适配"></a>开始适配</h1><p>这里的话拿推特的图标作为例子，案例图在下方：</p><p><img src="tuite.png" alt></p><p><img src="tuite_forge.png" alt></p><p>背景色用PS提取出来的颜色值是#1da2f2。</p><p>图标已经准备好了，我们开始做图标适配了，回到项目中，然后按下Windows：Ctrl+Shift+A / Mac：command+shft+A 快捷键，并输入Image Asset，如下所示：</p><p><img src="imageassets.png" alt></p><p>当然也可以对着app(module)目录下右键新建</p><p><img src="imageassetsother.png" alt></p><p>点击回车键打开Asset Studio编辑器，在这里就可以进行应用图标适配了。</p><p><img src="adapter1.png" alt></p><p>这个Asset Studio编辑器非常简单好用，一学就会。左边是操作区域，右边是预览区域。</p><p>先来看操作区域，第一行的<code>Icon Type</code>中选择<code>Adaptive and Legacy</code>，表示同时创建兼容8.0系统以及老版本系统的应用图标。第二行的Name用于指定应用图标的名称，这里也保持默认即可。接下来的三个页签，<code>Foreground Layer</code>用于编辑前景层，<code>Background Layer</code>用于编辑背景层，<code>Legacy</code>用于编辑老版本系统的图标。</p><p>再来看预览区域，这个就十分简单了，用于预览应用图标的最终效果。在预览区域中给出了可能生成的图标形状，包括圆形、圆角矩形、方形等等。</p><p><strong>注意每个预览图标中都有一个圆圈，这个圆圈叫作安全区域，必须要保证图标的前景层完全处于安全区域当中才行，否则可能会出现图标被手机厂商的mask裁剪掉的情况。</strong></p><p>放一张GIF操作过程：(PS:图比较大，不太懂的压缩)</p><p><img src="demo.gif" alt></p><p>Android Studio会自动帮我们生成适配8.0系统的应用图标，以及适配老版本系统的应用图标。</p><p>来看看运行效果：</p><p><img src="demo2.png" alt></p><p>这里适配就完成啦。</p><h1 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h1><p>Asset Studio自动生成的ic_launcher图标和ic_launcher_round分辨率比较低，在vivo厂商上架应用过程中被提示出将其替换为高清图标，按照vivo提示替换即可。</p><h1 id="参数说明"><a href="#参数说明" class="headerlink" title="参数说明"></a>参数说明</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Layer Name - 图层名称</span><br><span class="line">Resize - 制定大小</span><br><span class="line">Round Icon - 仅针对android 7.1 icon处理</span><br><span class="line">Google Play Store Icon - 在google play商店中展示图标</span><br><span class="line">Icon Type - Launcher Icons(Legacy only)</span><br><span class="line">Asset Type - 资源类型，可选图片，剪切画，文本</span><br><span class="line">Path - 资源路径</span><br><span class="line">Name - 如果您不想使用默认名称，可以键入一个新名称。如果资源名称已在项目中存在（向导底部出现错误提示），它将被覆盖。名称只能包含小写字符、下划线和数字。</span><br><span class="line">Trim - 要调整源资产中图标图形与边框之间的边距，请选择 Yes。此操作将移除透明空间，同时保留纵横比。要保持源资产不变，请选择 No。默认值为：No</span><br><span class="line">Padding - 如果您想要调整全部四侧的源资产内边距，请移动滑块。选择 -10% 和 50% 之间的值。如果您也选择了 Trim，则首先会进行剪裁。默认值为：0%</span><br><span class="line">Foreground - 要更改 Clip Art 或 Text 图标的前景色，请点击字段。在 Select Color 对话框中，指定颜色，然后点击 Choose。字段中会显示新值。默认值为：000000</span><br><span class="line">Background - 要更改背景色，请点击字段。在 Select Color 对话框中，指定颜色，然后点击 Choose。字段中会显示新值。默认值为：FFFFFF</span><br><span class="line">Scaling - 要适合图标大小，请选择 Crop 或 Shrink to Fit。选择裁剪，图像边缘会被剪切；选择缩减，图像边缘不会被剪切。源资产仍然不合适时，如果需要，您可以调整内边距。默认值为：Shrink to Fit</span><br><span class="line">Shape - 要为您的源资产添加背景，请选择形状，选项包括圆、正方形、竖直矩形或水平矩形。要想使用透明的背景，请选择 None。默认值为：Square</span><br><span class="line">Effect - 如果您想要为正方形或矩形的右上角添加折角效果，请选择 DogEar。如果不需要，请选择 None。默认值为：None</span><br></pre></td></tr></table></figure><p><a href="https://developer.android.com/studio/write/image-asset-studio?hl=zh-cn" target="_blank" rel="noopener">https://developer.android.com/studio/write/image-asset-studio?hl=zh-cn</a></p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://medium.com/google-design/understanding-android-adaptive-icons-cee8a9de93e2" target="_blank" rel="noopener">https://medium.com/google-design/understanding-android-adaptive-icons-cee8a9de93e2</a></p><p><a href="https://mp.weixin.qq.com/s/WxgHJ1stBjokPi6lTUd1Mg" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/WxgHJ1stBjokPi6lTUd1Mg</a></p><p><a href="https://developer.android.com/guide/practices/ui_guidelines/icon_design_adaptive" target="_blank" rel="noopener">https://developer.android.com/guide/practices/ui_guidelines/icon_design_adaptive</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Android 8.0现在已经很普及了，甚至有的厂商已经开始升级到Android P，至少我的三星上个星期也是7月初就开始推送Android P让我更新自己的手机系统了，那么应用图标的适配就肯定是板上钉钉的事情了。&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="http://hackycy.github.io/categories/Android/"/>
    
    
      <category term="Android" scheme="http://hackycy.github.io/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>解决Android Studio——No toolchains found in the NDK toolchains folder for ABI with prefix: mips64el-linux-android错误</title>
    <link href="http://hackycy.github.io/2019/07/12/%E8%A7%A3%E5%86%B3Android-Studio%E2%80%94%E2%80%94No-toolchains-found-in-the-NDK-toolchains-folder-for-ABI-with-prefix-mips64el-linux-android%E9%94%99%E8%AF%AF/"/>
    <id>http://hackycy.github.io/2019/07/12/解决Android-Studio——No-toolchains-found-in-the-NDK-toolchains-folder-for-ABI-with-prefix-mips64el-linux-android错误/</id>
    <published>2019-07-12T03:11:34.000Z</published>
    <updated>2019-07-12T03:17:29.887Z</updated>
    
    <content type="html"><![CDATA[<p>今天导入了一个比较老一些的项目，AS一直提示出该错误：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">No toolchains found <span class="keyword">in</span> the NDK toolchains folder <span class="keyword">for</span> ABI with prefix: mips64el-linux-android</span><br></pre></td></tr></table></figure><a id="more"></a><p>查了网上一些解决办法，可用的办法是该办法：</p><p><strong>解决方案：</strong></p><ol><li>修改build.gradle中的Gradle Build Tool版本，改为3.1以及以上版本</li><li>将Android Studio升级到3.1以及以上版本</li></ol><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    classpath <span class="string">'com.android.tools.build:gradle:3.2.0'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>问题原因：</strong></p><p>NDK的更新记录里有一段话：</p><blockquote><p>This version of the NDK is incompatible with the Android Gradle plugin<br>version 3.0 or older. If you see an error like<br><code>No toolchains found in the NDK toolchains folder for ABI with prefix: mips64el-linux-android</code>,<br>update your project file to [use plugin version 3.1 or newer]. You will also<br>need to upgrade to Android Studio 3.1 or newer.</p></blockquote><p>即新版本的NDK与3.0及以前旧版的Android Gradle plugin插件不兼容</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://cloud.tencent.com/developer/article/1379721" target="_blank" rel="noopener">https://cloud.tencent.com/developer/article/1379721</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天导入了一个比较老一些的项目，AS一直提示出该错误：&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;No toolchains found &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; the NDK toolchains folder &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; ABI with prefix: mips64el-linux-android&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="Android" scheme="http://hackycy.github.io/categories/Android/"/>
    
    
      <category term="Android" scheme="http://hackycy.github.io/tags/Android/"/>
    
      <category term="Android Studio" scheme="http://hackycy.github.io/tags/Android-Studio/"/>
    
  </entry>
  
</feed>
