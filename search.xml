<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Android P/9.0 http网络请求异常问题]]></title>
    <url>%2F2019%2F03%2F06%2FAndroid-P-9-0-http%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82%E5%BC%82%E5%B8%B8%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[使用Android P系统时，app使用http请求出现异常。 异常原因 Google表示，为保证用户数据和设备的安全，针对下一代 Android 系统(Android P)的应用程序，将要求默认使用加密连接，这意味着 Android P 将禁止 App使用所有未加密的连接，因此运行 Android P系统的安卓设备无论是接收或者发送流量，未来都不能明码传输，需要使用下一代(Transport LayerSecurity)传输层安全协议，而 Android Nougat 和 Oreo 则不受影响。 因此在Android P中使用HttpUrlConnection时会报出次异常 1W/System.err: java.io.IOException: Cleartext HTTP traffic to **** not permitted 而使用OKHttp时，同样也会报出异常 1java.net.UnknownServiceException: CLEARTEXT communication ** not permitted by network security policy 在Android P系统的设备上，如果应用使用的是非加密的明文流量的http网络请求，则会导致该应用无法进行网络请求，https则不会受影响，同样地，如果应用嵌套了webview，webview也只能使用https请求。有人认为 Android P 上所有的 App 都需要使用 TLS 加密会降低上网体验，事实上这是一种误解，至于 App 对于少数旧服务器的连接如果非要使用明码传输，开发者需要更改 App 的网络安全配置以允许此类连接。 解决方案APP内所有请求更改为Https将targetSdkVersion改为27以下开启/允许http请求在res下新增一个xml目录，然后创建一个名为：network_security_config.xml 文件（名字自定） ，内容如下，大概意思就是允许开启http请求 1234567&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;network-security-config&gt; &lt;base-config cleartextTrafficPermitted="true" /&gt;&lt;/network-security-config&gt; 然后在AndroidManifest.xml文件中的Application标签下增加一行属性 12345678&lt;application ... android:networkSecurityConfig="@xml/network_security_config" ...&gt; ...&lt;/application&gt; 参考链接https://www.jianshu.com/p/57047a84e559 https://android-developers.googleblog.com/2018/04/protecting-users-with-tls-by-default-in.html https://android-developers.googleblog.com/2018/04/dns-over-tls-support-in-android-p.html]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Html5新特性]]></title>
    <url>%2F2019%2F03%2F04%2FHtml5%E6%96%B0%E7%89%B9%E6%80%A7%2F</url>
    <content type="text"><![CDATA[01-HTML5基础了解HTML5 12345678910111213141516☞HTML5属于上一代HTML的新迭代语言，设计HTML5最主要的目的是为了在移动设备上支持多媒体！！！ 例如： video 标签和 audio 及 canvas 标记☞ 新特性： 1. 取消了过时的显示效果标记 &lt;font&gt;&lt;/font&gt; 和 &lt;center&gt;&lt;/center&gt; ... 2. 新表单元素引入 3. 新语义标签的引入 4. canvas标签（图形设计） 5. 本地数据库（本地存储） 6. 一些API☞ 好处： 1. 跨平台 例如：比如你开发了一款HTML5的游戏，你可以很轻易地移植到UC的开放平台、Opera的游戏中心、Facebook应用平台，甚至可以通过封装的技术发放到App Store或Google Play上，所以它的跨平台性非常强大，这也是大多数人对HTML5有兴趣的主要原因。☞ 缺点： 1. pc端浏览器支持不是特别友好，造成用户体验不佳 新语义标签网页布局结构标签及兼容处理12345678&lt;header&gt;&lt;/header&gt;&lt;footer&gt;&lt;/footer&gt;&lt;article&gt;&lt;/article&gt;&lt;aside&gt;&lt;/aside&gt;&lt;nav&gt;&lt;/nav&gt;&lt;section&gt;&lt;/section&gt;....http://www.w3school.com.cn/html/html5_semantic_elements.asp 多媒体标签及属性介绍12345678910111213141516☞ &lt;video&gt;&lt;/video&gt; 视频 属性：controls 显示控制栏 属性：autoplay 自动播放 属性：loop 设置循环播放☞ &lt;audio&gt;&lt;/audio&gt; 音频 属性：controls 显示控制栏 属性：autoplay 自动播放 属性：loop 设置循环播放☞ video标签支持的格式 http://www.w3school.com.cn/html5/html_5_video.asp☞ 多媒体标签在网页中的兼容效果方式 &lt;video&gt; &lt;source src="code/多媒体标签/trailer.mp4"&gt; &lt;source src="trailer.ogg"&gt; &lt;source src="trailer.WebM"&gt; &lt;/video&gt; 新表单元素及属性智能表单控件1234567891011 &lt;input type="email"&gt; email: 输入合法的邮箱地址 url： 输入合法的网址 number： 只能输入数字 range： 滑块 color： 拾色器 date： 显示日期 month： 显示月份 week ： 显示第几周 time： 显示时间 表单属性12345678910111213141516171819202122232425262728 ◆form属性： autocomplete=on | off 自动完成 novalidate=true | false 是否关闭校验 ◆ input属性： *autofocus ： 自动获取焦点 form： list： &lt;input type="text" list="abc"/&gt; &lt;datalist id="abc"&gt; &lt;option value="123"&gt;12312&lt;/option&gt; &lt;option value="123"&gt;12312&lt;/option&gt; &lt;option value="123"&gt;12312&lt;/option&gt; &lt;option value="123"&gt;12312&lt;/option&gt; &lt;/datalist&gt; multiple： 实现多选效果 *placeholder ： 占位符 （提示信息） *required： 必填项作业： ◆自己解决required自定义提示信息 ◆预习和复习留下的疑问： ◆ 如何修改表单控件中的默认提示信息 1. 表单验证触发oninvalid事件 2. 通过setCustomValidity方法设置修改内容 HTMl5中的API获取页面元素及类名操作和自定义属性123456789101112131415161718192021222324252627282930313233343536☞ document.querySelector("选择器")； 备注： 选择器： 可以是css中的任意一种选择器 通过该选择器只能选中第一个元素。☞ document.querySelectorAll("选择器"); 备注： 与document.querySelector区别： querySelectorAll 可以选中所有符合选择器规则的元素，返回的是一个列表。querySelector返回的只是单独的一个元素 ☞ Dom.classList.add("类名"): 给当前dom元素添加类样式☞ Dom.classList.remove("类名"); 给当前dom元素移除类样式☞ classList.contains("类名"); 检测是否包含类样式☞ classList.toggle("active"); 切换类样式（有就删除，没有就添加）☞ 自定义属性 （小案例分析体验自定义属性） data-自定义属性名 备注： 在标签中，以data-自定义名称 1. 获取自定义属性 Dom.dataset 返回的是一个对象 Dom.dataset.属性名 或者 Dom.dataset[属性名] 注意： 属性名是不包含data- 2. 设置自定义属性 Dom.dataset.自定义属性名=值 或者 Dom.dataset[自定义属性名]=值； 文件读取123456789101112131415 ☞ FileReader FileReader 接口有3个用来读取文件方法返回结果在result中 readAsBinaryString ---将文件读取为二进制编码 readAsText ---将文件读取为文本 readAsDataURL ---将文件读取为DataURL☞ FileReader 提供的事件模型 onabort 中断时触发 onerror 出错时触发 onload 文件读取成功完成时触发 onloadend 读取完成触发，无论成功或失败 onloadstart 读取开始时触发 onprogress 读取中☞ 分析读取图片小案例 获取网络状态123456☞ 获取当前网络状态 window.navigator.onLine 返回一个布尔值☞ 网络状态事件 1. window.ononline 2. window.onoffline 获取地理定位12345678910☞ 获取一次当前位置 window.navigator.geolocation.getCurrentPosition(success,error); 1. coords.latitude 维度 2. coords.longitude 经度☞ 实时获取当前位置 window.navigator.geolocation.watchPosition(success,error);☞ 分析地理定位小案例 本地存储12345678910111213141516171819202122☞发展： 随着互联网的快速发展，基于网页的应用越来越普遍，同时也变的越来越复杂，为了满足各种各样的需求，会经常性在本地存储大量的数据，传统方式我们以document.cookie来进行存储的，但是由于其存储大小只有4k左右，并且解析也相当的复杂，给开发带来诸多不便，HTML5规范则提出解决方案，使用sessionStorage和localStorage存储数据。 ☞ localStorage： 1. 永久生效 2. 多窗口共享 3. 容量大约为20M ◆window.localStorage.setItem(key,value) 设置存储内容 ◆window.localStorage.getItem(key) 获取内容 ◆window.localStorage.removeItem(key) 删除内容 ◆window.localStorage.clear() 清空内容 ☞ sessionStorage： 1. 生命周期为关闭当前浏览器窗口 2. 可以在同一个窗口下访问 3. 数据大小为5M左右 ◆window.sessionStorage.setItem(key,value) ◆window.sessionStorage.getItem(key) ◆window.sessionStorage.removeItem(key) ◆window.sessionStorage.clear() 操作多媒体1234http://www.w3school.com.cn/html5/html5_ref_audio_video_dom.asp作业： 完成一个在线音乐播放器或者视频播放器 Canvas画布绘图工具12345☞ 介绍canvas画布☞ 设置画布大小： 使用属性方式设置☞ 解决画布重绘问题 1. 设置一次描边 2. 开启新的图层 绘图方法123456789101112131415161718192021ctx.moveTo(x,y) 落笔ctx.lineTo(x,y) 连线ctx.stroke() 描边ctx.beginPath()； 开启新的图层演示： strokeStyle="值"线宽： linewidth="值" 备注：不需要带单位线连接方式： lineJoin: round | bevel | miter (默认)线帽（线两端的结束方式）： lineCap: butt(默认值) | round | square 闭合路径： ctx.closePath()--绘制一条直线演示代码--作业： 1. 从200,100的位置绘制宽为200高为150的矩形 2. 准备一个600*400的画布，三等分这个画布，分别绘制正方形。直角三角形，梯形 渐变方案1234567891011121314151617181920212223242526272829☞ 线性渐变 var grd=ctx.createLinearGradient(x0,y0,x1,y1); x0--&gt;渐变开始的x坐标 y0--&gt;渐变开始的y坐标 x1--&gt;渐变结束的x坐标 y1--&gt;渐变结束的y坐标 grd.addColorStop(0,&quot;black&quot;); 设置渐变的开始颜色 grd.addColorStop(0.1,&quot;yellow&quot;); 设置渐变的中间颜色 grd.addColorStop(1,&quot;red&quot;); 设置渐变的结束颜色 ctx.strokeStyle=grd; ctx.stroke(); 备注： addColorStop(offse,color); 中渐变的开始位置和结束位置介于0-1之间，0代表开始，1代表结束。中间可以设置任何小数 ☞ 径向渐变 ctx.createradialGradient(x0,y0,r0,x1,y1,r1); (x0,y0)：渐变的开始圆的 x,y 坐标 r0：开始圆的半径 (x1,y1)：渐变的结束圆的 x,y 坐标 r1：结束圆的半径 填充效果12ctx.fill(); 设置填充效果ctx.fillstyle=&quot;值&quot;; 设置填充颜色 非零环绕原则1☞ 绘制一个如下图形 1234567☞ 非零环绕原则： 1. 任意找一点，越简单越好 2. 以点为圆心，绘制一条射线，越简单越好（相交的边越少越好） 3. 以射线为半径顺时针旋转，相交的边同向记为+1，反方向记为-1，如果相加的区域等于0，则不填充。 4. 非零区域填充 ☞ 非零环绕原则案例： 绘制虚线12345678910111213141516171819202122原理： 设置虚线其实就是设置实线与空白部分直接的距离,利用数组描述其中的关系 例如： [10,10] 实线部分10px 空白部分10px 例如： [10,5] 实线部分10px 空白部分5px 例如： [10,5,20] 实线部分10px 空白5px 实线20px 空白部分10px 实线5px 空白20px....绘制： ctx.setLineDash(数组); ctx.stroke(); 例如： ctx.moveTo(100, 100); ctx.lineTo(300, 100); ctx.setLineDash([2,4]); ctx.stroke();注意： 如果要将虚线改为实线，只要将数组改为空数组即可。 绘制动画效果123456789☞ 绘制一个描边矩形： content.strokeRect(x,y,width,height) ☞ 绘制一个填充矩形： content.fillRect(x,y,width,height) ☞ 清除： content.clearRect(x,y,width,height) ☞ 实现动画效果： 1. 先清屏 2. 绘制图形 3. 处理变量 绘制文本123456789101112131415161718192021222324☞ 绘制填充文本 content.fillText(文本的内容,x,y)☞ 绘制镂空文本 content.strokeText(); ☞ 设置文字大小： content.font=&quot;20px 微软雅黑&quot; 备注： 该属性设置文字大小，必须按照cssfont属性的方式设置 ☞ 文字水平对齐方式【文字在圆心点位置的对齐方式】 content.textalign=&quot;left | right | center&quot;☞文字垂直对齐方式 content.textBaseline=&quot;top | middle | bottom | alphabetic(默认)&quot;☞文字阴影效果 ctx.shadowColor=&quot;red&quot;; 设置文字阴影的颜色 ctx.ShadowOffsetX=值; 设置文字阴影的水平偏移量 ctx.shadowOffsetY=值; 设置文字阴影的垂直偏移量 ctx.shadowBlur=值; 设置文字阴影的模糊度 绘制图片12345678910111213141516171819☞ //将图片绘制到画布的指定位置 content.drawImage(图片对象,x,y);☞ //将图片绘制到指定区域大小的位置 x,y指的是矩形区域的位置，width和height指的是矩形区域的大小 content.drawImage(图片对象,x,y,width,height); ☞ //将图片的指定区域绘制到指定矩形区域内 content.drawImage(图片对象,sx,sy,swidth,sheight,dx,dy,dwidth,dheight); sx,sy 指的是要从图片哪块区域开始绘制，swidth，sheight 是值 截取图片区域的大小 dx,dy 是指矩形区域的位置，dwidth,dheight是值矩形区域的大小 ☞ 解决图片绘制到某一个区域的按原比例缩放绘制： 绘制宽：绘制高==原始宽：原始高 绘制圆弧123456789101112131415161718192021222324252627282930313233343536373839404142434445464748☞ content.arc(x,y,radius,startradian,endradian[,direct]); x,y 圆心的坐标 radius 半径 startradian 开始弧度 endradian 结束弧度 direct 方向（默认顺时针 false） true 代表逆时针 ☞ 0度角在哪？ 以圆心为中心向右为0角 顺时针为正，逆时针为负 ☞ 备注： 角度 和 弧度的关系： 角度:弧度= 180:pi 特殊值 0度 = 0弧度 30度 = π/6 (180度的六分之一) 45度 = π/4 60度 = π/3 90度 = π/2 180度 = π 360度 = 2π ☞ 绘制圆上任意点： 公式： x=ox+r*cos( 弧度 ) y=oy+r*sin( 弧度 ) ox: 圆心的横坐标 oy: 圆心的纵坐标 r： 圆的半径 平移【坐标系圆点的平移】12345678910111213ctx.translate(x,y); 特点： 通过该方法可以将原点的位置进行重新设置。 注意： 1. translate(x,y) 中不能设置一个值 2. 与moveTo(x,y) 的区别： moveTo(x,y) 指的是将画笔的落笔点的位置改变，而坐标系中的原点位置并没有发生改变 translate(x,y) 是将坐标系中的原点位置发生改变 旋转【坐标系旋转】1ctx.rotate(弧度) 伸缩123456ctx.scale(x,y) 备注： 沿着x轴和y轴缩放 x,y 为倍数 例如： 0.5 1]]></content>
      <categories>
        <category>HTML</category>
      </categories>
      <tags>
        <tag>HTML</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IOS之自动布局AutoLayout]]></title>
    <url>%2F2019%2F03%2F04%2FIOS%E4%B9%8B%E8%87%AA%E5%8A%A8%E5%B8%83%E5%B1%80AutoLayout%2F</url>
    <content type="text"><![CDATA[AutoLayout自动布局介绍UI布局对于iOS开发者来说并不陌生，在iOS6之前，大家都是通过UI控件的Frame属性和Autoresizing Mask来进行UI布局的。AutoLayout则是苹果公司在iOS6推出的一种基于约束的，描述性的布局系统。自从AutoLayout问世以来，逐步得到了iOS开发者们的青睐，尤其是iPhone6机型尺寸的出现。 AutoLayout占据UI布局的主要领导位置依赖于它的特殊性： 基于约束：和以往定义frame的位置和尺寸不同，AutoLayout的位置确定是以所谓相对位置的约束来定义的，比如x坐标为superView的中心，y坐标为屏幕底部上方10像素等 描述性： 约束的定义和各个view的关系使用接近自然语言或者可视化语言（稍后会提到）的方法来进行描述 布局系统：即字面意思，用来负责界面的各个元素的位置。 AutoLayout使用原理创建约束IOS6中新加入了一个类，NSLayoutConstraint,它的约束满足一个公式 1item1.attribute = multiplier ⨉ item2.attribute + constant 相应公式的代码为12345678//view_1(红色)top 距离self.view的topNSLayoutConstraint *view_1TopToSuperViewTop = [NSLayoutConstraint constraintWithItem:view_1 attribute:NSLayoutAttributeTop relatedBy:NSLayoutRelationEqual toItem:self.view attribute:NSLayoutAttributeTop multiplier:1 constant:30]; 这里对应的约束是“view_1的顶部（y）＝ self.view的顶部(y)*1 + 30”。 添加约束在创建约束后，需要将其添加到作用的view上。UIView添加约束的实例方法 12- (void)addConstraint:(NSLayoutConstraint *)constraint NS_AVAILABLE_IOS(6_0);- (void)addConstraints:(NSArray&lt;__kindof NSLayoutConstraint *&gt; *)constraints NS_AVAILABLE_IOS(6_0); UIView中的一个属性translatesAutoresizingMaskIntoConstraints 1234//如果你定义的view想用autolayout，就将translatesAutoresizingMaskIntoConstraints = NO//如果你使用的不是autolayout，就将translatesAutoresizingMaskIntoConstraints = YES 约束的属性 当然，如何添加也有相应的规则。 对其他的view没有任何关系时，添加到自己的view上比如说添加一个按钮的宽和高的约束，对其他的view没有任何关系，则将约束添加到自己身上。 为按钮添加一个宽和高为两百的约束1234567891011121314151617181920#import &quot;ViewController.h&quot;@interface ViewController ()@property (strong, nonatomic) IBOutlet UIButton *btn1;@end@implementation ViewController- (void)viewDidLoad &#123; [super viewDidLoad]; // Do any additional setup after loading the view, typically from a nib. NSLayoutConstraint *c1 = [NSLayoutConstraint constraintWithItem:self.btn1 attribute:NSLayoutAttributeWidth relatedBy:NSLayoutRelationEqual toItem:nil attribute:NSLayoutAttributeWidth multiplier:1 constant:200]; NSLayoutConstraint *c2 = [NSLayoutConstraint constraintWithItem:self.btn1 attribute:NSLayoutAttributeHeight relatedBy:NSLayoutRelationEqual toItem:nil attribute:NSLayoutAttributeHeight multiplier:1 constant:200]; self.btn1.translatesAutoresizingMaskIntoConstraints = NO; [self.btn1 addConstraint:c1]; [self.btn1 addConstraint:c2];&#125;@end 对于两个同层级view之间的约束关系，则添加到他们的父View上例如3.1与3.2为同层级view，约束关系则添加到父view2.1上。 添加了一个蓝色view的上边线与绿色view的下边线对其的约束，两个view为同级约束，则添加到了父view上。 对于两个不同层级的view之间的约束关系，则添加到他们最近的共同的父view上。例如3.3与3.5为同层级view，约束关系则添加到父view1上。 但是相对于这种情况应该用的很少。 刷新约束可以通过setNeedsUpdateConstraints和layoutIfNeeded两个方法来刷新约束，使得UIView重新布局。 Masonry框架最后说明一下，在Masonry中能够添加autolayout约束有三个函数： 123456789- (NSArray *)mas_makeConstraints:(void(^)(MASConstraintMaker *make))block;- (NSArray *)mas_updateConstraints:(void(^)(MASConstraintMaker *make))block;- (NSArray *)mas_remakeConstraints:(void(^)(MASConstraintMaker *make))block;/*mas_makeConstraints 只负责新增约束 Autolayout不能同时存在两条针对于同一对象的约束 否则会报错 mas_updateConstraints 针对上面的情况 会更新在block中出现的约束 不会导致出现两个相同约束的情况mas_remakeConstraints 则会清除之前的所有约束 仅保留最新的约束三种函数善加利用 就可以应对各种情况了*/ 常用属性 123456//乘以- (MASConstraint * (^)(CGFloat multiplier))multipliedBy;//除以- (MASConstraint * (^)(CGFloat divider))dividedBy;//优先级- (MASConstraint * (^)(MASLayoutPriority priority))priority;]]></content>
      <categories>
        <category>Ios</category>
      </categories>
      <tags>
        <tag>Ios</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTML5语义性标签兼容解决]]></title>
    <url>%2F2019%2F03%2F02%2FHTML5%E8%AF%AD%E4%B9%89%E6%80%A7%E6%A0%87%E7%AD%BE%E5%85%BC%E5%AE%B9%E8%A7%A3%E5%86%B3%2F</url>
    <content type="text"><![CDATA[前言现在大部分的浏览器都能够很好的支持H5，但还是不免得有一些浏览器是不能够支持HTML5的新特性及其一些新标签，特别是在IE8以下的浏览器。 兼容办法第一种通过document.createElement(&quot;nav&quot;);的办法来逐个创建标签元素，但是通过其办法还需要定义好其元素的CSS样式。 第二种使用js插件，这里使用的是html5shiv，BootCDN有提供,链接 1&lt;script src="https://cdn.bootcss.com/html5shiv/r29/html5.js"&gt;&lt;/script&gt; 终极解决办法单纯使用第二种的时候，有一些浏览器本身就能够支持，所以在代码中进行判断是否需要该js 1234&lt;!-- 终极解决方案 --&gt; &lt;!--[if lte IE 8]&gt; &lt;script src="https://cdn.bootcss.com/html5shiv/r29/html5.js"&gt;&lt;/script&gt; &lt;![endif]--&gt; 是否需要兼容可以看业务是否需要，也可以提示用户进行更换浏览器，毕竟IE是个坑爹的浏览器。]]></content>
      <categories>
        <category>HTML</category>
      </categories>
      <tags>
        <tag>HTML</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Objective-C之深、浅拷贝]]></title>
    <url>%2F2019%2F03%2F01%2FObjective-C%E4%B9%8B%E6%B7%B1%E3%80%81%E6%B5%85%E6%8B%B7%E8%B4%9D%2F</url>
    <content type="text"><![CDATA[什么是深拷贝和浅拷贝 深拷贝就是对一个对象的拷贝，浅拷贝是对一个对象地址的拷贝。 copy，mutablecopy 原则：copy方法返回的是一个不可变对象，不可变即该对象不能执行增删操作，这也是MutableArray不能用copy修饰的原因。mutablecopy方法返回的是一个可变对象。 大多数NSString、Block都需要copy]]></content>
      <categories>
        <category>Ios</category>
      </categories>
      <tags>
        <tag>Ios</tag>
        <tag>Objective-C</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Objective-C之Block]]></title>
    <url>%2F2019%2F03%2F01%2FObjective-C%E4%B9%8BBlock%2F</url>
    <content type="text"><![CDATA[关于Block在iOS4.0之后，block横空出世，它本身封装了一段代码并将这段代码当做变量，通过block()的方式进行回调。 block的代码是内联的，效率高于函数调用block对于外部变量默认是只读属性block被Objective-C看成是对象处理 对于block的底层实现在网上已经有很多资料了，其源码更是可以在opensource.apple.com上下载，因此，本文更着重于对于block的基本应用 Block特性MRC环境 认识Block一个简单的block，实现两个数之和1234int(^sum)(int a, int b) = ^(int a, int b)&#123; return a + b; &#125;;NSLog(@&quot;%d&quot;,sum(3,5)); 代码左边是一个block的生命，int为block的返回值类型，^符号后面为block的名称，后面括号里面为参数列表，该block的参数列表有两个，两个都是int类型参数。右边为block的定义。用网上一张图来更好的认识到block。 Block访问外部基本类型数据 静态变量 和 全局变量 在加和不加 block 都会直接引用变量地址。也就意味着 可以修改变量的值。在没有加block 参数的情况下。 基本类型常量时，看一段代码 1234567891011int main(int argc, const char * argv[]) &#123; @autoreleasepool &#123; // insert code here... CGPoint p = CGPointMake(10, 10); void(^bt)(void) = ^()&#123; NSLog(@&quot;%f , %f&quot;, p.x, p.y); &#125;; bt(); &#125; return 0;&#125; 输出122019-03-01 11:35:15.244937+0800 BlockDemo[866:40789] 10.000000 , 10.000000Program ended with exit code: 0 可以看到block可以直接访问到外部的局部变量。但是block内使用外部的变量相当于拷贝了一份外部变量来使用，并不能直接修改外部变量的值，例如 编译器直接进行报错，但是如果想直接修改外部的局部变量的值，那就需要在外部的局部变量前面加上__block的声明。 Block访问外部常量变量NSString *a = @&quot;hello&quot;; a 为常量变量，@“hello”为常量。）—–不加block类型 block 会引用常量的地址（浅拷贝）。加block类型 block会去引用常量变量（如：a变量，a = @”abc”.可以任意修改a 指向的内容。）的地址。 block 会拷贝变量内容到自己的栈内存上，以便执行时可以调用。 但并不是对str 内容做了深拷贝，重新申请内存。 因为str 是栈内存上的变量，指向 一个常量区的@“hello”. 编译器做的优化是 当block 去拷贝str 指向内容时发现是个常量， 所以会去引用 @“hello” 的指针，没必要再取申请一块内存。 Block访问外部对象变量如（MyClass class、Block block）。 这里block 也是”类“对象（类似对象，其包含isa指针,clang 反编译可以查看。因为它不像从NSObject 继承下来的对象都支持 retain、copy、release）。* Block的copy、retain、release操作不同于NSObjec的copy、retain、release操作： Block_copy与copy等效，Block_release与release等效； Block_copy与copy等效，Block_release与release等效； 对Block不管是retain、copy、release都不会改变引用计数retainCount，retainCount始终是1； NSGlobalBlock：retain、copy、release操作都无效； NSStackBlock：retain、release操作无效，必须注意的是，NSStackBlock在函数返回后，Block内存将被回收。即使retain也没用。容易犯的错误是[[mutableAarry addObject:stackBlock]，在函数出栈后，从mutableAarry中取到的stackBlock已经被回收，变成了野指针。正确的做法是先将stackBlock copy到堆上，然后加入数组：[mutableAarry addObject:[[stackBlock copy] autorelease]]。支持copy，copy之后生成新的NSMallocBlock类型对象 NSMallocBlock支持retain、release，虽然retainCount始终是1，但内存管理器中仍然会增加、减少计数。copy之后不会生成新的对象，只是增加了一次引用，类似retain； 尽量不要对Block使用retain操作 Block循环引用最简单也最常出现的,block导致循环引用的现象,就是在block中执行了self.xxx,比如 这个问题大家的见的多了,也都知道怎么解决,声明一个用__weak修饰的self替换block中的self就可以解决问题了,不过下面这个方法也能够解决循环引用的问题 总结Block的特性也赋予了它许多的灵活性，但是也会出现很多的一些内存泄漏，不易调试的问题，还要多多深入探究。]]></content>
      <categories>
        <category>Ios</category>
      </categories>
      <tags>
        <tag>Ios</tag>
        <tag>Objective-C</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IOS基础 - WKWebView使用]]></title>
    <url>%2F2019%2F02%2F28%2FIOS%E5%9F%BA%E7%A1%80-WKWebView%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[WKWebView对比UIWebView的优势 1.WKWebView的内存开销要比UIWebView小很多2.拥有高达60FPS滚动刷新率及内置手势3.支持了更多的HTML5特性4.html页面和WKWebView交互更方便5.Safari相同的JavaScript引擎6.提供常用的属性，如加载网页进度的属性estimatedProgress 基本使用倒入库 引入头文件#import &lt;WebKit/WebKit.h&gt; 初始化123456789101112131415161718192021222324@interface MainViewController () &lt;WKNavigationDelegate&gt;@property(strong, nonatomic) WKWebView *webview;@end@implementation MainViewController- (void)viewDidLoad &#123; [super viewDidLoad]; // Do any additional setup after loading the view. WKWebView *wv = [[WKWebView alloc] init]; wv.navigationDelegate = self; [self.view addSubview:wv]; [wv mas_makeConstraints:^(MASConstraintMaker *make) &#123; make.top.equalTo(wv.superview.mas_top).with.offset(0); make.left.equalTo(wv.superview.mas_left).with.offset(0); make.right.equalTo(wv.superview.mas_right).with.offset(0); make.bottom.equalTo(wv.superview.mas_bottom).with.offset(0); &#125;]; self.webview = wv; //加载网页 [self.webview loadRequest:[NSURLRequest requestWithURL:[NSURL URLWithString:@&quot;https://www.baidu.com&quot;]]];&#125; 关于WKWebView的代理WKNavigationDelegate12345678910111213141516171819202122#pragma mark - WKNavigationDelegate// 页面开始加载时调用- (void)webView:(WKWebView *)webView didStartProvisionalNavigation:(WKNavigation *)navigation;// 当内容开始到达时调用- (void)webView:(WKWebView *)webView didCommitNavigation:(WKNavigation *)navigation;// 页面加载完成之后调用- (void)webView:(WKWebView *)webView didFinishNavigation:(WKNavigation *)navigation;// 页面加载失败时调用- (void)webView:(WKWebView *)webView didFailProvisionalNavigation:(WKNavigation *)navigation withError:(NSError *)error;//收到服务器重定向请求后调用- (void)webView:(WKWebView *)webView didReceiveServerRedirectForProvisionalNavigation:(WKNavigation *)navigation;// 在收到响应开始加载后，决定是否跳转- (void)webView:(WKWebView *)webView decidePolicyForNavigationResponse:(WKNavigationResponse *)navigationResponse decisionHandler:(void (^)(WKNavigationResponsePolicy))decisionHandler;// 在请求开始加载之前调用，决定是否跳转- (void)webView:(WKWebView *)webView decidePolicyForNavigationAction:(WKNavigationAction *)navigationAction decisionHandler:(void (^)(WKNavigationActionPolicy))decisionHandler; WKUIDelegate12345678910- (nullable WKWebView *)webView:(WKWebView *)webView createWebViewWithConfiguration:(WKWebViewConfiguration *)configuration forNavigationAction:(WKNavigationAction *)navigationAction windowFeatures:(WKWindowFeatures *)windowFeatures;// 在js中调用alert函数时，会调用该方法。- (void)webView:(WKWebView *)webView runJavaScriptAlertPanelWithMessage:(NSString *)message initiatedByFrame:(WKFrameInfo *)frame completionHandler:(void (^)(void))completionHandler;// 在js中调用confirm函数时，会调用该方法- (void)webView:(WKWebView *)webView runJavaScriptConfirmPanelWithMessage:(NSString *)message initiatedByFrame:(WKFrameInfo *)frame completionHandler:(void (^)(BOOL result))completionHandler;// 在js中调用prompt函数时，会调用该方法- (void)webView:(WKWebView *)webView runJavaScriptTextInputPanelWithPrompt:(NSString *)prompt defaultText:(nullable NSString *)defaultText initiatedByFrame:(WKFrameInfo *)frame completionHandler:(void (^)(NSString * __nullable result))completionHandler;]]></content>
      <categories>
        <category>Ios</category>
      </categories>
      <tags>
        <tag>Ios</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IDEA技巧]]></title>
    <url>%2F2019%2F02%2F28%2FIDEA%E6%8A%80%E5%B7%A7%2F</url>
    <content type="text"><![CDATA[IDEA技巧WebStorm 通用技巧 几乎在所有面板包括弹出窗口里，都能直接键入名字进行快速跳转。例如 在查找结果中增量查找 在 Outline 窗口中快速跳转 在 Project、Recent File 中快速跳转 常用快捷键(Mac)：导航： 打开文件：Shift + ⌘ + O (被我改成了和 Chrome 相同的 ⌘ + O) 文件名前面或后面加上/可打开目录 打开符号：Alt + ⌘ + O 搜索任意：双击 Shift 跳转到声明：⌘ + Alt + B 跳转到实现：⌘ + B 搜索所有引用：我定义的是 Shift + F12 弹出文件结构列表(Outline)：⌘ + F12 弹出最近关闭的文件列表(Recent File)：⌘ + E 之后直接键入文件名可快速跳转到最近关闭的文件，找不到的话按回车则在项目中查找。 跳转到下一查找结果：Alt + ⌘ + Down 文件内代码替换 Ctrl + R 弹出外部资源菜单：(在 Tab 标签上) ⌘ + Click 添加书签：F3，浏览书签：⌘ + F3 跳转到代码块开头：Alt + ⌘ + [ 在左右（花）括号之间跳转：Ctrl + M 视图： 跳转回编辑面板: Esc 切换下一个代码标签：Ctrl + Tab 或 Shift + ⌘ + ] 切换上一个代码标签：Shift + ⌘ + [ 最大化/还原编辑面板：双击标签栏 显示所有视图边栏：显示双击并按住 ⌘ 关闭当前显示查找结果标签页：Ctrl + Shift + F4 编辑： 插入代码片段(Code Snippet)：⌘ + J 重构：Ctrl + T 重命名（变量等）：Shift + F6 重构预览时，从搜索结果中排除：Delete 格式化代码：Alt + ⌘ + L 缩进对齐：Ctrl + Alt + I 弹出 Intention Actions: Alt + Enter 同时选中下一个相同代码块：Ctrl + G 同时选中所有相同代码块：Ctrl + ⌘ + G 一些 Unix 终端快捷键：Ctrl + A/E/K 单纯粘贴（不自动缩进也不格式化代码）：Shift + Alt + ⌘ + V 行注释：⌘ + / 块注释：Alt + ⌘ + / 行操作： 复制(选中)行：⌘ + D 上移(选中)行：Shift + Alt + Up 上移(选中)语句：Shift + ⌘ + Up 在上面插入新行：Alt + ⌘ + Enter 在下面插入新行： Shift + Enter 删除行：⌘ + Delete 显示： 显示方法参数说明：⌘ + P 显示光标处的代码文档：F1 快速查看定义：Alt + Space 高亮当前文件中所有选中字段：Shift + ⌘ + F7 (然后⌘ + G跳转下一个) 扩大选中的代码块：Alt + Up（可以用来选词，按越多次选中的代码块范围越大） 折叠/展开代码块：⌘ + -/= 光标向上/向下移动同时滚动视图(Move Up)：我定义的是 Shift + ⌘ + I/K 其它： 激活搜索框 “Match Case”: Alt + C 激活搜索框 “Words”: Alt + R 重复最近的搜索：焦点在输入框时按 Down 新建草稿文件: ⌘ + Shift + N 调整 Layout 以突出编码区域，更适合宽屏： [Preferences] Appearance &amp; Behavior &gt; Appearance：勾选 Widescreen … layout [Menu] View: 把 Toolbar, Tool Buttons, Status Bar, Navigation bar 全关掉 允许解析 module 等 node 全局变量： [Preferences] Languages &amp; Frameworks &gt; JavaScript &gt; Libraries: 勾选 Node.js Globals 隐藏代码折叠的箭头： [Preferences] Editor &gt; Code Folding: 取消 Show code folding outline 从项目中排除第三方文件，优化代码搜索结果： [Preferences] Project &gt; Directories: 选中不需要的文件夹，点上面的 Excluded，例如这样设置：也可以在 [Project] 面板上的文件夹点击右键，选择 Mark Directory As &gt; Excluded 不在 [Project] 显示已排除的第三方文件： [Project] 点击 “Scope按钮”，选择 Project Files 按文件类型排序： [Project] 点击齿轮下拉菜单，选中 Sort by Type 和 Folders Always on Top 在 [Project] 中定位到当前编辑的脚本： 点击图中的小图标 去掉 spell checking： [Preference] Editor &gt; Inspections: 把 spelling 项的复选去掉 设置缩进和代码格式化操作： [Preference] Editor &gt; General &gt; Smart Keys: 按需设置 屏蔽对象定义时最后多写一个逗号引起的报错： [Preference] Editor &gt; Inspections &gt; JavaScript &gt; General: 取消 Last comma in object literal 减少 jshint 报错 在项目的 .idea/jsLinters/ 目录下添加 jshint.xml Postfix Completion [Preferences] Editor &gt; General &gt; Postfix Completion：启用你喜欢的选项 开启 ES6 支持 [Preferences] Languages &amp; Frameworks &gt; JavaScript：选择 ECMAScript 6（需要重启 WebStorm 才能生效） 自动识别当前文件的缩进类型 [Preferences] Editor &gt; Code Style：选择 Detect and use existing file indents for editing 滚动条快速滚动到选中位置 系统设置中选中该项 WebStrom 作为 merge 工具/Applications/WebStorm.app/Contents/MacOS/webstorm merge $(cd $(dirname &quot;$LOCAL&quot;) &amp;&amp; pwd)/$(basename &quot;$LOCAL&quot;) $(cd $(dirname &quot;$REMOTE&quot;) &amp;&amp; pwd)/$(basename &quot;$REMOTE&quot;) $(cd $(dirname &quot;$BASE&quot;) &amp;&amp; pwd)/$(basename &quot;$BASE&quot;) $(cd $(dirname &quot;$MERGED&quot;) &amp;&amp; pwd)/$(basename &quot;$MERGED&quot;) WebStrom 作为 diff 工具/Applications/WebStorm.app/Contents/MacOS/webstorm diff $(cd $(dirname &quot;$LOCAL&quot;) &amp;&amp; pwd)/$(basename &quot;$LOCAL&quot;) $(cd $(dirname &quot;$REMOTE&quot;) &amp;&amp; pwd)/$(basename &quot;$REMOTE&quot;)]]></content>
      <categories>
        <category>程序人生</category>
      </categories>
      <tags>
        <tag>IDEA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[解决AndroidStudio导入项目在 Building gradle project info 一直卡住]]></title>
    <url>%2F2019%2F02%2F28%2F%E8%A7%A3%E5%86%B3AndroidStudio%E5%AF%BC%E5%85%A5%E9%A1%B9%E7%9B%AE%E5%9C%A8-Building-gradle-project-info-%E4%B8%80%E7%9B%B4%E5%8D%A1%E4%BD%8F%2F</url>
    <content type="text"><![CDATA[Android studio一个小小的痛点 解决AndroidStudio导入项目在 Building gradle project info 一直卡住Android Studio导入项目的时候，一直卡在Building gradle project info这一步，主要原因还是因为被墙的结果。gradle官网虽然可以访问，但是速度连蜗牛都赶不上… 三种解决办法离线包下载导入方式 查看所需gradle版本：打开C:\Users\用户名.gradle\wrapper\dists\gradle-x.xx-all\xxxxxxxxxxxx，如果里面的gradle-xx-all.zip不完整（如0KB），则说明下载不成功，需要下载离线包放置到该目录下。 下载地址：https://services.gradle.org/distributions/ 修改gradle-wrapper.properties方式 1、随便找一个你之前能够运行的AS项目 2、打开项目的/gradle/wrapper/gradle-wrapper.properties文件 3、复制最后一行distributionUrl这一整行的内容，例如：distributionUrl=https\://services.gradle.org/distributions/gradle-2.8-all.zip，替换到你要导入的项目里的gradle-wrapper.properties文件中。 4、重启Android Studio，重新导入项目就可以了~~ 翻墙翻开中国伟大的墙就可以了。本人一直用的蓝灯。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Android Studio</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mac安装Mysql教程]]></title>
    <url>%2F2019%2F02%2F25%2FMac%E5%AE%89%E8%A3%85Mysql%E6%95%99%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[环境 MacOS10以上 下载Mysql这里以Mysql5.7为例 官网为了方便开发，推荐直接选择dmg文件下载安装 安装Mysql直接双击即可，傻瓜式操作。 注意，安装成功后会弹出一个对话框，你直接忽略了可以看通知面板，这个就是Mysql的初始密码如图 启动Mysql安装完毕后系统偏好设置会多出一个选项 点击进去 安装之后，默认MySQL的状态是stopped，关闭的，需要点击“Start MySQL Server”按钮来启动它，启动之后，状态会变成running。下方还有一个复选框按钮，可以设置是否在系统启动的时候自动启动MySQL，默认是勾选的，建议取消，节省开机时间。 终端连接Mysql1vim ~/.bash_profile 添加export PATH=${PATH}:/usr/local/mysql/bin即可 登陆Mysql1mysql -uroot -p 输入刚开始安装对话框中提示的初始密码，登陆成功后请修改密码，否则无法执行其他命令。 1ALTER USER 'root'@'localhost' IDENTIFIED BY 'newpassword';]]></content>
      <categories>
        <category>DBA</category>
      </categories>
      <tags>
        <tag>Mysql</tag>
        <tag>环境搭建</tag>
        <tag>Mac</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mac使用HomeBrew安装Composer]]></title>
    <url>%2F2019%2F02%2F25%2FMac%E4%BD%BF%E7%94%A8HomeBrew%E5%AE%89%E8%A3%85Composer%2F</url>
    <content type="text"><![CDATA[环境 MacOS10以上 安装HomeBrewhomebrew官网 链接 1/usr/bin/ruby -e "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)" 回车安装即可 安装Composer1brew install composer 安装完毕后composer可能不是最新版本，也可以升级 1composer self-update 修改Packagist 镜像修改 composer 的全局配置文件 打开命令行窗口（windows用户）或控制台（Linux、Mac 用户）并执行如下命令：1composer config -g repo.packagist composer https://packagist.phpcomposer.com 使用composer举例我要引用phalcon的开发工具包。在项目文件夹下新建文件composer.json，并添加如下代码 12345&#123; &quot;require&quot;: &#123; &quot;phalcon/devtools&quot;: &quot;dev-master&quot; &#125;&#125; 运行 1composer update 项目文件夹下就会有vendor文件夹，依赖文件都在这下面啦。使用时直接包含autoload.php就可以了 1require 'vendor/autoload.php'; 更多命令可以直接查看官方文档http://docs.phpcomposer.com/03-cli.html 参考链接： https://www.jianshu.com/p/2b96cc9f593e https://pkg.phpcomposer.com/ https://getcomposer.org/]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>环境搭建</tag>
        <tag>Composer</tag>
        <tag>Homebrew</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mac使用HomeBrew安装Maven]]></title>
    <url>%2F2019%2F02%2F20%2FMac%E4%BD%BF%E7%94%A8HomeBrew%E5%AE%89%E8%A3%85Maven%2F</url>
    <content type="text"><![CDATA[环境 MacOS10以上 jdk1.6或以上 安装HomeBrewhomebrew官网 链接 1/usr/bin/ruby -e "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)" 回车安装即可 安装Maven12345678$ brew search maven==&gt; Formulaemaven ✔ maven-shell maven@3.3maven-completion maven@3.2 maven@3.5==&gt; Caskshomebrew/cask-fonts/font-maven-pro$ brew install maven 验证maven是否安装成功1mvn -v 配置Maven仓库setting.xml路径为/usr/local/Cellar/maven/3.5.0/libexec/conf/settings.xml修改即可。]]></content>
      <categories>
        <category>Maven</category>
      </categories>
      <tags>
        <tag>环境搭建</tag>
        <tag>Homebrew</tag>
        <tag>Maven</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CocoaPods简单安装和使用]]></title>
    <url>%2F2019%2F01%2F18%2FCocoaPods%E7%AE%80%E5%8D%95%E5%AE%89%E8%A3%85%E5%92%8C%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[什么是CocoaPodsCocoaPods是专门为iOS工程提供对第三方库的依赖的管理工具，通过CocoaPods，我们可以更方便地管理每个第三方库的版本，而且不需要我们做太多的配置。直观、集中和自动化地管理我们项目的第三方库。 安装CocoaPods更新gem1sudo gem update --system 更换镜像删除自带镜像1gem sources --remove https://rubygems.org/ 更换1gem sources -a https://gems.ruby-china.com/ 查看1gem sources -l 如图显示即为替换镜像成功 安装1sudo gem install cocoapods 配置1pod setup 到这里CocoaPods就已经安装完毕了。 使用CocoaPods查找第三方库比如说要查找某个库，直接在终端输入 1pod search QMUIKit 完成后他会自动进入一个新的页面显示搜索结果，上下滑动查看更多，要退出的话按wq就可以了。以后再搜索就不需要建索引了。 引入第三方库到项目中这里演示第三方库为QMUIKit 打开xcode新建一个项目，打开终端，进入项目路径中。 输入1pod init 将自动生成一个Podfile文件，也可以自己生成，命令生成有默认模板 vim编写,添加qmuikit 安装第三方库1pod install 查看项目目录变化 在访达中 原本使用xcodeproj打开项目，但是现在要改变成xcworkspace打开项目了。 这样就可以正常使用该库啦。但是有时候没有只能提示时候，需要更改Build Settings中的User header search paths添加$(SRCROOT)并选择recursive 增加第三方继续编写Podfile文件添加第三方库然后在执行pod install就可以了 更新第三方第三方库们都有人在维护升级，我们需要隔断时间就要更新下我们工程中第三方库的版本。只需要终端输入命令pod update就可以了。如果遇到pod install或者pod update慢的问题，原因在于当执行以上两个命令的时候会升级CocoaPods的spec仓库，加一个参数可以省略这一步，然后速度就会提升不少。加参数的命令如下： 12pod install --verbose --no-repo-updatepod update --verbose --no-repo-update 删除第三方当我们需要去掉某个第三方库时，只需要在Podfile删除该引入该库的语句，然后执行pod update或者pod install就可以了。 升级CocoaPods升级CocoaPods版本的命令和安装CocoaPods的命令一样，都是1sudo gem install cocoapods 卸载CocoaPods卸载CocoaPods的命令是1sudo gem uninstall cocoapods CocoaPods Mac AppCocoaPods桌面应用版下载地址：https://cocoapods.org/app 参考 https://juejin.im/entry/5c067eb56fb9a04a0a5ef583?utm_source=gold_browser_extension https://guides.cocoapods.org/syntax/podfile.html#podfile]]></content>
      <categories>
        <category>Ios</category>
      </categories>
      <tags>
        <tag>Ios</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Tomcat基本使用]]></title>
    <url>%2F2018%2F11%2F21%2FTomcat%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[下载安装到apache官网。www.apache.org http://jakarta.apache.org(产品的主页) 安装版：window （exe、msi） linux（rmp）压缩版：window（rar，zip） linux（tar，tar.gz） 学习时候使用 运行和关闭tomcat启动软件a）找到%tomcat%/bin/startup.bat ，双击这个文件b）弹出窗口，显示信息（不要关闭次窗口）c）打开浏览器，输出以下地址 http://localhost:8080d）看到一只猫画面，证明软件启动成功！ 关闭软件a）找到%tomcat%/bin/shutdown.bat，双击这个文件即可！b）打开浏览器，输出以下地址。看到“无法连接”（最好先清空浏览器缓存） Tomcat目录结构bin存放常用tomcat命令 conf存放server配置文件 lib自带jar包 logs存放日志 temp存放临时文件 webapps存放共享资源目录 work工作空间 Tomcat常见问题一闪而过配置好JDK环境即可，即JAVA_HOME,PATH，CLASSPATH环境变量即可。 端口占用的错误原因： tomcat启动所需的端口被其他软件占用了！解决办法：a）关闭其他软件程序，释放所需端口b）修改tomcat软件所需端口找到并修改%tomcat%/conf/server.xml文件 123&lt;Connector port="8081" protocol="HTTP/1.1" connectionTimeout="20000" redirectPort="8443" /&gt; CATALINA环境变量问题原因： tomcat软件启动后，除了查找JAVA_HOME后，还会再查找一个叫CATALINA_HOME变量，这个变量的作用是设置tomcat的根目录。解决办法：建议不要设置CATALINA_HOME变量。检查如果有的话，清除掉！！！]]></content>
      <categories>
        <category>Tomcat</category>
      </categories>
      <tags>
        <tag>环境搭建</tag>
        <tag>Tomcat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[单例模式-JAVA实现]]></title>
    <url>%2F2018%2F11%2F20%2F%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F-JAVA%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[单例模式什么是单例？就是保证在一个jvm当中只能由一个实例。（区分不是在多个jvm当中。） 单例模式有七种写法。 本文只提出两种，一种懒汉式和饿汉式。 懒汉式123456789101112131415161718192021222324252627public class Single &#123; public static void main(String[] args) &#123; System.out.println(Singleton.getInstance()); System.out.println(Singleton.getInstance()); System.out.println(Singleton.getInstance()); System.out.println(Singleton.getInstance()); &#125;&#125;class Singleton &#123; private static Singleton mSingleton; private Singleton()&#123;&#125; public static Singleton getInstance() &#123; if (mSingleton == null) &#123; synchronized (Singleton.class) &#123; //加锁，线程不安全，故加上 mSingleton = new Singleton(); &#125; &#125; return mSingleton; &#125;&#125; 1234cn.net.sweetlover.patern.Singleton@1540e19dcn.net.sweetlover.patern.Singleton@1540e19dcn.net.sweetlover.patern.Singleton@1540e19dcn.net.sweetlover.patern.Singleton@1540e19d 被需要时才进行初始化，且只有同一个实例，但会发生线程不安全。 饿汉式12345678910111213141516171819202122public class Single &#123; public static void main(String[] args) &#123; System.out.println(Singleton.getInstance()); System.out.println(Singleton.getInstance()); System.out.println(Singleton.getInstance()); System.out.println(Singleton.getInstance()); &#125;&#125;class Singleton &#123; private final static Singleton mSingleton = new Singleton(); private Singleton()&#123;&#125; public static Singleton getInstance() &#123; return mSingleton; &#125;&#125; 1234cn.net.sweetlover.patern.Singleton@1540e19dcn.net.sweetlover.patern.Singleton@1540e19dcn.net.sweetlover.patern.Singleton@1540e19dcn.net.sweetlover.patern.Singleton@1540e19d 这两者的区分：懒汉式不是线程安全的，且效率比饿汉式要低（因为加了同步），但是节约内存。但饿汉式是天生线程安全的，因为当class被加载的时候就已经被初始化了。]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>JAVA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[kafka简单入门(概念)]]></title>
    <url>%2F2018%2F11%2F05%2Fkafka%E7%AE%80%E5%8D%95%E5%85%A5%E9%97%A8-%E6%A6%82%E5%BF%B5%2F</url>
    <content type="text"><![CDATA[kafka简介Kafka是目前主流的流处理平台，同时作为消息队列家族的一员，其高吞吐性作为很多场景下的主流选择。 什么是Kafka LinkedIn开发 2011年初开源，加入Apache基金会 2012年从Apache Incubator毕业 Apache顶级开源 Apache Kafka是一个分布式流媒体平台。这到底是什么意思呢？ 流媒体平台有三个关键功能： 发布和订阅记录流，类似于消息队列或者企业消息传递系统。 以容错的持久方式存储记录流。 记录发生时处理流。 Kafka通常用于两大类应用： 构建可在系统或应用程序之间可靠获取数据的实时流数据管道 构建转换或响应数据流的实时流应用程序 Kafka概念Producer消息和数据的生产者，向Kafka的一个topic发布消息的进程/代码/服务。 Consumer消息和数据的消费者，订阅数据（topic）并且处理其发布的消息的进程/代码/服务。 Consumer Group对于同一个topic，会广播给不同的group，一个group中，只有 一个consumer 可以消费该消息。 Broker物理概念，Kafka集群中每个kafka节点。 Topic逻辑概念，Kafka消息的类别，对数据进行区分、隔离。 Partition物理概念，Kafka下数据存储的基本单元。一个Topic数据，会被分散存储到多个Partition，每个Partition是 有序的 。 每一个Topic被切分为多个Partitions 消费者数目少于或者等于Partition的数目 Broker Group中的每一个Broker保存Topic的一个或多个Partitions Consumer Group的仅有一个Consumer读取Topic的一个或者多个Partitions，并且是唯一的Consumer Replication一个partition的多个副本。同一个Partition可能有多个Replica，多个Replica之间数据是一样的，相当于备份一样。 当集群中有Broker挂掉的情况，系统可以主动的使Replicas提供服务 系统默认设置每一个Topic的Replication系数为1，可以在创建Topic单独设置 特点 基本单位是Topic的Partition 所有的读和写都从Leader进，Followers只是作为备份 Follower必须能够及时复制Leader的数据 增加容错性和可扩展性。 Replication Leader一个Partition的多个Replica上，需要一个Leader负责该Partition上的Producer和Consumer交互。且有且只有一个。 ReplicaManager负责管理当前Broker所有分区的副本的信息，处理KafkaController发起的一些请求，副本状态的切换、添加/读取消息等。]]></content>
      <categories>
        <category>消息队列</category>
      </categories>
      <tags>
        <tag>kafka</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android点击两次返回退出应用]]></title>
    <url>%2F2018%2F10%2F30%2FAndroid%E7%82%B9%E5%87%BB%E4%B8%A4%E6%AC%A1%E8%BF%94%E5%9B%9E%E9%80%80%E5%87%BA%E5%BA%94%E7%94%A8%2F</url>
    <content type="text"><![CDATA[在一些app中，一般都是主页面都会有一个连续点击两次返回键就能够退出，也是防止返回键误触导致直接退出了应用。示例没有复杂的activity管理，点击两次后直接finish就完成了。 思路直接判断用户两次按键的时间差是否在一个预期值之内，是则退出，否则应该出现一些提示来提醒用户。 12345678910111213141516171819202122232425262728293031public class MainActivity extends BaseActivity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); &#125; //记录用户首次点击返回键的时间 private long mExitFirstTime = 0; //双击间隔 private long mExitIntervalMs = 2000; @Override public boolean onKeyUp(int keyCode, KeyEvent event) &#123; switch (keyCode)&#123; case KeyEvent.KEYCODE_BACK: long secondTime = System.currentTimeMillis(); if(secondTime - mExitFirstTime &gt; mExitIntervalMs)&#123; mExitFirstTime = secondTime; Toast.makeText(MainActivity.this, R.string.exit_tip, Toast.LENGTH_SHORT) .show(); return true; //消费掉该事件 &#125;else&#123; finish(); &#125; break; &#125; return super.onKeyUp(keyCode, event); &#125;&#125; 重写onKeyDown()和onBackPressed()方法都能捕获Back的点击事件，]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[正则表达式]]></title>
    <url>%2F2018%2F09%2F28%2F%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[参考链接: https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Regular_Expressions 特殊字符 字符 含义 \ 匹配规则将依照下列规则：在非特殊字符之前的反斜杠表示下一个字符是特殊的，不能从字面上解释。例如，没有前面’\’的’b’通常匹配小写’b’，无论它们出现在哪里。如果加了’\’,这个字符变成了特殊意义的字符，意思是匹配一个字符边界。反斜杠也可以将其后的特殊字符，转义为字面量。例如，模式 /a/ 代表会匹配0个或者多个a。相反，模式 /a\/ 将 ‘‘ 的特殊性移除，从而可以匹配像 “a“ 这样的字符串。 ^ 匹配输入的开始，如果多行标志被设置为true，那么也匹配换行符后紧跟的位置。例如, /^A/ 并不匹配 “an A” 中的 ‘A’，但是会匹配 “An E”中的 ‘A’。当 ‘^’ 作为第一个字符出现在一个字符集合模式时，它将会有不同的含义。 $ 匹配输入的结束。如果多行标志被设置为true，那么也匹配换行符前的位置。例如， /t$/ 并不会匹配 “eater” 中的 ‘t’,但是会匹配 “eat” 中的 ‘t’。 * 匹配前一个表达式0次或者多次。等价于{0,}。例如，/bo*/ 会匹配”A ghost boooooed”中的 ‘booooo’ 和 “A bird warbled” 中的 ‘b’，但是在”A goat grunted” 中将不会匹配任何东西。 + 匹配前面一个表达式1次或者多次。等价于{1,}。例如，/a+/匹配了在”candy”中的’a’，和在”caaaaaaandy”中所有的’a’。 ? 匹配前面一个表达式0次或者1次。等价于{0,1}。例如，/e?le?/ 匹配”angel”中的’el’，和”angel”中的’el’，和”angle”中的’le’以及”oslo”中的’l’。如果紧跟在任何量词*、+、?或者{}的后面，将会使变量变为非贪婪的（匹配尽量少的字符），和缺省使用的贪婪模式（匹配尽可能多的字符）正好相反。例如，对”123abc”应用 /\d+/ 将会返回’123’，如果使用/\d+?/，则只会匹配到’1’。还可以运用先行断言。 . (小数点)匹配除换行符之外的任何单个字符。例如，/.n/将会匹配”nay, an apple is on the tree”中的’an’和’on’，但是不会匹配’nay’。 (x) 匹配’x’并且记住匹配项，就像下面的例子展示的那样。括号被称为捕获括号。模式 /(foo) (var) \1 \2/中的’(foo)’和’(bar)’匹配并记住字符串”foo bar foo bar”中的前两个单词，模式中的\1 和 \2 匹配字符串的后两个单词。注意\1、\2、\n是用在正则表达式的匹配环节。 (?:x) 匹配’x’但是不记住匹配项。这种叫做非捕获括号，使得你能够定义为正则表达式运算符一起使用的子表达式。来看表达式/(?:foo){1,2}/。如果表达式是/foo{1,2}/，{1,2}将只对’foo’的最后一个字符’o’生效。如果使用非捕获括号，则{1,2}会匹配整个’foo’单词。 x(?=y) 匹配’x’仅仅当’x’后面跟着’y’，这种叫做正向肯定查找。例如，/Jack(?=Spart)/会匹配到’Jack’仅仅当他后面跟着’Spart’。/Jack(?=Spart&#124;Frost)/匹配’Jack’仅仅当它后面跟着’Spart’或者是’Frost’。但是’Spart’和’Frost’都不是匹配结果的一部分。 x(?!y) 匹配’x’仅仅当’x’后面不跟着’y’，这个叫做正向否定查找。例如，/\d+(?!.)/匹配一个数字仅仅当这个数字后面没有跟小数点的时候。 x&#124;y 匹配’x’或者’y’。例如，/green&#124;red/匹配”green apple”中的’green’和”red apple”中的’red’ {n} n是一个正整数，匹配了前面一个字符刚好发生n次。 比如，/a{2}/不会匹配”candy”中的’a’，但是会匹配”caandy”中的所有a，以及”caaandy”中的前两个a。 {n,m} n,m都是整数。匹配前面的字符至少n次，最多m次。如果n和m的值为0，这个值被忽略。例如，/a{1,3}/ 并不匹配”cndy”中的任意字符，匹配”candy”中的’a’，匹配”caandy”中的前两个’a’，也匹配”caaaaaaaandy”中的前三个a。 [xyz] 一个字符集合。匹配方括号中的任意字符，包括转义字符。你可以使用破折号( - )来指定一个字符范围。对于( . )和星号( * )这样的特许符号在一个字符集中没有特殊的意义/他们不必进行转义，不过转义也是起作用的。例如，[abcd]和[a-d]是一样的。他们都匹配”brisket”中的’b’，也都匹配”city”中的’c’。/[a-z.]+/和/[\w.]+/都匹配”test.i.ng”中的所有字符。 [^xyz] 反向字符集。也就是说，它匹配任何没有包含在反括号中的字符。你可以使得破折号( - )来指定一个字符范围。任何普通字符在这里都是起作用的。例如，[^abc]和[^a-c]是一样的。他们匹配”brisker”中的’r’，也匹配”chop”中的’h’。 [\b] 匹配一个退格（U+0008）。不要和\b混淆了。 \b 匹配一个词的边界。一个词的边界就是一个词不被另外一个“字”字符跟随的位置或者没有其他“字”字符在其前面的位置。注意，一个匹配的词的边界并不包含在匹配的内容中。换句话说，一个匹配的词的边界的内容的长度为0.（不要和[\b]混淆了）。例如，/\bm/匹配”moon”中的”m”，/oo\b/并不匹配”oo”，因为’oo’被一个字符’n’紧跟着。/oon\b/匹配”moon”中的’oon’，因为’oon’是这个字符串的结束部分，这样他没有被一个字符紧跟着。/\w\b\w/将不能匹配任何字符串，因为在一个单词中间的字符永远不可能同时满足没有字符跟随和有字符跟随的两种跟随情况。 \B 匹配一个非单词边界。他匹配一个前后字符都是相同类型的位置：都是字符或者都不是字符。一个字符串的开始和结尾都被认为不是字符或者空字符串。例如，/\B../匹配”noonday”中的’oo’，而/y\B../则会匹配”possibly yestarday”中的’yes’。 \cX 当X是处于A到Z之间的字符的时候。匹配字符串中的一个控制符。例如，/\cM/匹配字符串中的”control-M”(U+000D)。 \d 匹配一个数字，相当于[0-9]。例如，/\d/或者/[0-9]/匹配”B2 is the bigjj”中的’2’。 \D 匹配一个非数字字符。相当于[^0-9]。例如，/\D/或者/[^0-9]/匹配”B2 is a jj”中的B。 \f 匹配一个换页符(U+000C)。 \n 匹配一个换行符(U+000A)。 \r 匹配一个回车符(U+000D)。 \s 匹配一个空白字符，包括空格、制表符、换页符和换行符。等价于[\f\n\r\t\v\u00a0\u1680\u1680\u180e\u2000-\u200a\u2028\u2029\u202f\u205f\u3000\ufeff]。例如，/\s\w*/匹配”foo bar.”中的’bar’。 \S 匹配一个非空白字符。等价于[^\f\n\r\t\v\u00a0\u1680\u1680\u180e\u2000-\u200a\u2028\u2029\u202f\u205f\u3000\ufeff]。例如，/\S\w*/匹配”foo bar.”中的’foo’。 \t 匹配一个水平制表符(U+0009)。 \v 匹配一个垂直制表符(U+000B)。 \w 匹配一个单字字符(字母、数字或者下划线)。等价于[A-Za-Z0-9_]。例如，/\w/匹配”apple”中的’a’，”$5.28”中的’5’和”3D”中的’3’。 \W 匹配一个非单字字符。等价于[^A-Za-z0-9_]。例如，/\W/或者/[^A-Za-z0-9_]/匹配”50%”中的’%’。 \n 在正则表达式中，它返回最后的第n个子捕获匹配的子字符串(捕获的数目以左括号计数)。比如/apple(,)\sorange\1/匹配”apple, orange, cherry, peach.”中的’apple, orange’。 \0 匹配NULL(U+0000)字符，不要在这后面跟其它小数，因为0&lt;digits&gt;是一个八进制转义序列。 \xhh 与代码hh匹配字符(两个十六进制数字)。 \uhhhh 与代码hhhh匹配字符(四个十六进制数字)。 \u{hhhh} (仅当设置了u标志时)使用Unicode值hhhh匹配字符(十六进制数字)。 常用正则表达式校验数字的表达式 数字：^[0-9]*$ n位的数字：^\d{n}$ 至少n位的数字：^\d{n,}$ m-n位的数字：^\d{m,n}$ 零和非零开头的数字：^(0|[1-9][0-9]*)$ 非零开头的最多带两位小数的数字：^([1-9][0-9]*)+(.[0-9]{1,2})?$ 带1-2位小数的正数或负数：^(-)?\d+(.\d{1,2})$ 正数、负数、和小数：^(-|+)?\d+(.\d+)?$ 有两位小数的正实数：^[0-9]+(.[0-9]{2})?$ 有1~3位小数的正实数：^[0-9]+(.[0-9]{1,3})?$ 非零的正整数：^[1-9]\d$ 或 ^([1-9][0-9]){1,3}$ 或 ^+?[1-9][0-9]*$ 非零的负整数：^-[1-9][]0-9”$ 或 ^-[1-9]\d$ 非负整数：^\d+$ 或 ^[1-9]\d*|0$ 非正整数：^-[1-9]\d*|0$ 或 ^((-\d+)|(0+))$ 非负浮点数：^\d+(.\d+)?$ 或 ^[1-9]\d.\d|0.\d[1-9]\d|0?.0+|0$ 非正浮点数：^((-\d+(.\d+)?)|(0+(.0+)?))$ 或 ^(-([1-9]\d.\d|0.\d[1-9]\d))|0?.0+|0$ 正浮点数：^[1-9]\d.\d|0.\d[1-9]\d$ 或 ^(([0-9]+.[0-9][1-9][0-9])|([0-9][1-9][0-9].[0-9]+)|([0-9][1-9][0-9]))$ 负浮点数：^-([1-9]\d.\d|0.\d[1-9]\d)$ 或 ^(-(([0-9]+.[0-9][1-9][0-9])|([0-9][1-9][0-9].[0-9]+)|([0-9][1-9][0-9])))$ 浮点数：^(-?\d+)(.\d+)?$ 或 ^-?([1-9]\d.\d|0.\d[1-9]\d|0?.0+|0)$ 校验字符的表达式 汉字：^[\u4e00-\u9fa5]{0,}$ 英文和数字：^[A-Za-z0-9]+$ 或 ^[A-Za-z0-9]{4,40}$ 长度为3-20的所有字符：^.{3,20}$ 由26个英文字母组成的字符串：^[A-Za-z]+$ 由26个大写英文字母组成的字符串：^[A-Z]+$ 由26个小写英文字母组成的字符串：^[a-z]+$ 由数字和26个英文字母组成的字符串：^[A-Za-z0-9]+$ 由数字、26个英文字母或者下划线组成的字符串：^\w+$ 或 ^\w{3,20}$ 中文、英文、数字包括下划线：^[\u4E00-\u9FA5A-Za-z0-9_]+$ 中文、英文、数字但不包括下划线等符号：^[\u4E00-\u9FA5A-Za-z0-9]+$ 或 ^[\u4E00-\u9FA5A-Za-z0-9]{2,20}$ 可以输入含有^%&amp;’,;=?$\”等字符：[^%&amp;’,;=?$\x22]+ 禁止输入含有~的字符：[^~\x22]+ 特殊需求表达式 Email地址：^\w+([-+.]\w+)@\w+([-.]\w+).\w+([-.]\w+)*$ 域名：[a-zA-Z0-9][-a-zA-Z0-9]{0,62}(/.[a-zA-Z0-9][-a-zA-Z0-9]{0,62})+/.? InternetURL：[a-zA-z]+://[^\s] 或 ^http://([\w-]+.)+[\w-]+(/[\w-./?%&amp;=])?$ 手机号码：^(13[0-9]|14[5|7]|15[0|1|2|3|5|6|7|8|9]|18[0|1|2|3|5|6|7|8|9])\d{8}$ 电话号码(“XXX-XXXXXXX”、”XXXX-XXXXXXXX”、”XXX-XXXXXXX”、”XXX-XXXXXXXX”、”XXXXXXX”和”XXXXXXXX)：^((\d{3,4}-)|\d{3.4}-)?\d{7,8}$ 国内电话号码(0511-4405222、021-87888822)：\d{3}-\d{8}|\d{4}-\d{7} 电话号码正则表达式（支持手机号码，3-4位区号，7-8位直播号码，1－4位分机号）: ((\d{11})|^((\d{7,8})|(\d{4}|\d{3})-(\d{7,8})|(\d{4}|\d{3})-(\d{7,8})-(\d{4}|\d{3}|\d{2}|\d{1})|(\d{7,8})-(\d{4}|\d{3}|\d{2}|\d{1}))$) 身份证号(15位、18位数字)，最后一位是校验位，可能为数字或字符X：(^\d{15}$)|(^\d{18}$)|(^\d{17}(\d|X|x)$) 帐号是否合法(字母开头，允许5-16字节，允许字母数字下划线)：^[a-zA-Z][a-zA-Z0-9_]{4,15}$ 密码(以字母开头，长度在6~18之间，只能包含字母、数字和下划线)：^[a-zA-Z]\w{5,17}$ 强密码(必须包含大小写字母和数字的组合，不能使用特殊字符，长度在 8-10 之间)：^(?=.\d)(?=.[a-z])(?=.*[A-Z])[a-zA-Z0-9]{8,10}$ 强密码(必须包含大小写字母和数字的组合，可以使用特殊字符，长度在8-10之间)：^(?=.\d)(?=.[a-z])(?=.*[A-Z]).{8,10}$ 日期格式：^\d{4}-\d{1,2}-\d{1,2} 一年的12个月(01～09和1～12)：^(0?[1-9]|1[0-2])$ 一个月的31天(01～09和1～31)：^((0?[1-9])|((1|2)[0-9])|30|31)$ xml文件：^([a-zA-Z]+-?)+[a-zA-Z0-9]+\.[x|X][m|M][l|L]$ 中文字符的正则表达式：[\u4e00-\u9fa5] 双字节字符：[^\x00-\xff] (包括汉字在内，可以用来计算字符串的长度(一个双字节字符长度计2，ASCII字符计1)) 空白行的正则表达式：\n\s*\r (可以用来删除空白行) HTML标记的正则表达式：&lt;(\S?)[^&gt;]&gt;.?|&lt;.? /&gt; ( 首尾空白字符的正则表达式：^\s|\s$或(^\s)|(\s$) (可以用来删除行首行尾的空白字符(包括空格、制表符、换页符等等)，非常有用的表达式) 腾讯QQ号：[1-9][0-9]{4,} (腾讯QQ号从10000开始) 中国邮政编码：[1-9]\d{5}(?!\d) (中国邮政编码为6位数字) IP地址：((?:(?:25[0-5]|2[0-4]\d|[01]?\d?\d)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d?\d)) 钱的输入格式 有四种钱的表示形式我们可以接受:”10000.00” 和 “10,000.00”, 和没有 “分” 的 “10000” 和 “10,000”：^[1-9][0-9]*$ 这表示任意一个不以0开头的数字,但是,这也意味着一个字符”0”不通过,所以我们采用下面的形式：^(0|[1-9][0-9]*)$ 一个0或者一个不以0开头的数字.我们还可以允许开头有一个负号：^(0|-?[1-9][0-9]*)$ 这表示一个0或者一个可能为负的开头不为0的数字.让用户以0开头好了.把负号的也去掉,因为钱总不能是负的吧。下面我们要加的是说明可能的小数部分：^[0-9]+(.[0-9]+)?$ 必须说明的是,小数点后面至少应该有1位数,所以”10.”是不通过的,但是 “10” 和 “10.2” 是通过的：^[0-9]+(.[0-9]{2})?$ 这样我们规定小数点后面必须有两位,如果你认为太苛刻了,可以这样：^[0-9]+(.[0-9]{1,2})?$ 这样就允许用户只写一位小数.下面我们该考虑数字中的逗号了,我们可以这样：^[0-9]{1,3}(,[0-9]{3})*(.[0-9]{1,2})?$ 1到3个数字,后面跟着任意个 逗号+3个数字,逗号成为可选,而不是必须：^([0-9]+|[0-9]{1,3}(,[0-9]{3})*)(.[0-9]{1,2})?$ “+”可以用”*”替代如果你觉得空字符串也可以接受的话(奇怪,为什么?)最后,别忘了在用函数时去掉去掉那个反斜杠,一般的错误都在这里]]></content>
      <categories>
        <category>程序人生</category>
      </categories>
      <tags>
        <tag>正则表达式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Go并发之channel]]></title>
    <url>%2F2018%2F09%2F25%2FGo%E5%B9%B6%E5%8F%91%E4%B9%8Bchannel%2F</url>
    <content type="text"><![CDATA[channel是什么channel是Go中一个非常重要的特性，在Go并发之goroutine里有介绍了CSP模型，CSP 是 Communicating Sequential Process 的简称，中文可以叫做通信顺序进程，是一种并发编程模型。Go实现了CSP部分的理论，goroutine对应CSP中并发执行的实体，channel也就对应着CSP中的channel。 channel操作符操作符 &lt;- 1234567ch := make(chan int)//读x &lt;- chan//写chan &lt;- 10 channel创建必须使用make创建channel 12bufChan := make(chan int, 10) //1、带缓冲channelnoBufChan := make(chan string) //2、无缓冲channel 和map类似，channel也是一个对应make创建的底层数据结构的引用，当我们复制一个channel或者用于函数参数传递时，只是拷贝了一个channel的引用，channel的零值为nil。 以方式1创建的channel是带缓冲的，方式2即为无缓冲的。 示例代码1：12345678910111213141516package mainimport "fmt"func main() &#123; channel := make(chan int) //创建一个int类型的channel //匿名函数 go func() &#123; channel &lt;- 10 fmt.Println("chan &lt;-") //子协程 &#125;() &lt;- channel //没有数据前阻塞 fmt.Println("&lt;- chan")&#125; 运行结果： 再来看一下下面这个例子 12345678910111213141516package mainimport "fmt"func main() &#123; var channel chan int go func() &#123; channel &lt;- 10 fmt.Println("chan &lt;-") &#125;() &lt;- channel fmt.Println("&lt;- chan")&#125; 运行结果： 为什么会deadlock，因为channel并没有创建。 不带缓冲channel一个基于无缓存的channel的发送操作将导致发送者goroutine阻塞，直到另一个goroutine在相同的channel上执行接收操作，当发送的值通过channel成功传输之后，两个goroutine可以继续执行后面的语句。反之，如果接受操作先发生，那么接收者goroutine也将阻塞，直到有另一个goroutine在相同的channel上执行发送操作。 基于无缓存channel的发送和接收操作将导致两个goroutine做一次同步操作。因为这个原因，无缓存channel有时候也被成为同步channel。当通过一个无缓存channel发送数据时，接收者收到数据发生在唤醒发送者goroutine之前。 channel接受和发送数据都是阻塞的，除非另一端已经准备好，这样使得goroutine同步变得更加的简单，不用显式的lock。 谓阻塞就是读取，会被阻塞，直到有数据接收。其次，任何发送将会被阻塞，直到数据被读出。 无缓冲的channel是多个goroutine之间同步很棒的工具。 示例代码：12345678910111213141516171819202122package mainimport "fmt"func sum(a []int, ch chan int)&#123; total := 0 fmt.Println(a) for _,v := range a &#123; total += v &#125; ch&lt;- total&#125;func main() &#123; ch := make(chan int) a := []int&#123;1,2,3,4,5,6&#125; go sum(a[:3], ch) go sum(a[3:], ch) x := &lt;-ch y := &lt;-ch fmt.Println(x, y)&#125; 运行结果： 结果有两种，这只是其中一种。 带缓冲的channel在Go中也允许指定channel的缓冲大小 1ch := make(chan type, value) 当 value = 0 时，channel就是无缓冲的channel，当 value &gt; 0 时， channel有缓冲、是非阻塞的，直到写满value个元素后才阻塞写入。 示例代码：123456789101112package mainimport "fmt"func main() &#123; ch := make(chan int, 2) //缓冲大小为2 ch&lt;- 10 ch&lt;- 20 fmt.Println(&lt;-ch) fmt.Println(&lt;-ch)&#125; 运行结果： 如果代码中将缓存区域设置为1，则会出现deadlock错误。fatal error: all goroutines are asleep - deadlock! 单向channel默认情况下是双向的，即可读可写，读代表receive，写代表send。 通常情况我们会将一个通道作为函数参数传递过去，但是默认是双向的，我只想让该参数只能进行读或者写，那就用到了单向channel。 123var ch1 chan int //默认双向var ch2 chan&lt;- int //单向，只读var ch3 &lt;-chan int //单项，只写 双向channel可以隐式转换为单向channel，反之则不行。 关闭channel关闭channel只需要close函数即可，可以使用多返回值的方式 v,ok := &lt;-ch方式来判断channel是否被关闭。 示例代码：1234567891011121314151617181920package mainimport "fmt"func foreach(arr []int, b chan bool)&#123; for i,v := range arr &#123; fmt.Printf("i=%d, v=%d \n", i, v) &#125; b&lt;- true close(b)&#125;func main() &#123; arr := []int&#123;12,4,6,7,9,2&#125; ch := make(chan bool, 10) go foreach(arr, ch) if v, ok := &lt;-ch; !ok &#123; fmt.Println(v) &#125;&#125; 当一个channel被关闭后，再向该channel发送数据将导致panic异常。 其实你并不需要关闭每一个channel。只要当需要告诉接收者goroutine，所有的数据已经全部发送时才需要关闭channel。不管一个channel是否被关闭，当它没有被引用时将会被Go语言的垃圾自动回收器回收。（不要将关闭一个打开文件的操作和关闭一个channel操作混淆。对于每个打开的文件，都需要在不使用的使用调用对应的Close方法来关闭文件。）试图重复关闭一个channel将导致panic异常，试图关闭一个nil值的channel也将导致panic异常。关闭一个channels还会触发一个广播机制 Range遍历channel可以通过range，像操作slice或者map一样操作缓存类型的channel 使用range实现斐波那契数列 示例代码：1234567891011121314151617181920package mainimport "fmt"func fibonacci(n int, f chan int)&#123; x, y := 1, 1 for i:=0; i&lt;n; i++ &#123; f &lt;- x x, y = y, x+y &#125; close(f)&#125;func main() &#123; ch := make(chan int, 10) go fibonacci(cap(ch), ch) for v := range ch &#123; fmt.Printf("%d ", v) &#125;&#125; SelectGo提供了一个关键字select，通过select可以监听channel上的数据流动。 语法和恶switch非常相似，每个条件由case来描述。但是select有很多限制，其中一条就是每个case语句里必须是一个IO操作。 大致结构12345678selct &#123; case &lt;-ch: //如果读数据，则执行 case ch&lt;- 1: //如果写数据，则执行 default: //默认处理流程，但是一般情况select不用该条件，因为无意义&#125; 在一个select语句中，Go会按顺序从头到尾评估每一条发送和接收的语句。 但是其中任意一语句都可以，是任意都可以(即没有被堵塞)，那么就从那么可以执行的语句中任意选择来使用。 如果没有任意一条语句可以执行，那么可能有两种情况。 如果给出了default语句，则会执行default语句，同时程序的执行会从select语句后的语句中恢复。 如果没有default语句，那么select语句将被阻塞，直到有一个通信可以进行下去。 使用select实现斐波那契数列示例代码：12345678910111213141516171819202122232425262728293031323334package mainimport "fmt"func fibonacci(n chan int, b chan bool) &#123; x, y := 1, 1 for &#123; select &#123; case n&lt;- x: x, y = y, x+y case &lt;-b: fmt.Println("end") return &#125; &#125;&#125;//使用select实现斐波那契func main() &#123; n := make(chan int, 10) b := make(chan bool) go func() &#123; for i := 0; i &lt; cap(n); i++ &#123; fmt.Println(&lt;-n) &#125; b&lt;- true &#125;() fibonacci(n, b)&#125; 运行结果：]]></content>
      <categories>
        <category>Golang</category>
      </categories>
      <tags>
        <tag>Golang基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Go并发之goroutine]]></title>
    <url>%2F2018%2F09%2F24%2FGo%E5%B9%B6%E5%8F%91%E4%B9%8Bgoroutine%2F</url>
    <content type="text"><![CDATA[Go语言并发优势作为云计算时代的C语言之称的Go语言，第一是因为Go语言设计简单，第二21实际最重要的就是并发程序设计，而Go在语言层面上就支持了并发。在此同时，并发程序的内存管理有时候是非常复杂的，而Go自身也提供了自动垃圾回收机制。 Go语言为并发编程而内置的上层API是基于CSP模型，这里引用了知乎原文链接,CSP(Communicating Sequential Process)模型和Actor模型是两门非常复古且外形接近的并发模型。但CSP与Actor有以下几点比较大的区别： CSP并不Focus发送消息的实体/Task，而是关注发送消息时消息所使用的载体，即channel。 在Actor的设计中，Actor与信箱是耦合的，而在CSP中channel是作为first-class独立存在的。 另外一点在于，Actor中有明确的send/receive的关系，而channel中并不区分这样的关系，执行块可以任意选择发送或者取出消息。 另外默认情况下的channel是无缓存的,对channel的send动作是同步阻塞的，直到另外一个持有该channel引用的执行块取出消息(channel为空)，反之，receive动作亦然。藉此，我们可以得到一个基本确定的事实，by default时，实际的receive操作只会在send之后才被发生。而Actor中，由于send这个动作是异步的，因此Actor的receive会按照信箱接受到消息的顺序来进行处理。当然，除此以外，channel还有种Buffered Channel的模式，在默认情况的基础上，你可以确定channel内的消息数量，当channel中消息数量不满足于初始化时Buffer数目时，send动作不会被阻塞，写入操作会立即完成(因此Buffered Channel在很大程度上与Actor非常接近)，直到Buffer数目已满，则send动作开始阻塞。 这也意味着显示锁都是可以避免的，因为Go语言通过安全的通道发送和接受以实现同步，也简化了并发程序的编写。 而一般情况下，桌面计算机跑十几二十个线程就有点负载了，而同样的一台计算机，却可以轻松跑起成百上千甚至万个goroutine进行资源竞争。 goroutine是什么goroutine是Go并行设计的设置核心，它其实就是协程，但是它比线程更小，十几个goroutine可能体现在底层就是五六个线程，Go语言内部帮你实现了这些goroutine之间的内存共享。执行goroutine只需极少的栈内存，当然会根据相应的数据伸缩。也正是如此，可以同时运行成千上万个并发任务。goroutine比thread更易用、更高效、更轻便。 goroutine的创建只需要函数调用前加一个 go 关键字，就可以创建并发执行单元。无需了解其他细节，调度器会自动安排到合适的系统线程上执行。 像java语言一样，go也有其main函数，有着其main thread。在go语言中，main函数既在一个单独的goroutine中运行，也可以成为main goroutine。新的goroutine用go语句来创建。 示例代码1：12345678910111213package mainimport ( "fmt" "time")func main() &#123; for &#123; //死循环 fmt.Println("this is main goroutine") time.Sleep(time.Second) &#125;&#125; 运行结果： 手动退出，这是一个主协程，那么再看下面一个代码示例代码2：1234567891011121314151617181920212223package mainimport ( "fmt" "time")func newTask()&#123; for &#123; fmt.Println("this is a new Task") time.Sleep(time.Second) &#125;&#125;func main() &#123; for &#123; fmt.Println("this is main goroutine") time.Sleep(time.Second) &#125; newTask()&#125; 运行结果： 毫无疑问示例2与示例1中运行结果没有区别，而如何让他们同时执行呢 示例代码3：12345678910111213141516171819202122232425package mainimport ( "fmt" "time")func newTask()&#123; for &#123; fmt.Println("this is a new Task") time.Sleep(time.Second) &#125;&#125;func main() &#123; go newTask() //新建一个协程 //需要将代码放置前面，如果放置后面，死循环同样没办法执行这条语句 for &#123; fmt.Println("this is main goroutine") time.Sleep(time.Second) &#125;&#125; 运行结果： 一个新的协程只需要一个关键字go就已经完成了。 main goroutine先退出我们再看一个奇怪的现象 示例代码4：12345678910111213141516171819package mainimport ( "fmt" "time")func newTask()&#123; for &#123; fmt.Println("this is a new Task") time.Sleep(time.Second) &#125;&#125;func main() &#123; go newTask()&#125; 运行结果： 为什么结果什么都没有，我们明明已经开了一个新的协程来进行执行newTask函数，这就是go中main函数执行的太快了，也就是main goroutine已经执行完了，所有的goroutine都会直接打断，程序退出。 为了防止main goroutine过快的结束，123456789101112131415161718192021package mainimport ( "fmt" "time")func newTask()&#123; for &#123; fmt.Println("this is a new Task") time.Sleep(time.Second) &#125;&#125;func main() &#123; go newTask() time.Sleep(5 * time.Second)&#125; 运行结果： 让main goroutine睡了5秒，而newTask也刚好执行了5次，也解释了当main goroutine结束时，所有的goroutine都会直接打断，程序退出。]]></content>
      <categories>
        <category>Golang</category>
      </categories>
      <tags>
        <tag>Golang基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Go环境搭建]]></title>
    <url>%2F2018%2F09%2F22%2FGo%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[Go语言优势GO语言（Golang）是云计算时代的C语言。它不仅有着更高的生产效率，也对多处理器系统应用程序的编程进行了优化，语言层面支持并发，内置runtime，支持GC，并且语法简单易学，并不像java有着那么复杂的语法。 Go可以做什么 服务器编程 分布式系统 网络编程 内存数据库 云平台 and so on 环境搭建教程基于win10，linux等系统请参考其他文章官网，自行下载msi文件，傻瓜式安装，安装路径不要出现中文避免出差错。需要翻墙，没有可以选择Golang中文网测试安装：打开终端输入12$ go versiongo version go1.11 windows/amd64 即可完成安装 环境配置打开终端输入123456789101112131415161718192021222324252627$ go envset GOARCH=amd64set GOBIN=set GOCACHE=C:\Users\Administrator\AppData\Local\go-buildset GOEXE=.exeset GOFLAGS=set GOHOSTARCH=amd64set GOHOSTOS=windowsset GOOS=windowsset GOPATH=E:\Goset GOPROXY=set GORACE=set GOROOT=G:\Golangset GOTMPDIR=set GOTOOLDIR=G:\Golang\pkg\tool\windows_amd64set GCCGO=gccgoset CC=gccset CXX=g++set CGO_ENABLED=1set GOMOD=set CGO_CFLAGS=-g -O2set CGO_CPPFLAGS=set CGO_CXXFLAGS=-g -O2set CGO_FFLAGS=-g -O2set CGO_LDFLAGS=-g -O2set PKG_CONFIG=pkg-configset GOGCCFLAGS=-m64 -mthreads -fno-caret-diagnostics -Qunused-arguments -fmessage-length=0 -fdebug-prefix-map=C:\Users\ADMINI~1\AppData\Local\Temp\go-build669911038=/tmp/go-build -gno-record-gcc-switches msi包基本会把环境配置完成，但要配置GOPATH目录，不要用默认配置的计算机(右键)-属性-高级系统设置-环境变量在 用户变量 下添加 GOPATH 值为你想要的路径即可。在配置目录下创建三个文件夹，分别是 src目录 此目录是自己在GoPath目录下手动创建的，用于放源代码文件。 pkg目录 此目录是在src的源文件目录下对.go文件通过go install之后自动生成的，放编译后的包文件。 bin目录 此目录是在src的源文件目录下对 .go文件通过go build和go install之后自动生成的，.go文件要调用pkg下的包文件。 环境基本搭建完成。再次输入1$ go env 发现修改了即可。]]></content>
      <categories>
        <category>Golang</category>
      </categories>
      <tags>
        <tag>环境搭建</tag>
        <tag>Golang基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Maven配置]]></title>
    <url>%2F2018%2F09%2F22%2FMaven%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[Maven基础环境搭建 环境 window10 jdk1.6或以上 下载Maven官网 直接选择 apache-maven-3.5.4-bin.zip格式下载解压即可 配置环境变量MAVEN_HOME我的解压存放的目录是 G:\Maven ，下面目录自行替换 计算机(右键)-属性-高级系统设置-环境变量 新建系统变量 MAVEN_HOME 变量值： G:\Maven 编辑系统变量 Path 添加变量值： G:\Maven\bin 检测是否安装成功git-bash或者命令提示符下，输入123456$ mvn --versionApache Maven 3.5.4 (1edded0938998edf8bf061f1ceb3cfdeccf443fe; 2018-06-18T02:33:14+08:00)Maven home: G:\MavenJava version: 1.8.0_131, vendor: Oracle Corporation, runtime: G:\Java\jreDefault locale: zh_CN, platform encoding: GBKOS name: "windows 10", version: "10.0", arch: "amd64", family: "windows" 出现类似即可。 Maven配置修改本地仓库地址Maven缺省的本地仓库路径 用户目录/.m2/repository 打开maven安装目录下的conf目录中的 settings.xml 文件 搜索 localRepository取消注释，修改成想要存放的路径保存即可，如图所示 IDEA配置 Eclipse配置]]></content>
      <categories>
        <category>Maven</category>
      </categories>
      <tags>
        <tag>环境搭建</tag>
        <tag>Maven</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[架构参考]]></title>
    <url>%2F2018%2F09%2F22%2F%E6%9E%B6%E6%9E%84%E5%8F%82%E8%80%83%2F</url>
    <content type="text"><![CDATA[架构参考，原文来自(https://blog.52itstyle.com/architecture.html) 技术选型网关：Nginx、Kong、Zuul缓存：Redis、MemCached、OsCache、EhCache搜索：ElasticSearch、Solr熔断：Hystrix 负载均衡：DNS、F5、LVS、Nginx、OpenResty、HAproxy注册中心：Eureka、Zookeeper、Redis、Etcd、Consul认证鉴权：JWT消费队列：RabbitMQ、ZeroMQ、Redis、ActiveMQ、Kafka 日志收集：ELK、Redis系统监控：GPE、PinPoint、Zipkin文件系统：OSS、NFS、FastDFS、MogileFSRPC框架： Dubbo、Motan、Thrift、grpc 构建工具：Maven、Gradle集成部署：Docker、Jenkins、Git、Maven 数据库：MySql、Redis、MongoDB、PostgreSQL、Memcache、HBase网络：专用网络VPC、弹性公网IP、CDN数据库中间件：DRDS （阿里云）、Mycat、360 Atlas、Cobar (不维护了)分布式框架：Dubbo、Motan、Spring-Could 架构必备负载均衡（负载均衡算法）反向代理服务隔离服务限流服务降级（自动优雅降级）失效转移超时重试（代理超时、容器超时、前端超时、中间件超时、数据库超时、NoSql超时）回滚机制（上线回滚、数据库版本回滚、事务回滚） 高并发应用缓存HTTP缓存多级缓存分布式缓存连接池异步并发 分布式事务二阶段提交(强一致)三阶段提交(强一致)消息中间件(最终一致性)，推荐阿里的RocketMQ 队列任务队列消息队列请求队列 扩容单体垂直扩容单体水平扩容应用拆分数据库拆分数据库分库分表数据异构分布式任务 网络安全SQL注入XSS攻击CSRF攻击拒绝服务（DoS，Denial of Service）攻击]]></content>
      <categories>
        <category>架构之路</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[开源协议介绍]]></title>
    <url>%2F2018%2F09%2F22%2F%E5%BC%80%E6%BA%90%E5%8D%8F%E8%AE%AE%E4%BB%8B%E7%BB%8D%2F</url>
    <content type="text"><![CDATA[一些开源协议的介绍，考古。分别是MIT,Apache,LGPL,GPL,BSD,MPL 现今存在的开源协议很多，而经过Open Source Initiative组织通过批准的开源协议目前有58种（http://www.opensource.org/licenses /alphabetical）。 Apache Licene 2.0Apache Licence是著名的非盈利开源组织Apache采用的协议。该协议和BSD类似，同样鼓励代码共享和尊重原作者的著作权，同样允许代码修改，再发布（作为开源或商业软件）。需要满足的条件也和BSD类似： 需要给代码的用户一份Apache Licence 如果你修改了代码，需要在被修改的文件中说明。 在延伸的代码中（修改和有源代码衍生的代码中）需要带有原来代码中的协议，商标，专利声明和其他原来作者规定需要包含的说明。 如果再发布的产品中包含一个Notice文件，则在Notice文件中需要带有Apache Licence。你可以在Notice中增加自己的许可，但不可以表现为对Apache Licence构成更改。 Apache Licence也是对商业应用友好的许可。使用者也可以在需要的时候修改代码来满足需要并作为开源或商业产品发布/销售。 英文原文：http://www.apache.org/licenses/LICENSE-2.0.html MPL (Mozilla Public License)MPL是The Mozilla Public License的简写，是1998年初Netscape的 Mozilla小组为其开源软件项目设计的软件许可证。MPL许可证出现的最重要原因就是，Netscape公司认为GPL许可证没有很好地平衡开发者对 源代码的需求和他们利用源代码获得的利益。同著名的GPL许可证和BSD许可证相比，MPL在许多权利与义务的约定方面与它们相同（因为都是符合OSIA 认定的开源软件许可证）。但是，相比而言MPL还有以下几个显著的不同之处: MPL虽然要求对于经MPL许可证发布的源代码的修改也要以MPL许可证的方式再许可出来，以保证其他人可以在MPL的条款下共享源代码。但是，在MPL 许可证中对“发布”的定义是“以源代码方式发布的文件”，这就意味着MPL允许一个企业在自己已有的源代码库上加一个接口，除了接口程序的源代码以MPL 许可证的形式对外许可外，源代码库中的源代码就可以不用MPL许可证的方式强制对外许可。这些，就为借鉴别人的源代码用做自己商业软件开发的行为留了一个 豁口。 MPL许可证第三条第7款中允许被许可人将经过MPL许可证获得的源代码同自己其他类型的代码混合得到自己的软件程序。 对软件专利的态度，MPL许可证不像GPL许可证那样明确表示反对软件专利，但是却明确要求源代码的提供者不能提供已经受专利保护的源代码（除非他本人是 专利权人，并书面向公众免费许可这些源代码），也不能在将这些源代码以开放源代码许可证形式许可后再去申请与这些源代码有关的专利。 对源代码的定义而在MPL（1.1版本）许可证中，对源代码的定义是:“源代码指的是对作品进行修改最优先择 取的形式，它包括:所有模块的所有源程序，加上有关的接口的定义，加上控制可执行作品的安装和编译的‘原本’（原文为‘Script’），或者不是与初始 源代码显著不同的源代码就是被源代码贡献者选择的从公共领域可以得到的程序代码。” MPL许可证第3条有专门的一款是关于对源代码修改进行描述的规定，就是要求所有再发布者都得有一个专门的文件就对源代码程序修改的时间和修改的方式有描述。 英文原文：http://www.mozilla.org/MPL/MPL-1.1.html BSDBSD开源协议是一个给于使用者很大自由的协议。基本上使用者可以”为所欲为”,可以自由的使用，修改源代码，也可以将修改后的代码作为开源或者专有软件再发布。 但”为所欲为”的前提当你发布使用了BSD协议的代码，或则以BSD协议代码为基础做二次开发自己的产品时，需要满足三个条件： 如果再发布的产品中包含源代码，则在源代码中必须带有原来代码中的BSD协议。 如果再发布的只是二进制类库/软件，则需要在类库/软件的文档和版权声明中包含原来代码中的BSD协议。 不可以用开源代码的作者/机构名字和原来产品的名字做市场推广。 BSD 代码鼓励代码共享，但需要尊重代码作者的著作权。BSD由于允许使用者修改和重新发布代码，也允许使用或在BSD代码上开发商业软件发布和销售，因此是对 商业集成很友好的协议。而很多的公司企业在选用开源产品的时候都首选BSD协议，因为可以完全控制这些第三方的代码，在必要的时候可以修改或者二次开发。 GPL（GNU General Public License）我们很熟悉的Linux就是采用了GPL。GPL协议和BSD, Apache Licence等鼓励代码重用的许可很不一样。GPL的出发点是代码的开源/免费使用和引用/修改/衍生代码的开源/免费使用，但不允许修改后和衍生的代 码做为闭源的商业软件发布和销售。这也就是为什么我们能用免费的各种linux，包括商业公司的linux和linux上各种各样的由个人，组织，以及商 业软件公司开发的免费软件了。 GPL协议的主要内容是只要在一个软件中使用(”使用”指类库引用，修改后的代码或者衍生代码)GPL 协议的产品，则该软件产品必须也采用GPL协议，既必须也是开源和免费。这就是所谓的”传染性”。GPL协议的产品作为一个单独的产品使用没有任何问题， 还可以享受免费的优势。 由于GPL严格要求使用了GPL类库的软件产品必须使用GPL协议，对于使用GPL协议的开源代码，商业软件或者对代码有保密要求的部门就不适合集成/采用作为类库和二次开发的基础。 其它细节如再发布的时候需要伴随GPL协议等和BSD/Apache等类似。 GPL V2 、 V3GPL同其它的自由软件许可证一样，许可社会公众享有：运行、复制软件的自由，发行传播软件的自由，获得软件源码的自由，改进软件并将自己作出的改进版本向社会发行传播的自由。GPL还规定：只要这种修改文本在整体上或者其某个部分来源于遵循GPL的程序，该修改文本的 整体就必须按照GPL流通，不仅该修改文本的源码必须向社会公开，而且对于这种修改文本的流通不准许附加修改者自己作出的限制。因此，一项遵循GPL流通 的程序不能同非自由的软件合并。GPL所表达的这种流通规则称为copyleft，表示与copyright(版权)的概念“相左”。 GPL协议最主要的几个原则： 确保软件自始至终都以开放源代码形式发布，保护开发成果不被窃取用作商业发售。任何一套软 件，只要其中使用了受 GPL 协议保护的第三方软件的源程序，并向非开发人员发布时，软件本身也就自动成为受 GPL 保护并且约束的实体。也就是说，此时它必须开放源代码。 GPL 大致就是一个左侧版权（Copyleft，或译为“反版权”、“版权属左”、“版权所无”、“版责”等）的体现。你可以去掉所有原作的版权 信息，只要你保持开源，并且随源代码、二进制版附上 GPL 的许可证就行，让后人可以很明确地得知此软件的授权信息。GPL 精髓就是，只要使软件在完整开源 的情况下，尽可能使使用者得到自由发挥的空间，使软件得到更快更好的发展。 无论软件以何种形式发布，都必须同时附上源代码。例如在 Web 上提供下载，就必须在二进制版本（如果有的话）下载的同一个页面，清楚地提供源代码下载的链接。如果以光盘形式发布，就必须同时附上源文件的光盘。 开发或维护遵循 GPL 协议开发的软件的公司或个人，可以对使用者收取一定的服务费用。但还是一句老话——必须无偿提供软件的完整源代码，不得将源代码与服务做捆绑或任何变相捆绑销售。 LGPL（GNU Lesser General Public License）LGPL是GPL的一个为主要为类库使用设计的开源协议。和GPL要求任何使用/修改/衍生之GPL类库的的软件必须采用GPL协议不同。 LGPL 允许商业软件通过类库引用(link)方式使用LGPL类库而不需要开源商业软件的代码。这使得采用LGPL协议的开源代码可以被商业软件作为类库引用并 发布和销售。 但是如果修改LGPL协议的代码或者衍生，则所有修改的代码，涉及修改部分的额外代码和衍生的代码都必须采用LGPL协议。因此LGPL协议的开源 代码很适合作为第三方类库被商业软件引用，但不适合希望以LGPL协议代码为基础，通过修改和衍生的方式做二次开发的商业软件采用。 GPL/LGPL都保障原作者的知识产权，避免有人利用开源代码复制并开发类似的产品 MITMIT是和BSD一样宽范的许可协议,作者只想保留版权,而无任何其他了限制.也就是说,你必须在你的发行版里包含原许可协议的声明,无论你是以二进制发布的还是以源代码发布的。 相关资料 http://www.open-open.com/solution/view/1319814738108 http://www.open-open.com/solution/view/1405088577732 http://www.open-open.com/solution/view/1319816219625]]></content>
      <categories>
        <category>程序人生</category>
      </categories>
      <tags>
        <tag>开源协议</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Go fmt包的格式化输出]]></title>
    <url>%2F2018%2F09%2F14%2FGo-fmt%E5%8C%85%E7%9A%84%E6%A0%BC%E5%BC%8F%E5%8C%96%E8%BE%93%E5%87%BA%2F</url>
    <content type="text"><![CDATA[golang 的fmt 包实现了格式化I/O函数，类似于C的 printf 和 scanf 普通占位符 占位符 说明 %v 相应值的默认格式，基本万能 %+v 打印结构体时，会添加字段名 %#v 响应值的Go语法表示 %T 响应值的类型的Go语法表示 %% 字面上的百分号，并非值的占位符 布尔占位符 占位符 说明 %t true 或者 false 整数占位符 占位符 说明 %b 二进制表示 %c 相应unicode码所表示的字符 %d 十进制表示 %o 八进制表示 %q 单引号围绕的字符字面值，由Go语法安全的转义，如Printf(%q, 0x4E2E)输出’中’ %x 十六进制表示，字母形式为小写a-f %X 十六进制表示，字母形式为A-F %U unicode格式，U+1234 等同于 U+%04X 浮点数和复数的组成部分（实部和虚部） 占位符 说明 %b 无小数部分的，指数为二的幂的科学记数法 %e 科学记数法 %E 科学计数法 %f 有小数点而无指数 %g 根据情况选择%e 或者 %f 以产生更紧凑的输出 %G 根据情况选择%E 或者 %f 以产生更紧凑的输出 字符串和字节切片 占位符 说明 %s 输出字符串表示（字符串类型或[]byte类型） %q 双引号围绕的字符串，由Go语法安全地转义 %x 十六进制，小写字母，每字节两个字符 %X 十六进制，大写字母，每字节两个字符 指针 占位符 说明 %p 十六进制表示，前缀0x 其他 占位符 说明 + 总打印数值的正负号；对于%q（%+q）保证只输出ASCII编码的字符。 - 在右侧而非左侧填充空格（左对齐该区域） # 备用格式：为八进制添加前导 0（%#o） ‘ ‘ (空格)为数值中省略的正负号留出空白（% d） 0 填充前导的0而非空格；对于数字，这会将填充移到正负号之后 golang没有 ‘%u’ 点位符，若整数为无符号类型，默认就会被打印成无符号的。 宽度与精度的控制格式以Unicode码点为单位。宽度为该数值占用区域的最小宽度；精度为小数点之后的位数。操作数的类型为int时，宽度与精度都可用字符 ‘*’ 表示。 对于 %g/%G 而言，精度为所有数字的总数，例如：123.45，%.4g 会打印123.5，（而 %6.2f 会打印123.45）。 %e 和 %f 的默认精度为6 对大多数的数值类型而言，宽度为输出的最小字符数，如果必要的话会为已格式化的形式填充空格。 而以字符串类型，精度为输出的最大字符数，如果必要的话会直接截断。]]></content>
      <categories>
        <category>Golang</category>
      </categories>
      <tags>
        <tag>Golang基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Go标准命令]]></title>
    <url>%2F2018%2F09%2F14%2FGo%E6%A0%87%E5%87%86%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[Go命令Go语言自带有一套完整的命令操作工具，你可以通过在命令行中执行go来查看它们： 图1.3 Go命令显示详细的信息 这些命令对于我们平时编写的代码非常有用，接下来就让我们了解一些常用的命令。 go build 这个命令主要用于编译代码。在包的编译过程中，若有必要，会同时编译与之相关联的包。 如果是普通包，就像我们在1.2节中编写的mymath包那样，当你执行go build之后，它不会产生任何文件。如果你需要在$GOPATH/pkg下生成相应的文件，那就得执行go install。 如果是main包，当你执行go build之后，它就会在当前目录下生成一个可执行文件。如果你需要在$GOPATH/bin下生成相应的文件，需要执行go install，或者使用go build -o 路径/a.exe。 如果某个项目文件夹下有多个文件，而你只想编译某个文件，就可在go build之后加上文件名，例如go build a.go；go build命令默认会编译当前目录下的所有go文件。 你也可以指定编译输出的文件名。例如1.2节中的mathapp应用，我们可以指定go build -o astaxie.exe，默认情况是你的package名(非main包)，或者是第一个源文件的文件名(main包)。 （注：实际上，package名在Go语言规范中指代码中“package”后使用的名称，此名称可以与文件夹名不同。默认生成的可执行文件名是文件夹名。） go build会忽略目录下以“_”或“.”开头的go文件。 如果你的源代码针对不同的操作系统需要不同的处理，那么你可以根据不同的操作系统后缀来命名文件。例如有一个读取数组的程序，它对于不同的操作系统可能有如下几个源文件： array_linux.goarray_darwin.goarray_windows.goarray_freebsd.go go build的时候会选择性地编译以系统名结尾的文件（Linux、Darwin、Windows、Freebsd）。例如Linux系统下面编译只会选择array_linux.go文件，其它系统命名后缀文件全部忽略。 参数的介绍 -o 指定输出的文件名，可以带上路径，例如 go build -o a/b/c -i 安装相应的包，编译+go install -a 更新全部已经是最新的包的，但是对标准包不适用 -n 把需要执行的编译命令打印出来，但是不执行，这样就可以很容易的知道底层是如何运行的 -p n 指定可以并行可运行的编译数目，默认是CPU数目 -race 开启编译的时候自动检测数据竞争的情况，目前只支持64位的机器 -v 打印出来我们正在编译的包名 -work 打印出来编译时候的临时文件夹名称，并且如果已经存在的话就不要删除 -x 打印出来执行的命令，其实就是和-n的结果类似，只是这个会执行 -ccflags &#39;arg list&#39; 传递参数给5c, 6c, 8c 调用 -compiler name 指定相应的编译器，gccgo还是gc -gccgoflags &#39;arg list&#39; 传递参数给gccgo编译连接调用 -gcflags &#39;arg list&#39; 传递参数给5g, 6g, 8g 调用 -installsuffix suffix 为了和默认的安装包区别开来，采用这个前缀来重新安装那些依赖的包，-race的时候默认已经是-installsuffix race,大家可以通过-n命令来验证 -ldflags &#39;flag list&#39; 传递参数给5l, 6l, 8l 调用 -tags &#39;tag list&#39; 设置在编译的时候可以适配的那些tag，详细的tag限制参考里面的 Build Constraints go clean 这个命令是用来移除当前源码包和关联源码包里面编译生成的文件。这些文件包括 _obj/ 旧的object目录，由Makefiles遗留 _test/ 旧的test目录，由Makefiles遗留 _testmain.go 旧的gotest文件，由Makefiles遗留 test.out 旧的test记录，由Makefiles遗留 build.out 旧的test记录，由Makefiles遗留 *.[568ao] object文件，由Makefiles遗留 DIR(.exe) 由go build产生 DIR.test(.exe) 由go test -c产生 MAINFILE(.exe) 由go build MAINFILE.go产生 *.so 由 SWIG 产生 我一般都是利用这个命令清除编译文件，然后github递交源码，在本机测试的时候这些编译文件都是和系统相关的，但是对于源码管理来说没必要。 $ go clean -i -n cd /Users/astaxie/develop/gopath/src/mathapp rm -f mathapp mathapp.exe mathapp.test mathapp.test.exe app app.exe rm -f /Users/astaxie/develop/gopath/bin/mathapp 参数介绍 -i 清除关联的安装的包和可运行文件，也就是通过go install安装的文件 -n 把需要执行的清除命令打印出来，但是不执行，这样就可以很容易的知道底层是如何运行的 -r 循环的清除在import中引入的包 -x 打印出来执行的详细命令，其实就是-n打印的执行版本 go fmt 有过C/C++经验的读者会知道,一些人经常为代码采取K&amp;R风格还是ANSI风格而争论不休。在go中，代码则有标准的风格。由于之前已经有的一些习惯或其它的原因我们常将代码写成ANSI风格或者其它更合适自己的格式，这将为人们在阅读别人的代码时添加不必要的负担，所以go强制了代码格式（比如左大括号必须放在行尾），不按照此格式的代码将不能编译通过，为了减少浪费在排版上的时间，go工具集中提供了一个go fmt命令 它可以帮你格式化你写好的代码文件，使你写代码的时候不需要关心格式，你只需要在写完之后执行go fmt &lt;文件名&gt;.go，你的代码就被修改成了标准格式，但是我平常很少用到这个命令，因为开发工具里面一般都带了保存时候自动格式化功能，这个功能其实在底层就是调用了go fmt。接下来的一节我将讲述两个工具，这两个工具都自带了保存文件时自动化go fmt功能。 使用go fmt命令，其实是调用了gofmt，而且需要参数-w，否则格式化结果不会写入文件。gofmt -w -l src，可以格式化整个项目。 所以go fmt是gofmt的上层一个包装的命令，我们想要更多的个性化的格式化可以参考 gofmt gofmt的参数介绍 -l 显示那些需要格式化的文件 -w 把改写后的内容直接写入到文件中，而不是作为结果打印到标准输出。 -r 添加形如“a[b:len(a)] -&gt; a[b:]”的重写规则，方便我们做批量替换 -s 简化文件中的代码 -d 显示格式化前后的diff而不是写入文件，默认是false -e 打印所有的语法错误到标准输出。如果不使用此标记，则只会打印不同行的前10个错误。 -cpuprofile 支持调试模式，写入相应的cpufile到指定的文件 go get 这个命令是用来动态获取远程代码包的，目前支持的有BitBucket、GitHub、Google Code和Launchpad。这个命令在内部实际上分成了两步操作：第一步是下载源码包，第二步是执行go install。下载源码包的go工具会自动根据不同的域名调用不同的源码工具，对应关系如下： BitBucket (Mercurial Git) GitHub (Git) Google Code Project Hosting (Git, Mercurial, Subversion) Launchpad (Bazaar) 所以为了go get 能正常工作，你必须确保安装了合适的源码管理工具，并同时把这些命令加入你的PATH中。其实go get支持自定义域名的功能，具体参见go help remote。 参数介绍： -d 只下载不安装 -f 只有在你包含了-u参数的时候才有效，不让-u去验证import中的每一个都已经获取了，这对于本地fork的包特别有用 -fix 在获取源码之后先运行fix，然后再去做其他的事情 -t 同时也下载需要为运行测试所需要的包 -u 强制使用网络去更新包和它的依赖包 -v 显示执行的命令 go install 这个命令在内部实际上分成了两步操作：第一步是生成结果文件(可执行文件或者.a包)，第二步会把编译好的结果移到$GOPATH/pkg或者$GOPATH/bin。 参数支持go build的编译参数。大家只要记住一个参数-v就好了，这个随时随地的可以查看底层的执行信息。 go test 执行这个命令，会自动读取源码目录下面名为*_test.go的文件，生成并运行测试用的可执行文件。输出的信息类似 ok archive/tar 0.011s FAIL archive/zip 0.022s ok compress/gzip 0.033s ... 默认的情况下，不需要任何的参数，它会自动把你源码包下面所有test文件测试完毕，当然你也可以带上参数，详情请参考go help testflag 这里我介绍几个我们常用的参数： -bench regexp 执行相应的benchmarks，例如 -bench=. -cover 开启测试覆盖率 -run regexp 只运行regexp匹配的函数，例如 -run=Array 那么就执行包含有Array开头的函数 -v 显示测试的详细命令 go toolgo tool下面下载聚集了很多命令，这里我们只介绍两个，fix和vet go tool fix . 用来修复以前老版本的代码到新版本，例如go1之前老版本的代码转化到go1,例如API的变化 go tool vet directory|files 用来分析当前目录的代码是否都是正确的代码,例如是不是调用fmt.Printf里面的参数不正确，例如函数里面提前return了然后出现了无用代码之类的。 go generate这个命令是从Go1.4开始才设计的，用于在编译前自动化生成某类代码。go generate和go build是完全不一样的命令，通过分析源码中特殊的注释，然后执行相应的命令。这些命令都是很明确的，没有任何的依赖在里面。而且大家在用这个之前心里面一定要有一个理念，这个go generate是给你用的，不是给使用你这个包的人用的，是方便你来生成一些代码的。 这里我们来举一个简单的例子，例如我们经常会使用yacc来生成代码，那么我们常用这样的命令： go tool yacc -o gopher.go -p parser gopher.y -o 指定了输出的文件名， -p指定了package的名称，这是一个单独的命令，如果我们想让go generate来触发这个命令，那么就可以在当然目录的任意一个xxx.go文件里面的任意位置增加一行如下的注释： //go:generate go tool yacc -o gopher.go -p parser gopher.y 这里我们注意了，//go:generate是没有任何空格的，这其实就是一个固定的格式，在扫描源码文件的时候就是根据这个来判断的。 所以我们可以通过如下的命令来生成，编译，测试。如果gopher.y文件有修改，那么就重新执行go generate重新生成文件就好。 $ go generate $ go build $ go test godoc在Go1.2版本之前还支持go doc命令，但是之后全部移到了godoc这个命令下，需要这样安装go get golang.org/x/tools/cmd/godoc 很多人说go不需要任何的第三方文档，例如chm手册之类的（其实我已经做了一个了，chm手册），因为它内部就有一个很强大的文档工具。 如何查看相应package的文档呢？ 例如builtin包，那么执行godoc builtin 如果是http包，那么执行godoc net/http 查看某一个包里面的函数，那么执行godoc fmt Printf 也可以查看相应的代码，执行godoc -src fmt Printf 通过命令在命令行执行 godoc -http=:端口号 比如godoc -http=:8080。然后在浏览器中打开127.0.0.1:8080，你将会看到一个golang.org的本地copy版本，通过它你可以查询pkg文档等其它内容。如果你设置了GOPATH，在pkg分类下，不但会列出标准包的文档，还会列出你本地GOPATH中所有项目的相关文档，这对于经常被墙的用户来说是一个不错的选择。 其它命令 go还提供了其它很多的工具，例如下面的这些工具 go version 查看go当前的版本 go env 查看当前go的环境变量 go list 列出当前全部安装的package go run 编译并运行Go程序 以上这些工具还有很多参数没有一一介绍，用户可以使用go help 命令获取更详细的帮助信息。]]></content>
      <categories>
        <category>Golang</category>
      </categories>
      <tags>
        <tag>Golang基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL错误集]]></title>
    <url>%2F2018%2F09%2F13%2FMySQL%E9%94%99%E8%AF%AF%E9%9B%86%2F</url>
    <content type="text"><![CDATA[MYSQL错误集记录 ERROR 1215-Cannot add foreign key constraint先看俩个表结构 对reader表进行添加外键约束book表12mysql&gt; ALTER TABLE reader ADD CONSTRAINT fk_book_reader FOREIGN key -&gt; reader(book_id) REFERENCES book(book_id); 报错：1215-Cannot add foreign key constraint问题分析： 主外键更多的是某表的主键与子表的某个列进行关联，要求是具备相同的数据类型和属性 要求：具备相同的数据类型和约束发现：unsigned，数字的字符长度不一致。修改reader表book_id列属性1mysql&gt; ALTER TABLE reader MODIFY book_id INT UNSIGNED; 再次进行添加外键约束，问题解决。 ERROR 1075 (42000): Incorrect table definition; there can be only one auto column and it must be defined as a key引发原因，建表语句：12345mysql&gt; create table if not exists user( -&gt; id int unsigned auto_increment, -&gt; uuid varchar(30) not null, -&gt; primary key (uuid,id) -&gt; ) engine=InnoDB default charset=utf8; 解决方法：当有一个自增键和另外一个字段需要作为主键时，一定要在定义primary key中先定义自增键，否则报错。12345mysql&gt; create table if not exists user( -&gt; id int unsigned auto_increment, -&gt; uuid varchar(30) not null, -&gt; primary key (id,uuid) -&gt; ) engine=InnoDB default charset=utf8;]]></content>
      <categories>
        <category>DBA</category>
      </categories>
      <tags>
        <tag>Mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Centos7搭建FTP服务器]]></title>
    <url>%2F2018%2F09%2F11%2FCentos7%E6%90%AD%E5%BB%BAFTP%E6%9C%8D%E5%8A%A1%E5%99%A8%2F</url>
    <content type="text"><![CDATA[之前部署阿里云服务器需要上传一些文件，所以搭建了FTP服务器，便记录一下。 环境 Centos7 安装VSFTPD1$ yum install vsftpd -y 配置VSFTPDvsftpd的配置文件是 /etc/vsftpd/vsftpd.conf ，直接用vim打开编辑即可。使用vim编辑器打开vsftpd配置文件：1$ vim /etc/vsftpd/vsftpd.conf 关键修改 anonymous_enable=YES 是否允许匿名用户登陆FTP。 为了安全起见关闭这个功能（将等号后的YES改成NO即可）。 dirmessage_enable=YES 切换目录时，显示目录下.message文件中的内容 默认是开启的 local_umask=022 FTP上本地的文件权限，默认是077，不过vsftpd安装后的配置文件里默认是022. 没有什么特殊情况不用修改。 xferlog_enable=YES 启用上传和下载的日志功能，默认开启。 ftpd_banner=XXXX FTP的欢迎信息。 data_connection_timeout=120 数据连接超时时间。 启动VSFTPD开机启动12$ systemctl enable vsftpd.service$ systemctl start vsftpd.service 创建FTP用户修改完vsftpd的配置文件之后我们还是不能使用vsftpd，因为我们还没有设置ftp的用户。添加一个名为ftpuser的用户，用户文件夹位置为：/home/ftpdir，且禁止此用户登陆服务器：12$ useradd -d /home/ftpdir -s /sbin/nologin ftpuser$ passwd ftpuser 这时候系统会要求您输入新的密码并且重复一遍。顺便一提在SSH中，密码一般不会回显，所以初学者可能会觉得输进去没反应，其实是已经输进去了。调整文件夹权限123$ chmod 777 /home/ftpdir$ cd /home$ ls -l 调整防火墙我这里用的是传统的管理方式在CentOS 7或RHEL 7或Fedora中防火墙由firewalld来管理，需要还原12$ systemctl stop firewalld $ systemctl mask firewalld 并且安装iptables-services：1$ yum install iptables-services -y 设置开机启动：12$ systemctl enable iptables$ systemctl start iptables 开放端口 主动模式 使用Vim编辑器打开iptables配置文件：1$ vim /etc/sysconfig/iptables 添加1-A INPUT -m state --state NEW -m tcp -p tcp --dport 21 -j ACCEPT 重启服务1$ systemctlrestart iptables.service 被动模式(未测试) 如果ftp处于被动模式下，除了需要修改iptables的配置文件以外，还需要修改vsftpd的配置文件。首先是修改vsftpd的配置文件：使用Vim编辑器打开vsftpd配置文件：1$ vim /etc/vsftpd/vsftpd.conf 现在配置文件中找到 “connect_from_port_20=YES” 并将它修改为 “connect_from_port_20=NO” ，关闭掉vsftpd的主动模式。 然后在配置文件的末尾追加： 使vsftpd运行在被动模式 pasv_enable=YES 被动模式最小端口号30000 pasv_min_port=30000 被动模式最大端口号31000 pasv_max_port=31000 保存配置文件并退出。然后重启vsftpd服务：1$ systemctl restart vsftpd.service 然后再使用Vim编辑器打开iptables配置文件：1$ vim /etc/sysconfig/iptables 添加这两句话：（“#”开头的是注释，可以不添加）1234#开放ftp协议21端口，允许接受来自21端口的新建TCP连接-A INPUT -p tcp -m state --state NEW -m tcp --dport 21 -j ACCEPT#开放30000-31000号端口，允许接受来自此端口号段的新建TCP连接 **-A INPUT -p tcp --dport 30000:31000 -j ACCEPT 保存并退出，然后重启iptables服务：1$ systemctl restart iptables.service]]></content>
      <categories>
        <category>服务器运维</category>
      </categories>
      <tags>
        <tag>Centos7</tag>
        <tag>FTP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[电脑小技巧]]></title>
    <url>%2F2018%2F09%2F10%2F%E7%94%B5%E8%84%91%E5%B0%8F%E6%8A%80%E5%B7%A7%2F</url>
    <content type="text"><![CDATA[日常电脑使用小技巧 不用截图工具截取整个网页打开浏览器(测试chrome可用)并调出控制台，快捷键 f12 然后选择快捷键 ctrl + shift + p 调出,如图(我也忘记叫什么了)输入capt，出现一下选择，选择如图即可截取整张网页，并自动下载至浏览器默认下载目录测试图太长就不放了，可以自行测试，应该浏览器都通用(国外)]]></content>
      <categories>
        <category>程序人生</category>
      </categories>
      <tags>
        <tag>chrome</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL入门]]></title>
    <url>%2F2018%2F09%2F10%2FMySQL%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[MySql入门教程,Sql语句复习 环境 centos7 virtualbox MySQL 5.7 教程 SQL语言分类 DQL(数据查询语言) 数据查询语言DQL基本结构是由SELECT子句，FROM子句，WHERE DML(数据操纵语言) 数据操纵语言DML主要有三种形式：插入：INSERT，更新：UPDATE，删除：DELETE DDL(数据定义语言) 数据定义语言DDL用来创建数据库中的各种对象—–表、视图、索引、同义词、聚簇等 DCL(数据控制语言) 数据控制语言DCL用来授予或回收访问数据库的某种特权，并控制数据库操纵事务发生的时间及效果，对数据库实行监视 Centos下Mysq显示方式设置 使用more 1mysql&gt; pager more 使用less 1mysql&gt; pager less less模式下按下键盘q退出 还原 1mysql&gt; nopager 使用\G按行垂直显示结果如果一行很长，需要这行显示的话，看起结果来就非常的难受。在SQL语句或者命令后使用\G而不是分号结尾，可以将每一行的值垂直输出。这个可能也是大家对于MySQL最熟悉的区别于其他数据库工具的一个特性了。 1234mysql&gt; use mysql;Database changedmysql&gt; select * from user\G MySQL用户设置如果你需要添加 MySQL 用户，你只需要在 mysql 数据库中的 user 表添加新用户即可。 以下为添加用户的的实例，用户名为guest，密码为guest123，并授权用户可进行 SELECT, INSERT 和 UPDATE操作权限：1234567891011121314151617181920mysql&gt; use mysql;Database changedmysql&gt; INSERT INTO user (host, user, password, select_priv, insert_priv, update_priv) VALUES ('localhost', 'guest', PASSWORD('guest123'), 'Y', 'Y', 'Y');Query OK, 1 row affected (0.20 sec)mysql&gt; FLUSH PRIVILEGES;Query OK, 1 row affected (0.01 sec)mysql&gt; SELECT host, user, password FROM user WHERE user = 'guest';+-----------+---------+------------------+| host | user | password |+-----------+---------+------------------+| localhost | guest | 6f8c114b58f2ce9e |+-----------+---------+------------------+1 row in set (0.00 sec) 注意：在 MySQL5.7 中 user 表的 password 已换成了authentication_string。 error 这种方式出现过mysql插入用户的时候，突然出现了 Field ‘ssl_cipher’ doesn’t have a default value 的错误，现已解决，步骤如下：在mysql的user表中增加连接用户帐号：这里不要直接使用INSERT语句添加user记录，使用INSERT可能出现：ERROR 1364 (HY000): Field ‘ssl_cipher’ doesn’t have a default value错误。 你可以在创建用户时，为用户指定权限，在对应的权限列中，在插入语句中设置为 ‘Y’ 即可，用户权限列表如下： Select_priv Insert_priv Update_priv Delete_priv Create_priv Drop_priv Reload_priv Shutdown_priv Process_priv File_priv Grant_priv References_priv Index_priv Alter_priv 另外一种添加用户的方法为通过SQL的 GRANT 命令，以下命令会添加用户 zara ，密码为 zara123 。123mysql&gt;GRANT SELECT ON *.* TO 'zara'@'localhost' IDENTIFIED BY 'zara123' -&gt;WITH GRANT OPTION;Query OK 为数据库TUTORIALS添加用户 zara ，密码为 zara1231234mysql&gt; GRANT SELECT,INSERT,UPDATE,DELETE,CREATE,DROP -&gt; ON TUTORIALS.* -&gt; TO 'zara'@'localhost' -&gt; IDENTIFIED BY 'zara123'; 管理数据库命令USE (dbname);选择要操作的数据库，之后所执行的mysql命令都是针对该数据库1mysql&gt; use mysql; SHOW DATABASES;列出Mysql数据库管理系统的数据库列表1mysql&gt; SHOW DATABASES; SHOW TABLES;显示指定数据库的所有表，使用该命令前需要使用 use 命令来选择要操作的数据库。1mysql&gt; SHOW TABLES; SHOW COLUMNS FROM (tablename):显示数据表的属性，属性类型，主键信息 ，是否为 NULL，默认值等其他信息。 SHOW INDEX FROM (tablename):显示数据表的详细索引信息，包括PRIMARY KEY（主键）。1mysql&gt; SHOW INDEX FROM user; SHOW TABLE STATUS LIKE [FROM db_name] [LIKE ‘pattern’] \G:该命令将输出Mysql数据库管理系统的性能及统计信息。 1mysql&gt; SHOW TABLE STATUS FROM mysql; 创建数据库登陆 MySQL 服务后，使用 create 命令创建数据库，语法如下:1CREATE DATABASE booklib; 删除数据库如果使用普通用户可能需要权限来进行删除数据库，登陆root账户，拥有最高权限，删除数据库需要谨慎，一旦删除，数据将会消失。语法如下1DROP DATABASE (dbname); MySQL数据类型 数字类型 整数: tinyint、smallint、mediumint、int、bigint 浮点数: float、double、real、decimal 日期和时间: date、time、datetime、timestamp、year 字符串类型 字符串: char、varchar 文本: tinytext、text、mediumtext、longtext 二进制(可用来存储图片、音乐等): tinyblob、blob、mediumblob、longblob 字符串类型 类型 单位 最大 特性 CHAR 字符 最大为255字符 存储定长，容易造成空间的浪费 VARCHAR 字符 可以超过255个字符 存储变长，节省存储空间 TEXT 字节 总大小为65535字节，约为64KB - TEXT在MySQL内部大多存储格式为溢出页，效率不如CHAR Mysql默认为utf-8，那么在英文模式下1个字符=1个字节，在中文模式下1个字符=3个字节。 数字类型整形 type Storage Minumun Value Maximum Value (Bytes) (Signed/Unsigned) (Signed/Unsigned) TINYINT 1 -128 127 0 255 SMALLINT 2 -32768 32767 0 65535 MEDIUMINT 3 -8388608 8388607 0 16777215 INT 4 -2147483648 2147483647 0 4294967295 BIGINT 8 -9223372036854775808 9223372036854775807 0 18446744073709551615 浮点型 属性 存储空间 精度 精确性 说明 FLOAT(M, D) 4 bytes 单精度 非精确 单精度浮点型，m总个数，d小数位 DOUBLE(M, D) 8 bytes 双精度 比Float精度高 双精度浮点型，m总个数，d小数位 FLOAT容易造成精度丢失 定点数DECIMAL 高精度的数据类型，常用来存储交易相关的数据 DECIMAL(M,N).M代表总精度，N代表小数点右侧的位数（标度） 1 &lt; M &lt; 254, 0 &lt; N &lt; 60; 存储空间变长 时间类型 类型 字节 例 精确性 DATE 三字节 2015-05-01 精确到年月日 TIME 三字节 11:12:00 精确到时分秒 DATETIME 八字节 2015-05-01 11::12:00 精确到年月日时分秒 TIMESTAMP 2015-05-01 11::12:00 精确到年月日时分秒 MySQL在5.6.4版本之后，TIMESTAMP和DATETIME支持到微秒。 TIMESTAMP会根据系统时区进行转换，DATETIME则不会 存储范围的区别 TIMESTAMP存储范围：1970-01-01 00::00:01 to 2038-01-19 03:14:07 DATETIME的存储范围：1000-01-01 00:00:00 to 9999-12-31 23:59:59 一般使用TIMESTAMP国际化 如存时间戳使用数字类型BIGINT 创建数据表创建MYSQL数据以下信息 表名 表字段名 定义表每个字段 语法1CREATE TABLE (tablename) (column name column type, ...) 例子：创建一个书本表，书本有编号,名字，出版社，作者名称，价格，出版日期12345678mysql&gt; CREATE TABLE IF NOT EXISTS book( &gt; book_id INT UNSIGNED AUTO_INCREMENT, &gt; book_name VARCHAR(50) NOT NULL, &gt; author VARCHAR(10) NOT NULL, &gt; pub VARCHAR(100), &gt; pub_date DATE, &gt; PRIMARY KEY (book_id) &gt; ) ENGINE=InnoDB DEFAULT CHARSET=utf8; 解析： 如果不想字段为NULL，可以设置字段为NOT NULL，但是一旦字段该数值为null，则会报错。 AUTO_INCREMENT定义列为自增的属性，一般用于主键，数值会自动加1。 PRIMARY KEY关键字用于定义列为主键。 您可以使用多列来定义主键，列间以逗号分隔。 ENGINE 设置存储引擎，CHARSET 设置编码。 删除数据表MySQL删除数据表，语法1DROP TABLE (tablename); 示例:1mysql&gt; DROP TABLE book; 插入数据使用 INSERT INTO 语句来插入数据,语法123INSERT INTO table_name ( field1, field2,...fieldN ) VALUES ( value1, value2,...valueN ); 如果数据是字符型，必须使用单引号或者双引号，如：”value”。 示例:12mysql&gt; INSERT INTO book(book_name, author, pub, pub_date) -&gt; VALUES('Android Coder', 'bitch', 'english', NOW()) 一次插入多行语句1234mysql&gt; INSERT INTO book(book_name, author, pub, pub_date) -&gt; VALUES -&gt; ('python', 'pp', 'english', DATE('2010-08-10')), -&gt; ('kotlin', 'kk', 'amearica', DATE('2013-07-10')); 查询数据使用SQL SELECT 查询数据,语法1234SELECT column_name,column_nameFROM table_name[WHERE Clause][LIMIT N][ OFFSET M] 查询语句中你可以使用一个或者多个表，表之间使用逗号(,)分割，并使用WHERE语句来设定查询条件。 SELECT 命令可以读取一条或者多条记录。 你可以使用星号（*）来代替其他字段，SELECT语句会返回表的所有字段数据 你可以使用 WHERE 语句来包含任何条件。 你可以使用 LIMIT 属性来设定返回的记录数。 你可以通过OFFSET指定SELECT语句开始查询的数据偏移量。默认情况下偏移量为0。 1mysql&gt; SELECT * FROM book; WHERE 字句我们知道从 MySQL 表中使用 SQL SELECT 语句来读取数据。如需有条件地从表中选取数据，可将 WHERE 子句添加到 SELECT 语句中。语法12SELECT field1, field2,...fieldN FROM table_name1, table_name2...[WHERE condition1 [AND [OR]] condition2..... 查询语句中你可以使用一个或者多个表，表之间使用逗号, 分割，并使用WHERE语句来设定查询条件。 你可以在 WHERE 子句中指定任何条件。 你可以使用 AND 或者 OR 指定一个或多个条件。 WHERE 子句也可以运用于 SQL 的 DELETE 或者 UPDATE 命令。 WHERE 子句类似于程序语言中的 if 条件，根据 MySQL 表中的字段值来读取指定的数据。 操作符 描述 实例 = 等号，检测两边值是否相等，相等返回true A = B 返回true &lt;&gt;, != 不等于，检测两边值是否相等，相等返回false A != B 返回false &gt; 大于，检测左边值是否大于右边值，大于则返回true A &gt; B 返回true &lt; 小于，检测左边值是否小于右边值，小于则返回true A &lt; B 返回true &gt;= 大于等于，检测左边值是否大于等于右边值，同上 A &gt;= B 返回true &lt;= 大于等于，检测左边值是否大于等于右边值，同上 A &lt;= B 返回true 如果我们想在 MySQL 数据表中读取指定的数据，WHERE 子句是非常有用的。使用主键来作为 WHERE 子句的条件查询是非常快速的。如果给定的条件在表中没有任何匹配的记录，那么查询不会返回任何数据。 1mysql&gt; SELECT * FROM book WHERE author='bitch' UPDATE 查询使用SQL UPDATE语句修改或更新数据库中数据 语法12UPDATE table_name SET field1=new-value1, field2=new-value2[WHERE Clause] 你可以同时更新一个或多个字段。 你可以在 WHERE 子句中指定任何条件。 你可以在一个单独表中同时更新数据。 1mysql&gt; UPDATE book SET author = 'jack' WHERE book_id = 4; DELETE 删除SQL 的 DELETE FROM 命令来删除 MySQL 数据表中的记录。语法1DELETE FROM table_name [WHERE Clause] 如果没有指定 WHERE 子句，MySQL 表中的所有记录将被删除。 你可以在 WHERE 子句中指定任何条件 您可以在单个表中一次性删除记录。 请谨慎 1mysql&gt; DELETE FROM book WHERE book_name = 'TEST'; LIKE 子句MySQL 中使用 SQL SELECT 命令来读取数据， 同时我们可以在 SELECT 语句中使用 WHERE 子句来获取指定的记录。WHERE 子句中可以使用等号 = 来设定获取数据的条件，如 “runoob_author = ‘RUNOOB.COM’”。但是有时候我们需要获取 runoob_author 字段含有 “COM” 字符的所有记录，这时我们就需要在 WHERE 子句中使用 SQL LIKE 子句。SQL LIKE 子句中使用百分号 %字符来表示任意字符，类似于UNIX或正则表达式中的星号 *。如果没有使用百分号 %, LIKE 子句与等号 = 的效果是一样的。 语法123SELECT field1, field2,...fieldN FROM table_nameWHERE field1 LIKE condition1 [AND [OR]] filed2 = 'somevalue' 你可以在 WHERE 子句中指定任何条件。 你可以在 WHERE 子句中使用LIKE子句。 你可以使用LIKE子句代替等号 =。 LIKE 通常与 % 一同使用，类似于一个元字符的搜索。 你可以使用 AND 或者 OR 指定一个或多个条件。 你可以在 DELETE 或 UPDATE 命令中使用 WHERE…LIKE 子句来指定条件。 like 匹配/模糊匹配，会与 % 和 _ 结合使用。‘%a’ //以a结尾的数据‘a%’ //以a开头的数据‘%a%’ //含有a的数据‘_a_’ //三位且中间字母是a的‘a’ //两位且结尾字母是a的‘a‘ //两位且开头字母是a的 1mysql&gt; SELECT * FROM book WHERE pub LIKE 'a%'; UNION 操作符MySQL UNION 操作符用于连接两个以上的 SELECT 语句的结果组合到一个结果集合中。多个 SELECT 语句会删除重复的数据。 语法1234567SELECT expression1, expression2, ... expression_nFROM tables[WHERE conditions]UNION [ALL | DISTINCT]SELECT expression1, expression2, ... expression_nFROM tables[WHERE conditions]; expression1, expression2, … expression_n: 要检索的列。 tables: 要检索的数据表。 WHERE conditions: 可选， 检索条件。 DISTINCT: 可选，删除结果集中重复的数据。默认情况下 UNION 操作符已经删除了重复数据，所以 DISTINCT 修饰符对结果没啥影响。 ALL: 可选，返回所有结果集，包含重复数据。 案例 排序读取的数据进行排序，我们就可以使用 MySQL 的 ORDER BY 子句来设定你想按哪个字段哪种方式来进行排序，再返回搜索结果。 语法12SELECT field1, field2,...fieldN table_name1, table_name2...ORDER BY field1, [field2...] [ASC [DESC]] 你可以使用任何字段来作为排序的条件，从而返回排序后的查询结果。 你可以设定多个字段来排序。 你可以使用 ASC 或 DESC 关键字来设置查询结果是按升序或降序排列。 默认情况下，它是按升序排列。 你可以添加 WHERE…LIKE 子句来设置条件。 1mysql&gt; SELECT * FROM book ORDER BY pub_date ASC; 分组GROUP BY 语句根据一个或多个列对结果集进行分组。在分组的列上我们可以使用 COUNT, SUM, AVG,等函数。 语法1234SELECT column_name, function(column_name)FROM table_nameWHERE column_name operator valueGROUP BY column_name; 1mysql&gt; SELECT COUNT(*), book_name FROM book GROUP BY book_name; 注意 group by 语句用法有一个注意点，在 select 语句中，所查询的字段除了聚合函数（SUM ,AVG,COUNT…)以外 必须只能是分组的字段，举例：1SELECT book_id,book_name,count(*) FROM book GROUP BY book_name; 以上会报错,纠正1SELECT book_id,book_name,count(*) FROM book GROUP BY book_id,book_name; 分组后的条件使用 HAVING 来限定，WHERE 是对原始数据进行条件限制。几个关键字的使用顺序为 where 、group by 、having、order by 连接使用 MySQL 的 JOIN 在两个或多个表中查询数据。你可以在 SELECT, UPDATE 和 DELETE 语句中使用 Mysql 的 JOIN 来联合多表查询。JOIN 按照功能大致分为如下三类： INNER JOIN（内连接,或等值连接）：获取两个表中字段匹配关系的记录。 LEFT JOIN（左连接）：获取左表所有记录，即使右表没有对应匹配的记录。 RIGHT JOIN（右连接）： 与 LEFT JOIN 相反，用于获取右表所有记录，即使左表没有对应匹配的记录。 实例 NULL 值处理我们已经知道 MySQL 使用 SQL SELECT 命令及 WHERE 子句来读取数据表中的数据,但是当提供的查询条件字段为 NULL 时，该命令可能就无法正常工作。为了处理这种情况，MySQL提供了三大运算符: IS NULL: 当列的值是 NULL,此运算符返回 true。 IS NOT NULL: 当列的值不为 NULL, 运算符返回 true。 &lt;=&gt;: 比较操作符（不同于=运算符），当比较的的两个值为 NULL 时返回 true。 关于 NULL 的条件比较运算是比较特殊的。你不能使用 = NULL 或 != NULL 在列中查找 NULL 值 。在 MySQL 中，NULL 值与任何其它值的比较（即使是 NULL）永远返回 false，即 NULL = NULL 返回false 。MySQL 中处理 NULL 使用 IS NULL 和 IS NOT NULL 运算符。 实例:表中有一行有NULL值的数据，如果使用1mysql&gt; SELECT * FROM book WHERE pub = NULL; 会出现判断NULL， =和！=是不起作用的12mysql&gt; SELECT * FROM book WHERE author IS NULL;mysql&gt; SELECT * FROM book WHERE author IS NOT NULL; 正则表达式案例 事务MySQL 事务主要用于处理操作量大，复杂度高的数据。比如说，在人员管理系统中，你删除一个人员，你即需要删除人员的基本资料，也要删除和该人员相关的信息，如信箱，文章等等，这样，这些数据库操作语句就构成一个事务！ 在 MySQL 中只有使用了 Innodb 数据库引擎的数据库或表才支持事务。 事务处理可以用来维护数据库的完整性，保证成批的 SQL 语句要么全部执行，要么全部不执行。 事务用来管理 insert,update,delete 语句 一般来说，事务是必须满足4个条件（ACID）：：原子性（Atomicity，或称不可分割性）、一致性（Consistency）、隔离性（Isolation，又称独立性）、持久性（Durability）。 原子性：一个事务（transaction）中的所有操作，要么全部完成，要么全部不完成，不会结束在中间某个环节。事务在执行过程中发生错误，会被回滚（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。 一致性：在事务开始之前和事务结束以后，数据库的完整性没有被破坏。这表示写入的资料必须完全符合所有的预设规则，这包含资料的精确度、串联性以及后续数据库可以自发性地完成预定的工作。 隔离性：数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。事务隔离分为不同级别，包括读未提交（Read uncommitted）、读提交（read committed）、可重复读（repeatable read）和串行化（Serializable）。 持久性：事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。 在 MySQL 命令行的默认设置下，事务都是自动提交的，即执行 SQL 语句后就会马上执行COMMIT 操作。因此要显式地开启一个事务务须使用命令 BEGIN 或 STARTTRANSACTION，或者执行命令 SET AUTOCOMMIT=0，用来禁止使用当前会话的自动提交。 事务控制语句： BEGIN或START TRANSACTION；显式地开启一个事务； COMMIT；也可以使用COMMIT WORK，不过二者是等价的。COMMIT会提交事务，并使已对数据库进行的所有修改成为永久性的； ROLLBACK；有可以使用ROLLBACK WORK，不过二者是等价的。回滚会结束用户的事务，并撤销正在进行的所有未提交的修改； SAVEPOINT identifier；SAVEPOINT允许在事务中创建一个保存点，一个事务中可以有多个SAVEPOINT； RELEASE SAVEPOINT identifier；删除一个事务的保存点，当没有指定的保存点时，执行该语句会抛出一个异常； ROLLBACK TO identifier；把事务回滚到标记点； SET TRANSACTION；用来设置事务的隔离级别。InnoDB存储引擎提供事务的隔离级别有READ UNCOMMITTED、READ COMMITTED、REPEATABLE READ和SERIALIZABLE。 案例 ALTER命令当我们需要修改数据表名或者修改数据表字段时，就需要使用到MySQL ALTER命令。 ALTER TABLE：添加，修改，删除表的列，约束等表的定义。 查看列：desc 表名; 修改表名：alter table t_book rename to bbb; 添加列：alter table 表名 add column 列名 varchar(30); 删除列：alter table 表名 drop column 列名; 修改列名MySQL： alter table bbb change nnnnn hh int; 修改列属性：alter table t_book modify name varchar(22); sp_rename：SQLServer 内置的存储过程，用与修改表的定义。 案例 约束MySQL 查看约束，添加约束，删除约束 添加列，修改列，删除列 查看表的字段信息：desc 表名; 查看表的所有信息：show create table 表名; 添加主键约束：alter table 表名 add constraint 主键 （形如：PK_表名） primary key 表名(主键字段); 添加外键约束：alter table 从表 add constraint 外键（形如：FK_从表_主表） foreign key 从表(外键字段) references 主表(主键字段); 删除主键约束：alter table 表名 drop primary key; 删除外键约束：alter table 表名 drop foreign key 外键（区分大小写）; 修改表名：alter table t_book rename to bbb; 添加列：alter table 表名 add column 列名 varchar(30); 删除列：alter table 表名 drop column 列名; 修改列名： alter table bbb change nnnnn hh int; 修改列属性：alter table t_book modify name varchar(22); 12mysql&gt; desc book;mysql&gt; desc reader; 添加book_id列到reader表，并添加外键约束(book表中的book_id)12mysql&gt; ALTER TABLE reader ADD book_id INT UNSIGNED;mysql&gt; desc reader; 12mysql&gt; ALTER TABLE reader ADD CONSTRAINT fk_book_reader FOREIGN key -&gt; reader(book_id) REFERENCES book(book_id); 出现1215详情见另一篇文章[MySQL错误集] 索引MySQL索引的建立对于MySQL的高效运行是很重要的，索引可以大大提高MySQL的检索速度。打个比方，如果合理的设计且使用索引的MySQL是一辆兰博基尼的话，那么没有设计和使用索引的MySQL就是一个人力三轮车。索引分单列索引和组合索引。单列索引，即一个索引只包含单个列，一个表可以有多个单列索引，但这不是组合索引。组合索引，即一个索引包含多个列。创建索引时，你需要确保该索引是应用在 SQL 查询语句的条件(一般作为 WHERE 子句的条件)。实际上，索引也是一张表，该表保存了主键与索引字段，并指向实体表的记录。上面都在说使用索引的好处，但过多的使用索引将会造成滥用。因此索引也会有它的缺点：虽然索引大大提高了查询速度，同时却会降低更新表的速度，如对表进行INSERT、UPDATE和DELETE。因为更新表时，MySQL不仅要保存数据，还要保存一下索引文件。建立索引会占用磁盘空间的索引文件。 显示索引1mysql&gt; SHOW INDEX FROM table_name\G 普通索引创建索引这是最基本的索引，它没有任何限制。它有以下几种创建方式：1CREATE INDEX indexName ON mytable(cname(length)); 如果是CHAR，VARCHAR类型，length可以小于字段实际长度；如果是BLOB和TEXT类型，必须指定 length。 修改表结构(添加索引)1ALTER table tableName ADD INDEX indexName(columnName) 创建表的时候直接指定12345CREATE TABLE mytable( ID INT NOT NULL, username VARCHAR(16) NOT NULL, INDEX [indexName] (username(length)) ); 删除索引的语法1DROP INDEX [indexName] ON mytable; 为book表中book_name建立基本的索引1mysql&gt; CREATE INDEX INDEX_BOOKNAME ON book(book_name(50)); 唯一索引它与前面的普通索引类似，不同的就是：索引列的值必须唯一，但允许有空值。如果是组合索引，则列值的组合必须唯一。它有以下几种创建方式： 创建索引1CREATE UNIQUE INDEX indexName ON mytable(username(length)) 修改表结构1ALTER table mytable ADD UNIQUE [indexName] (username(length)) 创建表的时候直接指定12345CREATE TABLE mytable( ID INT NOT NULL, username VARCHAR(16) NOT NULL, UNIQUE [indexName] (username(length)) ); 使用ALTER 命令添加和删除索引有四种方式来添加数据表的索引： ALTER TABLE tbl_name ADD PRIMARY KEY (column_list): 该语句添加一个主键，这意味着索引值必须是唯一的，且不能为NULL。 ALTER TABLE tbl_name ADD UNIQUE index_name (column_list): 这条语句创建索引的值必须是唯一的（除了NULL外，NULL可能会出现多次）。 ALTER TABLE tbl_name ADD INDEX index_name (column_list): 添加普通索引，索引值可出现多次。 ALTER TABLE tbl_name ADD FULLTEXT index_name (column_list):该语句指定了索引为 FULLTEXT ，用于全文索引。 例子：1mysql&gt; ALTER TABLE reader ADD INDEX (reader_name); 你还可以在 ALTER 命令中使用 DROP 子句来删除索引。尝试以下实例删除索引:1mysql&gt; ALTER TABLE reader DROP INDEX (reader_name); 使用 ALTER 命令添加和删除主键 主键只能作用于一个列上，添加主键索引时，你需要确保该主键默认不为空（NOT NULL）。实例如下：12mysql&gt; ALTER TABLE testalter_tbl MODIFY i INT NOT NULL;mysql&gt; ALTER TABLE testalter_tbl ADD PRIMARY KEY (i); 你也可以使用 ALTER 命令删除主键：1mysql&gt; ALTER TABLE testalter_tbl DROP PRIMARY KEY; 删除主键时只需指定PRIMARY KEY，但在删除索引时，你必须知道索引名。 临时表MySQL 临时表在我们需要保存一些临时数据时是非常有用的。临时表只在当前连接可见，当关闭连接时，Mysql会自动删除表并释放所有空间。临时表在MySQL 3.23版本中添加，如果你的MySQL版本低于 3.23版本就无法使用MySQL的临时表。不过现在一般很少有再使用这么低版本的MySQL数据库服务了。MySQL临时表只在当前连接可见，如果你使用PHP脚本来创建MySQL临时表，那每当PHP脚本执行完成后，该临时表也会自动销毁。如果你使用了其他MySQL客户端程序连接MySQL数据库服务器来创建临时表，那么只有在关闭客户端程序时才会销毁临时表，当然你也可以手动销毁。 语法和建表差不多，只不过 TABLE 关键字改成 TEMPORARY TABLE 即可。 删除和普通删除表语法没区别。 复制表使用 SHOW CREATE TABLE 命令获取创建数据表(CREATE TABLE) 语句，该语句包含了原数据表的结构，索引等。1mysql&gt; SHOW CREATE TABLE book\G 复制表的内容，你就可以使用 INSERT INTO … SELECT 语句来实现案例 note:来给大家区分下mysql复制表的两种方式。第一、只复制表结构到新表create table 新表 select from 旧表 where 1=2或者create table 新表 like 旧表第二、复制表结构及数据到新表create table新表 select from 旧表 序列使用MySQL 序列是一组整数：1, 2, 3, …，由于一张数据表只能有一个字段自增主键， 如果你想实现其他字段也实现自动增加，就可以使用MySQL序列来实现。 前面也有用到过的 AUTO_INCREMENT 来定义列既可以实现序列 重置序列如果你删除了数据表中的多条记录，并希望对剩下数据的AUTO_INCREMENT列进行重新排列，那么你可以通过删除自增的列，然后重新添加来实现。 不过该操作要非常小心，如果在删除的同时又有新记录添加，有可能会出现数据混乱。操作如下所示：1234mysql&gt; ALTER TABLE insect DROP id;mysql&gt; ALTER TABLE insect -&gt; ADD id INT UNSIGNED NOT NULL AUTO_INCREMENT FIRST, -&gt; ADD PRIMARY KEY (id); 序列的开始值创建表时12345678mysql&gt; CREATE TABLE insect -&gt; ( -&gt; id INT UNSIGNED NOT NULL AUTO_INCREMENT, -&gt; PRIMARY KEY (id), -&gt; name VARCHAR(30) NOT NULL, -&gt; date DATE NOT NULL, -&gt; origin VARCHAR(30) NOT NULL)engine=innodb auto_increment=100 charset=utf8; ALTER修改1mysql&gt; ALTER TABLE t AUTO_INCREMENT = 100; 处理重复数据防止表中出现重复数据你可以在MySQL数据表中设置指定的字段为 PRIMARY KEY（主键） 或者 UNIQUE（唯一） 索引来保证数据的唯一性。 统计重复数据以下我们将统计表中 first_name 和 last_name的重复记录数：1234mysql&gt; SELECT COUNT(*) as repetitions, last_name, first_name -&gt; FROM person_tbl -&gt; GROUP BY last_name, first_name -&gt; HAVING repetitions &gt; 1; 以上查询语句将返回 person_tbl 表中重复的记录数。 一般情况下，查询重复的值，请执行以下操作： 确定哪一列包含的值可能会重复。 在列选择列表使用COUNT(*)列出的那些列。 在GROUP BY子句中列出的列。 HAVING子句设置重复数大于1。 过滤重复数据如果你需要读取不重复的数据可以在 SELECT 语句中使用 DISTINCT 关键字来过滤重复数据。你也可以使用 GROUP BY 来读取数据表中不重复的数据： 导出数据更多 导出 SQL 格式的数据12$ mysqldump -u root -p (dbName) (tableName) &gt; dump.txtpassword ****** 表名可不加，不加则导出整个数据库实例:1$ mysqldump -u root -p booklib &gt; /tmp/booklib.txt 导入数据更多 source命令导入先登录进数据库1234mysql&gt; create database booklib; # 创建数据库mysql&gt; use booklib; # 使用已创建的数据库 mysql&gt; set names utf8; # 设置编码mysql&gt; source /tmp/booklib.sql # 导入备份数据库]]></content>
      <categories>
        <category>DBA</category>
      </categories>
      <tags>
        <tag>Mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Centos7安装Mysql5.7]]></title>
    <url>%2F2018%2F09%2F07%2FCentos7%E5%AE%89%E8%A3%85Mysql5-7%2F</url>
    <content type="text"><![CDATA[环境 centos7 virtualbox 安装centos7需要检查是否已经安装了Mariadb在安装MySQL之前要检查当前环境中是否已经装了Mariadb，如果存在则需要卸载，否则可能导致MySQL安装失败1$ rpm -qa | grep mariadb 如果输出maraidb等的信息则需要进行卸载，如图需要进行强制卸载1$ rpm -e --nodeps mariadb-libs-5.5.56-2.el7.x86_64 Yum Repo官方指导点击链接查看最新的Yum Repository123// 设置rpm$ rpm -Uvh https://dev.mysql.com/get/mysql80-community-release-el7-1.noarch.rpm$ yum repolist all | grep mysql 如图需要安装5.7版本，则需要选择发布系列,编辑/etc/yum.repos.d/mysql-community.repo 文件来选择系列 。这是文件中发布系列的子存储库的典型条目：123456[mysql80-community]name=MySQL 8.0 Community Serverbaseurl=http://repo.mysql.com/yum/mysql-8.0-community/el/6/$basearch/enabled=1gpgcheck=1gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-mysql 找到要配置的子存储库的条目，然后编辑该enabled选项。指定 enabled=0禁用子存储库，或 enabled=1启用子存储库。例如，要安装MySQL 5.7，请确保您拥有enabled=0MySQL 8.0的上述子存储库条目，并且具有 enabled=15.7系列的条目：1234567# Enable to use MySQL 5.7[mysql57-community]name=MySQL 5.7 Community Serverbaseurl=http://repo.mysql.com/yum/mysql-5.7-community/el/6/$basearch/enabled=1gpgcheck=1gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-mysql 您应该只在任何时候为一个发布系列启用子存储库。当启用多个版本系列的子存储库时，Yum将使用最新的系列。 通过运行以下命令并检查其输出来验证是否已启用和禁用了正确的子存储库（对于启用dnf的系统，请使用dnf替换 命令中的 yum）：1$ yum repolist enabled | grep mysql 安装mysql1$ yum install -y mysql-community-server 二进制编译安装后续补上 CMake方式安装后续补上 启动使用以下命令启动MySQL服务器：1$ systemctl start mysqld.service 检查MySQL服务器的状态1$ systemctl status mysqld.service MySQL服务器初始化（从MySQL5.7开始）：在服务器初始启动时，如果服务器的数据目录为空，则会发生以下情况： 服务器已初始化。 在数据目录中生成SSL证书和密钥文件。 该validate_password插件安装并启用。 将‘root‘@’localhost’ 创建一个超级用户帐户。设置超级用户的密码并将其存储在错误日志文件中。要显示它，请使用以下命令：1$ grep 'temporary password' /var/log/mysqld.log 通过上面命令获取生成的临时密码登录并为超级用户帐户设置自定义密码，尽快更改root密码：1$ mysql -uroot -p 修改root本地登录密码1$ ALTER USER 'root'@'localhost' IDENTIFIED BY 'MyNewPass4!'; 注意MySQL的 validate_password 插件默认安装。这将要求密码包含至少一个大写字母，一个小写字母，一个数字和一个特殊字符，并且密码总长度至少为8个字符。 实例]]></content>
      <categories>
        <category>DBA</category>
      </categories>
      <tags>
        <tag>Mysql</tag>
        <tag>Centos7</tag>
        <tag>环境搭建</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo + github 搭建个人博客]]></title>
    <url>%2F2018%2F09%2F07%2Fhexo-github-%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[我的历史上第一篇教程，Hexo+github搭建个人博客。虽然网上有很多，但是想从这一篇开始我的写作之路。 一些前戏搭建此博客时，百度了很多资料，但是上手还是从官方资料开始上手这是官方链接HexoNext主题图标库 开始使用前提Hexo博客的前提需要在本地先安装nodejs与git推荐一下使用淘宝NPM，本人是windows环境下搭建，建议用git-bash NodeJs Git以上的安装就不写在文章里了，不会可自行百度 部署 安装Hexo 1$ npm install -g hexo-cli 搭建安装Hexo完成后，请执行以下命令，hexo会在指定文件夹中创建文件1234$ cd e:/ $ hexo init &lt;folder&gt;$ cd &lt;folder&gt;$ npm install 新建完成后会生成hexo所需要的一些文件_config.yml网站的一些主要配置信息都在这文件下进行配置详细参数可点击链接进行查看config Hexo命令init1$ hexo init [folder] 新建一个网站。如果没有设置 folder ，Hexo 默认在目前的文件夹建立网站 new1$ hexo new [post|draft|page] &lt;title&gt; 新建一篇文章。如果没有设置 layout 的话，默认使用 _config.yml 中的 default_layout 参数代替。如果标题包含空格的话，请使用引号括起来。 generate1$ hexo g 生成静态文件。 server1$ hexo s 启动服务器。默认情况下，访问网址为： http://localhost:4000/。 deploy1$ hexo d 部署网站。 clean1$ hexo clean 清除缓存文件 (db.json) 和已生成的静态文件 (public)。 Hexo美化主题安装这里安装的是比较热门的Next主题里面也有中文文档，安装说明都很详细，具体安装不在本教程说明,但是具体说明主题中的 _config.yml 文件和站点中的 _config.yml 文件配置是有区别之分的，请详细查看清楚具体是配置哪个配置文件。 启用主题修改站点配置文件 _config.yml 1234# Extensions## Plugins: https://hexo.io/plugins/## Themes: https://hexo.io/themes/theme: next 主题设定选择 Scheme Scheme 是 NexT 提供的一种特性，借助于 Scheme，NexT 为你提供多种不同的外观。同时，几乎所有的配置都可以 在 Scheme 之间共用。目前 NexT 支持三种 Scheme，他们是： Muse - 默认 Scheme，这是 NexT 最初的版本，黑白主调，大量留白 Mist - Muse 的紧凑版本，整洁有序的单栏外观 Pisces - 双栏 Scheme，小家碧玉似的清新 Gemini - 左侧网站信息及目录，块+片段结构布局Scheme 的切换通过更改 主题配置文件，搜索 scheme 关键字。 你会看到有四行 scheme 的配置，将你需用启用的 scheme 前面注释 # 去除即可。 动态背景 目前NexT主题最新的是V6.0版本，这个版本中可以有4种动态背景： Canvas-nest three_waves canvas_lines canvas_sphere在 _config.yml 文件中即可配置，但是需要下载配置栗子 点击出现桃心效果浏览器输入：http://7u2ss1.com1.z0.glb.clouddn.com/love.js 拷贝所有代码，在/themes/next/source/js/src里面新建love.js，然后在\themes\next\layout_layout.swig文件末尾添加以下代码： 12&lt;!-- 页面点击小红心 --&gt; &lt;script type="text/javascript" src="/js/src/love.js"&gt;&lt;/script&gt; 设置网站图标默认的网站图标是一个N，当然是需要制定一个图了，在网上找到图后，将其放在 /themes/next/source/images 里面,找到主题配置文件中的favicon关键字，进行替换,如图 实现统计功能 实现效果图 具体实现方法在博客根目录下,git-bash1$ npm install hexo-wordcount --save 然后在主题的配置文件中，配置如下：123# Post wordcount display settings# Dependencies: https://github.com/willin/hexo-wordcountword_count: true 修改主题 swig 布局 为了能在文章信息处显示字数，我们需要修改 themes/next/layout/_macro/post.swig ，在 class 为 post-meta 的 div 中的添加如下内容：12345678910&#123;% if theme.word_count %&#125; &lt;span class=&quot;post-letters-count&quot;&gt; &amp;nbsp; | &amp;nbsp; &lt;i class=&quot;fa fa-align-right&quot;&gt;&lt;/i&gt; &lt;span&gt;字数统计:&#123;&#123; wordcount(post.content) &#125;&#125;字&lt;/span&gt; &amp;nbsp; | &amp;nbsp; &lt;i class=&quot;fa fa-align-left&quot;&gt;&lt;/i&gt; &lt;span&gt;阅读时长:&#123;&#123; min2read(post.content) &#125;&#125;分&lt;/span&gt; &lt;/span&gt;&#123;% endif %&#125; 修改文章内链接文本样式修改文件 themes\next\source\css_common\components\post\post.styl ，在末尾添加如下css样式，：1234567891011// 文章内链接文本样式.post-body p a&#123; color: #0593d3; border-bottom: none; border-bottom: 1px solid #0593d3; &amp;:hover &#123; color: #fc6423; border-bottom: none; border-bottom: 1px solid #fc6423; &#125;&#125; 其中选择 .post-body 是为了不影响标题，选择 p 是为了不影响首页“阅读全文”的显示样式,颜色可以自己定义。 添加背景在 theme/next/source/css/_custom 文件夹下打开 custom.styl 文件，往里面添加以下代码：1234567body&#123; background:url(图片链接); background-size:cover; background-repeat:no-repeat; background-attachment:fixed; background-position:center; &#125; 本地图片将图片放至主题目录下 source\images 修改文章底部的那个带#号的标签 具体实现方法 修改模板 /themes/next/layout/_macro/post.swig ，搜索 rel=”tag”&gt;# ，将 # 换成 在网站底部加上访问量 具体实现方法 打开 \themes\next\layout_partials\footer.swig 文件,在 copyright 前加上画红线这句话：1&lt;script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"&gt;&lt;/script&gt; 然后再合适的位置添加显示统计的代码，如图：1234567&lt;div class="powered-by"&gt; &lt;i class="fa fa-user-md"&gt;&lt;/i&gt; &lt;span id="busuanzi_container_site_uv"&gt; 本站访客数:&lt;span id="busuanzi_value_site_uv"&gt;&lt;/span&gt; &lt;/span&gt; &amp;nbsp|&amp;nbsp&lt;/div&gt; 在这里有两中不同计算方式的统计代码： pv的方式，单个用户连续点击n篇文章，记录n次访问量 123&lt;span id="busuanzi_container_site_pv"&gt; 本站总访问量&lt;span id="busuanzi_value_site_pv"&gt;&lt;/span&gt;次&lt;/span&gt; uv的方式，单个用户连续点击n篇文章，只记录1次访客数 123&lt;span id="busuanzi_container_site_uv"&gt; 本站总访问量&lt;span id="busuanzi_value_site_uv"&gt;&lt;/span&gt;次&lt;/span&gt; 文章加密访问打开 themes\next\layout_partials\head 文件,在以下位置插入这样一段代码：1234567891011121314&lt;script&gt; (function () &#123; if ('&#123;&#123; page.password &#125;&#125;') &#123; if (prompt('请输入文章密码') !== '&#123;&#123; page.password &#125;&#125;') &#123; alert('密码错误！'); if (history.length === 1) &#123; location.replace("http://xxxxxxx.xxx"); // 这里替换成你的首页 &#125; else &#123; history.back(); &#125; &#125; &#125; &#125;)();&lt;/script&gt; 然后在文章上写成类似这样：就ok啦，不过很容易被破解掉噢 当然还有另一种方式 guide1guide2按照指引就可以啦~ 部署首先需要进行创建您个人的github账户 创建公钥打开git-bash,执行 1ssh-keygen -t rsa -C "your_email@youremail.com" 直接按三次回车，可不用输入密码，然后打开C盘查找Users/当前用户目录(Administrator),找到.ssh文件夹，打开文件夹下的id_rsa.pub文件，可用记事本文件打开将里面文字全部复制 打开github个人主页 (https://github.com/settings/ssh) ,点击 Add SSH Key 按钮，粘贴进去保存即可 安装 hexo-deployer-git。 1$ npm install hexo-deployer-git --save 创建github仓库仓库名中填写&lt;github的用户名&gt;.github.io 修改 _config.yml 文件12345deploy: type: git repo: &lt;repository url&gt; branch: [branch] message: [message] repository url使用ssh url即可，message不填也可branch用master分支即可 执行1$ hexo d 或者1$ hexo g -d 进入博客的github所在仓库，进入仓库设置,查看GitHub Pages即可完成部署 基本操作这里只提到一些编写过程中遇到的问题 markdown语法 插入图片这里涉及到资源文件夹 绝对路径当Hexo项目中只用到少量图片时，可以将图片统一放在 source/images 文件夹中，通过markdown语法访问它们。1![](/images/image.jpg) 相对路径图片除了可以放在统一的 source/images 文件夹中，还可以放在文章自己的目录中。文章的目录可以通过配置 config.yml 来生成。1post_asset_folder: true 把 _config.yml 中配置post_asset_folder设置为true后，通过命令hexo new &lt;文章名字&gt;，hexo就会在文章的目录下建立一个和文章同名的文件夹，然后把图片资源放进该文件夹下，即可通过1234567891011121314![](images/image.jpg)``` 记住和第一点绝对路径有区别，别在路径前面加/，否则会出错## 文档格式假设我们的文章名为 “hello hexo markdwon”，在命令行键入以下命令即可：``` markdown---title: hello hexo markdowndate: 2016-11-16 18:11:25tags:--- 这些内容是干嘛的呢？事实上，他们就是用于设置 MarkDown 文档在被解析为静态网页文件时的相关配置，这些配置参数一般位于文件中最上方以 — 分隔的区域。 其中，title 的值是当前文档名，也是将来在网页中显示的文章标题。 date 值是我们新建文档时的当地时区时间。 tags 值是文档的标签，我们可以随意赋值为文档贴标签。其用法如下：12345678---title: hello hexo markdowndate: 2016-11-16 18:11:25tags:- hello- hexo- markdown--- 文章分类categories 是用来给文章分类的，它跟 tags 不同的是其具有顺序性和层次性。 categories 的用法同 tags 一样，只不过斗个 categories 值是分先后顺序的。12categories:- hexo 文章摘要有的时候，主题模板配置的不够好的话，Hexo 最终生成的静态站点是不会自动生成文章摘要的。 所以，为了保险起见，我们也自己手动设置文章摘要，这样也方便避免自动生成的摘要不优雅的情况。 设置文章摘要，我们只需在想显示为摘要的内容之后添 即可。像下面这样：1234567891011---title: hello hexo markdowndate: 2016-11-16 18:11:25tags:- hello- hexo- markdown---我是短小精悍的文章摘要(๑•̀ㅂ•́)و✧&lt;!-- more --&gt;紧接着文章摘要的正文内容 这样， 之前、文档配置参数之后中的内容便会被渲染为站点中的文章摘要。 注意！文章摘要在文章详情页是正文中最前面的内容。]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F09%2F07%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment Warn使用win10记事本编辑会出现乱码问题.]]></content>
  </entry>
</search>
