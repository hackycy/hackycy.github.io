<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Android返回不销毁Activity，直接进入后台]]></title>
    <url>%2F2019%2F07%2F03%2FAndroid%E8%BF%94%E5%9B%9E%E4%B8%8D%E9%94%80%E6%AF%81Activity%EF%BC%8C%E7%9B%B4%E6%8E%A5%E8%BF%9B%E5%85%A5%E5%90%8E%E5%8F%B0%2F</url>
    <content type="text"><![CDATA[最近打开闲鱼，微信，发现他们点击返回到桌面的时候，他们的activity并没有直接销毁，还是依然保留在返回之前浏览的界面，如果总是用Activity的onSaveInstanceState()和 onRestoreInstanceState()方法来恢复状态的话也没有办法来这么精准的恢复状态，查了一下资料，的确有可以操作的办法。 isTaskRoot()isTaskRoot()方法用来判断该Activity是否为任务栈中的根Activity，即启动应用的第一个Activity。 moveTaskToBack（）moveTaskToBack()方法用于将activity退到后台，而不是直接finish掉。 从生命周期来说，会执行onPause、onStop，但不会执行onDestroy 。恢复的时候也一样，会执行onStart、onResume，但不会执行onCreate。 参数nonRoot表示的含义是此方法对非根activity是否有效： true表示对所有activity均有效， false表示只对根activity有效。 返回值：该activity被退出到后台或者他已经在后台了返回true，否则返回false 官方文档： public boolean moveTaskToBack (boolean nonRoot)Since: API Level 1Move the task containing this activity to the back of the activity stack. The activity’s order within the task is unchanged.Parameters:nonRoot If false then this only works if the activity is the root of a task; if true it will work for any activity in a task.Returns:If the task was moved (or it was already at the back) true is returned, else false. 使用案例重写onBackPressed或者onKeyDown事件等来监听返回键事件： 1234567891011@Override public boolean onKeyDown(int keyCode, KeyEvent event) &#123; if (event.getKeyCode() == KeyEvent.KEYCODE_BACK) &#123; if (isTaskRoot()) &#123; moveTaskToBack(false); return true; &#125; else &#123; return super.onKeyDown(keyCode, event); &#125; &#125; &#125; 参考资料http://www.voidcn.com/article/p-wbosovty-bru.html http://www.voidcn.com/article/p-poscpyhl-bn.html]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IntelliJ IDEA For Mac 快捷键]]></title>
    <url>%2F2019%2F06%2F30%2FIntelliJ-IDEA-For-Mac-%E5%BF%AB%E6%8D%B7%E9%94%AE%2F</url>
    <content type="text"><![CDATA[IntelliJ IDEA For Mac 快捷键 建议将 Mac 系统中与 IntelliJ IDEA 冲突的快捷键取消或更改，不建议改 IntelliJ IDEA 的默认快捷键 Mac键盘符号和修饰键说明 ⌘ Command ⇧ Shift ⌥ Option ⌃ Control ↩︎ Return/Enter ⌫ Delete ⌦ 向前删除键（Fn+Delete） ↑ 上箭头 ↓ 下箭头 ← 左箭头 → 右箭头 ⇞ Page Up（Fn+↑） ⇟ Page Down（Fn+↓） Home Fn + ← End Fn + → ⇥ 右制表符（Tab键） ⇤ 左制表符（Shift+Tab） ⎋ Escape (Esc) 一、Editing（编辑） ⌃Space 基本的代码补全（补全任何类、方法、变量） ⌃⇧Space 智能代码补全（过滤器方法列表和变量的预期类型） ⌘⇧↩ 自动结束代码，行末自动添加分号 ⌘P 显示方法的参数信息 ⌃J, Mid. button click 快速查看文档 ⇧F1 查看外部文档（在某些代码上会触发打开浏览器显示相关文档） ⌘+鼠标放在代码上 显示代码简要信息 ⌘F1 在错误或警告处显示具体描述信息 ⌘N, ⌃↩, ⌃N 生成代码（getter、setter、构造函数、hashCode/equals,toString） ⌃O 覆盖方法（重写父类方法） ⌃I 实现方法（实现接口中的方法） ⌘⌥T 包围代码（使用if..else, try..catch, for, synchronized等包围选中的代码） ⌘/ 注释/取消注释与行注释 ⌘⌥/ 注释/取消注释与块注释 ⌥↑ 连续选中代码块 ⌥↓ 减少当前选中的代码块 ⌃⇧Q 显示上下文信息 ⌥↩ 显示意向动作和快速修复代码 ⌘⌥L 格式化代码 ⌃⌥O 优化import ⌃⌥I 自动缩进线 ⇥ / ⇧⇥ 缩进代码 / 反缩进代码 ⌘X 剪切当前行或选定的块到剪贴板 ⌘C 复制当前行或选定的块到剪贴板 ⌘V 从剪贴板粘贴 ⌘⇧V 从最近的缓冲区粘贴 ⌘D 复制当前行或选定的块 ⌘⌫ 删除当前行或选定的块的行 ⌃⇧J 智能的将代码拼接成一行 ⌘↩ 智能的拆分拼接的行 ⇧↩ 开始新的一行 ⌘⇧U 大小写切换 ⌘⇧] / ⌘⇧[ 选择直到代码块结束/开始 ⌥⌦ 删除到单词的末尾（⌦键为Fn+Delete） ⌥⌫ 删除到单词的开头 ⌘+ / ⌘- 展开 / 折叠代码块 ⌘⇧+ 展开所以代码块 ⌘⇧- 折叠所有代码块 ⌘W 关闭活动的编辑器选项卡 二、Search/Replace（查询/替换） Double ⇧ 查询任何东西 ⌘F 文件内查找 ⌘G 查找模式下，向下查找 ⌘⇧G 查找模式下，向上查找 ⌘R 文件内替换 ⌘⇧F 全局查找（根据路径） ⌘⇧R 全局替换（根据路径） ⌘⇧S 查询结构（Ultimate Edition 版专用，需要在Keymap中设置） ⌘⇧M 替换结构（Ultimate Edition 版专用，需要在Keymap中设置） 三、Usage Search（使用查询） ⌥F7 / ⌘F7 在文件中查找用法 / 在类中查找用法 ⌘⇧F7 在文件中突出显示的用法 ⌘⌥F7 显示用法 ⌘⇧I 查看定义的类,快速查看 四、Compile and Run（编译和运行） ⌘F9 编译Project ⌘⇧F9 编译选择的文件、包或模块 ⌃⌥R 弹出 Run 的可选择菜单 ⌃⌥D 弹出 Debug 的可选择菜单 ⌃R 运行 ⌃D 调试 ⌃⇧R, ⌃⇧D 从编辑器运行上下文环境配置 五、Debugging（调试） F8 进入下一步，如果当前行断点是一个方法，则不进入当前方法体内 F7 进入下一步，如果当前行断点是一个方法，则进入当前方法体内，如果该方法体还有方法，则不会进入该内嵌的方法中 ⇧F7 智能步入，断点所在行上有多个方法调用，会弹出进入哪个方法 ⇧F8 跳出 ⌥F9 运行到光标处，如果光标前有其他断点会进入到该断点 ⌥F8 计算表达式（可以更改变量值使其生效） ⌘⌥R 恢复程序运行，如果该断点下面代码还有断点则停在下一个断点上 ⌘F8 切换断点（若光标当前行有断点则取消断点，没有则加上断点） ⌘⇧F8 查看断点信息 六、Navigation（导航） ⌘O 查找类文件 ⌘⇧O 查找所有类型文件、打开文件、打开目录，打开目录需要在输入的内容前面或后面加一个反斜杠/ ⌘⌥O 前往指定的变量 / 方法 ⌃← / ⌃→ 左右切换打开的编辑tab页 F12 返回到前一个工具窗口 ⎋ 从工具窗口进入代码文件窗口 ⇧⎋ 隐藏当前或最后一个活动的窗口，且光标进入代码文件窗口 ⌘⇧F4 关闭活动run/messages/find/… tab ⌘L 在当前文件跳转到某一行的指定处 ⌘E 显示最近打开的文件记录列表 ⌘⌥← / ⌘⌥→ 退回 / 前进到上一个操作的地方 ⌘⇧⌫ 跳转到最后一个编辑的地方 ⌥F1 显示当前文件选择目标弹出层，弹出层中有很多目标可以进行选择(如在代码编辑窗口可以选择显示该文件的Finder) ⌘B / ⌘ 鼠标点击 进入光标所在的方法/变量的接口或是定义处 ⌘⌥B 跳转到实现处，在某个调用的方法名上使用会跳到具体的实现处，可以跳过接口 ⌥ Space, ⌘Y 快速打开光标所在方法、类的定义 ⌃⇧B 跳转到类型声明处 ⌘U 前往当前光标所在方法的父类的方法 / 接口定义 ⌃↓ / ⌃↑ 当前光标跳转到当前文件的前一个/后一个方法名位置 ⌘] / ⌘[ 移动光标到当前所在代码的花括号开始/结束位置 ⌘F12 弹出当前文件结构层，可以在弹出的层上直接输入进行筛选（可用于搜索类中的方法） ⌃H 显示当前类的层次结构 ⌘⇧H 显示方法层次结构 ⌃⌥H 显示调用层次结构 F2 / ⇧F2 跳转到下一个/上一个突出错误或警告的位置 F4 / ⌘↓ 编辑/查看代码源 ⌥ Home 显示到当前文件的导航条 F3选中文件/文件夹/代码行，添加/取消书签 ⌥F3 选中文件/文件夹/代码行，使用助记符添加/取消书签 ⌃0...⌃9 定位到对应数值的书签位置 ⌘F3 显示所有书签 七、Refactoring（重构） F5 复制文件到指定目录 F6 移动文件到指定目录 ⌘⌫ 在文件上为安全删除文件，弹出确认框 ⇧F6 重命名文件 ⌘F6 更改签名 ⌘⌥N 一致性 ⌘⌥M 将选中的代码提取为方法 ⌘⌥V 提取变量 ⌘⌥F 提取字段 ⌘⌥C 提取常量 ⌘⌥P 提取参数 八、VCS/Local History（版本控制/本地历史记录） ⌘K 提交代码到版本控制器 ⌘T 从版本控制器更新代码 ⌥⇧C 查看最近的变更记录 ⌃C 快速弹出版本控制器操作面板 九、Live Templates（动态代码模板） ⌘⌥J 弹出模板选择窗口，将选定的代码使用动态模板包住 ⌘J 插入自定义动态代码模板 十、General（通用） ⌘1...⌘9 打开相应编号的工具窗口 ⌘S 保存所有 ⌘⌥Y 同步、刷新 ⌃⌘F 切换全屏模式 ⌘⇧F12 切换最大化编辑器 ⌥⇧F 添加到收藏夹 ⌥⇧I 检查当前文件与当前的配置文件 §⌃, ⌃` 快速切换当前的scheme（切换主题、代码样式等） ⌘, 打开IDEA系统设置 ⌘; 打开项目结构对话框 ⇧⌘A 查找动作（可设置相关选项） ⌃⇥ 编辑窗口标签和工具窗口之间切换（如果在切换的过程加按上delete，则是关闭对应选中的窗口）]]></content>
      <categories>
        <category>程序人生</category>
      </categories>
      <tags>
        <tag>IDEA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android Toolbar 使用详解]]></title>
    <url>%2F2019%2F06%2F27%2FAndroid-Toolbar-%E4%BD%BF%E7%94%A8%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[初识ToolbarToolbar 是在 Android 5.0 开始推出的一个 Material Design 风格的导航控件 ，Google 非常推荐大家使用 Toolbar 来作为Android客户端的导航栏，以此来取代之前的 Actionbar 。 与 Actionbar 相比，Toolbar 明显要灵活的多。它不像 Actionbar 一样，一定要固定在Activity的顶部，而是可以放到界面的任意位置。除此之外，在设计 Toolbar 的时候，Google也留给了开发者很多可定制修改的余地，这些可定制修改的属性在API文档中都有详细介绍，如： 设置导航栏图标； 设置App的logo； 支持设置标题和子标题； 支持添加一个或多个的自定义控件； 支持Action Menu； 使用Toolbar前面提到 Toolbar 是在 Android 5.0 才开始加上的，Google 为了将这一设计向下兼容，自然也少不了要推出兼容版的 Toolbar 。为此，我们需要在工程中引入 appcompat-v7 的兼容包，使用 android.support.v7.widget.Toolbar 进行开发。但是由于support库现在google团队已经不在维护了，最新版本好像是28点多，已经迁移到了AndroidX，所以该篇文章使用AndroidX，只是包名相对的变化了，使用和v7包没有多大变化。 先来看看运行效果 按照效果图，从左到右分别是我们前面提及到的 导航栏图标、App的logo、标题和子标题、自定义控件、以及 ActionMenu 。接着，我们来看下布局文件和代码实现。 首先，在布局文件 activity_main.xml中添加进我们需要的 Toolbar 控件 1234567891011121314151617&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:tools="http://schemas.android.com/tools" android:layout_width="match_parent" android:layout_height="match_parent" tools:context=".MainActivity"&gt; &lt;androidx.appcompat.widget.Toolbar android:id="@+id/toolbar" android:layout_width="match_parent" android:background="@color/colorPrimary" android:layout_height="?attr/actionBarSize"&gt; &lt;TextView android:text="textview" android:layout_width="wrap_content" android:layout_height="wrap_content" /&gt; &lt;/androidx.appcompat.widget.Toolbar&gt;&lt;/LinearLayout&gt; 接着创建一个toolbar_menu.xml菜单项 1234567891011121314151617181920212223242526&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;menu xmlns:android="http://schemas.android.com/apk/res/android" xmlns:app="http://schemas.android.com/apk/res-auto"&gt; &lt;item android:id="@+id/action_search" android:icon="@android:drawable/ic_input_add" android:title="menu_search" app:showAsAction="ifRoom" /&gt; &lt;item android:id="@+id/action_notification" android:icon="@android:drawable/ic_delete" android:title="menu_notifications" app:showAsAction="ifRoom" /&gt; &lt;item android:id="@+id/action_item1" android:title="item_01" app:showAsAction="never" /&gt; &lt;item android:id="@+id/action_item2" android:title="item_02" app:showAsAction="never" /&gt;&lt;/menu&gt; 我的activity继承自AppCompatActivity，并不是原生sdk内部的，因此不能使用android:showAsAction，否则会报错。所以需要使用自定义的命名空间app。 ifRoom表示有空间则显示，never表示从不显示，而是会通过overflowwindow显示。 最后在MainActivity中调用 1234567891011121314151617181920212223242526public class MainActivity extends AppCompatActivity &#123; private Toolbar mToolbar; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); mToolbar = findViewById(R.id.toolbar); mToolbar.setTitle("标题"); mToolbar.setSubtitle("子标题"); mToolbar.setNavigationIcon(android.R.drawable.ic_menu_info_details); mToolbar.setLogo(android.R.drawable.ic_menu_view); setSupportActionBar(mToolbar); //最后设置 &#125; /** 菜单栏目 */ @Override public boolean onCreateOptionsMenu(Menu menu) &#123; getMenuInflater().inflate(R.menu.toolbar_menu, menu); return super.onCreateOptionsMenu(menu); &#125;&#125; 更改主题： 为了能够正常使用ToolBar，我们需要隐藏原来的ActionBar，这个可以在主题中修改 12&lt;item name="windowNoTitle"&gt;true&lt;/item&gt;&lt;item name="windowActionBar"&gt;false&lt;/item&gt; 或者继承某个父类:Theme.AppCompat.Light.NoActionBar 也可以在代码中 如果是AppCompatActivity 12supportRequestWindowFeature(Window.FEATURE_NO_TITLE);//setContentView之前调用，否则报错 如果是Activity 1requestWindowFeature(Window.FEATURE_NO_TITLE); 最后运行就可以有上面图中的效果啦。 注意事项 如果你想修改标题和子标题的字体大小、颜色等，可以调用setTitleTextColor、setTitleTextAppearance、setSubtitleTextColor、setSubtitleTextAppearance 这些API； 自定义的View位于 title、subtitle 和 actionmenu 之间，这意味着，如果 title 和 subtitle 都在，且 actionmenu选项 太多的时候，留给自定义View的空间就越小； 导航图标 和 app logo 的区别在哪？如果你只设置 导航图标（ or app logo） 和 title、subtitle，会发现 app logo 和 title、subtitle 的间距比较小，看起来不如 导航图标 与 它们两搭配美观； Toolbar 和其他控件一样，很多属性设置方法既支持代码设置，也支持在xml中设置 其他样式修改修改Toolbar popup menu样式点击右上角的三个点，会弹出一个popup menu，如下所示： 可以看到弹出菜单的样式是白底黑字，那么有没有办法改变它的背景颜色呢，使得菜单显示为黑底白字。这肯定是有的。 在styles.xml文件中新建一个主题 1234&lt;!-- toolbar弹出菜单样式 --&gt;&lt;style name="ToolbarPopupTheme" parent="@style/ThemeOverlay.AppCompat.Dark"&gt; &lt;item name="android:colorBackground"&gt;#000000&lt;/item&gt;&lt;/style&gt; 可以看到这个主题的parent是直接继承自ThemeOverlay.AppCompat.Dark，是支持包的一个主题，并且我们在内部声明了android:colorBackground这个属性，我们只要更改这个属性就能变更菜单的背景颜色了。接下来我们在布局文件中引入这个主题，这也很简单，为toolbar添加额外的属性如下: 1app:popupTheme="@style/ToolbarPopupTheme" 运行效果： 修改Toolbar popup menu 弹出位置在上图看到，弹出的菜单的位置是过于偏上的，我们可以修改它的位置，让它在toolbar的下面，这样看起来也美观一些： 修改styles.xml文件，添加 1234567891011&lt;!-- toolbar弹出菜单样式 --&gt;&lt;style name="ToolbarPopupTheme" parent="@style/ThemeOverlay.AppCompat.Dark"&gt; &lt;item name="android:colorBackground"&gt;#000000&lt;/item&gt; &lt;item name="actionOverflowMenuStyle"&gt;@style/OverflowMenuStyle&lt;/item&gt; &lt;!--新增一个item，用于控制menu--&gt;&lt;/style&gt;&lt;style name="OverflowMenuStyle" parent="Widget.AppCompat.Light.PopupMenu.Overflow"&gt; &lt;item name="overlapAnchor"&gt;false&lt;/item&gt; &lt;!--把该属性改为false即可使menu位置位于toolbar之下--&gt;&lt;/style&gt; 布局文件中引用该主题 1app:popupTheme="@style/ToolbarPopupTheme" 运行效果： 修改Action Menu Item 的文字颜色在styles.xml文件中，在popup menu的主题添加： 123456&lt;!-- toolbar弹出菜单样式 --&gt;&lt;style name="ToolbarPopupTheme" parent="@style/ThemeOverlay.AppCompat.Dark"&gt; &lt;item name="android:colorBackground"&gt;#000000&lt;/item&gt; &lt;item name="actionOverflowMenuStyle"&gt;@style/OverflowMenuStyle&lt;/item&gt; &lt;!--新增一个item，用于控制menu--&gt; &lt;item name="android:textColorPrimary"&gt;@color/colorPrimary&lt;/item&gt;&lt;/style&gt; 布局文件中引用该主题 1app:popupTheme="@style/ToolbarPopupTheme" 运行效果： 踩坑设置监听事件不生效看一下代码 123456789101112131415161718private void initToolbar()&#123; mToolbar = findViewById(R.id.toolbar); mToolbar.setTitle(""); mToolbar.setNavigationOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View view) &#123; //。。。 &#125; &#125;); mToolbar.setOnMenuItemClickListener(new Toolbar.OnMenuItemClickListener() &#123; @Override public boolean onMenuItemClick(MenuItem item) &#123; //。。。 return true; &#125; &#125;); setSupportActionBar(mToolbar);&#125; 代码正常设置监听但是就是监听事件就是没有触发，查询后，监听事件必须在setSupportActionBar(mToolbar);之后设置。 123456789101112131415161718private void initToolbar()&#123; mToolbar = findViewById(R.id.toolbar); mToolbar.setTitle(""); setSupportActionBar(mToolbar); mToolbar.setNavigationOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View view) &#123; //。。。 &#125; &#125;); mToolbar.setOnMenuItemClickListener(new Toolbar.OnMenuItemClickListener() &#123; @Override public boolean onMenuItemClick(MenuItem item) &#123; //。。。 return true; &#125; &#125;);&#125; 调换一下位置即可正常运行。 总结以上都是一些基本的使用，Toolbar控件的使用还是很灵活的，还有很多一些高级技巧，比如配合上状态栏变成沉浸式，或者配合CoordinatorLayout等实现更炫的效果。 参考资料https://www.jianshu.com/p/79604c3ddcae https://www.jianshu.com/p/ae0013a4f71a]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Activity 的4种启动模式]]></title>
    <url>%2F2019%2F06%2F20%2FActivity-%E7%9A%844%E7%A7%8D%E5%90%AF%E5%8A%A8%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[启动模式简单地说就是Activity启动时的策略，在AndroidManifest.xml中的标签的android:launchMode属性设置；启动模式有4种，分别为standard、singleTop、singleTask、singleInstance； standard 标准模式，每次都新建一个实例对象 singleTop 如果在任务栈顶发现了相同的实例则重用，否则新建并压入栈顶 singleTask 如果在任务栈中发现了相同的实例，将其上面的任务终止并移除，重用该实例。否则新建实例并入栈 singleInstance 允许不同应用，进程线程等共用一个实例，无论从何应用调用该实例都重用 任务栈每个应用都有一个任务栈，是用来存放Activity的，功能类似于函数调用的栈，先后顺序代表了Activity的出现顺序；比如Activity1–&gt;Activity2–&gt;Activity3,则任务栈为： 启动模式standard 每次激活Activity时(startActivity)，都创建Activity实例，并放入任务栈； 但是每次都新建一个实例的话真是过于浪费，为了优化应该尽量考虑余下三种方式。 singleTop 每次扫描栈顶，如果在任务栈顶发现了相同的实例则重用，否则新建并压入栈顶。 在AndroidManifest.xml中 12345&lt;activity android:name=".SingleTopActivity" android:label="@string/singletop" android:launchMode="singleTop" &gt;&lt;/activity&gt; singleTask 与singleTop的区别是singleTask会扫描整个任务栈并制定策略。上效果图： 使用时需要小心因为会将之前入栈的实例之上的实例全部移除，需要格外小心逻辑。 在AndroidManifest.xml中 12345&lt;activity android:name=".SingleTopActivity" android:label="@string/singletop" android:launchMode="singleTop" &gt;&lt;/activity&gt; singleInstance 这个的理解可以这么看：在微信里点击“用浏览器打开”一个朋友圈，然后切到QQ再用浏览器开一个网页，再跑到哪里再开一个页面。每次我们都在Activity中试图启动另一个浏览器Activity，但是在浏览器端看来，都是调用了同一个自己。因为使用了singleInstance模式，不同应用调用的Activity实际上是共享的。 在AndroidManifest.xml中 12345&lt;activity android:name=".SingleTopActivity" android:label="@string/singletop" android:launchMode="singleTop" &gt;&lt;/activity&gt; 参考链接 http://www.cnblogs.com/fanchangfa/archive/2012/08/25/2657012.html Android入门：Activity四种启动模式]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IOS之UIApplication]]></title>
    <url>%2F2019%2F06%2F20%2FIOS%E4%B9%8BUIApplication%2F</url>
    <content type="text"><![CDATA[UIApplication 的核心作用是提供了 iOS 程序运行期间的控制和协作工作。 每一个程序在运行期必须有且仅有一个UIApplication（或则其子类）的一个实例。在程序开始运行的时候，UIApplicationMain 函数是程序进入点，这个函数做了很多工作，其中一个重要的工作就是创建一个 UIApplication 的单例实例。在你的代码中你，你可以通过调用 [UIApplication sharedApplication]来得到这个单例实例的指针。 UIApplication 的一个主要工作是处理用户事件，它会起一个队列，把所有用户事件都放入队列，逐个处理，在处理的时候，它会发送当前事件 到一个合适的处理事件的目标控件。此外，UIApplication 实例还维护一个在本应用中打开的 window 列表（UIWindow 实例），这样它就 可以接触应用中的任何一个 UIView 对象。UIApplication 实例会被赋予一个代理对象，以处理应用程序的生命周期事件（比如程序启动和关闭）、系统事件（比如来电、记事项警告）等等。 UIApplicaion 生命周期一个 UIApplication 可以有如下几种状态： Not running（未运行）程序没启动 Inactive（未激活）程序在前台运行，不过没有接收到事件。在没有事件处理情况下程序通常停留在这个状态 Active（激活）程序在前台运行而且接收到了事件。这也是前台的一个正常的模式 Background（后台） 程序在后台而且能执行代码，大多数程序进入这个状态后会在在这个状态上停留一会。时间到之后会进入挂起状态 (Suspended)。有的程序经过特殊的请求后可以长期处于 Background 状态 Suspended（挂起）程序在后台不能执行代码。系统会自动把程序变成这个状态而且不会发出通知。当挂起时，程序还是停留在内存中的，当系统内存低时，系统就把挂起的程序清除掉，为前台程序提供更多的内存。 常见的代理方法有 (void)applicationWillResignActive:(UIApplication *)application 说明：当应用程序将要入非活动状态执行，在此期间，应用程序不接收消息或事件，比如来电话了 (void)applicationDidBecomeActive:(UIApplication *)application 说明：当应用程序入活动状态执行，这个刚好跟上面那个方法相反 (void)applicationDidEnterBackground:(UIApplication *)application 说明：当程序被推送到后台的时候调用。所以要设置后台继续运行，则在这个函数里面设置即可 (void)applicationWillEnterForeground:(UIApplication *)application 说明：当程序从后台将要重新回到前台时候调用，这个刚好跟上面的那个方法相反。 (void)applicationWillTerminate:(UIApplication *)application 说明：当程序将要退出是被调用，通常是用来保存数据和一些退出前的清理工作。这个需要设置 UIApplicationExitsOnSuspend 的键值。 (void)applicationDidReceiveMemoryWarning:(UIApplication *)application 说明：iPhone 设备只有有限的内存，如果为应用程序分配了太多内存操作系统会终止应用程序的运行，在终止前会执行这个方法，通常可以在这里进行内存清理工作防止程序被终止 (void)applicationSignificantTimeChange:(UIApplication*)application 说明：当系统时间发生改变时执行 (void)applicationDidFinishLaunching:(UIApplication*)application 说明：当程序载入后执行 App 生命周期示意图]]></content>
      <categories>
        <category>Ios</category>
      </categories>
      <tags>
        <tag>Ios</tag>
        <tag>Objective-C</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[纯HTML+CSS实现轮播图]]></title>
    <url>%2F2019%2F06%2F19%2F%E7%BA%AFHTML-CSS%E5%AE%9E%E7%8E%B0%E8%BD%AE%E6%92%AD%E5%9B%BE%2F</url>
    <content type="text"><![CDATA[一种纯HTML+CSS实现的轮播图，但由于没有JS不支持实现用户进行左右滑动。 DOM结构搭建12345678910111213141516171819&lt;div class="slide-container middle"&gt; &lt;div class="slide-wrap"&gt; &lt;div class="slide"&gt; &lt;img src="./1.jpg" alt=""&gt; &lt;/div&gt; &lt;div class="slide"&gt; &lt;img src="./2.jpg" alt=""&gt; &lt;/div&gt; &lt;div class="slide"&gt; &lt;img src="./3.jpg" alt=""&gt; &lt;/div&gt; &lt;div class="slide"&gt;a &lt;img src="./4.jpg" alt=""&gt; &lt;/div&gt; &lt;div class="slide"&gt; &lt;img src="./5.jpg" alt=""&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 123456789101112131415.slide-container &#123; width: 500px; height: 300px; overflow: hidden;&#125;.middle &#123; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);&#125;.slide img &#123; width: 100%; height: 100%;&#125; 图片并排显示可以看到正常文档流图片是向下排列的，如何让他们实现并排显示呢，可能会想到使用float，但是最简单的办法是使用flex布局。给slide-wrap容器指定为Flex布局。 12345678910.slide-wrap &#123; display: flex; width: 500%; height: 100%;&#125;.slide &#123; width: 20%; height: 100%; transition: 1s;&#125; 为什么slide-wrap要给予500%的宽度，因为该列有五张图片，一张图片刚好占满一个父容器。 实现点击轮播效果不用JS如何实现轮播图切换效果呢？我们先实现轮播图的小点点。 123456789101112131415161718.navigation &#123; position: absolute; left: 50%; bottom: 30px; transform: translateX(-50%); display: flex;&#125;.bar &#123; width: 20px; height: 10px; border: 3px white solid; margin-left: 10px; cursor: pointer; transition: 0.5s;&#125;.bar:hover &#123; background: white;&#125; 12345678&lt;!-- inner slide-wrap --&gt;&lt;div class="navigation"&gt; &lt;label class="bar" for=""&gt;&lt;/label&gt; &lt;label class="bar" for=""&gt;&lt;/label&gt; &lt;label class="bar" for=""&gt;&lt;/label&gt; &lt;label class="bar" for=""&gt;&lt;/label&gt; &lt;label class="bar" for=""&gt;&lt;/label&gt;&lt;/div&gt; 为什么使用label来实现指示器呢，这里就关键用到了它的for属性。 1234567891011121314&lt;!-- inner slide-wrap --&gt;&lt;input type="radio" name="r" id="r1" checked&gt;&lt;input type="radio" name="r" id="r2"&gt;&lt;input type="radio" name="r" id="r3"&gt;&lt;input type="radio" name="r" id="r4"&gt;&lt;input type="radio" name="r" id="r5"&gt;&lt;div class="navigation"&gt; &lt;label class="bar" for="r1"&gt;&lt;/label&gt; &lt;label class="bar" for="r2"&gt;&lt;/label&gt; &lt;label class="bar" for="r3"&gt;&lt;/label&gt; &lt;label class="bar" for="r4"&gt;&lt;/label&gt; &lt;label class="bar" for="r5"&gt;&lt;/label&gt;&lt;/div&gt; 1234input[name="r"] &#123; position: absolute; visibility: hidden;&#125; 使用label和input:radio进行关联起来后，点击的label就相当于选择了某个单选按钮，默认第一个单选按钮为选中状态，切换到第二个时，我们将第一张图向容器左边挪百分之20%的宽度(因为一共有五张图，一张图就占20%的宽度)，就可以看到切花成了第二张图，以此类推。看看代码的实现： 123456789101112131415#r1:checked ~ .s1 &#123; margin-left: 0;&#125;#r2:checked ~ .s1 &#123; margin-left: -20%;&#125;#r3:checked ~ .s1 &#123; margin-left: -40%;&#125;#r4:checked ~ .s1 &#123; margin-left: -60%;&#125;#r5:checked ~ .s1 &#123; margin-left: -80%;&#125; 点击指示器切换轮播图就完成啦。 自动轮播效果1234567891011121314151617181920212223242526272829303132333435363738394041.s1 &#123; animation: loop 12s linear infinite;&#125;@keyframes loop &#123; 0% &#123; margin-left: 0; &#125; 15% &#123; margin-left: 0; &#125; /* 停留1500ms */ 20% &#123; margin-left: -20%; &#125; /* 切换500ms 位移-20% */ 35% &#123; margin-left: -20%; &#125; 40% &#123; margin-left: -40%; &#125; 55% &#123; margin-left: -40%; &#125; 60% &#123; margin-left: -60%; &#125; 75% &#123; margin-left: -60%; &#125; 80% &#123; margin-left: -80%; &#125; 95% &#123; margin-left: -80%; &#125; 100% &#123; margin-left: 0; &#125; /* 复位到第一张图片 */ CSS3的动画属性就不过多介绍了，但是自动轮播和点击是相冲突的，但是这是一种纯CSS轮播图的一种实现思路，不需JS的实现。挺好玩的。 源码已放置GitHub：https://github.com/hackycy/Html-Css-Carousel]]></content>
      <categories>
        <category>HTML</category>
      </categories>
      <tags>
        <tag>HTML</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript必知必会]]></title>
    <url>%2F2019%2F05%2F29%2FJavaScript%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A%2F</url>
    <content type="text"><![CDATA[JavaScript基本介绍 JS的用途：Javascript可以实现浏览器端、服务器端(nodejs)。。。 浏览器端JS由以下三个部分组成： ECMAScript：基础语法(数据类型、运算符、函数。。。) BOM(浏览器对象模型)：window、location、history、navigator。。。 DOM(文档对象模型)：div、p、span。。。 ECMAScript又名es，有以下重大版本： 旧时代： es1.0。。。es3.1 新时代： es5 es6(es2015) es7(es2016)、es8(es2017) JavaScript基本数据类型和复杂数据类型一句总结，使用排除法，除掉基本数据类型都是复杂数据类型即字符串、数字、布尔值、null、undefined、Symbol其余都是对象类型。复杂数据类型例如Date、Array等。 对象的基本使用12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;script type="text/javascript"&gt; //创建对象 var person = &#123; name : "张三", age : 18, say : function()&#123; console.log('i am from china'); &#125; &#125;; //获取属性 console.log(person.name); console.log(person.age); person.say(); //设置属性 person.address = "中国广东广州"; console.log(person.address); //清除属性 delete person.address; delete person.adc //无意义,但是也不会报错 console.log(person.address); //delete只能删除对象的属性,而不能删除变量 //清空对象 person=&#123;&#125;; //将person变为null person = null; //两者意义不一样 &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 输出123张三18i am from china 对象是键值对的集合：对象是由属性和方法构成的 (ps：也有说法为：对象里面皆属性，认为方法也是一个属性) name是属性 age是属性 say是方法 获取属性的方式.语法 person.age获取age属性 person.say获取到一个方法 []语法 person[&quot;name&quot;]等价于person.age person[&quot;say&quot;]等价于person.say 2种方式的差异： .语法更方便，但是坑比较多(有局限性)，比如： .后面不能使用js中的关键字、保留字(class、this、function。。。) .后面不能使用数字123var obj=&#123;&#125;;obj.this=5; //语法错误obj.0=10; //语法错误 []使用更广泛 o1[变量name] [“class”]、[“this”]都可以随意使用 obj[&quot;this&quot;]=10 [0]、[1]、[2]也可以使用 obj[3]=50 = obj[&quot;3&quot;]=50 思考：为什么obj[3]=obj[“3”] 甚至还可以这样用：[“[object Array]”] jquery里面就有这样的实现 也可以这样用：[“{abc}”] 给对象添加了{abc}属性 设置属性 student[&quot;gender&quot;]=&quot;男&quot; 等价于： student.gender=&quot;男&quot; 含义：如果student对象中没有gender属性，就添加一个gender属性，值为”男” 如果student对象中有gender属性，就修改gender属性的值为”男” 案例1：student.isFemale=true 案例2：student[&quot;children&quot;]=[1,2,5] 案例3：123student.toShanghai=function()&#123; console.log("正在去往上海的路上") &#125; 删除属性 delete student[&quot;gender&quot;] delete student.gender 属性简写123var a = 10;var obj = &#123; a &#125;; // &#123; a: 10 &#125; 构造函数概念12345678&lt;script type="text/javascript"&gt; function Person(name, age)&#123; this.name = name; this.age = age; &#125; var person = new Person('张三', 40); console.log(person);&lt;/script&gt; person就是根据【Person构造函数】创建出来的对象 任何函数都可以当成构造函数 例如function CreateFunc(){ } 只要把一个函数通过new的方式来进行调用，我们就把这一次函数的调用方式称之为：构造函数的调用 new CreateFunc(); 此时CreateFunc就是一个构造函数 CreateFunc(); 此时的CreateFunc并不是构造函数 关于new Object()，new Object()等同于对象字面量{} 构造函数的执行过程var person = new Person() 创建一个对象，称之为这个Person构造函数的实例，p1 创建一个内部对象，this，将this指向该实例 执行函数内部的代码，其中，操作this的部分就是操作了该实例 返回值 如果函数没有返回值，没有return语句，那么就会返回构造函数的实例p1 如果函数返回了一个基本数据类型的值，那么就会返回本次构造函数的实例p1 如果函数返回了一个复杂数据类型的值，那么本次函数的返回值就是该值。 12345678910111213141516171819function fn()&#123; &#125;var f1=new fn(); //f1就是fn的实例function fn2()&#123; return "abc";&#125;var f2=new fn2(); //f2是fn2构造函数的实例function fn3()&#123; return [1,3,5]; //数组是一个对象类型的值， //所以数组是一个复杂数据类型的值 //--&gt;本次构造函数的真正返回值就是该数组 //--&gt;不再是fn3构造函数的实例&#125;var f3=new fn3(); //f3还是fn3的实例吗？错//f3值为[1,3,5] JS中的继承JS中的继承和其他语言不太一样。JS中的继承是你可以通过某种方式让某个对象访问到其他对象中的属性、方法，那么这种方式就可以称之为继承。而并不是简单的所谓的Xxx extends Parent 为什么要使用继承 有些对象会有方法(动作、行为)，而这些方法都是函数，如果把这些方法和函数都放在构造函数中声明就会导致内存的浪费12345678function Person()&#123; this.say=function()&#123; console.log("你好") &#125;&#125;var p1=new Person();var p2=new Person();console.log(p1.say === p2.say); //false 继承的方式原型链继承原型链继承第一种方式123Person.prototype.say = function()&#123; console.log('hello');&#125; 当然这样写没有问题，但是方法一旦过多，代码的冗余将会非常的多。 原型链继承第二种方式123456789Person.prototype = &#123; constructor:Person, say:function()&#123; console.log('hello'); &#125;, run:function()&#123; console.log('running'); &#125;&#125; 注意：1、一般情况下，应该先改变原型对象，再创建对象。2、对于新原型，一般会添加一个constructor属性，从而不破坏原来的原型对象结构。 拷贝继承（也称混入继承：mixin）场景：有时候想使用某个对象中的属性，但是又不想直接破坏它，于是就可以创建这个对象的拷贝类似于jQuery中的$.extend，编写Jquery插件的必经之路 来看一个例子12345678910111213var o1 = &#123; age : 1&#125;var o2 = o1;o2.age = 18;console.log(o1.age); //结果输出18//1、修改了o2对象的age属性//2、由于o2对象跟o1对象是同一个对象//3、所以此时o1对象的age属性也被修改了 这里涉及到一个知识点深拷贝和浅拷贝， 深拷贝只是拷贝一层属性，没有内部对象 深拷贝其实是利用了递归的原理，将对象的若干层属性拷贝出来。 上述例子中只是一个浅拷贝。 那么什么场景下适合使用拷贝继承12345678910var o3 = &#123; gender : '男', grade : '初三', name : '张三'&#125;var o4 = &#123; gender : '男', grade : '初三', name : '李四'&#125; 实现11234567891011var o3 = &#123; gender : '男', grade : '初三', name : '张三'&#125;var cp = &#123;&#125;;cp.gender = o3.gender;cp.grade = o3.gender;cp.name = o3.name;console.log(cp); //&#123;gender: "男", grade: "男", name: "张三"&#125; 这样的方式可以说在开发中就是写死的，毫无重用性。 实现21234567891011121314var o3 = &#123; gender : '男', grade : '初三', name : '张三'&#125;function extend(target,source)&#123; for(key in source) &#123; target[key] = source[key]; &#125; return target;&#125;var target = &#123;&#125;;extend(target, o3);console.log(target); //&#123;gender: "男", grade: "初三", name: "张三"&#125; 如果很多时候需要用到拷贝继承，无疑封装成一个函数来进行复用是很好的。 在es6中也有了对象扩展运算符，仿佛就是为了拷贝继承而生的:123456789var o3 = &#123; gender : '男', grade : '初三', name : '张三'&#125;var target = &#123; ...o3 &#125;;console.log(target);//&#123;gender: "男", grade: "初三", name: "张三"&#125;var target2 = &#123; ...o3, age:20 &#125;;console.log(target2);//&#123;gender: "男", grade: "初三", name: "张三", age: 20&#125; 可以说简单到令人发指的操作，当然也会存在兼容问题啦，这里不涉及es6，单纯扯一下。 原型式继承（道格拉斯在蝴蝶书中提出的） 使用场景 可以创建一个纯洁的对象，对象中什么属性都没有 创建一个继承自某个父对象的字对象 12345678910111213//创建空对象var o1 = Object.create(null);console.log(o1); //&#123;&#125;console.log(o1.__proto__) //undefined//继承父对象var parent = &#123; age : 50, name : "爸爸"&#125;var s1 = Object.create(parent);console.log(s1); //&#123;&#125;console.log(s1.__proto__); //&#123;age: 50, name: "爸爸"&#125; 可以看得出一些区别，所谓的纯洁对象，真的很纯。这个使用也很方便。 借用构造函数继承场景：适用于2种构造函数之间有相似的逻辑的情况。原理：函数的call、apply调用方式（函数的调用方式在文章后面讲解） 场景举例：1234567891011121314function Animal(name,age,gender)&#123; this.name=name; this.age=age; this.gender=gender;&#125;function Person(name,age,gender,say)&#123; this.name=name; this.age=age; this.gender=gender; this.say=function()&#123; &#125;&#125; 局限性：Animal（父类的构造函数）的构造函数必须完全适用于Person（子类的构造函数） 借用构造函数实现1234567891011121314151617181920function Animal(name,age)&#123; this.name=name; this.age=age;&#125;function Person(name,age,say)&#123; // this.name=name; // this.age=age; // this.gender=gender; Animal.apply(this, [name, age]); //等同与下面语句 //Animal.call(this, name, age); this.say=function()&#123; &#125;&#125;console.log(new Person('张三', 18, function()&#123; console.log('say');&#125;)) //&#123;name: "张三", age: 18, say: ƒ&#125; and so on还有寄生继承，寄生组合继承，这里举例出以上几条常用的，其余这里就不再一一细数了。 原型链概念：JS中的对象可能会有父对象，父对象中可能还会有父对象，就是祖宗十九代了。根本：继承 - 属性：对象中几乎都会有一个`__proto__`的一个属性，指向他的父对象 - 意义，可以访问到父对象中的相关属性和方法 根对象：Object.prototype 123456function Animal()&#123;&#125;var cat = new Animal();console.log(cat.__proto__); //等同于 Animal.prototypeconsole.log(cat.__proto__.__proto__);//等同于 Object.prototype 函数对象都有prototype（原型对象）；而普通对象则只有__proto__（原型指针） 变量作用域概念：就是一个变量可以使用的范围。 最外层作用域：全局作用域 通过函数创建出一个独立的作用域，其中函数还可以嵌套，所以作用域也可以嵌套。 作用域链 由于作用域是相对于变量而言的，而如果存在多级作用域，这个变量又来自于哪里？这个问题就需要好好地探究一下了，我们把这个变量的查找过程称之为变量的作用域链 作用域链的意义：查找变量（确定变量来自于哪里，变量是否可以访问） 简单来说，作用域链可以用以下几句话来概括：(或者说：确定一个变量来自于哪个作用域) 查看当前作用域，如果当前作用域声明了这个变量，就确定结果 查找当前作用域的上级作用域，也就是当前函数的上级函数，看看上级函数中有没有声明 再查找上级函数的上级函数，直到全局作用域为止 如果全局作用域中也没有，我们就认为这个变量未声明(xxx is not defined) 例子1：1234567891011121314var age = 10; //全局变量(function log()&#123; console.log(age); //可访问 var name = "zhangsan"; console.log(name); //可访问&#125;)();console.log(name); //不能访问console.log(age); //可访问 例子2：12345678910var gender = "男";var f = (function()&#123; console.log(gender); //可以访问 return function() &#123; console.log(gender); //可以访问 &#125; var age = 10;&#125;)();f(); 闭包一个经典的例子1234567891011function fn()&#123; var a = 1; return function()&#123; a++; console.log(a); &#125;&#125;var f = fn();f(); //2f(); //3f(); //4 可以看出a的输出并没有一直输出3，而是2、3、4，而产生的原因是因为fn函数执行完毕后，匿名函数的引用导致没有释放a变量，而作用域中保留了最新的a变量的值，闭包问题就产生了。 闭包不仅仅只是说要返回一个函数，还可以是一个对象 闭包的内存释放12345678910111213&lt;script&gt; function f1()&#123; var a=5; return function()&#123; a++; console.log(a); &#125; &#125; var q1=f1(); //要想释放q1里面保存的a，只能通过释放q1 q1=null; //q1=undefined&lt;/script&gt; 闭包的应用 模块化 防止变量被破坏 举例：模块化的应用参考Vue.js中的源码 防止变量被破坏，运用场景 举例：KTV中的最低消费，最低消费的数值不能够暴露出去让别人随便修改，这样会脏了数据，返回一个对象暴露方法来进行业务操作，而不是进行直接操作。 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;script type="text/javascript"&gt; //场景举例 function KTV()&#123; //最低消费1000 var leastPrice = 1000; var sale = 0; return &#123; //消费 pay:function(pr)&#123; sale += pr; &#125;, //结账 settlement:function()&#123; if(sale&lt;leastPrice)&#123; console.log("您未达到最低消费，请继续消费"); &#125; else &#123; console.log("欢迎下次光临"); &#125; &#125; &#125; &#125; var p1 = KTV(); p1.pay(100); p1.settlement(); //您未达到最低消费，请继续消费 p1.pay(1000); p1.settlement(); //欢迎下次光临 &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 但是如果需要进行修改最低消费，场景：老板的朋友进行消费，需要修改 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;script type="text/javascript"&gt; //场景举例 function KTV()&#123; //最低消费1000 var leastPrice = 1000; var sale = 0; return &#123; //消费 pay:function(pr)&#123; sale += pr; &#125;, //结账 settlement:function()&#123; if(sale&lt;leastPrice)&#123; console.log("您未达到最低消费，请继续消费"); &#125; else &#123; console.log("欢迎下次光临"); &#125; &#125;, //传入工号，和修改最低消费值 edit:function(id,lp)&#123; if(id == 888)&#123; leastPrice = lp; &#125;else&#123; console.log("你不是管理员，无法修改"); &#125; &#125; &#125; &#125; var p1 = KTV(); p1.pay(100); p1.settlement(); //您未达到最低消费，请继续消费 p1.edit(100, 200); //你不是管理员，无法修改 p1.edit(888, 100); //欢迎下次光临 p1.settlement(); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 闭包的运用防止变量被破坏，暴露出方法来间接修改数值，防止出现脏数据。闭包中也有作用域链的相关运用。 严格模式从 ES5 开始，函数内部可以设定为严格模式。 严格模式主要有以下限制。 变量必须声明后再使用 函数的参数不能有同名属性，否则报错 不能使用with语句 不能对只读属性赋值，否则报错 不能使用前缀 0 表示八进制数，否则报错 不能删除不可删除的属性，否则报错 不能删除变量delete prop，会报错，只能删除属性delete global[prop] eval不会在它的外层作用域引入变量 eval和arguments不能被重新赋值 arguments不会自动反映函数参数的变化 不能使用arguments.callee 不能使用arguments.caller 禁止this指向全局对象 不能使用fn.caller和fn.arguments获取函数调用的堆栈 增加了保留字（比如protected、static和interface） 上面这些限制，模块都必须遵守。由于严格模式是 ES5 引入的，不属于 ES6，所以请参阅相关 ES5 书籍，本书不再详细介绍了。 其中，尤其需要注意this的限制。ES6 模块之中，顶层的this指向undefined，即不应该在顶层代码使用this。 函数的四种调用方式为什么要区分函数的调用方式呢？是因为在ES6前，函数内部的this是由该函数的调用方式决定的，函数内部的this跟大小写、书写位置无关。 函数调用方式12345function Person()&#123; console.log(this);&#125;Person(); //Window 可以看到打印的this指向的是window对象。 在看第二种情况 123456789101112131415var p = &#123; say:function()&#123; console.log(this); &#125;&#125;var s = p.say;s(); //WindowPerson.prototype.say = function()&#123; console.log(this);&#125;var f1 = Person.prototype.say;f1(); //Window this的指向还是window对象。 而在严格模式下 123456function Person()&#123; 'use strict' console.log(this);&#125;Person(); //undefined 1234567891011121314151617var p = &#123; say: function () &#123; 'use strict' console.log(this); &#125;&#125;var s = p.say;s(); //undefinedPerson.prototype.say = function () &#123; 'use strict' console.log(this);&#125;var f1 = Person.prototype.say;f1(); //undefined 可以看到，如果是以函数方式来调用，函数内部的this将指向window对象。而在严格模式下，由于函数调用方式this都是指向顶层对象，而严格模式禁止this指向顶层对象，所以this都是undefined 方法调用方式12345678910function Person()&#123; //这里不讨论age和say方法中的this this.age = 10; this.say = function()&#123; console.log(this); &#125;&#125;var p1 = new Person();p1.say(); //Person this指向了p1对象。 12345678910function Person()&#123; this.age = 10;&#125;Person.prototype.say = function()&#123; console.log(this);&#125;var p2 = new Person();p2.say(); //Person this指向了p2对象。 1234567var p3 = &#123; age: 10, say: function()&#123; console.log(this); &#125;&#125;p3.say(); //p2 this指向了p3对象。 12345678910var clear = function()&#123; console.log(this.length);&#125;var tom = &#123; c: clear, length: 20&#125;tom.c(); //20 可以看到c函数还是使用方法调用的方式来调用的，c指向了clear函数，所以函数体中的this指向了tom，所以打印了20. 可以看到，使用方法方法调用的this会指向调用该方法的对象。 构造函数调用方式1234function Person()&#123; this.age = 20;&#125;var p1 = new Person(); //p1 通过new关键字来调用的，那么这种方式就是构造函数的调用方式，这种方式创建的函数内部this将指向该构造函数的实例对象。 12345678910111213141516171819function jQuery()&#123; var _init=jQuery.prototype.init; //如果函数返回了一个复杂数据类型的值，那么本次函数的返回值就是该值。 return new _init(); &#125; jQuery.prototype=&#123; constructor:jQuery, length:100, init:function()&#123; //this指向init构造函数的实例 //--&gt;1、首先查看本身有没有length属性 //--&gt;2、如果本身没有该属性，那么去它的原型对象中查找 //--&gt;3、如果原型对象中没有，那么就去原型对象的原型对象中查找，最终一直找到根对象（Object.prototype） //--&gt;4、最终都没有找到的话，我们认为该对象并没有该属性，如果获取该属性的值：undefined console.log(this.length); &#125; &#125;new jQuery(); //undefined 上述说了this指向该构造函数的实例对象，可以访问自身实例的属性和方法，这里返回了init.prototype的属性，但是这并不是Jquery.prototype的属性，所以打印的是undefined。 12//修改了init函数的默认原型，指向新原型jQuery.prototype.init.prototype = jQuery.prototype; 如果我们修改了init.prototype指向了jQuery.prototype，那么再运行上述代码，this.length打印的值将是100。 上下文调用方式call12345678910111213function fcall()&#123; console.log(this);&#125;fcall.call(this); //Windowfcall.call([1,3,5]); //[1, 3, 5]fcall.call(1); //Numberfcall.call("abc"); //Stringfcall.call(true); //Booleanfcall.call(null); //Windowfcall.call(new fcall()); //fcallfcall.call(&#123;age:20,height:1000&#125;); //&#123;age: 20, height: 1000&#125;fcall.call(undefined); //Window call方法的第一个参数就决定了函数内部this的指向。如果第一个参数的类型是： 对象类型：那么this将指向该对象 如果是undefined,null，那么this将指向Window 如果是普通的数据类型比如&quot;abc&quot;,1,true则会转换成对应构造函数的实例（装箱），例如String,Number,Boolean。 applyapply和call方法调用方式可以完全相同，只是后面传参数时有异同。 12345function toString(a,b,c)&#123; console.log(a+" "+b+" "+c);&#125;toString.call(null,1,3,5) //"1 3 5"toString.apply(null,[1,3,5])//"1 3 5" bindbind是es5中才有的(IE9+) 123456789var obj = &#123; age: 10, run: function()&#123; setTimeout(function()&#123; console.log(this.age); //undefined &#125;, 50); &#125;&#125;obj.run(); 以前这样书写时，可能会定义一个另外的变量来指向this 12345678910var obj = &#123; age: 10, run: function()&#123; var _that = this; setTimeout(function()&#123; console.log(_that.age); //10 &#125;, 50); &#125;&#125;obj.run(); 但是现在可以使用bind来实现了。 123456789var obj = &#123; age: 10, run: function()&#123; setTimeout((function()&#123; console.log(this.age); //10 &#125;).bind(this), 50); &#125;&#125;obj.run(); 可以发现，使用bind方式后this的指向将改为了obj。 更直观的了解bind方法。 123456function speed()&#123; console.log(this.speed);&#125;var speedOther = speed.bind(&#123; speed: 20 &#125;);speedOther(); // 20 speed.bind方法执行后会产生了一个新的函数，新的函数体内与原来的是一样的，但是唯一的不同就是this的指向改为了{ speed: 20 }。 12345678var obj=&#123; name:"西瓜", drink:(function()&#123; //this指向了：&#123; name:"橙汁" &#125; console.log(this.name); &#125;).bind(&#123; name:"橙汁" &#125;)&#125;obj.drink(); //"橙汁" 三者的区别call\apply是立刻执行了这个函数，并且在执行过程中绑定了this的值，而bind并没有立刻执行这个函数，而是产生了一个新的函数，新的函数绑定了this的值。 ES6中的箭头函数12345678//匿名函数div.onclick = function () &#123; console.log("你好")&#125;//箭头函数div.onclick = () =&gt; &#123; console.log("你好")&#125; 有一个参数的箭头函数 1234567var fn = (a) =&gt; &#123; console.log("abc");&#125;//等价于：var fn = a =&gt; &#123; console.log("abc");&#125; 有2个及更多参数的箭头函数 123var f=(a,b,c)=&gt;&#123; console.log("abc")&#125; 箭头函数和普通匿名函数有哪些不同？ 函数体内的this对象，就是定义时所在的对象，而不是使用时所在的对象。 不可以当作构造函数，也就是说，不可以使用new命令，否则会抛出一个错误。 不可以使用arguments对象，该对象在函数体内不存在。如果要用，可以用 rest 参数代替。 （不常用）不可以使用yield命令，因此箭头函数不能用作 Generator 函数。 generator函数现在经常用async替代 数据类型判断 typeof typeof只能判断：数字、字符串、布尔值、undefined、函数 Object.prototype.toString.call() 5 [object Number] “abc”[object String] true [object Boolean] null [object Null] undefined [object Undefined] [1,3,5] [object Array] function(){} [object Function] new Date() [object Date] /abc/ [object RegExp] Array.isArray() es5中提出来的检测数组 isNaN() isInfinity()]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTML5移动端自适应方案——手淘flexible方案]]></title>
    <url>%2F2019%2F05%2F28%2FHTML5%E7%A7%BB%E5%8A%A8%E7%AB%AF%E8%87%AA%E9%80%82%E5%BA%94%E6%96%B9%E6%A1%88%E2%80%94%E2%80%94%E6%89%8B%E6%B7%98flexible%E6%96%B9%E6%A1%88%2F</url>
    <content type="text"><![CDATA[前文讲过了[HTML5移动端自适应方案——媒体查询-rem方案]，基于媒体查询方式的响应式有优点也有缺点： 优点：兼容性好，@media在ie9以上是支持的，PC和MOBILE是同一套代码的，不用分开。 缺点：要写得css相对另外两个多很多，而且各个断点都要做好。css样式会稍微大点，更麻烦。 本文中不涉及一些viewport、dpr、em、rem等的概念介绍，详细了解可以再查看本博客中另一篇文章有具体讲解这些概念。 所以这里介绍另一种使用Flexible实现手淘H5页面的终端适配。 lib-flexible使用GitHub:https://github.com/amfe/lib-flexible lib-flexible是一个制作H5适配的开源库，可以点击这里下载相关文件，获取需要的JavaScript和CSS文件。 或者阿里CDN 建议使用经典版本0.3.2 github 1&lt;script src="http://g.tbcdn.cn/mtb/lib-flexible/&#123;&#123;version&#125;&#125;/??flexible_css.js,flexible.js"&gt;&lt;/script&gt; 将代码中的换成对应的版本号0.3.4。 在Web页面的&lt;head&gt;&lt;/head&gt;中添加对应的flexible_css.js,flexible.js文件： 1234&lt;script src="build/flexible.js"&gt;&lt;/script&gt;//cdn&lt;script src="http://g.tbcdn.cn/mtb/lib-flexible/0.3.4/??flexible_css.js,flexible.js"&gt;&lt;/script&gt; 另外强烈建议对JS做内联处理，在所有资源加载之前执行这个JS。执行这个JS后，会在&lt;html&gt;元素上增加一个data-dpr属性，以及一个font-size样式。JS会根据不同的设备添加不同的data-dpr值，比如说2或者3，同时会给html加上对应的font-size的值，比如说75px。 如此一来，页面中的元素，都可以通过rem单位来设置。他们会根据html元素的font-size值做相应的计算，从而实现屏幕的适配效果。 除此之外，在引入lib-flexible需要执行的JS之前，可以手动设置meta来控制dpr值，如： 1&lt;meta name="flexible" content="initial-dpr=2" /&gt; 其中initial-dpr会把dpr强制设置为给定的值。如果手动设置了dpr之后，不管设备是多少的dpr，都会强制认为其dpr是你设置的值。在此不建议手动强制设置dpr，因为在Flexible中，只对iOS设备进行dpr的判断，对于Android系列，始终认为其dpr为1。 12345678910111213141516171819if (!dpr &amp;&amp; !scale) &#123; var isAndroid = win.navigator.appVersion.match(/android/gi); var isIPhone = win.navigator.appVersion.match(/iphone/gi); var devicePixelRatio = win.devicePixelRatio; if (isIPhone) &#123; // iOS下，对于2和3的屏，用2倍的方案，其余的用1倍方案 if (devicePixelRatio &gt;= 3 &amp;&amp; (!dpr || dpr &gt;= 3)) &#123; dpr = 3; &#125; else if (devicePixelRatio &gt;= 2 &amp;&amp; (!dpr || dpr &gt;= 2))&#123; dpr = 2; &#125; else &#123; dpr = 1; &#125; &#125; else &#123; // 其他设备下，仍旧使用1倍的方案 dpr = 1; &#125; scale = 1 / dpr;&#125; Flexible实现自适应图片素材： 该设计图是按照iPhone6作为基准设计尺寸，iPhone6的分辨率为750px * 1334px，iPhone6的DPR为2，则CSS像素则缩小为设计稿尺寸的1/2。既设计稿量出某宽为20px，则css像素则转为为10px。 理想适口的缩放比为1的情况下 首先按照设计稿尺寸还原页面，为了方便理解，首先使用px还原页面，在iPhone6下显示设计。 实现代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; * &#123; padding: 0; margin: 0; box-sizing: border-box; -webkit-tap-highlight-color: transparent; &#125; html,body &#123; height: 100%; &#125; html,body &#123; height: 100%; background-color: #f5294c; &#125; body &#123; font-size: 14px; &#125; #content &#123; /* background-color: #f5294c; */ min-width: 100%; &#125; #content .header h1 img &#123; width: 100%; &#125; #content .section &#123; padding: 0 5px; &#125; #content .section .item &#123; background-color: #fff; position: relative; &#125; #content .section .item .left &#123; padding: 5px 0; display: table-cell; &#125; #content .section .item .left img&#123; width: 88px; height: 88px; &#125; #content .section .item .right &#123; display: table-cell; padding: 5px 8px 0 8px; vertical-align: top; width: 100%; font-size: 13px; line-height: 1.25; &#125; #content .section .item .right .price &#123; margin: 9px 0; &#125; #content .section .item .right .price &#123; color: #f32a4c; &#125; #content .section .item .right .price span &#123; font-size: 10px; background-color: #f32a4c; color: #fffffd; &#125; #content .section .item .right .intro &#123; color: #ffb09b; &#125; #content .section .item .buy &#123; position: absolute; right: 9px; bottom: 7px; line-height: 1.25; font-size: 13px; padding: 5px 18px; background-color: #f42a4b; color: #fefffc; &#125; #content .section .item .buy a:visited &#123; color: #fefffc; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="content"&gt; &lt;!-- 海报 --&gt; &lt;div class="header"&gt; &lt;h1&gt; &lt;img src="image/haibao.jpg" alt="" srcset=""&gt; &lt;/h1&gt; &lt;/div&gt; &lt;ul class="section"&gt; &lt;li class="item"&gt; &lt;a class="left" href="##"&gt; &lt;img src="image/grayscale.jpeg" alt="" srcset=""&gt; &lt;/a&gt; &lt;div class="right"&gt; &lt;div class="title"&gt; &lt;a href="##"&gt;Carter's1年式灰色长袖连体衣包脚爬服全棉鲸鱼男婴儿童装115G093&lt;/a&gt; &lt;/div&gt; &lt;div class="price"&gt; &lt;span&gt;双11价&lt;/span&gt; &lt;strong&gt;¥ 299&lt;/strong&gt; &lt;small&gt;（满400 减 100）&lt;/small&gt; &lt;/div&gt; &lt;div class="intro"&gt; &lt;small&gt;一小时热卖1769件&lt;/small&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="buy"&gt; &lt;a href="##"&gt;马上抢！&lt;/a&gt; &lt;/div&gt; &lt;/li&gt; &lt;li class="item"&gt; &lt;a class="left" href="##"&gt; &lt;img src="image/grayscale.jpeg" alt="" srcset=""&gt; &lt;/a&gt; &lt;div class="right"&gt; &lt;div class="title"&gt; &lt;a href="##"&gt;Carter's1年式灰色长袖连体衣包脚爬服全棉鲸鱼男婴儿童装115G093&lt;/a&gt; &lt;/div&gt; &lt;div class="price"&gt; &lt;span&gt;双11价&lt;/span&gt; &lt;strong&gt;¥ 299&lt;/strong&gt; &lt;small&gt;（满400 减 100）&lt;/small&gt; &lt;/div&gt; &lt;div class="intro"&gt; &lt;small&gt;一小时热卖1769件&lt;/small&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="buy"&gt; &lt;a href="##"&gt;马上抢！&lt;/a&gt; &lt;/div&gt; &lt;/li&gt; &lt;li class="item"&gt; &lt;a class="left" href="##"&gt; &lt;img src="image/grayscale.jpeg" alt="" srcset=""&gt; &lt;/a&gt; &lt;div class="right"&gt; &lt;div class="title"&gt; &lt;a href="##"&gt;Carter's1年式灰色长袖连体衣包脚爬服全棉鲸鱼男婴儿童装115G093&lt;/a&gt; &lt;/div&gt; &lt;div class="price"&gt; &lt;span&gt;双11价&lt;/span&gt; &lt;strong&gt;¥ 299&lt;/strong&gt; &lt;small&gt;（满400 减 100）&lt;/small&gt; &lt;/div&gt; &lt;div class="intro"&gt; &lt;small&gt;一小时热卖1769件&lt;/small&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="buy"&gt; &lt;a href="##"&gt;马上抢！&lt;/a&gt; &lt;/div&gt; &lt;/li&gt; &lt;li class="item"&gt; &lt;a class="left" href="##"&gt; &lt;img src="image/grayscale.jpeg" alt="" srcset=""&gt; &lt;/a&gt; &lt;div class="right"&gt; &lt;div class="title"&gt; &lt;a href="##"&gt;Carter's1年式灰色长袖连体衣包脚爬服全棉鲸鱼男婴儿童装115G093&lt;/a&gt; &lt;/div&gt; &lt;div class="price"&gt; &lt;span&gt;双11价&lt;/span&gt; &lt;strong&gt;¥ 299&lt;/strong&gt; &lt;small&gt;（满400 减 100）&lt;/small&gt; &lt;/div&gt; &lt;div class="intro"&gt; &lt;small&gt;一小时热卖1769件&lt;/small&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="buy"&gt; &lt;a href="##"&gt;马上抢！&lt;/a&gt; &lt;/div&gt; &lt;/li&gt; &lt;li class="item"&gt; &lt;a class="left" href="##"&gt; &lt;img src="image/grayscale.jpeg" alt="" srcset=""&gt; &lt;/a&gt; &lt;div class="right"&gt; &lt;div class="title"&gt; &lt;a href="##"&gt;Carter's1年式灰色长袖连体衣包脚爬服全棉鲸鱼男婴儿童装115G093&lt;/a&gt; &lt;/div&gt; &lt;div class="price"&gt; &lt;span&gt;双11价&lt;/span&gt; &lt;strong&gt;¥ 299&lt;/strong&gt; &lt;small&gt;（满400 减 100）&lt;/small&gt; &lt;/div&gt; &lt;div class="intro"&gt; &lt;small&gt;一小时热卖1769件&lt;/small&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="buy"&gt; &lt;a href="##"&gt;马上抢！&lt;/a&gt; &lt;/div&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 这里不做过多的页面美化。预览一下 在head中配置flexible 1&lt;script src="./node_modules/amfe-flexible/index.js"&gt;&lt;/script&gt; 把视觉稿中的px换算成rem 之前提到设计稿是以iPhone6为基准的，即750px * 1334px的设计稿。而iPhone6中DPR为2，所以iPhone6下的布局视口宽度为375。 理想适口的缩放比为1的情况下 而Flexible的方案就是将视觉稿分成100份，每一份成为a，同时1rem单位被认定为10a，针对该设计稿可以算出 121a = 3.75px1rem = 37.5px 则我们将设计稿分成10a，则整个宽度为10rem，所以对应的&lt;html&gt;的font-size则为37.5px。 得到了基准值后，只需要原始的px值（CSS像素）除以rem基准值即可。例如一个75px * 75px即转换成2rem * 2rem。 我们统一将页面内的px值统一换算成rem，来浏览一下适配效果： 如何快速换算 编辑器 在开发中总不能让自己一个一个的去计算，编辑器可以有一键转换px2rem的插件，sb3有cssrem，vscode有px to rem。 CSS处理器，可以使用Less或者Sass实现快速转换 PostCSS(px2rem) 除了Sass这样的CSS处理器这外，手淘团队的大神还开发了一款npm的工具px2rem。安装好px2rem之后，可以在项目中直接使用。也可以使用PostCSS。使用PostCSS插件postcss-px2rem： 12345678910var gulp = require(&apos;gulp&apos;);var postcss = require(&apos;gulp-postcss&apos;);var px2rem = require(&apos;postcss-px2rem&apos;);gulp.task(&apos;default&apos;, function() &#123; var processors = [px2rem(&#123;remUnit: 75&#125;)]; return gulp.src(&apos;./src/*.css&apos;) .pipe(postcss(processors)) .pipe(gulp.dest(&apos;./dest&apos;));&#125;); 除了在Gulp中配置外，还可以使用其他的配置方式，详细的介绍可以点击这里进行了解。 配置完成之后，在实际使用时，你只要像下面这样使用： 123456.selector &#123; width: 150px; height: 64px; /*px*/ font-size: 28px; /*px*/ border: 1px solid #ddd; /*no*/&#125; px2rem处理之后将会变成： 12345678910111213141516.selector &#123; width: 2rem; border: 1px solid #ddd;&#125;[data-dpr=&quot;1&quot;] .selector &#123; height: 32px; font-size: 14px;&#125;[data-dpr=&quot;2&quot;] .selector &#123; height: 64px; font-size: 28px;&#125;[data-dpr=&quot;3&quot;] .selector &#123; height: 96px; font-size: 42px;&#125; 在整个开发中有了这些工具之后，完全不用担心px值转rem值影响开发效率。 文本字号不建议使用rem前面大家都见证了如何使用rem来完成H5适配。那么文本又将如何处理适配。是不是也通过rem来做自动适配。 显然，我们在iPhone3G和iPhone4的Retina屏下面，希望看到的文本字号是相同的。也就是说，我们不希望文本在Retina屏幕下变小，另外，我们希望在大屏手机上看到更多文本，以及，现在绝大多数的字体文件都自带一些点阵尺寸，通常是16px和24px，所以我们不希望出现13px和15px这样的奇葩尺寸。 如此一来，就决定了在制作H5的页面中，rem并不适合用到段落文本上。所以在Flexible整个适配方案中，考虑文本还是使用px作为单位。只不过使用[data-dpr]属性来区分不同dpr下的文本字号大小。 1234567891011div &#123; width: 1rem; height: 0.4rem; font-size: 12px; // 默认写上dpr为1的fontSize&#125;[data-dpr="2"] div &#123; font-size: 24px;&#125;[data-dpr="3"] div &#123; font-size: 36px;&#125; 为了能更好的利于开发，在实际开发中，我们可以定制一个font-dpr()这样的Sass混合宏： 1234567891011@mixin font-dpr($font-size)&#123; font-size: $font-size; [data-dpr="2"] &amp; &#123; font-size: $font-size * 2; &#125; [data-dpr="3"] &amp; &#123; font-size: $font-size * 3; &#125;&#125; 有了这样的混合宏之后，在开发中可以直接这样使用： 1@include font-dpr(16px); 当然这只是针对于描述性的文本，比如说段落文本。但有的时候文本的字号也需要分场景的，比如在项目中有一个slogan,业务方希望这个slogan能根据不同的终端适配。针对这样的场景，完全可以使用rem给slogan做计量单位。 注意，如果需要该功能版本的请使用0.3.2版本，既主分支版本或者使用cdn版本 Flexible原理flexible的核心代码很简单： 12345678var docEl = document.documentElement // set 1rem = viewWidth / 10function setRemUnit () &#123; var rem = docEl.clientWidth / 10 docEl.style.fontSize = rem + 'px'&#125;setRemUnit() 上面的代码中，将html节点的font-size设置为页面clientWidth(布局视口)的1/10，即1rem就等于页面布局视口的1/10，所以这就是为什么上面所说的px换算rem的代码实现。 里面还有一些监听页面大小变化，布局可以自适应: 1234567// reset rem unit on page resize window.addEventListener('resize', setRemUnit) window.addEventListener('pageshow', function (e) &#123; if (e.persisted) &#123; setRemUnit() &#125; &#125;) 以及设置data-dpr 1docEl.setAttribute('data-dpr', dpr); 完整源码请查看主分支版本中的js 由于viewport单位得到众多浏览器的兼容，lib-flexible这个过渡方案已经被官方弃用，但是其原理还是需要去理解的。因为vh、vw的方案原理都是大致相同的。]]></content>
      <categories>
        <category>HTML</category>
      </categories>
      <tags>
        <tag>HTML</tag>
        <tag>移动端适配</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android UI适配指南]]></title>
    <url>%2F2019%2F05%2F22%2FAndroid-UI%E9%80%82%E9%85%8D%E6%8C%87%E5%8D%97%2F</url>
    <content type="text"><![CDATA[背景在Android开发中，由于Android碎片化严重，屏幕分辨率千奇百怪，而想要在各种分辨率的设备上显示基本一致的效果，适配成本越来越高。虽然Android官方提供了dp单位来适配，但其在各种奇怪分辨率下表现却不尽如人意。 Android屏幕分辨率分布图 对比IOS屏幕分辨率分布图 所以Android的屏幕适配已经为重中之重的话题。 概念屏幕尺寸、屏幕分辨率、屏幕像素密度 屏幕尺寸：屏幕对角线长度，单位是英寸，我们常说的多少多少寸，比如4.7存手机、5.7存手机，指的就是这个。 屏幕分辨率：如 1920×1080，是指在手机屏幕的像素点的个数，单位是px，1px = 1 像素点，一般是纵向像素 × 横向像素，意味着高有 1920 个像素点，宽有 1080 个像素点。 屏幕像素密度：是指每英寸上的像素点数，单位是 dpi（dotper inch）。像素密度和屏幕尺寸和屏幕分辨率有关，它是由对角线的像素点数除以屏幕的大小得到的，关系如下： 单一变化条件下，屏幕尺寸越小、分辨率越高，像素密度越大，反之越小。 与PPI的概念和计算方式是相同的 dp：是Android 特有的，意为密度无关像素，Google 发布的 BASELINE（基准线）为 160，以此为基准。 dip：Density Independent Pixels，同dp一个意思，目前废弃了，一般都写dp。 dpi：像素密度是屏幕上单位面积内的像素数，称为dpi（每英寸的点数）。 它与分辨率不同，后者是屏幕上像素的总数。 sp：Scale-IndependentPixels的缩写，可以根据文字大小首选项自动进行缩放。Google推荐我们使用12sp以上的大小，通常可以使用12sp，14sp，18sp，22sp，为避免精度损失，建议最好不要使用奇数和小数。 px：就是我们常说的像素 density：就这个单词本身直接翻译的意思而言，其也代表“密度”。但需要注意的是，在Android中，其实并非如此。注意我们这里指的是，通过代码context.getResources().getDisplayMetrics().density获取的“density”值。而通过该方法获取到的该值，实际上是等价于“dpi / 160”的一个结果值。 dp直接适配dp的概念是谷歌官方提出的适配的一种方式。 在android中的dp在渲染前会将dp转为px，计算公式： px = density * dp; density = dpi / 160; px = dp * (dpi / 160); 而dpi是根据屏幕真实的分辨率和尺寸来计算的，每个设备都可能不一样的。 而因为Android碎片化非常严重的原因就导致了dpi的值非常乱，根本没有规律可循，即使dp适配可以做到80%的适配，但是效果还是差强人意。 我们用案例来看一下对比： 这里创建了两个个模拟器，同样的分辨率480 * 800两种类别的设备，同样的放一张图片，布局代码 12345678910111213141516&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;FrameLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:app="http://schemas.android.com/apk/res-auto" xmlns:tools="http://schemas.android.com/tools" android:layout_width="match_parent" android:layout_height="match_parent" tools:context=".MainActivity"&gt; &lt;ImageView android:id="@+id/iv_adapterimg" android:src="@mipmap/img" android:scaleType="fitXY" android:layout_width="300dp" android:layout_height="300dp" /&gt;&lt;/FrameLayout&gt; 同样的代码，设置为300dp，但是两台机型却表现得不尽人意。这里就要涉及到上面一些公式的概念进行换算了，因为最终都会转换成px，我们来换算一下： 480*800 5.1寸机型下 12dpi = √(480^2 * 800^2)/ 5.1 = 182.93px = 300 * (183 / 160) = 342 其余相同计算方式，对照表格： 480*800/5.1 480*800/4 dpi 182.93 233.24 density 1.14 1.46 px 342 438 上述计算结果均为保留小数点后两位 但是计算的结果真的是这样吗，我们使用代码来获取一下控件的高和宽 123456789101112131415161718192021222324252627282930313233343536373839public class MainActivity extends AppCompatActivity &#123; private ImageView iv_adapterimg; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); iv_adapterimg = findViewById(R.id.iv_adapterimg); iv_adapterimg.getViewTreeObserver().addOnPreDrawListener(new ViewTreeObserver.OnPreDrawListener() &#123; @Override public boolean onPreDraw() &#123; Log.e("logImageViewInfo", "Height: " + iv_adapterimg.getHeight() + " / Width: " + iv_adapterimg.getWidth()); return true; &#125; &#125;); logDisplayInfo(); &#125; private void logDisplayInfo()&#123; String TAG = "logDisplayInfo"; //通常我们在使用DisplayMetrics时，都是直接获取内部变量来使用。所以下面直接列出各个内部变量。 DisplayMetrics dm = new DisplayMetrics(); getWindowManager().getDefaultDisplay().getMetrics(dm); Log.e(TAG, "当前设备的系统dpi: " + dm.densityDpi); Log.e(TAG, "当前设备的density: " + dm.density); Log.e(TAG, "物理屏幕上 Y 轴方向每英寸的像素: " + dm.ydpi); Log.e(TAG, "物理屏幕上 X 轴方向每英寸的像素: " + dm.xdpi); Log.e(TAG, "屏幕高度的像素数量: " + dm.heightPixels); Log.e(TAG, "屏幕宽度的像素数量: " + dm.widthPixels); &#125;&#125; 我们查看一下Log输出： 480*800/5.1 480*800/4 Imageview height 300 450 imageview width 300 450 density 1.0 1.5 dpi 160 240 ydpi 160.0 240.0 xdpi 160.0 240.0 heightPixels 800 800 widthPixels 480 480 那么这为什么和我们计算的不一样呢，这里就要设计到系统dpi和物理dpi了，我们需要深究到其源码。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152//platform_frameworks_base/core/java/android/util/DisplayMetrics.javapackage android.util;import android.annotation.UnsupportedAppUsage;import android.os.SystemProperties;/** * A structure describing general information about a display, such as its * size, density, and font scaling. * &lt;p&gt;To access the DisplayMetrics members, initialize an object like this:&lt;/p&gt; * &lt;pre&gt; DisplayMetrics metrics = new DisplayMetrics(); * getWindowManager().getDefaultDisplay().getMetrics(metrics);&lt;/pre&gt; */public class DisplayMetrics &#123; //... /** * The device's current density. * &lt;p&gt; * This value reflects any changes made to the device density. To obtain * the device's stable density, use &#123;@link #DENSITY_DEVICE_STABLE&#125;. * * @hide This value should not be used. * @deprecated Use &#123;@link #DENSITY_DEVICE_STABLE&#125; to obtain the stable * device density or &#123;@link #densityDpi&#125; to obtain the current * density for a specific display. */ @Deprecated public static int DENSITY_DEVICE = getDeviceDensity(); /** * The device's stable density. * &lt;p&gt; * This value is constant at run time and may not reflect the current * display density. To obtain the current density for a specific display, * use &#123;@link #densityDpi&#125;. */ public static final int DENSITY_DEVICE_STABLE = getDeviceDensity(); private static int getDeviceDensity() &#123; // qemu.sf.lcd_density can be used to override ro.sf.lcd_density // when running in the emulator, allowing for dynamic configurations. // The reason for this is that ro.sf.lcd_density is write-once and is // set by the init process when it parses build.prop before anything else. return SystemProperties.getInt("qemu.sf.lcd_density", SystemProperties.getInt("ro.sf.lcd_density", DENSITY_DEFAULT)); &#125; //... &#125; 深究其方法是一个native方法，在代码注释中提到的init的方法，深究源头 1234567891011121314151617181920void DisplayHardware::init(uint32_t dpy)&#123; ///....省略 /* Read density from build-specific ro.sf.lcd_density property * except if it is overridden by qemu.sf.lcd_density. */ if (property_get("qemu.sf.lcd_density", property, NULL) &lt;= 0) &#123; if (property_get("ro.sf.lcd_density", property, NULL) &lt;= 0) &#123; LOGW("ro.sf.lcd_density not defined, using 160 dpi by default."); strcpy(property, "160"); &#125; &#125; else &#123; /* for the emulator case, reset the dpi values too */ mDpiX = mDpiY = atoi(property); &#125; mDensity = atoi(property) * (1.0f/160.0f); //....省略&#125; 看其源码可以看出density的值是通过获取ro.sf.lcd_density配置的值，如果没有默认使用DENSITY_DEFAULT，其默认值有 1234567891011121314151617181920212223242526272829303132333435363738public static final int DENSITY_LOW = 120;public static final int DENSITY_MEDIUM = 160;public static final int DENSITY_TV = 213;public static final int DENSITY_HIGH = 240;public static final int DENSITY_260 = 260;public static final int DENSITY_280 = 280;public static final int DENSITY_300 = 300;public static final int DENSITY_XHIGH = 320;public static final int DENSITY_340 = 340;public static final int DENSITY_360 = 360;public static final int DENSITY_400 = 400;public static final int DENSITY_420 = 420;public static final int DENSITY_440 = 440;public static final int DENSITY_XXHIGH = 480;public static final int DENSITY_560 = 560;public static final int DENSITY_600 = 600;public static final int DENSITY_XXXHIGH = 640;public static final int DENSITY_DEFAULT = DENSITY_MEDIUM;public static final float DENSITY_DEFAULT_SCALE = 1.0f / DENSITY_DEFAULT; 那么问题来了，ro.sf.lcd_density的值在哪里找到，其配置文件路径在手机的/system/build.prop文件中。 可以使用adb命令来将文件进行导出。但是要注意的是，avd模拟器下该文件没有ro.sf.lcd_density该配置项。但是可以在emulator根目录下/config.ini中的hw.lcd.density可以找到配置的值。 4寸模拟器下config.ini的hw.lcd.density值 1hw.lcd.density=240 我们将4寸的模拟器的配置文件修改成160后查看打印日志: 可以查看到日志的输出和上面原来的输出发生了改变，改成了自己配置的值。但是该选项只是avd模拟器环境下，真机或者一些游戏模拟器环境下都是在/system/build.prop配置文件中ro.sf.lcd_density的值。一般该值都是出厂时就编译好的。 1ro.sf.lcd_density=240 这是MUMU中读取/system/build.prop文件的读取的值，这里没有root的真机，无法演示真机环境，但原理相同。但是可以测试一下真机环境下，DPI是根据配置读取的，而非真实通过物理分辨率求出来的从而验证上述的结论。这里以三星s8手机为例，主屏分辨率2960*1440，尺寸5.8，求出dpi约为3.5，而依靠上述代码输出的值为4.5。 所以dp都是使用系统定义的dpi来进行换算的。而非是说单纯的使用物理分辨率和尺寸来计算的。但依然如此，Android的碎片化还是让dp直接适配还是无法让人满意，尽管dp适配可以解决小部分的适配问题。 宽高限定符适配为了高效的实现UI开发，出现了新的适配方案，我把它称作宽高限定符适配。简单说，就是穷举市面上所有的Android手机的宽高像素值： 然后我们根据一个基准，为基准的意思就是,比如设计图的尺寸为480 * 800的分辨率，有个300*300px的ImageView，则 宽度为480，将任何分辨率的宽度分为480份，每一份1px，取值为x1-x480。 高度为800，将任何分辨率的高度分为800份，每一份1px，取值为y1-y800。 则对于540 * 860的分辨率来说 可以看到x1 = 540 / 基准 = 540 / 480 = 1.12 ;而其他分辨率的计算方式相同。 看一下使用该方式适配的对比结果，同样适用dp适配所使用的布局 123456789101112131415&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;FrameLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:app="http://schemas.android.com/apk/res-auto" xmlns:tools="http://schemas.android.com/tools" android:layout_width="match_parent" android:layout_height="match_parent" tools:context=".MainActivity"&gt; &lt;ImageView android:src="@mipmap/img" android:scaleType="fitXY" android:layout_width="@dimen/x300" android:layout_height="@dimen/y300" /&gt;&lt;/FrameLayout&gt; 修改了ImageView的宽和高，适配结果为下图 再看看不同机型分辨率下的表现 可以看到对比于使用dp方案来适配的结果要完美上许多。通过dimens引用去寻找该分辨率的文件夹下面对应的值。这样基本可以解决我们的适配问题。 那么重点来了，既然可以适配，但为什么很少人使用该方案呢，这就涉及到该方案的一个致命的缺点：那就是需要精准命中才能适配。如果values限定符下的分辨率没有对应上手机，则就只能用默认的values下的dimens文件了。如果使用默认尺寸，而又不同于设计稿的尺寸，就可以会发生UI变形。简单的说容错率太低了。 生成的values文件夹下以哪个为基准也需要同样的拷贝一份基准值去默认values文件夹下作为默认值。 那么如何生成上述所说的文件夹呢，这里使用鸿洋大神给出的一份自动生成代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167import java.io.File;import java.io.FileNotFoundException;import java.io.FileOutputStream;import java.io.PrintWriter;public class GenerateValueFiles &#123; private int baseW; private int baseH; private String dirStr = "./res"; private final static String WTemplate = "&lt;dimen name=\"x&#123;0&#125;\"&gt;&#123;1&#125;px&lt;/dimen&gt;\n"; private final static String HTemplate = "&lt;dimen name=\"y&#123;0&#125;\"&gt;&#123;1&#125;px&lt;/dimen&gt;\n"; /** * &#123;0&#125;-HEIGHT */ private final static String VALUE_TEMPLATE = "values-&#123;0&#125;x&#123;1&#125;"; /** * 需要适配的分辨率,格式为width,height; */ private static final String SUPPORT_DIMESION = "320,480;480,800;480,854;540,960;600,1024;720,1184;720,1196;720,1280;768,1024;800,1280;1080,1812;1080,1920;1440,2560;"; private String supportStr = SUPPORT_DIMESION; public GenerateValueFiles(int baseX, int baseY, String supportStr) &#123; this.baseW = baseX; this.baseH = baseY; if (!this.supportStr.contains(baseX + "," + baseY)) &#123; this.supportStr += baseX + "," + baseY + ";"; &#125; this.supportStr += validateInput(supportStr); System.out.println(supportStr); File dir = new File(dirStr); if (!dir.exists()) &#123; dir.mkdir(); &#125; System.out.println(dir.getAbsoluteFile()); &#125; /** * @param supportStr * w,h_...w,h; * @return */ private String validateInput(String supportStr) &#123; StringBuffer sb = new StringBuffer(); String[] vals = supportStr.split("_"); int w = -1; int h = -1; String[] wh; for (String val : vals) &#123; try &#123; if (val == null || val.trim().length() == 0) continue; wh = val.split(","); w = Integer.parseInt(wh[0]); h = Integer.parseInt(wh[1]); &#125; catch (Exception e) &#123; System.out.println("skip invalidate params : w,h = " + val); continue; &#125; sb.append(w + "," + h + ";"); &#125; return sb.toString(); &#125; public void generate() &#123; String[] vals = supportStr.split(";"); for (String val : vals) &#123; String[] wh = val.split(","); generateXmlFile(Integer.parseInt(wh[0]), Integer.parseInt(wh[1])); &#125; &#125; private void generateXmlFile(int w, int h) &#123; StringBuffer sbForWidth = new StringBuffer(); sbForWidth.append("&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;\n"); sbForWidth.append("&lt;resources&gt;"); float cellw = w * 1.0f / baseW; System.out.println("width : " + w + "," + baseW + "," + cellw); for (int i = 1; i &lt; baseW; i++) &#123; sbForWidth.append(WTemplate.replace("&#123;0&#125;", i + "").replace("&#123;1&#125;", change(cellw * i) + "")); &#125; sbForWidth.append(WTemplate.replace("&#123;0&#125;", baseW + "").replace("&#123;1&#125;", w + "")); sbForWidth.append("&lt;/resources&gt;"); StringBuffer sbForHeight = new StringBuffer(); sbForHeight.append("&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;\n"); sbForHeight.append("&lt;resources&gt;"); float cellh = h *1.0f/ baseH; System.out.println("height : "+ h + "," + baseH + "," + cellh); for (int i = 1; i &lt; baseH; i++) &#123; sbForHeight.append(HTemplate.replace("&#123;0&#125;", i + "").replace("&#123;1&#125;", change(cellh * i) + "")); &#125; sbForHeight.append(HTemplate.replace("&#123;0&#125;", baseH + "").replace("&#123;1&#125;", h + "")); sbForHeight.append("&lt;/resources&gt;"); File fileDir = new File(dirStr + File.separator + VALUE_TEMPLATE.replace("&#123;0&#125;", h + "")// .replace("&#123;1&#125;", w + "")); fileDir.mkdir(); File layxFile = new File(fileDir.getAbsolutePath(), "lay_x.xml"); File layyFile = new File(fileDir.getAbsolutePath(), "lay_y.xml"); try &#123; PrintWriter pw = new PrintWriter(new FileOutputStream(layxFile)); pw.print(sbForWidth.toString()); pw.close(); pw = new PrintWriter(new FileOutputStream(layyFile)); pw.print(sbForHeight.toString()); pw.close(); &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125; &#125; public static float change(float a) &#123; int temp = (int) (a * 100); return temp / 100f; &#125; public static void main(String[] args) &#123; //基准分辨率 int baseW = 480; int baseH = 800; String addition = ""; try &#123; if (args.length &gt;= 3) &#123; baseW = Integer.parseInt(args[0]); baseH = Integer.parseInt(args[1]); addition = args[2]; &#125; else if (args.length &gt;= 2) &#123; baseW = Integer.parseInt(args[0]); baseH = Integer.parseInt(args[1]); &#125; else if (args.length &gt;= 1) &#123; addition = args[0]; &#125; &#125; catch (NumberFormatException e) &#123; System.err .println("right input params : java -jar xxx.jar width height w,h_w,h_..._w,h;"); e.printStackTrace(); System.exit(-1); &#125; new GenerateValueFiles(baseW, baseH, addition).generate(); &#125;&#125; 对于主流的分辨率我已经集成到了我们的程序中，当然对于特殊的，你可以通过参数指定。关于屏幕分辨率信息，可以通过该网站查询：http://screensiz.es/phone AndroidAutoLayout库适配鸿洋大佬的适配方案的项目也来自于宽高限定符方案的启发。虽然该框架已经停止维护，但是许多老项目也在使用该方案。因为集成简单，并且不需要使用dp单位，而是定义好设计稿的尺寸后使用px单位即可完成适配。 使用方法： Android Studio 123dependencies &#123; compile 'com.zhy:autolayout:1.4.5'&#125; AndroidManifest注册设计稿尺寸 1234&lt;meta-data android:name="design_width" android:value="768"&gt;&lt;/meta-data&gt;&lt;meta-data android:name="design_height" android:value="1280"&gt;&lt;/meta-data&gt; 集成AutoLayoutActivity 然后就可以在布局文件按照设计稿的尺寸来使用具体的像素值了。比如，设计稿上是96*96,那么我们可以直接写96px，APP运行时，框架会帮助我们根据不同手机的具体尺寸按比例伸缩。这是比宽高限定符更好的方案，因为解决了宽高限定符的容错率问题。 但是框架要在运行时会在onMeasure里面做变换，自定义的控件可能会被影响或限制，可能有些特定的控件，需要单独适配，这里面可能存在的暗坑是不可预见的。因为这是由框架来完成，并非系统完成。并且该库作者已经放弃维护了。 smallestWidth适配smallestWidth适配也叫做sw限定符适配。值得是Android会识别屏幕可用宽度和高度的最小尺寸的dp值，然后再根据识别的结果去资源文件中寻找对应的限定符的文件夹下的资源文件。 这种机制上和上文提到的宽高限定符适配原理上是一样的。都是通过系统特定的规则选择对应的文件。 例如，比如一台手机的dpi为480，横向分辨率为1080px，根据公式px = dp(dpi/160)，横向的dp值是360dp。则系统就会自动去寻找value-sw360dp的文件夹以及对应的资源文件。 理论条件下物理dp等于系统dp 而该方案对比与宽高限定符适配方案最大的区别也是优点就是，该方案有更好的容错率。比如上述例子中，如果系统找不到value-sw350dp文件夹，则系统会向下寻找，比如找到离一个360最近的value-sw320dp文件夹。那么系统就会选择该文件下的资源文件。 例如设计稿同样为480 * 800,同样有一个300 * 300px的ImageView，例如在values-sw360dp文件夹下的dimen应该如何编写呢？360dp则意味着手机最小宽度为360dp，我们将360dp分成480份，每一个设计稿中的像素大概代表着手机的0.75dp。那么一个300 * 300px对应的dimen引用则为 123456789&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;resources&gt; &lt;dimen name="base_dpi"&gt;360dp&lt;/dimen&gt; //.... &lt;dimen name="qb_px_0"&gt;0.00dp&lt;/dimen&gt; &lt;dimen name="qb_px_1"&gt;0.75dp&lt;/dimen&gt; &lt;dimen name="qb_px_300"&gt;225.00dp&lt;/dimen&gt; //...&lt;/resources&gt; 而这种dimens引用，在不同的values-sw&lt;N&gt;dp文件夹下的数值是不同的，比如values-sw400dp和values-sw420dp 123456789101112131415161718192021//400dp&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;resources&gt; &lt;dimen name="base_dpi"&gt;400dp&lt;/dimen&gt; &lt;dimen name="qb_px_0"&gt;0.00dp&lt;/dimen&gt; &lt;dimen name="qb_px_1"&gt;0.83dp&lt;/dimen&gt; &lt;dimen name="qb_px_2"&gt;1.67dp&lt;/dimen&gt; &lt;dimen name="qb_px_3"&gt;2.50dp&lt;/dimen&gt; &lt;dimen name="qb_px_4"&gt;3.33dp&lt;/dimen&gt;&lt;resources&gt; //420dp&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;resources&gt; &lt;dimen name="base_dpi"&gt;420dp&lt;/dimen&gt; &lt;dimen name="qb_px_0"&gt;0.00dp&lt;/dimen&gt; &lt;dimen name="qb_px_1"&gt;0.88dp&lt;/dimen&gt; &lt;dimen name="qb_px_2"&gt;1.75dp&lt;/dimen&gt; &lt;dimen name="qb_px_3"&gt;2.63dp&lt;/dimen&gt; &lt;dimen name="qb_px_4"&gt;3.50dp&lt;/dimen&gt;&lt;resources&gt; 计算完后，那么对应的布局文件编写代码： 12345678910111213141516&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;FrameLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:app="http://schemas.android.com/apk/res-auto" xmlns:tools="http://schemas.android.com/tools" android:layout_width="match_parent" android:layout_height="match_parent" tools:context=".MainActivity"&gt; &lt;ImageView android:id="@+id/iv_adapterimg" android:src="@mipmap/img" android:scaleType="fitXY" android:layout_width="@dimen/qb_px_300" android:layout_height="@dimen/qb_px_300" /&gt;&lt;/FrameLayout&gt; 运行一下来看看适配的效果： smallestWidth的适配机制由系统保证，我们只需要针对这套规则生成对应的资源文件即可，不会出现什么难以解决的问题，也根本不会影响我们的业务逻辑代码，而且只要我们生成的资源文件分布合理，，即使对应的smallestWidth值没有找到完全对应的资源文件，它也能向下兼容，寻找最接近的资源文件。 当然该方案也有他的缺点，生成的文件夹越多，也就意味着生成的dimens文件的覆盖范围和尺寸范围越大，apk的安装包也会增加，宽高限定符适配方案也同样有着该缺点。 smallestWidth适配方案有一个小问题，那就是它是在Android 3.2 以后引入的，Google的本意是用它来适配平板的布局文件（但是实际上显然用于diemns适配的效果更好），不过目前所有的项目应该最低支持版本应该都是4.0了（糗事百科这么老的项目最低都是4.0哦），所以，这问题其实也不重要了。 当然，计算的方式肯定也不会是自己一点计算再编写， 附上生成的代码文件。代码链接 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183import java.io.File;import java.io.FileNotFoundException;import java.io.FileOutputStream;import java.io.IOException;import java.math.BigDecimal;public class GenerateSWValueFiles &#123; /** * 适配手机dp列表 */ public enum DimenTypes &#123; //适配Android 3.2以上 大部分手机的sw值集中在 300-460之间 DP_sw__300(300), // values-sw300 DP_sw__310(310), DP_sw__320(320), DP_sw__330(330), DP_sw__340(340), DP_sw__350(350), DP_sw__360(360), DP_sw__370(370), DP_sw__380(380), DP_sw__390(390), DP_sw__410(410), DP_sw__420(420), DP_sw__430(430), DP_sw__440(440), DP_sw__450(450), DP_sw__460(460), DP_sw__470(470), DP_sw__480(480), DP_sw__490(490), DP_sw__400(400); // 想生成多少自己以此类推 /** * 屏幕最小宽度 */ private int swWidthDp; DimenTypes(int swWidthDp) &#123; this.swWidthDp = swWidthDp; &#125; public int getSwWidthDp() &#123; return swWidthDp; &#125; public void setSwWidthDp(int swWidthDp) &#123; this.swWidthDp = swWidthDp; &#125; &#125; /** * 生成SW工具类 */ public static class MakeUtils &#123; private static final String XML_HEADER = "&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;\r\n"; private static final String XML_RESOURCE_START = "&lt;resources&gt;\r\n"; private static final String XML_RESOURCE_END = "&lt;/resources&gt;\r\n"; private static final String XML_DIMEN_TEMPLETE = "&lt;dimen name=\"qb_%1$spx_%2$d\"&gt;%3$.2fdp&lt;/dimen&gt;\r\n"; private static final String XML_BASE_DPI = "&lt;dimen name=\"base_dpi\"&gt;%ddp&lt;/dimen&gt;\r\n"; private static final int MAX_SIZE = 720; /** * 生成的文件名 */ private static final String XML_NAME = "lay_sw.xml"; public static float px2dip(float pxValue, int sw,int designWidth) &#123; float dpValue = (pxValue/(float)designWidth) * sw; BigDecimal bigDecimal = new BigDecimal(dpValue); float finDp = bigDecimal.setScale(2, BigDecimal.ROUND_HALF_UP).floatValue(); return finDp; &#125; /** * 生成所有的尺寸数据 * * @param type * @return */ private static String makeAllDimens(DimenTypes type, int designWidth) &#123; float dpValue; String temp; StringBuilder sb = new StringBuilder(); try &#123; sb.append(XML_HEADER); sb.append(XML_RESOURCE_START); //备份生成的相关信息 temp = String.format(XML_BASE_DPI, type.getSwWidthDp()); sb.append(temp); for (int i = 0; i &lt;= MAX_SIZE; i++) &#123; dpValue = px2dip((float) i,type.getSwWidthDp(),designWidth); temp = String.format(XML_DIMEN_TEMPLETE,"", i, dpValue); sb.append(temp); &#125; sb.append(XML_RESOURCE_END); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return sb.toString(); &#125; /** * 生成的目标文件夹 * 只需传宽进来就行 * * @param type 枚举类型 * @param buildDir 生成的目标文件夹 */ public static void makeAll(int designWidth, DimenTypes type, String buildDir) &#123; try &#123; //生成规则 final String folderName; if (type.getSwWidthDp() &gt; 0) &#123; //适配Android 3.2+ folderName = "values-sw" + type.getSwWidthDp() + "dp"; &#125;else &#123; return; &#125; //生成目标目录 File file = new File(buildDir + File.separator + folderName); if (!file.exists()) &#123; file.mkdirs(); &#125; //生成values文件 FileOutputStream fos = new FileOutputStream(file.getAbsolutePath() + File.separator + XML_NAME); fos.write(makeAllDimens(type,designWidth).getBytes()); fos.flush(); fos.close(); &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; /** * 设计稿尺寸(将自己设计师的设计稿的宽度填入) */ private static final int DESIGN_WIDTH = 480; /** * 设计稿的高度 （将自己设计师的设计稿的高度填入） */ private static final int DESIGN_HEIGHT = 800; //generater public static void main(String[] args) &#123; int smallest = DESIGN_WIDTH &gt; DESIGN_HEIGHT ? DESIGN_HEIGHT : DESIGN_WIDTH; // 求得最小宽度 DimenTypes[] values = DimenTypes.values(); for (DimenTypes value : values) &#123; File file = new File("dimens"); //当前项目路径 MakeUtils.makeAll(smallest, value, file.getAbsolutePath()); &#125; &#125;&#125; 主流dp也可以查询相关网站 今日头条适配方案文章链接 该方案的思想来源就是修改density的值，强行把所有不同分辨率的手机的宽度改成一个统一的值。 上文提到dp适配的DisplayMetrics中的相关变量： DisplayMetrics#density 就是上述的density DisplayMetrics#densityDpi 就是上述的dpi DisplayMetrics#scaledDensity 字体的缩放因子，正常情况下和density相等，但是调节系统字体大小后会改变这个值 那么是不是所有的dp和px的转换都是通过 DisplayMetrics 中相关的值来计算的呢？ 首先来看看布局文件中dp的转换，最终都是调用 TypedValue#applyDimension(int unit, float value, DisplayMetrics metrics)来进行转换: 12345678910111213141516171819public static float applyDimension(int unit, float value, DisplayMetrics metrics) &#123; switch (unit) &#123; case COMPLEX_UNIT_PX: return value; case COMPLEX_UNIT_DIP: return value * metrics.density; case COMPLEX_UNIT_SP: return value * metrics.scaledDensity; case COMPLEX_UNIT_PT: return value * metrics.xdpi * (1.0f/72); case COMPLEX_UNIT_IN: return value * metrics.xdpi; case COMPLEX_UNIT_MM: return value * metrics.xdpi * (1.0f/25.4f); &#125; return 0; &#125; 这里用到的DisplayMetrics正是从Resources中获得的。 再看看图片的decode，BitmapFactory#decodeResourceStream方法: 12345678910111213141516171819202122public static Bitmap decodeResourceStream(@Nullable Resources res, @Nullable TypedValue value, @Nullable InputStream is, @Nullable Rect pad, @Nullable Options opts) &#123; validate(opts); if (opts == null) &#123; opts = new Options(); &#125; if (opts.inDensity == 0 &amp;&amp; value != null) &#123; final int density = value.density; if (density == TypedValue.DENSITY_DEFAULT) &#123; opts.inDensity = DisplayMetrics.DENSITY_DEFAULT; &#125; else if (density != TypedValue.DENSITY_NONE) &#123; opts.inDensity = density; &#125; &#125; if (opts.inTargetDensity == 0 &amp;&amp; res != null) &#123; opts.inTargetDensity = res.getDisplayMetrics().densityDpi; &#125; return decodeStream(is, pad, opts); &#125; 当然还有些其他dp转换的场景，基本都是通过 DisplayMetrics 来计算的，这里不再详述。因此，想要满足上述需求，我们只需要修改 DisplayMetrics 中和 dp 转换相关的变量即可。 通过该原理得到的适配方案： 比如，设计稿的宽度是480px，那么开发代码时会把目标dp值设置为480dp，在不同设备中，动态修改density的值，从而保证手机像素宽度/density这个值始终是360dp。这样来保证UI在不同设备上表现一致。 今日头条屏幕适配方案的核心原理在于，根据以下公式算出 density 当前设备屏幕总宽度（单位为像素）/ 设计图总宽度（单位为 dp) = density 今日头条方案代码实现： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950import android.app.Activity;import android.app.Application;import android.content.ComponentCallbacks;import android.content.res.Configuration;import android.support.annotation.NonNull;import android.util.DisplayMetrics;public class App extends Application &#123; private static float sNoncompatDensity; private static float sNoncompatScaledDensity; public static void setCustomDensity(@NonNull Activity activity, @NonNull final Application application)&#123; final DisplayMetrics appDisplayMetrics = application.getResources().getDisplayMetrics(); if( sNoncompatDensity == 0) &#123; sNoncompatDensity = appDisplayMetrics.density; sNoncompatScaledDensity = appDisplayMetrics.scaledDensity; application.registerComponentCallbacks(new ComponentCallbacks() &#123; @Override public void onConfigurationChanged(Configuration newConfig) &#123; if(newConfig != null &amp;&amp; newConfig.fontScale &gt; 0) &#123; sNoncompatScaledDensity = application.getResources().getDisplayMetrics().scaledDensity; &#125; &#125; @Override public void onLowMemory() &#123; &#125; &#125;); &#125; final float targetDensity = (float) (appDisplayMetrics.widthPixels / 480.0); final int targetDensityDPI = (int) (targetDensity * 160); final float targetScaledDensity = targetDensity * (sNoncompatScaledDensity / sNoncompatDensity); appDisplayMetrics.density = targetDensity; appDisplayMetrics.densityDpi = targetDensityDPI; appDisplayMetrics.scaledDensity = targetScaledDensity; final DisplayMetrics activityDisplayMetrics = activity.getResources().getDisplayMetrics(); activityDisplayMetrics.density = targetDensity; activityDisplayMetrics.densityDpi = targetDensityDPI; activityDisplayMetrics.scaledDensity = targetScaledDensity; &#125;&#125; 然后在activity#onCreate方法中调用即可，在setContentView之前。运行看看适配的效果： 以设计图宽480dp去适配的，如果要以高维度适配，可以再扩展下代码即可 优点 使用成本非常低，操作非常简单，使用该方案后在页面布局时不需要额外的代码和操作，这点可以说完虐其他屏幕适配方案 侵入性非常低，该方案和项目完全解耦，在项目布局时不会依赖哪怕一行该方案的代码，而且使用的还是 Android 官方的 API，意味着当你遇到什么问题无法解决，想切换为其他屏幕适配方案时，基本不需要更改之前的代码，整个切换过程几乎在瞬间完成，会少很多麻烦，节约很多时间，试错成本接近于 0 可适配三方库的控件和系统的控件(不止是是 Activity 和 Fragment，Dialog、Toast 等所有系统控件都可以适配)，由于修改的 density 在整个项目中是全局的，所以只要一次修改，项目中的所有地方都会受益 不会有任何性能的损耗 缺点暂时没发现其他什么很明显的缺点，已知的缺点有一个，那就是第三个优点，它既是这个方案的优点也同样是缺点，但是就这一个缺点也是非常致命的 只需要修改一次 density，项目中的所有地方都会自动适配，这个看似解放了双手，减少了很多操作，但是实际上反应了一个缺点，那就是只能一刀切的将整个项目进行适配，但适配范围是不可控的 这样不是很好吗？这样本来是很好的，但是应用到这个方案是就不好了，因为我上面的原理也分析了，这个方案依赖于设计图尺寸，但是项目中的系统控件、三方库控件、等非我们项目自身设计的控件，它们的设计图尺寸并不会和我们项目自身的设计图尺寸一样 当这个适配方案不分类型，将所有控件都强行使用我们项目自身的设计图尺寸进行适配时，这时就会出现问题，当某个系统控件或三方库控件的设计图尺寸和和我们项目自身的设计图尺寸差距非常大时，这个问题就越严重 这里是JessYan总结的优缺点，个人很赞同。 AndroidAutoSIze一个基于今日头条方案的开源库，一个极低成本的 Android 屏幕适配方案. 如果项目没有什么特殊要求，两个步骤即可完成适配： 添加依赖 1implementation 'me.jessyan:autosize:1.1.2' 请在 AndroidManifest 中填写全局设计图尺寸 (单位 dp) 12345678910&lt;manifest&gt; &lt;application&gt; &lt;meta-data android:name="design_width_in_dp" android:value="360"/&gt; &lt;meta-data android:name="design_height_in_dp" android:value="640"/&gt; &lt;/application&gt; &lt;/manifest&gt; Github，更多详细集成文档建议查看github链接。github中有很详细的用法以及使用的问题。 总结适配就是根据设计图来达到某一个维度上显示一致，不能够说使用适配就可以不使用wrap_content等，比如一个页面时上下滑动的，我们只需要保持设备在宽的维度上保持显示一致即可。而如果一个不支持上下滑动的页面，只需要保持设备在高的维度上保持显示一致。 如何适配，如何选择适配的方案还是要结合自己业务的需求。因为开发就是要追求高效和稳定。 参考资料https://blog.csdn.net/ghost_Programmer/article/details/50042805 https://juejin.im/post/5ae9cc3a5188253dc612842b https://blog.csdn.net/lmj623565791/article/details/45460089 https://juejin.im/post/5b7a29736fb9a019d53e7ee2 https://mp.weixin.qq.com/s/SDHL26XgIjjlK-RLd_SSCw]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android屏幕适配</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MongoDB安装和使用]]></title>
    <url>%2F2019%2F05%2F11%2FMongoDB%E5%AE%89%E8%A3%85%E5%92%8C%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[MongoDB简介MongoDB 是由C++语言编写的，是一个基于分布式文件存储的开源数据库系统。 在高负载的情况下，添加更多的节点，可以保证服务器性能。 MongoDB 旨在为WEB应用提供可扩展的高性能数据存储解决方案。 MongoDB 将数据存储为一个文档，数据结构由键值(key=&gt;value)对组成。MongoDB 文档类似于 JSON 对象。字段值可以包含其他文档，数组及文档数组。 特点 MongoDB的提供了一个面向文档存储，操作起来比较简单和容易。 你可以在MongoDB记录中设置任何属性的索引 (如：FirstName=”Sameer”,Address=”8 Gandhi Road”)来实现更快的排序。 你可以通过本地或者网络创建数据镜像，这使得MongoDB有更强的扩展性。 如果负载的增加（需要更多的存储空间和更强的处理能力） ，它可以分布在计算机网络中的其他节点上这就是所谓的分片。 Mongo支持丰富的查询表达式。查询指令使用JSON形式的标记，可轻易查询文档中内嵌的对象及数组。 MongoDb 使用update()命令可以实现替换完成的文档（数据）或者一些指定的数据字段 。 Mongodb中的Map/reduce主要是用来对数据进行批量处理和聚合操作。 Map和Reduce。Map函数调用emit(key,value)遍历集合中所有的记录，将key与value传给Reduce函数进行处理。 Map函数和Reduce函数是使用Javascript编写的，并可以通过db.runCommand或mapreduce命令来执行MapReduce操作。 GridFS是MongoDB中的一个内置功能，可以用于存放大量小文件。 MongoDB允许在服务端执行脚本，可以用Javascript编写某个函数，直接在服务端执行，也可以把函数的定义存储在服务端，下次直接调用即可。 MongoDB支持各种编程语言:RUBY，PYTHON，JAVA，C++，PHP，C#等多种语言。 MongoDB安装简单。 安装MongoDB Community Edition本文只介绍Mac安装，其余安装方法请查阅：https://docs.mongodb.com/manual/administration/install-community/ 使用Homebrew安装 123456789$ brew tap mongodb/brew$ brew install mongodb-community@4.0==&gt; CaveatsTo have launchd start mongodb/brew/mongodb-community now and restart at login: brew services start mongodb/brew/mongodb-communityOr, if you don't want/need a background service you can just run: mongod --config /usr/local/etc/mongod.conf==&gt; Summary🍺 /usr/local/Cellar/mongodb-community/4.0.9: 20 files, 221.0MB, built in 23 seconds 安装后可查看到后面这段文字，为MongoDB的一些配置文件路径 the configuration file (/usr/local/etc/mongod.conf) the log directory path (/usr/local/var/log/mongodb) the data directory path (/usr/local/var/mongodb) MongoDB 数据类型 数据类型 描述 String 字符串。存储数据常用的数据类型。在 MongoDB 中，UTF-8 编码的字符串才是合法的。 Integer 整型数值。用于存储数值。根据你所采用的服务器，可分为 32 位或 64 位。 Boolean 布尔值。用于存储布尔值（真/假）。 Double 双精度浮点值。用于存储浮点值。 Min/Max keys 将一个值与 BSON（二进制的 JSON）元素的最低值和最高值相对比。 Arrays 用于将数组或列表或多个值存储为一个键。 Timestamp 时间戳。记录文档修改或添加的具体时间。 Object 用于内嵌文档。 Null 用于创建空值。 Symbol 符号。该数据类型基本上等同于字符串类型，但不同的是，它一般用于采用特殊符号类型的语言。 Date 日期时间。用 UNIX 时间格式来存储当前日期或时间。你可以指定自己的日期时间：创建 Date 对象，传入年月日信息。 Object ID 对象 ID。用于创建文档的 ID。 Binary Data 二进制数据。用于存储二进制数据。 Code 代码类型。用于在文档中存储 JavaScript 代码。 Regular expression 正则表达式类型。用于存储正则表达式。 MongoDB概念数据库一个mongodb中可以建立多个数据库。 MongoDB的默认数据库为”db”，该数据库存储在data目录中。 MongoDB的单个实例可以容纳多个独立的数据库，每一个都有自己的集合和权限，不同的数据库也放置在不同的文件中。 “show dbs” 命令可以显示所有数据的列表。 数据库也通过名字来标识。数据库名可以是满足以下条件的任意UTF-8字符串。 不能是空字符串（””)。 不得含有’ ‘（空格)、.、$、/、\和\0 (空宇符)。 应全部小写。 最多64字节。 有一些数据库名是保留的，可以直接访问这些有特殊作用的数据库。 admin： 从权限的角度来看，这是”root”数据库。要是将一个用户添加到这个数据库，这个用户自动继承所有数据库的权限。一些特定的服务器端命令也只能从这个数据库运行，比如列出所有的数据库或者关闭服务器。 local: 这个数据永远不会被复制，可以用来存储限于本地单台服务器的任意集合 config: 当Mongo用于分片设置时，config数据库在内部使用，用于保存分片的相关信息。 文档文档是一个键值(key-value)对(即BSON)。MongoDB 的文档不需要设置相同的字段，并且相同的字段不需要相同的数据类型，这与关系型数据库有很大的区别，也是 MongoDB 非常突出的特点。 一个简单的文档例子如下： 1&#123;"site":"hackycy.github.io", "name":"博客"&#125; 关系型数据库和MongoDB的一些区别 RDBMS MongoDB 数据库 数据库 表格 集合 行 文档 列 字段 表联合 嵌入文档 主键 主键 (MongoDB 提供了 key 为 _id ) 需要注意的是： 文档中的键/值对是有序的。 文档中的值不仅可以是在双引号里面的字符串，还可以是其他几种数据类型（甚至可以是整个嵌入的文档)。 MongoDB区分类型和大小写。 MongoDB的文档不能有重复的键。 文档的键是字符串。除了少数例外情况，键可以使用任意UTF-8字符。 文档键命名规范： 键不能含有\0 (空字符)。这个字符用来表示键的结尾。 .和$有特别的意义，只有在特定环境下才能使用。 以下划线”_”开头的键是保留的(不是严格要求的)。 集合集合就是 MongoDB 文档组，类似于 RDBMS （关系数据库管理系统：Relational Database Management System)中的表格。 集合存在于数据库中，集合没有固定的结构，这意味着你在对集合可以插入不同格式和类型的数据，但通常情况下我们插入集合的数据都会有一定的关联性。 基础命令https://docs.mongodb.com/manual/crud/ http://www.runoob.com/mongodb/mongodb-operators.html 启动服务器1$ mongod --dbpath "/usr/local/var/mongodb" mongodb常用启动参数 参数 描述 –bind_ip 绑定服务IP，若绑定127.0.0.1，则只能本机访问，不指定默认本地所有IP –logpath 定义MongoDB日志文件，注意是指定文件不是目录 –logappend 使用追加的方式写日志 –dbpath 指定数据库路径 –port 指定服务端口号，默认端口27017 –serviceName 指定服务名称 –serviceDisplayName 指定服务名称，有多个mongodb服务时执行。 –install 指定作为一个Windows服务安装。 命令行连接服务器1$ mongo 默认连接的是test数据库 查询数据库1234&gt; show dbs;admin 0.000GBconfig 0.000GBlocal 0.000GB 切换/创建数据库1234&gt; use shop;switched to db shop&gt; dbshop 删除数据库1&gt; db.dropDatabase() 删除当前数据库，默认为 test，你可以使用 db 命令查看当前数据库名。 创建集合语法：db.createCollection(name, options) 1&gt; db.createCollection("users"); 查询集合1&gt; show collections; 查询数据语法：db.集合名.find(条件); 12345&gt; db.users.find();&#123; "_id" : ObjectId("5cd6f9a519ee5a000f483e6f"), "name" : "tom", "age" : 20 &#125;&#123; "_id" : ObjectId("5cd6fe7419ee5a000f483e70"), "name" : "jack", "age" : 25 &#125;&gt; db.users.find(&#123;age:&#123;$gt:21&#125;&#125;);&#123; "_id" : ObjectId("5cd6fe7419ee5a000f483e70"), "name" : "jack", "age" : 25 &#125; (&gt;) 大于 - $gt (&lt;) 小于 - $lt (&gt;=) 大于等于 - $gte (&lt;= ) 小于等于 - $lte 添加数据语法：db.集合名.save(对象)或者db.集合名.insert(对象) 123456&gt; db.users.save(&#123;name:"jack", age:20&#125;)WriteResult(&#123; "nInserted" : 1 &#125;)&gt; show collections;users&gt; db.users.find();&#123; "_id" : ObjectId("5cd6f5e919ee5a000f483e6e"), "name" : "jack", "age" : 20 &#125; mongo默认会给我们加入_id作为该文档对象的唯一标识 删除数据语法：db.集合名.remove(条件对象); 123&gt; &gt; db.users.remove(&#123;name:"jack"&#125;);WriteResult(&#123; "nRemoved" : 1 &#125;)&gt; db.users.find(); 更新数据语法：db.集合名.update({匹配条件对象},{$set:{修改后的对象}}); 123456&gt; db.users.save(&#123;name:"jack", age:20&#125;)WriteResult(&#123; "nInserted" : 1 &#125;)&gt; db.users.update(&#123;name:'jack'&#125;,&#123;$set:&#123;name:'tom'&#125;&#125;);WriteResult(&#123; "nMatched" : 1, "nUpserted" : 0, "nModified" : 1 &#125;)&gt; db.users.find();&#123; "_id" : ObjectId("5cd6f9a519ee5a000f483e6f"), "name" : "tom", "age" : 20 &#125; 分页skip() skip()方法来跳过指定数量的数据，skip方法同样接受一个数字参数作为跳过的记录条数。 语法：db.集合名.find().skip(Number) 12345&gt; db.users.find();&#123; "_id" : ObjectId("5cd6f9a519ee5a000f483e6f"), "name" : "tom", "age" : 20 &#125;&#123; "_id" : ObjectId("5cd6fe7419ee5a000f483e70"), "name" : "jack", "age" : 25 &#125;&gt; db.users.find().skip(1);&#123; "_id" : ObjectId("5cd6fe7419ee5a000f483e70"), "name" : "jack", "age" : 25 &#125; limit() 该方法可以读取指定数量的数据记录。 语法：db.集合名.find().limit(Number) 12345&gt; db.users.find();&#123; "_id" : ObjectId("5cd6f9a519ee5a000f483e6f"), "name" : "tom", "age" : 20 &#125;&#123; "_id" : ObjectId("5cd6fe7419ee5a000f483e70"), "name" : "jack", "age" : 25 &#125;&gt; db.users.find().limit(1);&#123; "_id" : ObjectId("5cd6f9a519ee5a000f483e6f"), "name" : "tom", "age" : 20 &#125; 这两个方法可以连用。 排序使用 sort() 方法对数据进行排序 语法：db.集合名.find().sort({key:排序方式}); 123456&gt; db.users.find()&#123; "_id" : ObjectId("5cd6f9a519ee5a000f483e6f"), "name" : "tom", "age" : 20 &#125;&#123; "_id" : ObjectId("5cd6fe7419ee5a000f483e70"), "name" : "jack", "age" : 25 &#125;&gt; db.users.find().sort(&#123;age:-1&#125;)&#123; "_id" : ObjectId("5cd6fe7419ee5a000f483e70"), "name" : "jack", "age" : 25 &#125;&#123; "_id" : ObjectId("5cd6f9a519ee5a000f483e6f"), "name" : "tom", "age" : 20 &#125; 正数代表升序，负数代表降序 聚合函数聚合(aggregate)主要用于处理数据(诸如统计平均值,求和等)，并返回计算后的数据结果。有点类似sql语句中的 count(*)。 表达式 描述 实例 $sum 计算总和。 db.mycol.aggregate([{$group : {_id : “$by_user”, num_tutorial : {$sum : “$likes”}}}]) $avg 计算平均值 db.mycol.aggregate([{$group : {_id : “$by_user”, num_tutorial : {$avg : “$likes”}}}]) $min 获取集合中所有文档对应值得最小值。 db.mycol.aggregate([{$group : {_id : “$by_user”, num_tutorial : {$min : “$likes”}}}]) $max 获取集合中所有文档对应值得最大值。 db.mycol.aggregate([{$group : {_id : “$by_user”, num_tutorial : {$max : “$likes”}}}]) $push 在结果文档中插入值到一个数组中。 db.mycol.aggregate([{$group : {_id : “$by_user”, url : {$push: “$url”}}}]) $addToSet 在结果文档中插入值到一个数组中，但不创建副本。 db.mycol.aggregate([{$group : {_id : “$by_user”, url : {$addToSet : “$url”}}}]) $first 根据资源文档的排序获取第一个文档数据。 db.mycol.aggregate([{$group : {_id : “$by_user”, first_url : {$first : “$url”}}}]) $last 根据资源文档的排序获取最后一个文档数据 db.mycol.aggregate([{$group : {_id : “$by_user”, last_url : {$last : “$url”}}}]) 管道的概念管道在Unix和Linux中一般用于将当前命令的输出结果作为下一个命令的参数。 MongoDB的聚合管道将MongoDB文档在一个管道处理完毕后将结果传递给下一个管道处理。管道操作是可以重复的。 表达式：处理输入文档并输出。表达式是无状态的，只能用于计算当前聚合管道的文档，不能处理其它的文档。 这里我们介绍一下聚合框架中常用的几个操作： $project：修改输入文档的结构。可以用来重命名、增加或删除域，也可以用于创建计算结果以及嵌套文档。 $match：用于过滤数据，只输出符合条件的文档。$match使用MongoDB的标准查询操作。 $limit：用来限制MongoDB聚合管道返回的文档数。 $skip：在聚合管道中跳过指定数量的文档，并返回余下的文档。 $unwind：将文档中的某一个数组类型字段拆分成多条，每条包含数组中的一个值。 $group：将集合中的文档分组，可用于统计结果。 $sort：将输入文档排序后输出。 $geoNear：输出接近某一地理位置的有序文档。 求当前集合的记录数 12&gt; db.users.find().count();2 类似于sql语句 1&gt; select name, count(*) from users group by name; 方便练习的基础数据1234567891011121314151617181920db.users.save(&#123;contry:&apos;中国&apos;,name:&apos;小明&apos;,score:77&#125;);db.users.save(&#123;contry:&apos;中国&apos;,name:&apos;小红&apos;,score:88&#125;);db.users.save(&#123;contry:&apos;中国&apos;,name:&apos;小张&apos;,score:99&#125;);db.users.save(&#123;contry:&apos;美国&apos;,name:&apos;jack&apos;,score:45&#125;);db.users.save(&#123;contry:&apos;美国&apos;,name:&apos;rose&apos;,score:67&#125;);db.users.save(&#123;contry:&apos;美国&apos;,name:&apos;mick&apos;,score:89&#125;);db.orders.insert([ &#123; &quot;_id&quot; : 1, &quot;item&quot; : &quot;almonds&quot;, &quot;price&quot; : 12, &quot;quantity&quot; : 2 &#125;, &#123; &quot;_id&quot; : 2, &quot;item&quot; : &quot;pecans&quot;, &quot;price&quot; : 20, &quot;quantity&quot; : 1 &#125;, &#123; &quot;_id&quot; : 3 &#125;]);db.inventory.insert([ &#123; &quot;_id&quot; : 1, &quot;sku&quot; : &quot;almonds&quot;, description: &quot;product 1&quot;, &quot;instock&quot; : 120 &#125;, &#123; &quot;_id&quot; : 2, &quot;sku&quot; : &quot;bread&quot;, description: &quot;product 2&quot;, &quot;instock&quot; : 80 &#125;, &#123; &quot;_id&quot; : 3, &quot;sku&quot; : &quot;cashews&quot;, description: &quot;product 3&quot;, &quot;instock&quot; : 60 &#125;, &#123; &quot;_id&quot; : 4, &quot;sku&quot; : &quot;pecans&quot;, description: &quot;product 4&quot;, &quot;instock&quot; : 70 &#125;, &#123; &quot;_id&quot; : 5, &quot;sku&quot;: null, description: &quot;Incomplete&quot; &#125;, &#123; &quot;_id&quot; : 6 &#125;]); 使用命令还是很不方便，开发中尽量使用一些界面式的工具，例如Navicat]]></content>
      <categories>
        <category>MongoDB</category>
      </categories>
      <tags>
        <tag>MongoDB</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android Manifest权限描述表]]></title>
    <url>%2F2019%2F05%2F11%2FAndroid-Manifest%E6%9D%83%E9%99%90%E6%8F%8F%E8%BF%B0%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[Android权限描述，方便自己查找。 权限 名称 描述 android.permission.ACCESS_CHECKIN_PROPERTIES 访问登记属性 读取或写入登记check-in数据库属性表的权限 android.permission.ACCESS_COARSE_LOCATION 获取错略位置 通过WiFi或移动基站的方式获取用户错略的经纬度信息,定位精度大概误差在30~1500米 android.permission.ACCESS_FINE_LOCATION 获取精确位置 通过GPS芯片接收卫星的定位信息,定位精度达10米以内 android.permission.ACCESS_LOCATION_EXTRA_COMMANDS 访问定位额外命令 允许程序访问额外的定位提供者指令 android.permission.ACCESS_MOCK_LOCATION 获取模拟定位信息 获取模拟定位信息,一般用于帮助开发者调试应用 android.permission.ACCESS_NETWORK_STATE 获取网络状态 获取网络信息状态,如当前的网络连接是否有效 android.permission.ACCESS_SURFACE_FLINGER 访问Surface Flinger Android平台上底层的图形显示支持,一般用于游戏或照相机预览界面和底层模式的屏幕截图 android.permission.ACCESS_WIFI_STATE 获取WiFi状态 获取当前WiFi接入的状态以及WLAN热点的信息 android.permission.ACCOUNT_MANAGER 账户管理 获取账户验证信息,主要为GMail账户信息,只有系统级进程才能访问的权限 android.permission.AUTHENTICATE_ACCOUNTS 验证账户 允许一个程序通过账户验证方式访问账户管理ACCOUNT_MANAGER相关信息 android.permission.BATTERY_STATS 电量统计 获取电池电量统计信息 android.permission.BIND_APPWIDGET 绑定小插件 允许一个程序告诉appWidget服务需要访问小插件的数据库,只有非常少的应用才用到此权限 android.permission.BIND_DEVICE_ADMIN 绑定设备管理 请求系统管理员接收者receiver,只有系统才能使用 android.permission.BIND_INPUT_METHOD 绑定输入法 请求InputMethodService服务,只有系统才能使用 android.permission.BIND_REMOTEVIEWS 绑定RemoteView 必须通过RemoteViewsService服务来请求,只有系统才能用 android.permission.BIND_WALLPAPER 绑定壁纸 必须通过WallpaperService服务来请求,只有系统才能用 android.permission.BLUETOOTH 使用蓝牙 允许程序连接配对过的蓝牙设备 android.permission.BLUETOOTH_ADMIN 蓝牙管理 允许程序进行发现和配对新的蓝牙设备 android.permission.BRICK 变成砖头 能够禁用手机,非常危险,顾名思义就是让手机变成砖头 android.permission.BROADCAST_PACKAGE_REMOVED 应用删除时广播 当一个应用在删除时触发一个广播 android.permission.BROADCAST_SMS 收到短信时广播 当收到短信时触发一个广播 android.permission.BROADCAST_STICKY 连续广播 允许一个程序收到广播后快速收到下一个广播 android.permission.BROADCAST_WAP_PUSH WAP PUSH广播 WAP PUSH服务收到后触发一个广播 android.permission.CALL_PHONE 拨打电话 允许程序从非系统拨号器里输入电话号码 android.permission.CALL_PRIVILEGED 通话权限 允许程序拨打电话,替换系统的拨号器界面 android.permission.CAMERA 拍照权限 允许访问摄像头进行拍照 android.permission.CHANGE_COMPONENT_ENABLED_STATE 改变组件状态 改变组件是否启用状态 android.permission.CHANGE_CONFIGURATION 改变配置 允许当前应用改变配置,如定位 android.permission.CHANGE_NETWORK_STATE 改变网络状态 改变网络状态如是否能联网 android.permission.CHANGE_WIFI_MULTICAST_STATE 改变WiFi多播状态 改变WiFi多播状态 android.permission.CHANGE_WIFI_STATE 改变WiFi状态 改变WiFi状态 android.permission.CLEAR_APP_CACHE 清除应用缓存 清除应用缓存 android.permission.CLEAR_APP_USER_DATA 清除用户数据 清除应用的用户数据 android.permission.CWJ_GROUP 底层访问权限 允许CWJ账户组访问底层信息 android.permission.CELL_PHONE_MASTER_EX 手机优化大师扩展权限 手机优化大师扩展权限 android.permission.CONTROL_LOCATION_UPDATES 控制定位更新 允许获得移动网络定位信息改变 android.permission.DELETE_CACHE_FILES 删除缓存文件 允许应用删除缓存文件 android.permission.DELETE_PACKAGES 删除应用 允许程序删除应用 android.permission.DEVICE_POWER 电源管理 允许访问底层电源管理 android.permission.DIAGNOSTIC 应用诊断 允许程序到RW到诊断资源 android.permission.DISABLE_KEYGUARD 禁用键盘锁 允许程序禁用键盘锁 android.permission.DUMP 转存系统信息 允许程序获取系统dump信息从系统服务 android.permission.EXPAND_STATUS_BAR 状态栏控制 允许程序扩展或收缩状态栏 android.permission.FACTORY_TEST 工厂测试模式 允许程序运行工厂测试模式 android.permission.FLASHLIGHT 使用闪光灯 允许访问闪光灯 android.permission.FORCE_BACK 强制后退 允许程序强制使用back后退按键,无论Activity是否在顶层 android.permission.GET_ACCOUNTS 访问账户Gmail列表 访问GMail账户列表 android.permission.GET_PACKAGE_SIZE 获取应用大小 获取应用的文件大小 android.permission.GET_TASKS 获取任务信息 允许程序获取当前或最近运行的应用 android.permission.GLOBAL_SEARCH 允许全局搜索 允许程序使用全局搜索功能 android.permission.HARDWARE_TEST 硬件测试 访问硬件辅助设备,用于硬件测试 android.permission.INJECT_EVENTS 注射事件 允许访问本程序的底层事件,获取按键、轨迹球的事件流 android.permission.INSTALL_LOCATION_PROVIDER 安装定位提供 安装定位提供 android.permission.INSTALL_PACKAGES 安装应用程序 允许程序安装应用 android.permission.INTERNAL_SYSTEM_WINDOW 内部系统窗口 允许程序打开内部窗口,不对第三方应用程序开放此权限 android.permission.INTERNET 访问网络 访问网络连接,可能产生GPRS流量 android.permission.KILL_BACKGROUND_PROCESSES 结束后台进程 允许程序调用killBackgroundProcesses(String).方法结束后台进程 android.permission.MANAGE_ACCOUNTS 管理账户 允许程序管理AccountManager中的账户列表 android.permission.MANAGE_APP_TOKENS 管理程序引用 管理创建、摧毁、Z轴顺序,仅用于系统 android.permission.MTWEAK_USER 高级权限 允许mTweak用户访问高级系统权限 android.permission.MTWEAK_FORUM 社区权限 允许使用mTweak社区权限 android.permission.MASTER_CLEAR 软格式化 允许程序执行软格式化,删除系统配置信息 android.permission.MODIFY_AUDIO_SETTINGS 修改声音设置 修改声音设置信息 android.permission.MODIFY_PHONE_STATE 修改电话状态 修改电话状态,如飞行模式,但不包含替换系统拨号器界面 android.permission.MOUNT_FORMAT_FILESYSTEMS 格式化文件系统 格式化可移动文件系统,比如格式化清空SD卡 android.permission.MOUNT_UNMOUNT_FILESYSTEMS 挂载文件系统 挂载、反挂载外部文件系统 android.permission.NFC 允许NFC通讯 允许程序执行NFC近距离通讯操作,用于移动支持 android.permission.PERSISTENT_ACTIVITY 永久Activity 创建一个永久的Activity,该功能标记为将来将被移除 android.permission.PROCESS_OUTGOING_CALLS 处理拨出电话 允许程序监视,修改或放弃播出电话 android.permission.READ_CALENDAR 读取日程提醒 允许程序读取用户的日程信息 android.permission.READ_CONTACTS 读取联系人 允许应用访问联系人通讯录信息 android.permission.READ_FRAME_BUFFER 屏幕截图 读取帧缓存用于屏幕截图 com.android.browser.permission.READ_HISTORY_BOOKMARKS 读取收藏夹和历史记录 读取浏览器收藏夹和历史记录 android.permission.READ_INPUT_STATE 读取输入状态 读取当前键的输入状态,仅用于系统 android.permission.READ_LOGS 读取系统日志 读取系统底层日志 android.permission.READ_PHONE_STATE 读取电话状态 访问电话状态 android.permission.READ_SMS 读取短信内容 读取短信内容 android.permission.READ_SYNC_SETTINGS 读取同步设置 读取同步设置,读取Google在线同步设置 android.permission.READ_SYNC_STATS 读取同步状态 读取同步状态,获得Google在线同步状态 android.permission.REBOOT 重启设备 允许程序重新启动设备 android.permission.RECEIVE_BOOT_COMPLETED 开机自动允许 允许程序开机自动运行 android.permission.RECEIVE_MMS 接收彩信 接收彩信 android.permission.RECEIVE_SMS 接收短信 接收短信 android.permission.RECEIVE_WAP_PUSH 接收Wap Push 接收WAP PUSH信息 android.permission.RECORD_AUDIO 录音 录制声音通过手机或耳机的麦克 android.permission.REORDER_TASKS 排序系统任务 重新排序系统Z轴运行中的任务 android.permission.RESTART_PACKAGES 结束系统任务 结束任务通过restartPackage(String)方法,该方式将在外来放弃 android.permission.SEND_SMS 发送短信 发送短信 android.permission.SET_ACTIVITY_WATCHER 设置Activity观察其 设置Activity观察器一般用于monkey测试 com.android.alarm.permission.SET_ALARM 设置闹铃提醒 设置闹铃提醒 android.permission.SET_ALWAYS_FINISH 设置总是退出 设置程序在后台是否总是退出 android.permission.SET_ANIMATION_SCALE 设置动画缩放 设置全局动画缩放 android.permission.SET_DEBUG_APP 设置调试程序 设置调试程序,一般用于开发 android.permission.SET_ORIENTATION 设置屏幕方向 设置屏幕方向为横屏或标准方式显示,不用于普通应用 android.permission.SET_PREFERRED_APPLICATIONS 设置应用参数 设置应用的参数,已不再工作具体查看addPackageToPreferred(String)介绍 android.permission.SET_PROCESS_LIMIT 设置进程限制 允许程序设置最大的进程数量的限制 android.permission.SET_TIME 设置系统时间 设置系统时间 android.permission.SET_TIME_ZONE 设置系统时区 设置系统时区 android.permission.SET_WALLPAPER 设置桌面壁纸 设置桌面壁纸 android.permission.SET_WALLPAPER_HINTS 设置壁纸建议 设置壁纸建议 android.permission.SIGNAL_PERSISTENT_PROCESSES 发送永久进程信号 发送一个永久的进程信号 android.permission.STATUS_BAR 状态栏控制 允许程序打开、关闭、禁用状态栏 android.permission.SUBSCRIBED_FEEDS_READ 访问订阅内容 访问订阅信息的数据库 android.permission.SUBSCRIBED_FEEDS_WRITE 写入订阅内容 写入或修改订阅内容的数据库 android.permission.SYSTEM_ALERT_WINDOW 显示系统窗口 显示系统窗口 android.permission.UPDATE_DEVICE_STATS 更新设备状态 更新设备状态 android.permission.USE_CREDENTIALS 使用证书 允许程序请求验证从AccountManager android.permission.USE_SIP 使用SIP视频 允许程序使用SIP视频服务 android.permission.VIBRATE 使用振动 允许振动 android.permission.WAKE_LOCK 唤醒锁定 允许程序在手机屏幕关闭后后台进程仍然运行 android.permission.WRITE_APN_SETTINGS 写入GPRS接入点设置 写入网络GPRS接入点设置 android.permission.WRITE_CALENDAR 写入日程提醒 写入日程,但不可读取 android.permission.WRITE_CONTACTS 写入联系人 写入联系人,但不可读取 android.permission.WRITE_EXTERNAL_STORAGE 写入外部存储 允许程序写入外部存储,如SD卡上写文件 android.permission.WRITE_GSERVICES 写入Google地图数据 允许程序写入Google Map服务数据 com.android.browser.permission.WRITE_HISTORY_BOOKMARKS 写入收藏夹和历史记录 写入浏览器历史记录或收藏夹,但不可读取 android.permission.WRITE_SECURE_SETTINGS 读写系统敏感设置 允许程序读写系统安全敏感的设置项 android.permission.WRITE_SETTINGS 读写系统设置 允许读写系统设置项 android.permission.WRITE_SMS 编写短信 允许编写短信]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浅析JS中的模块化(CommonJS,AMD,CMD)]]></title>
    <url>%2F2019%2F05%2F07%2F%E6%B5%85%E6%9E%90JS%E4%B8%AD%E7%9A%84%E6%A8%A1%E5%9D%97%E5%8C%96-CommonJS-AMD-CMD%2F</url>
    <content type="text"><![CDATA[背景历史上，JavaScript一直都没有模块（module）体系，这就导致了在大项目中无法拆分成互相依赖的小文件，再进行拼装。这对开发复杂的项目形成了巨大的障碍。 模块化概念理想情况下，开发者只需要实现核心的业务逻辑，其他都可以加载别人已经写好的模块。 原始的写法 模块就是实现某个特定功能的方法，只要把不同的函数或变量放在一起就算是一个模块 123456789101112var _count = 0;function m1() &#123; console.log('m1');&#125;function m2() &#123; console.log('m2');&#125;// m1();// m2();// console.log(_count); 这里的m1,m2方法组成了一个模块，使用的时候直接调用即可。但是这样很明显有一个缺点：“污染”全局变量，没有办法保证模块与模块之间不发生变量名或者方法名冲突，并且模块间与模块间并无法分清是否有直接联系。 对象写法 对于原始写法的缺点，将方法或者变量声明在某个对象中，像m1,m2函数都封装在对象体内，需要时再用对象进行调用。 12345678910111213var module1 = &#123; _count: 0, m1: function()&#123; console.log('m1'); &#125;, m2: function()&#123; console.log('m2'); &#125;&#125;// module1.m1();// module1.m2();// console.log(module1._count); 但是这样依然会有缺点：暴露出了模块的所有成员，内部状态可以被改写，比如内部_count变量会被外部直接改写。 立即执行函数写法 会涉及到闭包的概念，用‘立即执行函数’（Immediately-Invoked Function Expression，IIFE）即可以达到不暴露私有成员的目的。类似于jQuery的封装。 123456789101112131415161718192021222324var module1 = (function()&#123; var _count = 0; function m1() &#123; console.log('m1'); &#125; function m2() &#123; console.log('m2'); &#125; return &#123; m1: m1, m2: m2, getCount: function()&#123; return _count; &#125; &#125;&#125;)();// module1.m1();// module1.m2();// console.log(module1._count); //undefined// console.log(module1.getCount()); //0 CommonJSCommonJS) 是以在浏览器环境之外构建 JavaScript 生态系统为目标而产生的项目，比如在服务器和桌面环境中。 2009年，美国程序员Ryan Dahl创造了node.js项目，将javascript语言用于服务器端编程。 这标志”Javascript模块化编程”正式诞生。前端的复杂程度有限，没有模块也是可以的，但是在服务器端，一定要有模块，与操作系统和其他应用程序互动，否则根本没法编程。 node编程中最重要的思想之一就是模块，而正是这个思想，让JavaScript的大规模工程成为可能。模块化编程在js界流行，也是基于此，随后在浏览器端，requirejs和seajs之类的工具包也出现了，可以说在对应规范下，require统治了ES6之前的所有模块化编程，即使现在，在ES6 module被完全实现之前，还是这样。 例如在Node中，Node 应用由模块组成，采用 CommonJS 模块规范。 每个文件就是一个模块，有自己的作用域。在一个文件里面定义的变量、函数、类，都是私有的，对其他文件不可见。 CommonJS规范规定，每个模块内部，module变量代表当前模块。这个变量是一个对象，它的·exports属性（即·module.exports）是对外的接口。加载某个模块，其实是加载该模块的·module.exports属性。 12345678910111213141516//user.jsvar _count = 0;var expose_num = 100;var m1 = function()&#123; console.log('m1');&#125;var m2 = function()&#123; console.log('m2');&#125;var getCount = function()&#123; return _count;&#125;module.exports.m1 = m1;module.exports.m2 = m2;module.exports.getCount = getCount;module.exports.expose_num = expose_num; 上面代码通过module.exports输出变量expose_num和函数m1,m2,getCount。 require方法进行加载模块 123456//main.jsconst module1 = require('./user.js');module1.m1(); //m1module1.m2(); //m2console.log(module1.getCount()); //0console.log(module1.expose_num); //100 module.exports属性 module.exports属性表示当前模块对外输出的接口，其他文件加载该模块，实际上就是读取module.exports变量。 exports变量 为了方便，Node为每个模块提供一个exports变量，指向module.exports。这等同在每个模块头部，有一行这样的命令。 1var exports = module.exports; 如果你觉得，exports与module.exports之间的区别很难分清，一个简单的处理方法，就是放弃使用exports，只使用module.exports。 es6中为export,注意区分。 CommonJS模块的特点如下 所有代码都运行在模块作用域，不会污染全局作用域。 模块可以多次加载，但是只会在第一次加载时运行一次，然后运行结果就被缓存了，以后再加载，就直接读取缓存结果。要想让模块再次运行，必须清除缓存。 模块加载的顺序，按照其在代码中出现的顺序。 详细学习使用请参考链接：https://javascript.ruanyifeng.com/nodejs/module.html AMD有了服务器端的模块化后，很自然客户端也需要进行模块化，最好两者能够兼容，并且在服务器和浏览器都能够运行。也由于一个重大的局限，使得CommonJS规范不适用于浏览器环境上。 就例如上述中CommonJS中的案例代码，在未加载完第一行的require(&#39;./user.js&#39;)代码时，后面的module1.m1()等的方法都会进行等待第一行完成后才可以继续运行。这对服务端来说不是问题，因为所有的模块都存放在本地硬盘，没有网络等其他原因，可以很快的同步加载完成，只需要等待硬盘的读取时间。但是对于浏览器环境，却是一个很大的问题，因为所有的模块都放置于服务端，等待时间不是取决于硬盘，而是取决于网速的快慢，这就导致了可能会导致等待时间过长，导致浏览器出现’假死’状态。 因此浏览器端的模块不可以采用’同步加载’（synchronous），只能使用’异步加载’（asynchronous）。这就是AMD](https://github.com/amdjs/amdjs-api/wiki/AMD-(中文版))规范的诞生背景。 所谓AMD即Asynchronous Module Definition的缩写，意思就是’异步模块定义’。它采用异步方式加载模块，模块的加载不影响后面的语句的运行。所有依赖这个模块的语句，都定义在一个回调函数中，等到加载完成之后，这个回调函数才会运行。 该规范只定义了一个函数 define，它是全局变量。函数的描述为： 1define(id?, dependencies?, factory); id：第一个参数，id，是个字符串。它指的是定义中模块的名字，这个参数是可选的 dependencies：第二个参数，dependencies，是个定义中模块所依赖模块的数组 factory：第三个参数，factory，为模块初始化要执行的函数或对象。 例如在RequireJS中， RequireJS是一个工具库，主要用于客户端的模块管理。它可以让客户端的代码分成一个个模块，实现异步或动态加载，从而提高代码的性能和可维护性。它的模块管理遵守AMD规范（Asynchronous Module Definition）。 RequireJS的基本思想是，通过define方法，将代码定义为模块；通过require方法，实现代码的模块加载。 首先，将require.js嵌入网页，然后就能在网页中进行模块化编程了。 1&lt;script data-main="app" src="https://requirejs.org/docs/release/2.3.6/comments/require.js"&gt;&lt;/script&gt; 上面代码的data-main属性不可省略，用于指定主代码所在的脚本文件，在上例中为当前目录下的app.js文件。用户自定义的代码就放在这个app.js文件中。 define方法：定义模块 独立模块 123456789//user.jsdefine(&#123; m1:function()&#123; console.log('m1'); &#125;, m2:function()&#123; console.log('m2'); &#125;&#125;); 另一种等价的写法是，把对象写成一个函数，该函数的返回值就是输出的模块。 1234567891011//user.jsdefine(function()&#123; return &#123; m1:function()&#123; console.log('m1'); &#125;, m2:function()&#123; console.log('m2'); &#125; &#125;&#125;); 后一种写法的自由度更高一点，可以在函数体内写一些模块初始化代码。值得指出的是，define定义的模块可以返回任何值，不限于对象。 非独立模块 123456789101112//cart.jsdefine(['user'], function (user) &#123; console.log('cart'); user.m1(); user.m2(); var getCartCount = function()&#123; return 100; &#125; return &#123; getCartCount:getCartCount &#125;&#125;); define方法的第一个参数是一个数组，它的成员是当前模块所依赖的模块。比如，[‘user’]表示我们定义的这个新模块依赖于user模块，只有先加载这两个模块，新模块才能正常运行。一般情况下，user模块指的是，当前目录下的user.js文件，等同于写成[’./user’]。 define方法的第二个参数是一个函数，当前面数组的所有成员加载成功后，它将被调用。它的参数与数组的成员一一对应，比如function(user)就表示，这个函数的第一个参数user对应user模块，以此类推。这个函数必须返回一个对象，供其他模块调用。 require方法：调用模块 require方法用于调用模块。它的参数与define方法类似。 12345678910//app.jsrequire(['cart'], function(cart)&#123; //...do console.log(cart.getCartCount());&#125;);//输出：//cart//m1//m2//100 上面方法表示加载cart一个模块，当这一个模块都加载成功后，执行一个回调函数。该回调函数就用来完成具体的任务。而cart.getCartCount()和cart模块加载不是同步的，浏览器不会再发生假死状态，所以AMD规范更适合浏览器环境。 require方法也可以用在define方法内部，即动态加载。 define和require这两个定义模块、调用模块的方法，合称为AMD模式。它的模块定义的方法非常清晰，不会污染全局环境，能够清楚地显示依赖关系。 AMD模式可以用于浏览器环境，并且允许非同步加载模块，也可以根据需要动态加载模块。 详细学习使用请参考链接：https://javascript.ruanyifeng.com/tool/requirejs.html AMD规范与CommonJS规范的兼容性CommonJS规范加载模块是同步的，也就是说，只有加载完成，才能执行后面的操作。AMD规范则是非同步加载模块，允许指定回调函数。由于Node.js主要用于服务器编程，模块文件一般都已经存在于本地硬盘，所以加载起来比较快，不用考虑非同步加载的方式，所以CommonJS规范比较适用。但是，如果是浏览器环境，要从服务器端加载模块，这时就必须采用非同步模式，因此浏览器端一般采用AMD规范。 AMD规范使用define方法定义模块，下面就是一个例子： 123456789define(['package/lib'], function(lib)&#123; function foo()&#123; lib.log('hello world!'); &#125; return &#123; foo: foo &#125;;&#125;); AMD规范允许输出的模块兼容CommonJS规范，这时define方法需要写成下面这样： 123456789101112define(function (require, exports, module)&#123; var someModule = require("someModule"); var anotherModule = require("anotherModule"); someModule.doTehAwesome(); anotherModule.doMoarAwesome(); exports.asplode = function ()&#123; someModule.doTehAwesome(); anotherModule.doMoarAwesome(); &#125;;&#125;); CMDCMD 是 SeaJS 在推广过程中对模块定义的规范化产出。 首先通过 script 引入 sea.js 后，有一段配置代码： 12345678910// seajs 的简单配置seajs.config(&#123; base: "../sea-modules/", alias: &#123; "jquery": "jquery/jquery/1.10.1/jquery.js" &#125;&#125;)// 加载入口模块seajs.use("../static/hello/src/main") sea.js 在下载完成后，会自动加载入口模块。页面中的代码就这么简单。 1define(id?, deps?, factory) id：第一个参数，id，是个字符串。它指的是定义中模块的名字，这个参数是可选的 deps：第二个参数，dependencies，是个定义中模块所依赖模块的数组 factory：第三个参数，factory，为模块初始化要执行的函数或对象。 注意：带 id 和 dependencies 参数的 define 用法不属于 CMD 规范，而属于 Modules/Transport 规范。 如果一个模块不依赖其他模块，那么可以直接定义在define()函数之中。 1234567891011121314// 所有模块都通过 define 来定义define(function(require, exports, module) &#123; // 通过 require 引入依赖 var $ = require('jquery'); var Spinning = require('./spinning'); // 通过 exports 对外提供接口 exports.doSomething = ... // 或者通过 module.exports 提供整个接口 module.exports = ...&#125;); 上面就是 Sea.js 推荐的 CMD 模块书写格式。如果你有使用过 Node.js，一切都很自然。 详细学习使用请参考链接：https://seajs.github.io/seajs/docs/#quick-start AMD和CMD的区别AMD和CMD最大的区别是对依赖模块的执行时机处理不同，而不是加载的时机或者方式不同，二者皆为异步加载模块。 AMD依赖前置，js可以方便知道依赖模块是谁，立即加载； CMD就近依赖，需要使用把模块变为字符串解析一遍才知道依赖了那些模块。 AMD 的 API 默认是一个当多个用，CMD 的 API 严格区分，推崇职责单一。比如 AMD 里，require 分全局 require 和局部 require，都叫 require。CMD 里，没有全局 require，而是根据模块系统的完备性，提供 seajs.use 来实现模块系统的加载启动。CMD 里，每个 API 都简单纯粹。 CMD 推崇依赖就近，AMD 推崇依赖前置 RequireJS 从 2.0 开始，也改成可以延迟执行（根据写法不同，处理方式不同）。 12345678910// CMDdefine(function(require, exports, module) &#123; var a = require('./a') a.doSomething() // 此处略去 100 行 var b = require('./b') // 依赖可以就近书写 b.doSomething() // ... &#125;) 1234567// AMD 默认推荐的是define(['./a', './b'], function(a, b) &#123; // 依赖必须一开始就写好 a.doSomething() // 此处略去 100 行 b.doSomething() &#125;) 即使AMD也可以支持CMD的写法，因为define内部也可以使用require，前面有提到。但是RequireJS 的作者默认是最喜欢上面的写法，也是官方文档里默认的模块定义写法。 ES6 ModuleES6 模块的设计思想是尽量的静态化，使得编译时就能确定模块的依赖关系，以及输入和输出的变量。 export导出模块 模块功能主要由两个命令构成：export和import。export命令用于规定模块的对外接口，import命令用于输入其他模块提供的功能。 一个模块就是一个独立的文件。该文件内部的所有变量，外部无法获取。如果你希望外部能够读取模块内部的某个变量，就必须使用export关键字输出该变量。下面是一个 JS 文件，里面使用export命令输出变量。 123456// profile.jsvar firstName = 'Michael';var lastName = 'Jackson';var year = 1958;export &#123;firstName, lastName, year&#125;; export命令除了输出变量，还可以输出函数或类（class）。 import导入模块 使用export命令定义了模块的对外接口以后，其他 JS 文件就可以通过import命令加载这个模块。 123456// main.jsimport &#123;firstName, lastName, year&#125; from './profile.js';function setName(element) &#123; element.textContent = firstName + ' ' + lastName;&#125; 上面代码的import命令，用于加载profile.js文件，并从中输入变量。import命令接受一对大括号，里面指定要从其他模块导入的变量名。大括号里面的变量名，必须与被导入模块（profile.js）对外接口的名称相同。 export default默认导出 从前面的例子可以看出，使用import命令的时候，用户需要知道所要加载的变量名或函数名，否则无法加载。但是，用户肯定希望快速上手，未必愿意阅读文档，去了解模块有哪些属性和方法。 为了给用户提供方便，让他们不用阅读文档就能加载模块，就要用到export default命令，为模块指定默认输出。 1234// export-default.jsexport default function () &#123; console.log('foo');&#125; 上面代码是一个模块文件export-default.js，它的默认输出是一个函数。 其他模块加载该模块时，import命令可以为该匿名函数指定任意名字。 123// import-default.jsimport customName from './export-default';customName(); // 'foo' ES6中Module还有很多语法，这里主要讲解es6前js的模块化概念，所以不多概述使用，详细使用参考下面链接。 详细学习使用请参考链接：https://es6.ruanyifeng.com/#docs/module]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>CommonJS</tag>
        <tag>AMD</tag>
        <tag>CMD</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP常用函数参考表]]></title>
    <url>%2F2019%2F05%2F05%2FPHP%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0%E5%8F%82%E8%80%83%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[各种常用的php函数，包括php字符串函数,php数组函数,php数学函数,mysql函数,文件目录函数,GD库函数,SESSION函数,Date/Time 函数等，涵盖了php基本操作所涉及的各类常用函数，并针对各个函数提供了简单的解释说明，方便查阅 字符串相关操作函数去除空格或其他字符 方法 说明 trim 删除字符串两端空格或其他预定义字符 rtrim 删除字符串右边空格或其他预定义字符 chop rtrim() 的别名 chop() 与 Perl 的 chop() 函数有所不同，它会删除字符串的最后一个字符。 ltrim 删除字符串左边空格或其他预定义字符 字符串生成与转换 方法 说明 str_pad 使用另一个字符串填充字符串为指定长度 str_replace 子字符串替换 str_split 将字符串转换为数组 strrev 反转字符串 wordwrap 打断字符串为指定数量的字串 str_shuffle 随机打乱一个字符串 parse_str 将字符串解析成变量 number_format 通过千位分组来格式化字符串 字符串大小写转换 方法 说明 strtolower 将字符串转化为小写 strtoupper 将字符串转化为大写 ucfirst 将字符串的首字母转换为大写 ucwords 将字符串中每个单词的首字母转换为大写 html标签关联 方法 说明 htmlentities 将字符转换为HTML实体 htmlspecialchars 预定义字符串转HTML编码 nl2br 在字符串所有新行之前插入 HTML 换行标记 \n转换为&lt;br&gt;标签 strip_tags 从字符串中去除 HTML 和 PHP 标记 addcslashes 以 C 语言风格使用反斜线转义字符串中的字符 stripcslashes 反引用一个使用 addcslashes() 转义的字符串 addslashes 使用反斜线引用字符串 stripslashes 删除由addslashes添加的转义字符 quotemeta 字符串中某些预定义字符串前加反斜杠 chr 从指定的 ASCII 值返回字符 ord 返回字符串第一个字符的 ASCII 值 字符串比较 方法 说明 strcasecmp 不区分大小写比较两个字符串 strcmp 区分大小写比较两个字符串 strncmp 比较字符串前N个字符，区分大小写 strncasecmp 比较字符串前N个字符，不区分大小写 strnatmp 自然顺序法比较字符串长度，区分大小写 strnatcasecmp 自然顺序法比较字符串长度，不区分大小写 字符串查找替换 方法 说明 str_replace 字符串替换操作，区分大小写 str_ireplace 字符串替换操作，不区分大小写 substr_count 统计一个字符串，在另一个字符串中出现的次数 substr_replace 替换字符串中某串为另一个字符串 similar_text 返回两字符串相同字符的数量 strrchr 返回一个字符串在另一个字符串中最后一次出现位置开始到末尾的字符串 strstr 返回一个字符串在另一个字符串中开始位置到结束位置的字符串 strchr strstr的别名，返回一个字符串在另一个中首次出现位置开始到末尾的字符串 stristr 返回一个字符串在另一个字符串中开始位置到结束位置的字符串，不区分大小写 strtr 转换字符串中某些字符 strpos 寻找字符中某些字符最先出现的位置 stripos 寻找字符中某些字符最先出现的位置，不区分大小写 strrpos 寻找字符中某些字符最后出现的位置 strripos 寻找字符中某些字符最后出现的位置，不区分大小写 strspn 返回字符串中首次符合mask的字符串长度 strcspn 返回字符串中不符合mask的字符串的长度 字符串统计 方法 说明 str_word_count 统计字符串含有的单词数 strlen 统计字符串长度 count_chars 统计字符串中所有字母出现的次数（0..255） 字符串编码 方法 说明 md5 计算字符串的 MD5 散列值 hash 生成一个哈希码 数组相关函数创建数组 方法 说明 array 生成一个数组 array_combine 生成一个数组，用一个数组的值作为键名，另一个数组的值作为值 range 创建并返回一个包含指定范围的元素的数组 compact 创建一个由参数所带变量组成的数组 array_fill 用给定的值填充生成数组 数组合并和拆分 方法 说明 array_chunk 把一个数组分割为新的数组块 array_merge 把两个或多个数组合并成一个数组 array_slice 在数组中根据条件取出一段值，并返回。 数组比较 方法 说明 array_diff 返回两个数组的差集数组 array_intersect 返回两个或多个数组的交集数组 数组查找替换 方法 说明 array_search 在数组中查找一个键值 array_splice 把数组一部分删除把其他值替代 array_sum 返回数组中所有值的总和 in_array 在数组中搜索指定的值，区分大小写 array_key_exists 判断某个数组中是否存在指定的key 数组指针操作 方法 说明 key 返回数组内部指针当前指向的键名 current 返回数组中的当前元素 next 把指向当前元素的指针移动到下一个元素位置，并返回当前元素的值 prev 把指向当前元素的指针移动到上一个元素位置，并返回当前元素的值 end 将数组内部指针指向最后一个元素，并返回该元素的值（如果成功） reset 把数组内部指针指向第一个元素，并返回该元素的值 list 用数组中的元素为一组变量赋值 array_shift 删除数组中的第一个元素，并返回被删除元素的值 array_unshif 在数组开头插入一个或者多个元素 array_push 向数组最后压入一个或多个元素 array_pop 删除数组最后一个元素 数组键值操作 方法 说明 shuffle 将数组打乱，保留键名 count 计算数组中单元个数或者对象属性个数 array_flip 返回一个键值翻转后的数组 array_keys 返回数组所有键，组成一个数组 array_values 返回数组所有值，组成一个数组 array_reverse 返回一个元素顺序相反的数组 array_count_values 统计数组中所有值出现的次数 array_rand 从数组中随机抽取一个或者多个元素，注意是键名 each 返回数组中当前的键／值对并将数组指针向前移动一步 array_unique 移除数组中重复的值 数组排序 方法 说明 sort 对数组排序 rsort 对数组逆向排序 asort 对数组进行排序并保持索引关系 arsort 对数组进行逆向排序并保持索引关系 ksort 对数组按照键名排序 krsort 对数组按照键名逆向排序 natsort 用“自然排序”算法对数组排序 natcasesort 用“自然排序”算法对数组进行不区分大小写字母的排序 数学相关函数 方法 说明 abs 求绝对值 ceil 进一法取整 floor 舍去法取整 fmod 返回除法的浮点数余数 pow 返回数的N次方 round 浮点数四舍五入法 sqrt 求平方根 max 求最大值 min 求最小值 mt_rand 更好的随机数 rand 随机数 pi 获得圆周率 octdec 八进制转换为十进制 mysql相关函数 方法 说明 mysql_affected_rows 取得前一次 MySQL 操作所影响的记录行数 mysql_client_encoding 返回字符集的名称 mysql_close 关闭 MySQL 连接 mysql_connect 打开一个到 MySQL 服务器的连接 mysql_create_db 新建一个 MySQL 数据库 mysql_data_seek 移动内部结果的指针 mysql_db_name 取得结果数据 mysql_db_query 发送一条 MySQL 查询 mysql_drop_db 丢弃（删除）一个 MySQL 数据库 mysql_errno 返回上一个 MySQL 操作中的错误信息的数字编码 mysql_error 返回上一个 MySQL 操作产生的文本错误信息 mysql_escape_string 转义一个字符串用于 mysql_query mysql_fetch_array 从结果集中取得一行作为关联数组，或数字数组，或二者兼有 mysql_fetch_assoc 从结果集中取得一行作为关联数组 mysql_fetch_field 从结果集中取得列信息并作为对象返回 mysql_fetch_lengths 取得结果集中每个输出的长度 mysql_fetch_object 从结果集中取得一行作为对象 mysql_fetch_object 从结果集中取得一行作为枚举数组 mysql_field_flags 从结果中取得和指定字段关联的标志 mysql_field_len 返回指定字段的长度 mysql_field_name 取得结果中指定字段的字段名 mysql_field_seek 将结果集中的指针设定为制定的字段偏移量 mysql_field_table 取得指定字段所在的表名 mysql_field_type 取得结果集中指定字段的类型 mysql_free_result 释放结果内存 mysql_get_client_info 取得 MySQL 客户端信息 mysql_get_host_info 取得 MySQL 主机信息 mysql_get_proto_info 取得 MySQL 协议信息 mysql_get_server_info 取得 MySQL 服务器信息 mysql_info 取得最近一条查询的信息 mysql_insert_id 取得上一步 INSERT 操作产生的 ID mysql_list_dbs 列出 MySQL 服务器中所有的数据库 mysql_list_fields 列出 MySQL 结果中的字段 mysql_list_processes 列出 MySQL 进程 mysql_list_tables 列出 MySQL 数据库中的表 mysql_num_fields 取得结果集中字段的数目 mysql_num_rows 取得结果集中行的数目 mysql_pconnect 打开一个到 MySQL 服务器的持久连接 mysql_ping Ping 一个服务器连接，如果没有连接则重新连接 mysql_query 发送一条 MySQL 查询 mysql_real_escape_string 转义 SQL 语句中使用的字符串中的特殊字符，并考虑到连接的当前字符集 mysql_result 取得结果数据 mysql_select_db 选择 MySQL 数据库 mysql_set_charset 设置客户端字符集 mysql_stat 取得当前系统状态 mysql_tablename 取得表名 mysql_thread_id 返回当前线程的 ID mysql_unbuffered_query 向 MySQL 发送一条 SQL 查询，并不获取和缓存结果的行 文件目录处理相关函数 方法 说明 basename 返回路径中的文件名部分 chgrp 改变文件所属的组 chmod 改变文件模式 chown 改变文件的所有者 clearstatcache 清除文件状态缓存 copy 拷贝文件 delete 参见 unlink 或 unset dirname 返回路径中的目录部分 disk_free_space 返回目录中的可用空间 disk_total_space 返回一个目录的磁盘总大小 diskfreespace disk_free_space 的别名 fclose 关闭一个已打开的文件指针 feof 测试文件指针是否到了文件结束的位置 fflush 将缓冲内容输出到文件 fgetc 从文件指针中读取字符 fgetcsv 从文件指针中读入一行并解析 CSV 字段 fgets 从文件指针中读取一行 fgetss 从文件指针中读取一行并过滤掉 HTML 标记 file_exists 检查文件或目录是否存在 file_get_contents 将整个文件读入一个字符串 file_put_contents 将一个字符串写入文件 file 把整个文件读入一个数组中 fileatime 取得文件的上次访问时间 filectime 取得文件的 inode 修改时间 filegroup 取得文件的组 fileinode 取得文件的 inode filemtime 取得文件修改时间 fileowner 取得文件的所有者 fileperms 取得文件的权限 filesize 取得文件大小 filetype 取得文件类型 flock 轻便的咨询文件锁定 fnmatch 用模式匹配文件名 fopen 打开文件或者 URL fpassthru 输出文件指针处的所有剩余数据 fputcsv 将行格式化为 CSV 并写入文件指针 fputs fwrite 的别名 fread 读取文件（可安全用于二进制文件) fscanf 从文件中格式化输入 fseek 在文件指针中定位 fstat 通过已打开的文件指针取得文件信息 ftell 返回文件指针读/写的位置 ftruncate 将文件截断到给定的长度 fwrite 写入文件（可安全用于二进制文件） glob 寻找与模式匹配的文件路径 is_dir 判断给定文件名是否是一个目录 is_executable 判断给定文件名是否可执行 is_file 判断给定文件名是否为一个正常的文件 is_link 判断给定文件名是否为一个符号连接 is_readable 判断给定文件名是否可读 is_uploaded_file 判断文件是否是通过 HTTP POST 上传的 is_writable 判断给定的文件名是否可写 is_writeable is_writable 的别名 lchgrp Changes group ownership of symlink lchown Changes user ownership of symlink link 建立一个硬连接 linkinfo 获取一个连接的信息 lstat 给出一个文件或符号连接的信息 mkdir 新建目录 move_uploaded_file 将上传的文件移动到新位置 parse_ini_file 解析一个配置文件 parse_ini_string Parse a configuration string pathinfo 返回文件路径的信息 pclose 关闭进程文件指针 popen 打开进程文件指针 readfile 输出一个文件 readlink 返回符号连接指向的目标 realpath_cache_get Get realpath cache entries realpath_cache_size Get realpath cache size realpath 返回规范化的绝对路径名 rename 重命名一个文件或目录 rewind 倒回文件指针的位置 rmdir 删除目录 set_file_buffer stream_set_write_buffer 的别名 stat 给出文件的信息 symlink 建立符号连接 tempnam 建立一个具有唯一文件名的文件 tmpfile 建立一个临时文件 touch 设定文件的访问和修改时间 umask 改变当前的 umask unlink 删除文件 GD/Image函数 方法 说明 gd_info 取得当前安装的 GD 库的信息 getimagesize 取得图像大小 getimagesizefromstring Get the size of an image from a string image_type_to_extension 取得图像类型的文件后缀 image_type_to_mime_type 取得 getimagesize，exif_read_data，exif_thumbnail，exif_imagetype 所返回的图像类型的 MIME 类型 image2wbmp 以 WBMP 格式将图像输出到浏览器或文件 imagealphablending 设定图像的混色模式 imageantialias 是否使用抗锯齿（antialias）功能 imagearc 画椭圆弧 imagechar 水平地画一个字符 imagecharup 垂直地画一个字符 imagecolorallocate 为一幅图像分配颜色 imagecolorallocatealpha 为一幅图像分配颜色 + alpha imagecolorat 取得某像素的颜色索引值 imagecolorclosest 取得与指定的颜色最接近的颜色的索引值 imagecolorclosestalpha 取得与指定的颜色加透明度最接近的颜色 imagecolorclosesthwb 取得与给定颜色最接近的色度的黑白色的索引 imagecolordeallocate 取消图像颜色的分配 imagecolorexact 取得指定颜色的索引值 imagecolorexactalpha 取得指定的颜色加透明度的索引值 imagecolormatch 使一个图像中调色板版本的颜色与真彩色版本更能匹配 imagecolorresolve 取得指定颜色的索引值或有可能得到的最接近的替代值 imagecolorresolvealpha 取得指定颜色 + alpha 的索引值或有可能得到的最接近的替代值 imagecolorset 给指定调色板索引设定颜色 imagecolorsforindex 取得某索引的颜色 imagecolorstotal 取得一幅图像的调色板中颜色的数目 imagecolortransparent 将某个颜色定义为透明色 imageconvolution 用系数 div 和 offset 申请一个 3x3 的卷积矩阵 imagecopy 拷贝图像的一部分 imagecopymerge 拷贝并合并图像的一部分 imagecopymergegray 用灰度拷贝并合并图像的一部分 imagecopyresampled 重采样拷贝部分图像并调整大小 imagecopyresized 拷贝部分图像并调整大小 imagecreate 新建一个基于调色板的图像 imagecreatefromgd2 从 GD2 文件或 URL 新建一图像 imagecreatefromgd2part 从给定的 GD2 文件或 URL 中的部分新建一图像 imagecreatefromgd 从 GD 文件或 URL 新建一图像 imagecreatefromgif 由文件或URL创建一个新图象 imagecreatefromjpeg 由文件或URL创建一个新图象 imagecreatefrompng 由文件或URL创建一个新图象 imagecreatefromstring 从字符串中的图像流新建一图像 imagecreatefromwbmp 由文件或URL创建一个新图象 imagecreatefromxbm 由文件或URL创建一个新图象 imagecreatefromxpm 由文件或URL创建一个新图象 imagecreatetruecolor 新建一个真彩色图像 imagedashedline 画一虚线 imagedestroy 销毁一图像 imageellipse 画一个椭圆 imagefill 区域填充 imagefilledarc 画一椭圆弧且填充 imagefilledellipse 画一椭圆并填充 imagefilledpolygon 画一多边形并填充 imagefilledrectangle 画一矩形并填充 imagefilltoborder 区域填充到指定颜色的边界为止 imagefilter 对图像使用过滤器 imagefontheight 取得字体高度 imagefontwidth 取得字体宽度 imageftbbox 给出一个使用 FreeType 2 字体的文本框 imagefttext 使用 FreeType 2 字体将文本写入图像 imagegammacorrect 对 GD 图像应用 gamma 修正 imagegd2 将 GD2 图像输出到浏览器或文件 imagegd 将 GD 图像输出到浏览器或文件 imagegif 输出图象到浏览器或文件 imagegrabscreen Captures the whole screen imagegrabwindow Captures a window imageinterlace 激活或禁止隔行扫描 imageistruecolor 检查图像是否为真彩色图像 imagejpeg 输出图象到浏览器或文件 imagelayereffect 设定 alpha 混色标志以使用绑定的 libgd 分层效果 imageline 画一条线段 imageloadfont 载入一新字体 imagepalettecopy 将调色板从一幅图像拷贝到另一幅 imagepng 以 PNG 格式将图像输出到浏览器或文件 imagepolygon 画一个多边形 imagepsbbox 给出一个使用 PostScript Type1 字体的文本方框 imagepsencodefont 改变字体中的字符编码矢量 imagepsextendfont 扩充或精简字体 imagepsfreefont 释放一个 PostScript Type 1 字体所占用的内存 imagepsloadfont 从文件中加载一个 PostScript Type 1 字体 imagepsslantfont 倾斜某字体 imagepstext 用 PostScript Type1 字体把文本字符串画在图像上 imagerectangle 画一个矩形 imagerotate 用给定角度旋转图像 imagesavealpha 设置标记以在保存 PNG 图像时保存完整的 alpha 通道信息（与单一透明色相反） imagesetbrush 设定画线用的画笔图像 imagesetpixel 画一个单一像素 imagesetstyle 设定画线的风格 imagesetthickness 设定画线的宽度 imagesettile 设定用于填充的贴图 imagestring 水平地画一行字符串 imagestringup 垂直地画一行字符串 imagesx 取得图像宽度 imagesy 取得图像高度 imagetruecolortopalette 将真彩色图像转换为调色板图像 imagettfbbox 取得使用 TrueType 字体的文本的范围 imagettftext 用 TrueType 字体向图像写入文本 imagetypes 返回当前 PHP 版本所支持的图像类型 imagewbmp 以 WBMP 格式将图像输出到浏览器或文件 imagexbm 将 XBM 图像输出到浏览器或文件 iptcembed 将二进制 IPTC 数据嵌入到一幅 JPEG 图像中 iptcparse 将二进制 IPTC http://www.iptc.org/ 块解析为单个标记 jpeg2wbmp 将 JPEG 图像文件转换为 WBMP 图像文件 png2wbmp 将 PNG 图像文件转换为 WBMP 图像文件 session函数 方法 说明 session_cache_expire 返回当前缓存到期 session_cache_limiter get和set the current缓存限制/金 session_commit session_write_close 的别名 session_decode 将会话数据从一个会话编码的字符串 session_destroy 销毁已注册到会话的所有数据 session_encode 将当前会话数据编码为一个字符串 session_get_cookie_params 获得会话饼干参数 session_id 获得和/或设置当前会话标识 session_is_registered 检查变量是否在会话中已经注册 session_module_name 获得和/或设置当前会话模块 session_name 获得和/或设置当前会话名称 session_regenerate_id 更新新生成的会话标识 session_register_shutdown 会话关机功能 session_register 注册一个或多个全局变量与当前会话 session_save_path 获取和/或设置当前会话保存路径 session_set_cookie_params 设置会话饼干参数 session_set_save_handler 设置用户级会话存储功能 session_start 开始新的或恢复现有的会话 session_status 返回当前会话状态 session_unregister 注销当前会话的一个全局变量 session_unset 自由所有会话变量 session_write_close 写会话数据和结束会话 cookie函数 方法 说明 setcookie 设置cookie setrawcookie 发送没有URL编码的cookie Date/Time 函数 方法 说明 checkdate 验证一个格里高里日期 date_add 别名 DateTime::add date_create_from_format 别名 DateTime::createFromFormat date_create 别名 DateTime::__construct date_date_set 别名 DateTime::setDate date_default_timezone_get 取得一个脚本中所有日期时间函数所使用的默认时区 date_default_timezone_set 设定用于一个脚本中所有日期时间函数的默认时区 date_diff 别名 DateTime::diff date_format 别名 DateTime::format date_get_last_errors 别名 DateTime::getLastErrors date_interval_create_from_date_string 别名 DateInterval::createFromDateString date_interval_format 别名 DateInterval::format date_isodate_set 别名 DateTime::setISODate date_modify 别名 DateTime::modify date_offset_get 别名 DateTime::getOffset date_parse_from_format Get info about given date formatted according to the specified format date_parse Returns associative array with detailed info about given date date_sub 别名 DateTime::sub date_sun_info Returns an array with information about sunset/sunrise and twilight begin/end date_sunrise 返回给定的日期与地点的日出时间 date_sunset 返回给定的日期与地点的日落时间 date_time_set 别名 DateTime::setTime date_timestamp_get 别名 DateTime::getTimestamp date_timestamp_set 别名 DateTime::setTimestamp date_timezone_get 别名 DateTime::getTimezone date_timezone_set 别名 DateTime::setTimezone date 格式化一个本地时间／日期 getdate 取得日期／时间信息 gettimeofday 取得当前时间 gmdate 格式化一个 GMT/UTC 日期／时间 gmmktime 取得 GMT 日期的 UNIX 时间戳 gmstrftime 根据区域设置格式化 GMT/UTC 时间／日期 idate 将本地时间日期格式化为整数 localtime 取得本地时间 microtime 返回当前 Unix 时间戳和微秒数 mktime 取得一个日期的 Unix 时间戳 strftime 根据区域设置格式化本地时间／日期 strptime 解析由 strftime 生成的日期／时间 strtotime 将任何英文文本的日期时间描述解析为 Unix 时间戳 time 返回当前的 Unix 时间戳 timezone_abbreviations_list 别名 DateTimeZone::listAbbreviations timezone_identifiers_list 别名 DateTimeZone::listIdentifiers timezone_location_get 别名 DateTimeZone::getLocation timezone_name_from_abbr Returns the timezone name from abbreviation timezone_name_get 别名 DateTimeZone::getName timezone_offset_get 别名 DateTimeZone::getOffset timezone_open 别名 DateTimeZone::__construct timezone_transitions_get 别名 DateTimeZone::getTransitions timezone_version_get Gets the version of the timezonedb]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTTP状态代码]]></title>
    <url>%2F2019%2F05%2F05%2FHTTP%E7%8A%B6%E6%80%81%E4%BB%A3%E7%A0%81%2F</url>
    <content type="text"><![CDATA[HTTP 状态代码指示特定 HTTP 请求是否已成功完成。响应分为五类：信息响应，成功响应，重定向，客户端错误和服务器错误。 常见的状态代码 200 服务器成功返回内容 301/2 永久/临时重定向 304 未修改 Not Modified 307 重定向中保留原始数据 404 请求的页面不存在 500 服务器内部错误 503 服务器暂时不可用 分类 代码 说明 1** 信息，服务器收到请求，需要请求者继续执行操作 2** 成功，操作被成功接收并处理 3** 重定向，需要进一步的操作以完成请求 4** 客户端错误，请求包含语法错误或无法完成请求 5** 服务器错误，服务器在处理请求的过程中发生了错误 信息响应 代码 说明 100 Continue 这个临时响应表明，迄今为止的所有内容都是可行的，客户端应该继续请求，如果已经完成，则忽略它。 101 Switching Protocol 该代码是响应客户端的 Upgrade 标头发送的，并且指示服务器也正在切换的协议。 102 Processing 此代码表示服务器已收到并正在处理该请求，但没有响应可用。 103 Early Hints 此状态代码主要用于与Link 链接头一起使用，以允许用户代理在服务器仍在准备响应时开始预加载资源 成功响应 代码 说明 200 OK 请求成功。成功的含义取决于HTTP方法：GET：资源已被提取并在消息正文中传输。HEAD：实体标头位于消息正文中。POST：描述动作结果的资源在消息体中传输。TRACE：消息正文包含服务器收到的请求消息 201 Created 该请求已成功，并因此创建了一个新的资源。这通常是在PUT请求之后发送的响应。 202 Accepted 请求已经接收到，但还未响应，没有结果。意味着不会有一个异步的响应去表明当前请求的结果，预期另外的进程和服务去处理请求，或者批处理。 203 Non-Authoritative Information 服务器已成功处理了请求，但返回的实体头部元信息不是在原始服务器上有效的确定集合，而是来自本地或者第三方的拷贝。当前的信息可能是原始版本的子集或者超集。例如，包含资源的元数据可能导致原始服务器知道元信息的超集。使用此状态码不是必须的，而且只有在响应不使用此状态码便会返回200 OK的情况下才是合适的。 204 No Content 服务器成功处理了请求，但不需要返回任何实体内容，并且希望返回更新了的元信息。响应可能通过实体头部的形式，返回新的或更新后的元信息。如果存在这些头部信息，则应当与所请求的变量相呼应。如果客户端是浏览器的话，那么用户浏览器应保留发送了该请求的页面，而不产生任何文档视图上的变化，即使按照规范新的或更新后的元信息应当被应用到用户浏览器活动视图中的文档。由于204响应被禁止包含任何消息体，因此它始终以消息头后的第一个空行结尾。 205 Reset Content 服务器成功处理了请求，且没有返回任何内容。但是与204响应不同，返回此状态码的响应要求请求者重置文档视图。该响应主要是被用于接受用户输入后，立即重置表单，以便用户能够轻松地开始另一次输入。与204响应一样，该响应也被禁止包含任何消息体，且以消息头后的第一个空行结束。 206 Partial Content 服务器已经成功处理了部分 GET 请求。类似于 FlashGet 或者迅雷这类的 HTTP 下载工具都是使用此类响应实现断点续传或者将一个大文档分解为多个下载段同时下载。该请求必须包含 Range 头信息来指示客户端希望得到的内容范围，并且可能包含 If-Range 来作为请求条件。 207 Multi-Status 由WebDAV(RFC 2518)扩展的状态码，代表之后的消息体将是一个XML消息，并且可能依照之前子请求数量的不同，包含一系列独立的响应代码。 208 Multi-Status 在 DAV 里面使用: propstat 响应元素以避免重复枚举多个绑定的内部成员到同一个集合。 226 IM Used 服务器已经完成了对资源的 GET 请求，并且响应是对当前实例应用的一个或多个实例操作结果的表示。 重定向 代码 说明 300 Multiple Choice 被请求的资源有一系列可供选择的回馈信息，每个都有自己特定的地址和浏览器驱动的商议信息。用户或浏览器能够自行选择一个首选的地址进行重定向。 301 Moved Permanently 被请求的资源已永久移动到新位置，并且将来任何对此资源的引用都应该使用本响应返回的若干个 URI 之一。如果可能，拥有链接编辑功能的客户端应当自动把请求的地址修改为从服务器反馈回来的地址。除非额外指定，否则这个响应也是可缓存的。 302 Found 请求的资源现在临时从不同的 URI 响应请求。由于这样的重定向是临时的，客户端应当继续向原有地址发送以后的请求。只有在Cache-Control或Expires中进行了指定的情况下，这个响应才是可缓存的。 303 See Other 对应当前请求的响应可以在另一个 URI 上被找到，而且客户端应当采用 GET 的方式访问那个资源。这个方法的存在主要是为了允许由脚本激活的POST请求输出重定向到一个新的资源。 304 Not Modified 如果客户端发送了一个带条件的 GET 请求且该请求已被允许，而文档的内容（自上次访问以来或者根据请求的条件）并没有改变，则服务器应当返回这个状态码。304 响应禁止包含消息体，因此始终以消息头后的第一个空行结尾。 305 Use Proxy 被请求的资源必须通过指定的代理才能被访问。Location 域中将给出指定的代理所在的 URI 信息，接收者需要重复发送一个单独的请求，通过这个代理才能访问相应资源。只有原始服务器才能建立305响应。 306 unused 在最新版的规范中，306 状态码已经不再被使用。 307 Temporary Redirect 请求的资源现在临时从不同的URI 响应请求。由于这样的重定向是临时的，客户端应当继续向原有地址发送以后的请求。只有在Cache-Control或Expires中进行了指定的情况下，这个响应才是可缓存的。 308 Permanent Redirect 这意味着资源现在永久位于由 Location: HTTP Response 标头指定的另一个 URI。 这与 301 Moved Permanently HTTP 响应代码具有相同的语义，但用户代理不能更改所使用的 HTTP 方法：如果在第一个请求中使用 POST，则必须在第二个请求中使用 POST。 客户端响应 代码 说明 400 Bad Request 1、语义有误，当前请求无法被服务器理解。除非进行修改，否则客户端不应该重复提交这个请求。2、请求参数有误。 401 Unauthorized 当前请求需要用户验证。该响应必须包含一个适用于被请求资源的 WWW-Authenticate 信息头用以询问用户信息。客户端可以重复提交一个包含恰当的 Authorization 头信息的请求。如果当前请求已经包含了 Authorization 证书，那么401响应代表着服务器验证已经拒绝了那些证书。如果401响应包含了与前一个响应相同的身份验证询问，且浏览器已经至少尝试了一次验证，那么浏览器应当向用户展示响应中包含的实体信息，因为这个实体信息中可能包含了相关诊断信息。 402 Payment Required 此响应码保留以便将来使用，创造此响应码的最初目的是用于数字支付系统，然而现在并未使用 403 Forbidden 服务器已经理解请求，但是拒绝执行它。与 401 响应不同的是，身份验证并不能提供任何帮助，而且这个请求也不应该被重复提交。如果这不是一个 HEAD 请求，而且服务器希望能够讲清楚为何请求不能被执行，那么就应该在实体内描述拒绝的原因。当然服务器也可以返回一个 404 响应，假如它不希望让客户端获得任何信息。 404 Not Found 请求失败，请求所希望得到的资源未被在服务器上发现。没有信息能够告诉用户这个状况到底是暂时的还是永久的。假如服务器知道情况的话，应当使用410状态码来告知旧资源因为某些内部的配置机制问题，已经永久的不可用，而且没有任何可以跳转的地址。404这个状态码被广泛应用于当服务器不想揭示到底为何请求被拒绝或者没有其他适合的响应可用的情况下。 405 Method Not Allowed 请求行中指定的请求方法不能被用于请求相应的资源。该响应必须返回一个Allow 头信息用以表示出当前资源能够接受的请求方法的列表。 鉴于 PUT，DELETE 方法会对服务器上的资源进行写操作，因而绝大部分的网页服务器都不支持或者在默认配置下不允许上述请求方法，对于此类请求均会返回405错误。 406 Not Acceptable 请求的资源的内容特性无法满足请求头中的条件，因而无法生成响应实体。 407 Proxy Authentication Required 与401响应类似，只不过客户端必须在代理服务器上进行身份验证。代理服务器必须返回一个 Proxy-Authenticate 用以进行身份询问。客户端可以返回一个 Proxy-Authorization 信息头用以验证。 408 Request Timeout 请求超时。客户端没有在服务器预备等待的时间内完成一个请求的发送。客户端可以随时再次提交这一请求而无需进行任何更改。 409 Conflict 由于和被请求的资源的当前状态之间存在冲突，请求无法完成。这个代码只允许用在这样的情况下才能被使用：用户被认为能够解决冲突，并且会重新提交新的请求。该响应应当包含足够的信息以便用户发现冲突的源头。 410 Gone 被请求的资源在服务器上已经不再可用，而且没有任何已知的转发地址。这样的状况应当被认为是永久性的。如果可能，拥有链接编辑功能的客户端应当在获得用户许可后删除所有指向这个地址的引用。如果服务器不知道或者无法确定这个状况是否是永久的，那么就应该使用 404 状态码。除非额外说明，否则这个响应是可缓存的。 411 Length Required 服务器拒绝在没有定义 Content-Length 头的情况下接受请求。在添加了表明请求消息体长度的有效 Content-Length 头之后，客户端可以再次提交该请求。 412 Precondition Failed 服务器在验证在请求的头字段中给出先决条件时，没能满足其中的一个或多个。这个状态码允许客户端在获取资源时在请求的元信息（请求头字段数据）中设置先决条件，以此避免该请求方法被应用到其希望的内容以外的资源上。 413 Payload Too Large 服务器拒绝处理当前请求，因为该请求提交的实体数据大小超过了服务器愿意或者能够处理的范围。此种情况下，服务器可以关闭连接以免客户端继续发送此请求。如果这个状况是临时的，服务器应当返回一个 Retry-After 的响应头，以告知客户端可以在多少时间以后重新尝试。 414 URI Too Long 请求的URI 长度超过了服务器能够解释的长度，因此服务器拒绝对该请求提供服务。这比较少见，通常的情况包括：本应使用POST方法的表单提交变成了GET方法，导致查询字符串（Query String）过长。 415 Unsupported Media Type 对于当前请求的方法和所请求的资源，请求中提交的实体并不是服务器中所支持的格式，因此请求被拒绝。 416 Requested Range Not Satisfiable 如果请求中包含了 Range 请求头，并且 Range 中指定的任何数据范围都与当前资源的可用范围不重合，同时请求中又没有定义 If-Range 请求头，那么服务器就应当返回416状态码。 417 Expectation Failed 此响应代码意味着服务器无法满足 Expect 请求标头字段指示的期望值。 418 I’m a teapot 服务器拒绝尝试用 “茶壶冲泡咖啡”。 421 Misdirected Request 该请求针对的是无法产生响应的服务器。 这可以由服务器发送，该服务器未配置为针对包含在请求 URI 中的方案和权限的组合产生响应。 422 Unprocessable Entity 请求格式良好，但由于语义错误而无法遵循。 423 Locked 正在访问的资源被锁定 424 Failed Dependency 由于先前的请求失败，所以此次请求失败。 425 Too Early 服务器不愿意冒着风险去处理可能重播的请求. 426 Upgrade Required 服务器拒绝使用当前协议执行请求，但可能在客户机升级到其他协议后愿意这样做。 服务器在 426 响应中发送 Upgrade 头以指示所需的协议。 428 Precondition Required 原始服务器要求该请求是有条件的。 旨在防止“丢失更新”问题，即客户端获取资源状态，修改该状态并将其返回服务器，同时第三方修改服务器上的状态，从而导致冲突。 429 Too Many Requests 用户在给定的时间内发送了太多请求（“限制请求速率”）。 431 Request Header Fields Too Large 服务器不愿意处理请求，因为它的 请求头字段太大（ Request Header Fields Too Large）。 请求可以在减小请求头字段的大小后重新提交。 451 Unavailable For Legal Reasons 用户请求非法资源，例如：由政府审查的网页。 服务端响应 代码 说明 500 Internal Server Error 服务器遇到了不知道如何处理的情况。 501 Not Implemented 此请求方法不被服务器支持且无法被处理。只有GET和HEAD是要求服务器支持的，它们必定不会返回此错误代码。 502 Bad Gateway 此错误响应表明服务器作为网关需要得到一个处理这个请求的响应，但是得到一个错误的响应。 503 Service Unavailable 服务器没有准备好处理请求。 常见原因是服务器因维护或重载而停机。 请注意，与此响应一起，应发送解释问题的用户友好页面。 这个响应应该用于临时条件和 Retry-After：如果可能的话，HTTP头应该包含恢复服务之前的估计时间。 网站管理员还必须注意与此响应一起发送的与缓存相关的标头，因为这些临时条件响应通常不应被缓存。 504 Gateway Timeout 当服务器作为网关，不能及时得到响应时返回此错误代码。 505 HTTP Version Not Supported 服务器不支持请求中所使用的HTTP协议版本。 506 Variant Also Negotiates 服务器有一个内部配置错误：对请求的透明内容协商导致循环引用。 507 Insufficient Storage 服务器有内部配置错误：所选的变体资源被配置为参与透明内容协商本身，因此不是协商过程中的适当端点。 508 Loop Detected 服务器在处理请求时检测到无限循环。 510 Not Extended 客户端需要对请求进一步扩展，服务器才能实现它。服务器会回复客户端发出扩展请求所需的所有信息。 511 Network Authentication Required 511 状态码指示客户端需要进行身份验证才能获得网络访问权限。 参考资料https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Status]]></content>
      <categories>
        <category>HTTP</category>
      </categories>
      <tags>
        <tag>HTTP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mac Homebrew常用命令]]></title>
    <url>%2F2019%2F05%2F04%2FMac-Homebrew%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[Homebrew是Mac OSX上的软件包管理工具，能在Mac中方便的安装软件或者卸载软件， 使用命令，非常方便。 常用命令1234567891011121314$ brew --help #简洁命令帮助$ man brew #完整命令帮助$ brew install git #安装软件包(这里是示例安装的Git版本控制)$ brew uninstall git #卸载软件包$ brew search git #搜索软件包$ brew list #显示已经安装的所有软件包$ brew update #同步远程最新更新情况，对本机已经安装并有更新的软件用*标明$ brew outdated #查看已安装的哪些软件包需要更新$ brew upgrade git #更新单个软件包$ brew info git #查看软件包信息$ brew home git #访问软件包官方站$ brew cleanup #清理所有已安装软件包的历史老版本$ brew cleanup git #清理单个已安装软件包的历史版本$ brew tap #可以为brew的软件的 跟踪,更新,安装添加更多的的tap formulae 程序安装路径及文件夹 bin #用于存放所安装程序的启动链接（相当于快捷方式） Cellar #所有brew安装的程序，都将以[程序名/版本号]存放于本目录下 etc #brew安装程序的配置文件默认存放路径 Library #Homebrew 系统自身文件夹 Formula #程序的下载路径和编译参数及安装路径等配置文件存放地 Homebrew #brew程序自身命令集 替换及重置Homebrew默认源 替换brew.git: 12$ cd "$(brew --repo)"$ git remote set-url origin https://mirrors.ustc.edu.cn/brew.git ​ 可选镜像源： 123https://git.coding.net/homebrew/homebrew.git - Codinghttps://mirrors.tuna.tsinghua.edu.cn/git/homebrew/brew.git - 清华https://mirrors.ustc.edu.cn/brew.git - 中科大 替换homebrew-core.git: 12$ cd "$(brew --repo)/Library/Taps/homebrew/homebrew-core"$ git remote set-url origin https://mirrors.ustc.edu.cn/homebrew-core.git 重置brew.git: 12$ cd "$(brew --repo)"$ git remote set-url origin https://github.com/Homebrew/brew.git 重置homebrew-core.git: 12$ cd "$(brew --repo)/Library/Taps/homebrew/homebrew-core"$ git remote set-url origin https://github.com/Homebrew/homebrew-core.git LaunchRocketLaunchRecket是管理homebrew所安装应用的一个管理器，它在系统设置中。 1234# installbrew cask install launchrocket# uninstallbrew cask uninstall launchrocket https://github.com/jimbojsb/launchrocket 参考链接https://mirrors.tuna.tsinghua.edu.cn/help/homebrew/]]></content>
      <categories>
        <category>程序人生</category>
      </categories>
      <tags>
        <tag>Homebrew</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MacOS Apache配置]]></title>
    <url>%2F2019%2F05%2F04%2FMacOS-Apache%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[环境 macOS Mojave 10.14.4 Apache/2.4.38 查看ApachemacOS系统自带Apache软件，我们直接在命令行下查看Apache版本： 123$ httpd -vServer version: Apache/2.4.38 (Unix)Server built: Feb 10 2019 02:48:38 启动Apache命令行直接启动，如果是普通用户下需要sudo，普通用户没有权限操作apachectl 123$ sudo apachectl start$ sudo apachectl stop$ sudo apachectl restart mac 下 Apache 默认的目录在 /Library/WebServer 下 开启Apache多用户主目录执行 sudo vim /etc/apache2/httpd.conf 打开 httpd.conf 文件，然后查找 userdir 12# User home directories#Include /private/etc/apache2/extra/httpd-userdir.conf 1#LoadModule userdir_module libexec/apache2/mod_userdir.so 去掉前面#注释即可。 接着再编辑 /private/etc/apache2/extra/httpd-userdir.conf 文件，增加内容： 1UserDir Sites 如果有则不用添加了。 配置虚拟主机执行 sudo vim /etc/apache2/httpd.conf，查找vhost 1#LoadModule vhost_alias_module libexec/apache2/mod_vhost_alias.so 12# Virtual hosts#Include /private/etc/apache2/extra/httpd-vhosts.conf 去掉前面#注释即可。再修改/private/etc/apache2/extra/httpd-vhosts.conf配置即可。 使用Homebrew代替自带的由于之前不知道搞了什么，自带的怎么更改都不生效，所以重新安装了。 安装apache123$ brew tap homebrew/apache$ brew tap homebrew/php$ brew install httpd 配置apache配置文件路径为/usr/local/etc/httpd/httpd.conf，配置的方法和上述自带无差别。只是配置路径发生了变化。 配置PHP模块12345678910LoadModule php7_module /usr/local/Cellar/php@7.1/7.1.26/lib/httpd/modules/libphp7.so&lt;IfModule mod_php7.c&gt; AddType application/x-httpd-php .php AddType application/x-httpd-php-source .phps &lt;IfModule mod_dir.c&gt; DirectoryIndex index.html index.php &lt;/IfModule&gt;&lt;/IfModule&gt; 找到所在php的so文件添加进配置即可，php版本可根据自己需要更改。]]></content>
      <categories>
        <category>Apache</category>
      </categories>
      <tags>
        <tag>环境搭建</tag>
        <tag>Apache</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Apache配置文件详解]]></title>
    <url>%2F2019%2F04%2F29%2FApache%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[环境 Centos7 Apache/2.4.38 配置文件路径找到apache所在的配置文件，在本文环境下即centos7以yum源安装的httpd所在的配置环境路径为/etc/httpd/conf。也可以使用命令找到该配置文件。 1$ sudo find / -name 'httpd.conf' 以下以本文中的配置路径为准，其他系统下路径可能不一致。在 Ubnutu/Mac 上，apache 服务叫 apache2，而不是 httpd（在 Centos 上叫 httpd），主配置文件为 /etc/apache2/apache2.conf Apache配置文件Apache提供了灵活的web服务配置，理解其参数的含义很重要。 Apache配置文件中英文对照：http://www.cnblogs.com/adamite/p/apache_configuration.html Apache主目录ServerRoot &quot;/etc/httpd&quot; 监听端口Listen 80 加载动态模块LoadModule php5_module modules/libphp5.so 或者加载动态模块的配置文件 Include conf.modules.d/*.conf Apache的进程执行者12User apacheGroup apache 服务器域名该项可配置也可不配置 ServerName www.example.com:80 网站根目录DocumentRoot &quot;/var/www/html&quot; 设置网站根目录的访问权限123456789101112131415161718192021222324252627&lt;Directory &quot;/var/www/html&quot;&gt; # # Possible values for the Options directive are &quot;None&quot;, &quot;All&quot;, # or any combination of: # Indexes Includes FollowSymLinks SymLinksifOwnerMatch ExecCGI MultiViews # # Note that &quot;MultiViews&quot; must be named *explicitly* --- &quot;Options All&quot; # doesn&apos;t give it to you. # # The Options directive is both complicated and important. Please see # http://httpd.apache.org/docs/2.4/mod/core.html#options # for more information. # Options Indexes FollowSymLinks # # AllowOverride controls what directives may be placed in .htaccess files. # It can be &quot;All&quot;, &quot;None&quot;, or any combination of the keywords: # Options FileInfo AuthConfig Limit # AllowOverride None # # Controls who can get stuff from this server. # Require all granted&lt;/Directory&gt; 参数详解 Allow from all 参数允许所有人访问/var/www/html下的资源 Deny from all 参数拒绝所有人访问/var/www/html下的资源 Options Indexes 参数:访问目录时,如果不存在默认首页则展示站点列表 该行建议改成 Options None Options FollowSymLinks 参数:是否允许快捷方式(ln -s 软连接) Options MultiViews 多视图,访问/index等同访问index.php或index.html Apache服务器访问权限控制包括:Apache 服务权限12deny from all (**403 forbidden** error!)allow from all Linux 系统权限123selinuxiptableshttpd进程执行者对根目录的权限(**403 forbidden** error!) 设置目录默认首页优先级从左往右依次降低 DirectoryIndex index.html index.php 错误日志ErrorLog &quot;logs/error_log&quot; 访问日志CustomLog &quot;logs/access_log&quot; common 解析php脚本AddType application/x-httpd-php .php 控制错误页面的输出1234#ErrorDocument 500 &quot;The server made a boo boo.&quot;#ErrorDocument 404 /missing.html#ErrorDocument 404 &quot;/cgi-bin/missing_handler.pl&quot;#ErrorDocument 402 http://www.example.com/subscription_info.html 包含外部配置文件Include extra/httpd-vhosts.conf 虚拟目录http://localhost/mnt mnt目录并不在网站根目录下,目录资源在/tmp/mnt目录下 在/usr/local/apache2/etc/http.conf文件里增加 12345678Alias /mnt &quot;/mnt/www&quot; # 虚拟目录（目录别名）&lt;Directory &quot;/mnt/www&quot;&gt; Options none AllowOverride None Order allow,deny Deny from all # 拒绝所有 Allow from all # 允许所有&lt;/Directory&gt; http://localhost/mnt 重启apache后访问的资源便是 /mnt/www目录下的资源 Apache虚拟主机配置基于域名的虚拟主机，指定服务器IP（和可能的端口）使主机接受请求。用NameVirtualHost进行配置。 如果服务器上所有的IP地址都会用到，可以用*作为NameVirtualHost的参数。在NameVirtualHost指令中指明IP地址不会使服务器自动侦听那个IP地址。 找到Apache的主配置文件httpd.conf12$ cd /etc/httpd/conf$ vim httpd.conf 我们搜索关键字vhosts，如果没有则在文件后添加 12# Load vhost-config files in the &quot;/etc/httpd/vhost-conf.d&quot; directory if anyInclude vhost.d/*.conf 不使用官方原版的单个配置文件有个好处是 每个虚拟主机配置独立开来 减少操作的误差 然后我们到/etc/httpd/目录下创建vhost.d文件夹 12345$ mkdir vhost.d$ cd vhost.d$ pwd/etc/httpd/vhost.d$ vim www_sweetlover_cn_net.conf 添加以下内容 1234567891011121314151617&lt;VirtualHost *:80&gt; ServerAdmin zjyzy@www.sweetlover.net.cn DocumentRoot /var/www/html/sweetlover ServerName www.sweetlover.net.cn RewriteEngine On Options All &lt;Directory &quot;/var/www/html/sweetlover&quot;&gt; # Options -Indexes FollowSymLinks # 为了服务器的安全 Indexes参数一般要取消 Options FollowSymLinks AllowOverride All Allow from all &lt;/Directory&gt; ErrorLog logs/www_sweetlover_net_cn-error_log CustomLog logs/www_sweetlover_net_cn-access_log common&lt;/VirtualHost&gt; 再次修改主配置文件httpd.conf,找到Listen 80，添加以下代码 12Listen 80NameVirtualHost *:80 我们再配置一个同域名下不同端口虚拟主机，配置8080端口下的 12$ cd /etc/httpd/vhost.d$ vim www_sweetlover_net_cn_8080.conf 针对www_sweetlover_cn_net.conf改变相应的配置，即修改ServerName为www.sweetlover.net.cn:8080，DocumentRoot和Directory修改为/var/www/html/sweetlover@8080。 修改主配置文件，添加 12Listen 8080NameVirtualHost *:8080 由于环境下为虚拟机环境，直接访问ip加端口号即可访问到配置的网站。在上述配置的DocumentRoot下创建index.html或者index.php即可访问网页。 如果出现该错误 1[warn] default VirtualHost overlap on port 80, the first has precedence 打开apache主配置文件在任意位置添加一行,在 40行的Listion:80后添加一行内容如下:NameVirtualHost *:80 如果使用源码编译安装的，直接去掉注释即可，然后再修改配置文件 1#LoadModule vhost_alias_module libexec/apache2/mod_vhost_alias.so 12# Virtual hosts#Include /private/etc/apache2/extra/httpd-vhosts.conf 去掉前面#注释即可。再修改/private/etc/apache2/extra/httpd-vhosts.conf配置即可。 Apache常见错误ServerName配置未填写或错误1httpd: Could not reliably determine the server's fully qualified domain name, using luo.centos6.5 for ServerName 在Apache主配置文件httpd.conf的98行左右#ServerName www.example.com:80前面的#去掉，换成自己的域名或者ip地址。例如：修改为ServerName localhost:80或者ServerName 127.0.0.1:80 403 Forbidden错误123403 - Forbidden（禁止访问）,服务器拒绝请求 - forbidden request (matches a deny filter) =&gt; HTTP 403 - The request was a legal request, but the server is refusing to respond to it. 原因1：apache的配置文件没有对站点目录许可 apache配置文件中没有对站点目录的权限许可配置，这通常是在初始化安装apahce后，更改了默认的apache站点目录导致。 解决办法可能是：通过给主配置文件增加&lt;Directory &quot;/var/www/html&quot;&gt;&lt;/Directory&gt;标签实现对指定目录的权限控制典型如下(对/var/www目录下的文件允许访问)： 123456&lt;Directory &quot;/var/www&quot;&gt; Options -Indexes FollowSymLinks # 为了服务器的安全 Indexes参数一般要取消 AllowOverride None Order allow,deny # 允许未被明确拒绝的 Allow from all&lt;/Directory&gt; 原因2：站点目录下没有首页文件，而apache 的配置又禁止了目录的浏览 站点目录下没有首页文件(index.php、index.html等默认文件)，而apache的配置又禁止了目录浏览（#Indexes参数:访问目录时,如果不存在默认首页则展示站点列表，该行建议改成Options None，也会提示403错误。解决办法：在站点目录添加默认首页文件或者将配置文件中Options Index增加上。 原因3：deny from all 禁用了所有来访者访问 1234567&lt;Directory &quot;/var/www&quot;&gt; Options -Indexes FollowSymLinks # 为了服务器的安全 Indexes参数一般要取消 AllowOverride None Order allow,deny # 允许未被明确拒绝的 Deny from all # Deny from &lt;/Directory&gt; 解决办法：参考原因2解决方法配置&lt;Directory &gt;&lt;/Directory&gt;参数。 站点目录权限问题 站点目录需要apache的用户有访问权限，否则就会报403错误(一般web站点目录权限给755，站点文件权限给644，上传程序通过另外的上传服务器提供文件上传)。 Apache服务器优化错误页面优雅显示可以将404 500等的错误信息页面重定向到网站首页或其他页面，提升用户体验。 编辑apache主配置文件1$ vim httpd.conf 修改如下内容ErrorDocument 404 http://www.domain.com mod_defalte文件压缩功能gzip是把文件先在服务器端进行压缩然后再传输，传输完毕后浏览器会重新对压缩过得内容进行解压缩。这样可以显著减少文件传输的大小，没有特殊情况，所有的文本内容都应该被gzip压缩（html,css,js,xml,txt..） 添加如下内容到httpd.conf或者vhost.conf中 1234567&lt;ifmodule mod_deflate.c&gt; DeflateCompressionLevel 9 SetOutputFilter DEFLATE AddOutputFilterByType DEFLATE text/html text/plain text/xml AddOutputFilterByType DEFLATE application/javscript AddOutputFilterByType DEFLATE text/css&lt;/ifmodule&gt; 更改apache的默认用户创建apache用户，用于子进程和线程 1$ useradd -M -s /sbin/nologin webadmin 编辑apache的主配置文件,添加或者修改如下内容 12User webadminGroup webadmin 开启apache防盗链功能主配置文件中增加如下配置 12345678&lt;IfModule rewrite_module&gt;RewriteEngine OnRewriteCond %&#123;HTTP_REFERER&#125; !^http://domain.com/.*$ [NC]RewriteCond %&#123;HTTP_REFERER&#125; !^http://www.domain.com/.*$ [NC]RewriteRule .*\.(gif|jpg|swf)$ http://www.domain.com [R,NC]# RewriteRule .*\.(gif|jpg|swf)$ http://www.domain.com/about/no.png [R,NC]&lt;/IfModule&gt; 禁止目录Index123456&lt;Directory &quot;/var/www/html&quot;&gt; Options -Indexes FollowSymLinks AllowOverride None Order allow,deny Allow from all&lt;/Directory&gt; 或者 123456&lt;Directory &quot;/var/www/html&quot;&gt; Options FollowSymLinks AllowOverride None Order allow,deny Allow from all&lt;/Directory&gt; 禁止用户覆盖(重载)配置文件123456&lt;Directory &quot;/var/www/html&quot;&gt; Options FollowSymLinks AllowOverride None # 禁止用户覆盖(重载)配置文件, All即为开启 Order allow,deny Allow from all&lt;/Directory&gt; 关闭CGI(Common Gateway Interface 通用网关接口)123456789&lt;IfModule alias_module&gt;ScriptAlias /cgi-bin/ &quot;/var/www/cgi-bin/&quot;&lt;/IfModule&gt;&lt;Directory &quot;/var/www/cgi-bin&quot;&gt; AllowOverride None Options None Order allow,deny Allow from all&lt;/Directory&gt; 避免使用.htaccess文件(分布式配置文件)默认选项：AccessFileName .htaccess 改为 # AccessFileName .htaccess 先考虑性能，如果AllowOverride启用了.haccess文件，则apache需要在每个目录中查找.htaccess文件，因此无论是否真正用到启用.htaccess文件都会导致服务器性能的下降。 另外对于每一个请求，都需要读取一次.htaccess文件。 其次是安全考虑，这样会允许用户自己修改服务器的配置，这可能会导致某些意想不到的修改，所以请认真考虑是否应道给予用户这样的特权。 PHP开启路由重写下需要使用 apache 的安全模块mod_evasive20( 防DDOS攻击)mod_limittipconn(针对单站点)配置mod_security(防止SQL注入) apache日志授予root 700权限不需要在日志目录给apache用户读或者写权限许可，因为apache的初始进程用户为root 禁止PHP解析指点站点目录1234567Directory &quot;/var/www/html/bbs/Uploads&quot;&gt; Options FollowSymLinks AllowOverride None Order allow,deny Allow from all php_flag engine off # 注意这行&lt;/Directory&gt; 参考资料https://www.kancloud.cn/curder/apache/91272 https://www.linuxidc.com/Linux/2017-05/143590.htm]]></content>
      <categories>
        <category>Apache</category>
      </categories>
      <tags>
        <tag>服务器运维</tag>
        <tag>Apache</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript-正则表达式基础]]></title>
    <url>%2F2019%2F04%2F28%2FJavaScript-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[正则表达式基础 学习网站https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/RegExp 概念 正则表达式是为了解决字符串操作中一些比较麻烦的场景，比如字符串提取、字符串替换、字符串验证等 常用于：表单验证：是否是一个数字、是一个电话号码、是一个邮箱。。。 字符串替换： 字符串查找 正则表达式其实也是js里面的一个对象创建一个正则表达式 var reg2=new RegExp(&quot;a&quot;); var reg1=/a/; 其中//是标记，a表示要匹配的字符 正则表达式匹配1234567891011121314var reg=/a/; //匹配字符串中的a字符reg.test("abc"); //正则表达式的test用来检测字符串是否满足正则表达式的要求；//由于"abc"中存在a，所以是符合要求的，所以这段代码的返回值为：trueconst isTrue = reg.test("coke"); //由于"coke"中不存在a字符，所以不符合条件 --&gt;isTrue:falsevar reg2=/abc/; reg2.test("adbcd"); //字符串中必然存在"abc"才符合要求，所以这段代码的返回值为falsereg2.test("1abc"); //truereg2.test("abc123"); //truereg2.test("abcabc"); //true 正则表达式特殊字符字符类别 . 表示除了换行符(\r \n)以外的任意字符 123456789101112var reg=/./;reg.test("a"); //truereg.test("."); //truereg.test("\r"); //falsereg.test("1\r"); //存在一个1，不是换行符，所以结果为：truereg.test("\r\n"); //false//注意点：如果以后要匹配.字符，不要直接写.//为了匹配qq邮箱，写了 /qq.com/ 这是一个错误的写法：//=&gt;/qq.com/不仅匹配："qq.com"也匹配"qq3com" "qq@com"//解决方案：/qq\.com/ 或者 /qq[.]com/ \d 表示数字 1234567891011var reg=/\d/;reg.test("123abc"); //由于存在一个数字，所以结果为truereg.test("abcde"); //由于不存在任何数字，所以结果为false//扩展：var _reg=/\d\d/;_reg.test("1b"); //不存在2个连续数字，所以结果为：false_reg.test("a12c"); //存在2个连续数字，结果为：true//匹配手机号码：出现了连续11个数字var isCellphoneNumber=/\d\d\d\d\d\d\d\d\d\d\d/; 案例：匹配手机号码 1234var reg = /\d\d\d\d\d\d\d\d\d\d\d/;reg.test("13532159091"); //truereg.test("17380889395"); //truereg.test("a7380889395"); //false \D 是\d的取反结果，表示不是数字 1234567var reg=/\D/;_reg.test("123"); //由于全是数字，所以结果为：false_reg.test("123a"); //存在一个字母，所以结果为：truevar reg2=/123\D5/;_reg.test("12345"); //false_reg.test("123b5"); //true \w 匹配字母、数字、下划线 ，三者满足其一即可 1234567891011var reg=/\w/; reg.test("123"); //存在数字，结果为：truereg.test("a"); //truereg.test("1"); //truereg.test("_"); //truereg.test("-"); //falsereg.test("."); //falsereg.test("1."); //truereg.test("_\r\n"); //truereg.test("\r\n"); //false \W 是\w的取反 \s 表示一个空白字符（例如：\r \n \t 空格 。。。） 1234var reg=/\s/;reg.test("abc def"); //存在一个空白，结果为：truereg.test("abc\r123"); //存在一个\r，结果为：truereg.test("abc"); //false \S 是\s的取反 123456789var reg=/\S/;reg.test(" \r \n "); //全是空白字符，结果为falsereg.test("123 abc"); //存在一个空白，结果为truevar reg3=/\s\S/;reg3.test(" a"); //truereg3.test("a "); //falsereg3.test("a b"); //true \ 转义字符 12345var reg=/./; //匹配除了换行符以外的任意字符var reg=/\./; //匹配.字符var reg=/\//; //匹配一个正斜杠：/var reg=/[/]/; //。。。。。。。。。 案例：匹配邮箱 12345//asfas.com//123ad.com//ABC12.com//abc_1.comvar reg =/\w\w\w\w\w\.com/; 字符集合 [] 123456789101112131415161718192021222324var reg=/[1a2b3]/; //匹配一个字符，这个字符必须是：1/a/2/b/3其中一种，如果是就表示满足，如果不是就不满足reg.test("a"); //结果为：truereg.test("3"); //结果为：truereg.test("fg5678"); //一个符合要求的字符都不存在，结果为：falsereg.test("a999999"); //结果为：true//升级版var reg2=/[123][abc]/; //为了匹配连续2个字符，第一个字符必须在1/2/3之内，第二个字符必须在a/b/c之内reg2.test("2a"); //truereg2.test("3c"); //truereg2.test("1basdfasf"); //truereg2.test("asdfasdf1c"); //存在符合条件的1c，结果为：truereg2.test("39"); //falsevar reg2=/[0-9]/; //匹配数字0-9之间，任何一个数字 等价于：/\d/var reg3=/[a-z]/; //匹配小写字母var reg4=/[A-Z]/; //匹配大写字母var reg5=/[a-zA-Z]/;//匹配所有字母var reg6=/[A-Za-z]/;//..........var reg10=/[0-9abc]/;reg10.test("3");//truereg10.test("five");//falsereg10.test("banana");//true [^] 12345var reg=/[^123]/; //匹配一个字符，但是这个字符既不是1 并且 不是2 并且 不是3 reg.test("a"); //truereg.test("3"); //falsereg.test("123"); //没有1，2，3以外的字符，结果为：falsereg.test("a123"); //存在一个符合条件的a，所以结果为：true 边界 ^ 表示字符串最左边 $ 表示字符串最右边123var reg=/^abc/; //表示以abc开头reg.test("123abc123"); //并不是以abc开头，结果为：falsereg.test("abc123"); //以abc开头，结果为：true 1234var reg=/abc$/; //表示以abc结尾reg.test("123abc"); //结果为：truereg.test("abc123"); //结果为：falsereg.test("123bc"); //结果为：false 123456789//匹配一个手机号码 (11位)--&gt;(1)+(10位数字)var reg=/1\d\d\d\d\d\d\d\d\d\d/;reg.test("13166668888a"); //truevar reg2=/^1\d\d\d\d\d\d\d\d\d\d$/;reg2.test("13166668888a"); //falsereg2.test("13166668888"); //truevar reg3=/^1[0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9]$/; 123var reg=/^abc$/; //表示字符串abcreg.test("abc"); //结果为：truereg.test("123abc"); //结果为：false 量词 * 出现0次或多次 123456789var reg=/\d*/;reg.test("123"); //truereg.test("234"); //truevar reg3=/1\d*/;reg3.test("1"); //truereg3.test("123"); //truereg3.test("a123") //truereg3.test("a123456b"); //false + 出现1次或多次(至少一次) 123var reg=/1\d+/;reg.test("1"); //falsereg.test("123"); //true ? 出现0次或一次 123var reg=/1\d?/; reg.test("12"); //truereg.test("1"); //true {3} 出现3次 1234var reg=/1\w&#123;5&#125;/;reg.test("1abc"); //falsereg.test("112345"); //truereg.test("1abc12"); //true {3,} 至少出现3次 123var reg=/\d&#123;2,&#125;/;reg.test("12"); //truereg.test("5"); //false {3,5} 出现3-5次 1234var reg=/abc&#123;3&#125;/; //表示匹配abcccreg.test("123abccc123"); //结果为：truevar reg3=/(abc)&#123;2&#125;/; //匹配abcabc | 或者 123456789var reg=/abc|123/; //表示匹配abc或者123reg.test("abc456"); //truevar reg5=/^abc|123$/; //匹配以abc开头，或者以123结尾reg5.test("abcafsadfasd");//truereg5.test("afsdfasdf123");//truevar reg6=/^(abc|123)$/; //匹配abc/123 () 分组 12345678//010-88889999//0576-12312312//0895-1234567var reg=/(\d&#123;3,4&#125;)-(\d&#123;7,8&#125;)/; //匹配电话号码var arr="021-33335555".match(/(\d&#123;3,4&#125;)-(\d&#123;7,8&#125;)/)arr[0] //全部arr[1] //第一组：区号：021arr[2] //第二组：号码：333355555 123var reg=/(\d&#123;3,4&#125;)-(\d&#123;7,8&#125;)/;"021-33335555".replace(/(\d&#123;3,4&#125;)-(\d&#123;7,8&#125;)/,'区号是：$1')//区号是：021 123456789101112131415var str="[object Array]";var str2="[object Object]";var str3='[object Function]';var str4='[object Date]';str.replace("[object ","").replace("]","").toLowerCase();str.replace(/\[object /,"").replace(/\]/,"").toLowerCase();//这样的话正则表达式只匹配一次，也就是说后面的]换不掉str.replace(/\[object |\]/,"").toLowerCase();//如何解决？进行全局匹配str.replace(/\[object |\]/g,"").toLowerCase();str.replace(/[^\s]+\s/,"").replace(/\]/,"")]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一次仿写jQuery库的简单代码]]></title>
    <url>%2F2019%2F04%2F25%2F%E4%B8%80%E6%AC%A1%E4%BB%BF%E5%86%99jQuery%E5%BA%93%E7%9A%84%E7%AE%80%E5%8D%95%E4%BB%A3%E7%A0%81%2F</url>
    <content type="text"><![CDATA[功能的实现都很简单，但是是需要学着别人的思想 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script&gt; //模块化：内部的东西对外是封闭的，只暴露出$,jQuery操作。 (function (global) &#123; function jQuery(selector) &#123; // //获取页面中所有指定的元素 // const elements = document.querySelectorAll(selector); // console.log(elements); // //但是随着$()操作的增加，将会产生无数个css方法，浪费了很多的内存 // elements.css = function()&#123; // console.log('query css'); // &#125; // return elements; var _init = jQuery.prototype.init; // console.log(jQuery.prototype); return new jQuery.prototype.init(selector); &#125; // 为了方便少写prototype单词，简化 jQuery.fn = jQuery.prototype = &#123; constructor: jQuery, init: function (selector) &#123; // // 把查找到的DO吗元素放在变量中 // const elements = document.querySelectorAll(selector); // // this.elements = elements; // // 但是jQuery为了操作方便，所以将DOM元素放在了自己身上，也就是伪对象数组 // for (let i = 0; i &lt; elements.length; i++) &#123; // this[i] = elements[i]; // &#125; // this.length = elements.length; //判断如果是一个string，则查找 if (jQuery.type(selector) === 'string') &#123; const elements = document.querySelectorAll(selector); // this.elements = elements; // 但是jQuery为了操作方便，所以将DOM元素放在了自己身上，也就是伪对象数组 for (let i = 0; i &lt; elements.length; i++) &#123; this[i] = elements[i]; &#125; this.length = elements.length; &#125; else &#123; //如果是一个对象，则直接赋值 this[0] = selector; this.length = 1; &#125; &#125;, // css(attr, value) &#123; // for (let i = 0; i &lt; this.length; i++) &#123; // this[i].style[attr] = value; // &#125; // &#125; &#125; jQuery.fn.init.prototype = jQuery.fn; // jQuery插件编写之路 // 无法使用箭头函数 jQuery.fn.extend = jQuery.extend = function (...args) &#123; if (args.length &lt;= 0) &#123; return; &#125; let target, source = null; source = [...args]; // $.extend | $.fn.extend if (args.length == 1) &#123; target = this; &#125; else &#123; // args[0].extend target = args[0]; source.splice(0, 1); &#125; // 判断当前是谁 // if (this === jQuery) &#123; // target = args[0]; // // 删除第一个元素 // source.splice(0, 1); // &#125; else &#123; // target = this; // &#125; // console.log(target); // console.log(source); // source.forEach((item,index) =&gt; &#123; // for (const key in item) &#123; // target[key] = item[key]; // &#125; // &#125;); //for循环优化 // Object.assign() 方法用于将所有可枚举属性的值从一个或多个源对象复制到目标对象。它将返回目标对象。 有兼容性问题 Object.assign(target, ...source); return target; &#125; //添加一些工具类方法：$.xxx() //$.ajax $.post $.get $.type $.each jQuery.extend(&#123; //$.each([1,3,5],function(index,value)&#123;&#125;) //$.each(&#123; age:18,height:200 &#125;,function(key,value)&#123;&#125;) //可以遍历数组和对象 each(target, callback) &#123; //对象有两种，数组对象和普通数组 //不仅仅可以遍历数组，也可以遍历伪数组 //&#123; length:0 &#125; //&#123; 0:100,length:1 &#125; //&#123; 0:"a",1:"b",2:"c",length:3 &#125; if ((length in target) &amp;&amp; target.length &gt;= 0) &#123; for (let i = 0; i &lt; target.length; i++) &#123; callback.call(target[i], i, target[i]); &#125; &#125; else &#123; // 普通对象 // //获取到p1自身拥有的属性组成数组 // Object.keys(target).forEach((value,index)=&gt;&#123; // console.log(value,index); // &#125;) for (const key in target) &#123; if (target.hasOwnProperty(key)) &#123; callback.call(target[key], key, target[key]); &#125; &#125; &#125; &#125;, type(target) &#123; // console.log('type'); var type = Object.prototype.toString.call(target); return type.replace("[object ", "") .replace("]", "") .toLowerCase(); &#125;, ajax() &#123; console.log('ajax'); &#125; &#125;); const events = [ //&#123; ele:div1,type:"click",callback:function()&#123;&#125; &#125;, //&#123; ele:div1,type:"click",callback:function()&#123;&#125; &#125; ]; jQuery.fn.extend(&#123; // 遍历自己 each(callback) &#123; jQuery.each(this, callback); &#125;, //1、获取样式$("div").css("color") 只能获取到第一个div的颜色 //2、设置样式 // $("div").css("color","red") 设置每一个div的字体颜色 // $("div").css(&#123; color:"red","backgroundColor","blue" &#125;) css(...args) &#123; if (args.length === 1) &#123; // 一个参数时分两种情况，如果是一个字符串，则为获取属性，但是如果为一个对象则为设置样式 if (jQuery.type(args[0]) === 'string') &#123; // console.log(this); this指向$("div"),init方法放回的元素 //不管元素有多少个，只取第一个 let $this = this[0]; let style = window.getComputedStyle($this, null); // console.log(style); return style[args[0]]; &#125; else &#123; // 设置样式,需要遍历选择器 // jQuery.each(this, function()&#123; // let $this = this; // jQuery.each(args[0], function(key, value)&#123; // $this.style[key] = value; // &#125;) // &#125;); //优化上述代码 let _that = this; jQuery.each(args[0], function (key, value) &#123; _that.css(key, value); &#125;); return this; //链式调用 &#125; &#125; else &#123; // 参数为两个，则为一个属性，一个属性值 // 设置单个样式 // let key = args[0]; // let value = args[1]; this.each(function () &#123; this.style[args[0]] = args[1]; &#125;); return this; //链式调用 &#125; &#125;, show() &#123; this.css('display', 'block'); &#125;, hide() &#123; this.css('display', 'none'); &#125;, toggle() &#123; let _that = this; //this -&gt; jQuery this.each(function () &#123; // this -&gt; dom // if (jQuery(this).css('display') === 'block') &#123; // jQuery(this).css('display', 'none'); // &#125;else &#123; // jQuery(this).css('display', 'block'); // &#125; //优化上述代码 let $this = jQuery(this); $this.css('display') === 'block' ? $this.hide() : $this.show(); &#125;) &#125;, // 添加event on(type, callback) &#123; this.each(function () &#123; // console.log(this); this.addEventListener(type, callback); events.push(&#123; ele: this, type: type, callback: callback &#125;); &#125;); return this; //链式编程 &#125;, //解绑绑定：$("div").off("click")：表示解除当前元素的所有的单击事件 off(type) &#123; this.each(function () &#123; let _that = this; let es = events.filter(function (e, i) &#123; console.log(i, e); //查看绑定的元素是否存在events数组中，并且有没有该元素绑定的事件,并且移除 let isCurent = e.ele === _that &amp;&amp; e.type === type if (isCurent) &#123; events.splice(i, 1); &#125; return isCurent; &#125;); if (es.length &lt;= 0) &#123; return; &#125; //可能存在多次绑定 es.forEach(function (e) &#123; console.log(e, _that); let &#123; callback &#125; = e; _that.removeEventListener(type, callback); &#125;); console.log(events); &#125;) &#125; &#125;); // function F(selector) &#123; // // 把查找到的DO吗元素放在变量中 // const elements = document.querySelectorAll(selector); // // this.elements = elements; // // 但是jQuery为了操作方便，所以将DOM元素放在了自己身上，也就是伪对象数组 // for (let i = 0; i &lt; elements.length; i++) &#123; // this[i] = elements[i]; // &#125; // this.length = elements.length; // &#125; // F.prototype.css = function(attr, value) &#123; // console.log(this.elements.length); // for(let i=0; i&lt;this.elements.length; i++) &#123; // this.elements[i].style[attr] = value; // &#125; // &#125; // F.prototype = &#123; // constructor: F, // css(attr, value) &#123; // for (let i = 0; i &lt; this.length; i++) &#123; // this[i].style[attr] = value; // &#125; // &#125; // &#125; // 相当于赋值给顶层对象window的属性 global.$ = global.jQuery = jQuery; &#125;)(window); //自调用函数 // console.log($); window.onload = function () &#123; // $('div').css('color', 'red'); // $('.header').css('color', 'blue'); // var p = &#123;&#125;; // $.extend(p, &#123; a: 1 &#125;, &#123; b: 2 &#125;); // console.log(p); // $.fn.extend(&#123; a: 0 &#125;); // console.log($.fn); // $.each(&#123; a: 'a', b: 'b' &#125;, function (key, value) &#123; // console.log(key, value); // &#125;); // $.each(&#123; 0: 100, 1: 200, 2: 300, length: 3 &#125;, function (key, value) &#123; // console.log(key, value); // &#125;); // $.each([1, 2, 3], function (key, value) &#123; // console.log(key, value); // &#125;); // console.log($.type(&#123; a: 1 &#125;)); // $('div').css(&#123; // 'color': 'red', // 'backgroundColor': 'blue' // &#125;) // $('div').css('color', 'red'); // $('.header').hide(); // $('div').toggle(); $('.footer').on('click', function (e) &#123; alert('footer'); &#125;); $('.header').on('click', function (e) &#123; alert('header'); &#125;); $('.section').on('click', function (e) &#123; $('.footer').off('click'); console.log('remove') &#125;); // $('.header').off('click'); &#125; &lt;/script&gt; &lt;style&gt; div:first-child &#123; color: rebeccapurple; /* display: none; */ &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="footer"&gt;aaa&lt;/div&gt; &lt;br&gt; &lt;br&gt; &lt;div class="header"&gt;bbb&lt;/div&gt; &lt;div class="section"&gt;ccc&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo next主题首页隐藏指定文章]]></title>
    <url>%2F2019%2F04%2F23%2Fhexo-next%E4%B8%BB%E9%A2%98%E9%A6%96%E9%A1%B5%E9%9A%90%E8%97%8F%E6%8C%87%E5%AE%9A%E6%96%87%E7%AB%A0%2F</url>
    <content type="text"><![CDATA[因为博客下混合了我技术类和生活类的文章，但是首页我只想显示技术类，所以记录下做法。 具体做法 找到themes⁩ ▸ ⁨next⁩ ▸ ⁨layout⁩文件夹下的index.swig文件 定位修改post_template.render 修改成以下代码,其中修改的是为文章的首页显示添加判断条件 123&#123;% if post.visible !== &apos;hide&apos; %&#125; &#123;&#123; post_template.render(post, true) &#125;&#125;&#123;% endif %&#125; 即修改后 在新的post中添加visible字段来控制是否首页显示 1234567891011---title: post titledate: 2019-04-23 12:24:19tags: - hexocategories: - hexovisible: hide---.........]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTML5移动端自适应方案——媒体查询+rem方案]]></title>
    <url>%2F2019%2F04%2F22%2FHTML5%E7%A7%BB%E5%8A%A8%E7%AB%AF%E8%87%AA%E9%80%82%E5%BA%94%E6%96%B9%E6%A1%88%E2%80%94%E2%80%94%E5%AA%92%E4%BD%93%E6%9F%A5%E8%AF%A2-rem%E6%96%B9%E6%A1%88%2F</url>
    <content type="text"><![CDATA[背景虽然H5的页面与PC的Web页面相比简单了不少，但让我们头痛的事情是要想尽办法让页面能适配众多不同的终端设备。 本文中不涉及一些viewport、dpr等的概念介绍，详细了解可以再查看本博客中另一篇文章有具体讲解这些概念。 EM和REM使用REM+媒体查询方式进行编写自适应方案时，先来了解下EM和REM是什么？ EMem是相对长度单位。相对于当前对象内文本的字体尺寸。如当前对行内文本的字体尺寸未被人为设置，则相对于浏览器的默认字体尺寸。 EM的特点 em的值并不是固定的 em会继承父级元素的字体大小 注意：任意浏览器的默认字体高都是16px。所有未经调整的浏览器都符合: 1em=16px。那么12px=0.75em,10px=0.625em。为了简化font-size的换算，需要在css中的body选择器中声明Font-size=62.5%，这就使em值变为 16px*62.5%=10px, 这样12px=1.2em, 10px=1em, 也就是说只需要将你的原来的px数值除以10，然后换上em作为单位就行了。所以我们在写CSS的时候，需要注意两点： body选择器中声明Font-size=62.5%； 将你的原来的px数值除以10，然后换上em作为单位； 重新计算那些被放大的字体的em数值。避免字体大小的重复声明。也就是避免1.2 * 1.2= 1.44的现象。比如说你在#content中声明了字体大小为1.2em，那么在声明p的字体大小时就只能是1em，而不是1.2em, 因为此em非彼em，它因继承#content的字体高而变为了1em=12px。 REMrem是CSS3新增的一个相对单位（root em，根em），这个单位引起了广泛关注。这个单位与em有什么区别呢？区别在于使用rem为元素设定字体大小时，仍然是相对大小，但相对的只是HTML根元素。这个单位可谓集相对大小和绝对大小的优点于一身，通过它既可以做到只修改根元素就成比例地调整所有字体大小，又可以避免字体大小逐层复合的连锁反应。目前，除了IE8及更早版本外，所有浏览器均已支持rem。 简单的理解，rem就是相对于根元素&lt;html&gt;的font-size来做计算。而我们的方案中使用rem单位，是能轻易的根据&lt;html&gt;的font-size计算出元素的盒模型大小。而这个特色对我们来说是特别的有益处。 媒体查询 + Rem实现自适应放上代码中所使用的设计稿和图片，自行右键保存。图片来源手淘H5适配方案 该设计图是按照iPhone6作为基准设计尺寸，iPhone6的分辨率为750px * 1334px，iPhone6的DPR为2，则CSS像素则缩小为设计稿尺寸的1/2。既设计稿量出某宽为20px，则css像素则转为为10px。 理想适口的缩放比为1的情况下 首先按照设计稿尺寸还原页面，为了方便理解，首先使用px还原页面，在iPhone6下显示设计。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; * &#123; padding: 0; margin: 0; box-sizing: border-box; -webkit-tap-highlight-color: transparent; &#125; html,body &#123; height: 100%; &#125; html,body &#123; height: 100%; background-color: #f5294c; &#125; body &#123; font-size: 14px; &#125; #content &#123; /* background-color: #f5294c; */ min-width: 100%; &#125; #content .header h1 img &#123; width: 100%; &#125; #content .section &#123; padding: 0 5px; &#125; #content .section .item &#123; background-color: #fff; position: relative; &#125; #content .section .item .left &#123; padding: 5px 0; display: table-cell; &#125; #content .section .item .left img&#123; width: 88px; height: 88px; &#125; #content .section .item .right &#123; display: table-cell; padding: 5px 8px 0 8px; vertical-align: top; width: 100%; font-size: 13px; line-height: 1.25; &#125; #content .section .item .right .price &#123; margin: 9px 0; &#125; #content .section .item .right .price &#123; color: #f32a4c; &#125; #content .section .item .right .price span &#123; font-size: 10px; background-color: #f32a4c; color: #fffffd; &#125; #content .section .item .right .intro &#123; color: #ffb09b; &#125; #content .section .item .buy &#123; position: absolute; right: 9px; bottom: 7px; line-height: 1.25; font-size: 13px; padding: 5px 18px; background-color: #f42a4b; color: #fefffc; &#125; #content .section .item .buy a:visited &#123; color: #fefffc; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="content"&gt; &lt;!-- 海报 --&gt; &lt;div class="header"&gt; &lt;h1&gt; &lt;img src="image/haibao.jpg" alt="" srcset=""&gt; &lt;/h1&gt; &lt;/div&gt; &lt;ul class="section"&gt; &lt;li class="item"&gt; &lt;a class="left" href="##"&gt; &lt;img src="image/grayscale.jpeg" alt="" srcset=""&gt; &lt;/a&gt; &lt;div class="right"&gt; &lt;div class="title"&gt; &lt;a href="##"&gt;Carter's1年式灰色长袖连体衣包脚爬服全棉鲸鱼男婴儿童装115G093&lt;/a&gt; &lt;/div&gt; &lt;div class="price"&gt; &lt;span&gt;双11价&lt;/span&gt; &lt;strong&gt;¥ 299&lt;/strong&gt; &lt;small&gt;（满400 减 100）&lt;/small&gt; &lt;/div&gt; &lt;div class="intro"&gt; &lt;small&gt;一小时热卖1769件&lt;/small&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="buy"&gt; &lt;a href="##"&gt;马上抢！&lt;/a&gt; &lt;/div&gt; &lt;/li&gt; &lt;li class="item"&gt; &lt;a class="left" href="##"&gt; &lt;img src="image/grayscale.jpeg" alt="" srcset=""&gt; &lt;/a&gt; &lt;div class="right"&gt; &lt;div class="title"&gt; &lt;a href="##"&gt;Carter's1年式灰色长袖连体衣包脚爬服全棉鲸鱼男婴儿童装115G093&lt;/a&gt; &lt;/div&gt; &lt;div class="price"&gt; &lt;span&gt;双11价&lt;/span&gt; &lt;strong&gt;¥ 299&lt;/strong&gt; &lt;small&gt;（满400 减 100）&lt;/small&gt; &lt;/div&gt; &lt;div class="intro"&gt; &lt;small&gt;一小时热卖1769件&lt;/small&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="buy"&gt; &lt;a href="##"&gt;马上抢！&lt;/a&gt; &lt;/div&gt; &lt;/li&gt; &lt;li class="item"&gt; &lt;a class="left" href="##"&gt; &lt;img src="image/grayscale.jpeg" alt="" srcset=""&gt; &lt;/a&gt; &lt;div class="right"&gt; &lt;div class="title"&gt; &lt;a href="##"&gt;Carter's1年式灰色长袖连体衣包脚爬服全棉鲸鱼男婴儿童装115G093&lt;/a&gt; &lt;/div&gt; &lt;div class="price"&gt; &lt;span&gt;双11价&lt;/span&gt; &lt;strong&gt;¥ 299&lt;/strong&gt; &lt;small&gt;（满400 减 100）&lt;/small&gt; &lt;/div&gt; &lt;div class="intro"&gt; &lt;small&gt;一小时热卖1769件&lt;/small&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="buy"&gt; &lt;a href="##"&gt;马上抢！&lt;/a&gt; &lt;/div&gt; &lt;/li&gt; &lt;li class="item"&gt; &lt;a class="left" href="##"&gt; &lt;img src="image/grayscale.jpeg" alt="" srcset=""&gt; &lt;/a&gt; &lt;div class="right"&gt; &lt;div class="title"&gt; &lt;a href="##"&gt;Carter's1年式灰色长袖连体衣包脚爬服全棉鲸鱼男婴儿童装115G093&lt;/a&gt; &lt;/div&gt; &lt;div class="price"&gt; &lt;span&gt;双11价&lt;/span&gt; &lt;strong&gt;¥ 299&lt;/strong&gt; &lt;small&gt;（满400 减 100）&lt;/small&gt; &lt;/div&gt; &lt;div class="intro"&gt; &lt;small&gt;一小时热卖1769件&lt;/small&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="buy"&gt; &lt;a href="##"&gt;马上抢！&lt;/a&gt; &lt;/div&gt; &lt;/li&gt; &lt;li class="item"&gt; &lt;a class="left" href="##"&gt; &lt;img src="image/grayscale.jpeg" alt="" srcset=""&gt; &lt;/a&gt; &lt;div class="right"&gt; &lt;div class="title"&gt; &lt;a href="##"&gt;Carter's1年式灰色长袖连体衣包脚爬服全棉鲸鱼男婴儿童装115G093&lt;/a&gt; &lt;/div&gt; &lt;div class="price"&gt; &lt;span&gt;双11价&lt;/span&gt; &lt;strong&gt;¥ 299&lt;/strong&gt; &lt;small&gt;（满400 减 100）&lt;/small&gt; &lt;/div&gt; &lt;div class="intro"&gt; &lt;small&gt;一小时热卖1769件&lt;/small&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="buy"&gt; &lt;a href="##"&gt;马上抢！&lt;/a&gt; &lt;/div&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 编写后页面显示，当然这里是举例，有些像素为了方便计算，只是大概的测量了一下，这里使用的测量工具为Mark Man。 然后看看其他设备显示的效果，因为这里使用的是流式布局，即百分比布局，页面还没有说变形很严重，但是在iPhone5设备上或者更小的设备上显示就会显得页面元素偏大，而在一些ipad就显得更为难受了。(换成其他DPR下情况也是相同)。 这里不讲解媒体查询是什么和具体语法，详细了解可以查看MDN 而该方案就是基于rem的原理，针对不同屏幕尺寸的改变来改变根节点html的font-size的大小。 这里总结出了一个公式： 1font-size(rem) = 预设font-size(rem)基准值 / （设计稿宽度 / DPR） * 设备宽度 该公式的原理就是先根据设计稿的尺寸和DPR求出设备的宽度，根据该设备的宽度下预设一个font-size的基准值，再求出该设备下的宽度与预设基准值的比值，然后其他设备下的设备宽度除以该基准值就可以求出其他设备下的html的font-size的值。所以上述公式是由下条公式变化得来的。 1font-size(rem) = 设备宽度 / （（设计稿宽度 / DPR） / 预设font-size(rem)基准值） 按照本文中设计稿为iPhone6的尺寸设计，我们以设计稿下iPhone6为375px的html的font-size预设基准值为100px（方便计算）,即1rem = 100px，则其他设备像素下html的font-size的值为 iPhone5的设备像素320px:100 / (750 / 2) * 320 = 85.333px iPhone6的设备像素375px:100px iPhone6Plus的设备像素414px:100 / (750 / 2) * 414 = 110.4px 只要以设计稿下预设的基准值再根据其他屏幕来换算计算出其他设备下的html的font-size大小即可。 页面中再根据1rem = 100px将页面中px单位换算成rem即可。再添加上根据设备宽度的媒体查询设置根节点的font-size大小。 12345678910111213141516171819202122232425262728293031323334353637383940414243/* base-rem = 100px */ @media (min-width: 320px) &#123; html &#123; font-size: 85.333px; &#125; &#125; @media (min-width: 360px) &#123; html &#123; font-size: 96px; &#125; &#125; @media (min-width: 375px) &#123; html &#123; font-size: 100px; &#125; &#125; @media (min-width: 414px) &#123; html &#123; font-size: 110.4px; &#125; &#125; @media (min-width: 480px) &#123; html &#123; font-size: 128px; &#125; &#125; @media (min-width: 540px) &#123; html &#123; font-size: 144px; &#125; &#125; @media (min-width: 768px) &#123; html &#123; font-size: 204.8px; &#125; &#125; 更改后整体页面代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0,user-scalable=no"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; * &#123; padding: 0; margin: 0; box-sizing: border-box; &#125; html,body &#123; height: 100%; &#125; /* base-rem = 100px */ @media (min-width: 320px) &#123; html &#123; font-size: 85.333px; &#125; &#125; @media (min-width: 360px) &#123; html &#123; font-size: 96px; &#125; &#125; @media (min-width: 375px) &#123; html &#123; font-size: 100px; &#125; &#125; @media (min-width: 414px) &#123; html &#123; font-size: 110.4px; &#125; &#125; @media (min-width: 480px) &#123; html &#123; font-size: 128px; &#125; &#125; @media (min-width: 540px) &#123; html &#123; font-size: 144px; &#125; &#125; @media (min-width: 768px) &#123; html &#123; font-size: 204.8px; &#125; &#125; html,body &#123; height: 100%; background-color: #f5294c; &#125; body &#123; font-size: 14px; &#125; #content &#123; /* background-color: #f5294c; */ min-width: 100%; &#125; #content .header h1 img &#123; width: 100%; &#125; #content .section &#123; padding: 0 0.05rem; &#125; #content .section .item &#123; background-color: #fff; position: relative; &#125; #content .section .item .left &#123; padding: 0.05rem 0; display: table-cell; &#125; #content .section .item .left img&#123; width: 0.88rem; height: 0.88rem; &#125; #content .section .item .right &#123; display: table-cell; padding: 0.05rem 0.08rem 0 0.08rem; vertical-align: top; width: 100%; font-size: 0.13rem; line-height: 1.25; &#125; #content .section .item .right .price &#123; margin: 0.09rem 0; &#125; #content .section .item .right .price &#123; color: #f32a4c; &#125; #content .section .item .right .price span &#123; font-size: 0.1rem; background-color: #f32a4c; color: #fffffd; &#125; #content .section .item .right .intro &#123; color: #ffb09b; &#125; #content .section .item .buy &#123; position: absolute; right: 0.09rem; bottom: 0.07rem; line-height: 1.25; font-size: 0.13rem; padding: 0.05rem 0.18rem; background-color: #f42a4b; color: #fefffc; &#125; #content .section .item .buy a:visited &#123; color: #fefffc; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="content"&gt; &lt;!-- 海报 --&gt; &lt;div class="header"&gt; &lt;h1&gt; &lt;img src="image/haibao.jpg" alt="" srcset=""&gt; &lt;/h1&gt; &lt;/div&gt; &lt;ul class="section"&gt; &lt;li class="item"&gt; &lt;a class="left" href="##"&gt; &lt;img src="image/grayscale.jpeg" alt="" srcset=""&gt; &lt;/a&gt; &lt;div class="right"&gt; &lt;div class="title"&gt; &lt;a href="##"&gt;Carter's1年式灰色长袖连体衣包脚爬服全棉鲸鱼男婴儿童装115G093&lt;/a&gt; &lt;/div&gt; &lt;div class="price"&gt; &lt;span&gt;双11价&lt;/span&gt; &lt;strong&gt;¥ 299&lt;/strong&gt; &lt;small&gt;（满400 减 100）&lt;/small&gt; &lt;/div&gt; &lt;div class="intro"&gt; &lt;small&gt;一小时热卖1769件&lt;/small&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="buy"&gt; &lt;a href="##"&gt;马上抢！&lt;/a&gt; &lt;/div&gt; &lt;/li&gt; &lt;li class="item"&gt; &lt;a class="left" href="##"&gt; &lt;img src="image/grayscale.jpeg" alt="" srcset=""&gt; &lt;/a&gt; &lt;div class="right"&gt; &lt;div class="title"&gt; &lt;a href="##"&gt;Carter's1年式灰色长袖连体衣包脚爬服全棉鲸鱼男婴儿童装115G093&lt;/a&gt; &lt;/div&gt; &lt;div class="price"&gt; &lt;span&gt;双11价&lt;/span&gt; &lt;strong&gt;¥ 299&lt;/strong&gt; &lt;small&gt;（满400 减 100）&lt;/small&gt; &lt;/div&gt; &lt;div class="intro"&gt; &lt;small&gt;一小时热卖1769件&lt;/small&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="buy"&gt; &lt;a href="##"&gt;马上抢！&lt;/a&gt; &lt;/div&gt; &lt;/li&gt; &lt;li class="item"&gt; &lt;a class="left" href="##"&gt; &lt;img src="image/grayscale.jpeg" alt="" srcset=""&gt; &lt;/a&gt; &lt;div class="right"&gt; &lt;div class="title"&gt; &lt;a href="##"&gt;Carter's1年式灰色长袖连体衣包脚爬服全棉鲸鱼男婴儿童装115G093&lt;/a&gt; &lt;/div&gt; &lt;div class="price"&gt; &lt;span&gt;双11价&lt;/span&gt; &lt;strong&gt;¥ 299&lt;/strong&gt; &lt;small&gt;（满400 减 100）&lt;/small&gt; &lt;/div&gt; &lt;div class="intro"&gt; &lt;small&gt;一小时热卖1769件&lt;/small&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="buy"&gt; &lt;a href="##"&gt;马上抢！&lt;/a&gt; &lt;/div&gt; &lt;/li&gt; &lt;li class="item"&gt; &lt;a class="left" href="##"&gt; &lt;img src="image/grayscale.jpeg" alt="" srcset=""&gt; &lt;/a&gt; &lt;div class="right"&gt; &lt;div class="title"&gt; &lt;a href="##"&gt;Carter's1年式灰色长袖连体衣包脚爬服全棉鲸鱼男婴儿童装115G093&lt;/a&gt; &lt;/div&gt; &lt;div class="price"&gt; &lt;span&gt;双11价&lt;/span&gt; &lt;strong&gt;¥ 299&lt;/strong&gt; &lt;small&gt;（满400 减 100）&lt;/small&gt; &lt;/div&gt; &lt;div class="intro"&gt; &lt;small&gt;一小时热卖1769件&lt;/small&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="buy"&gt; &lt;a href="##"&gt;马上抢！&lt;/a&gt; &lt;/div&gt; &lt;/li&gt; &lt;li class="item"&gt; &lt;a class="left" href="##"&gt; &lt;img src="image/grayscale.jpeg" alt="" srcset=""&gt; &lt;/a&gt; &lt;div class="right"&gt; &lt;div class="title"&gt; &lt;a href="##"&gt;Carter's1年式灰色长袖连体衣包脚爬服全棉鲸鱼男婴儿童装115G093&lt;/a&gt; &lt;/div&gt; &lt;div class="price"&gt; &lt;span&gt;双11价&lt;/span&gt; &lt;strong&gt;¥ 299&lt;/strong&gt; &lt;small&gt;（满400 减 100）&lt;/small&gt; &lt;/div&gt; &lt;div class="intro"&gt; &lt;small&gt;一小时热卖1769件&lt;/small&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="buy"&gt; &lt;a href="##"&gt;马上抢！&lt;/a&gt; &lt;/div&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 适配后 图片较大，可自行运行代码在dpr为1、2、3下再更改屏幕尺寸，运行结果良好，可谓够用。 为什么可谓够用，该方案有缺点：通过设备宽度范围区间这样的媒体查询来动态改变rem基准值，其实不够精确，比如：宽度为360px 和 宽度为320px的手机，因为屏宽在同一范围区间内(&lt;375px)，所以会被同等对待(rem基准值相同)，而事实上他们的屏幕宽度并不相等，它们的布局也应该有所不同。最终，结论就是：这样的做法，没有做到足够的精确，但是够用。 Less优化如果项目中使用Less或者Sass等CSS预处理器可以更加简化代码的编写与计算量。 123456789101112131415161718192021//需要适配的设备宽度数组@adapterDeviceWidthList: 320px, 360px, 375px, 414px, 480px, 540px, 640px, 750px;@psdWidth: 750;@psdDpr: 2;@baseFontSize: 100px;@deviceLength: length(@adapterDeviceWidthList);.adapterMixin(@index) when (@index &lt;= @deviceLength) &#123; @media (min-width: extract(@adapterDeviceWidthList, @index)) &#123; html &#123; font-size: 100 / (@psdWidth / @psdDpr) * extract(@adapterDeviceWidthList, @index); &#125; &#125; .adapterMixin(@index + 1);&#125;.adapterMixin(1); 生成的css为 12345678910111213141516171819202122232425262728293031323334353637383940@media (min-width: 320px) &#123; html &#123; font-size: 85.33333333px; &#125;&#125;@media (min-width: 360px) &#123; html &#123; font-size: 96px; &#125;&#125;@media (min-width: 375px) &#123; html &#123; font-size: 100px; &#125;&#125;@media (min-width: 414px) &#123; html &#123; font-size: 110.4px; &#125;&#125;@media (min-width: 480px) &#123; html &#123; font-size: 128px; &#125;&#125;@media (min-width: 540px) &#123; html &#123; font-size: 144px; &#125;&#125;@media (min-width: 640px) &#123; html &#123; font-size: 170.66666667px; &#125;&#125;@media (min-width: 750px) &#123; html &#123; font-size: 200px; &#125;&#125; 使用less维护起来就方便很多，只要维护adapterDeviceWidthList中设备的宽度即可，如果设计稿开始有变化更改变量即可。]]></content>
      <categories>
        <category>HTML</category>
      </categories>
      <tags>
        <tag>HTML</tag>
        <tag>移动端适配</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Less入门]]></title>
    <url>%2F2019%2F04%2F15%2FLess%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[Less是什么LESS 将 CSS 赋予了动态语言的特性，如 变量， 继承， 运算， 函数. LESS 既可以在 客户端 上运行 (支持IE 6+, Webkit, Firefox)，也可以借助Node.js或者Rhino在服务端运行。 Less官方文档 Less安装客户端引入你的.less样式文件的时候要设置rel属性值为“stylesheet/less”: 1&lt;link rel="stylesheet/less" type="text/css" href="styles.less"&gt; 下载less.js,下载地址,在 中引入: 1&lt;script src="less.js" type="text/javascript"&gt;&lt;/script&gt; 注意你的less样式文件一定要在引入less.js前先引入。在浏览器中使用less.js开发是很好的，但不推荐用于生产环境中。 特别注意 确保包涵 .less 样式表在 less.js 脚本之前 当你引入多个 .less 样式表时，它们都是独立编译的。所以，在每个文件中定义的变量、混合、命名空间都不会被其它的文件共享。 服务端在服务器端安装LESS的最简单方式就是通过npm(node 的包管理器), 像这样: 1$ npm install less 如果你想下载最新稳定版本的 LESS，可以尝试像下面这样操作: 1$ npm install less@latest 命令行使用一旦安装完成，就可以在命令行中调用，例如: 1$ lessc styles.less 这样的话编译后的CSS将会输出到 ‘stdout’ 中，你可以选择将这个输出重定向到文件中: 1$ lessc styles.less &gt; styles.css 查看版本 12$ lessc -v$ lessc --version 如果你想输出一个压缩后的CSS，只要加到-x选项即可。如果你想要更NB的压缩，你也可以选择使用 Clean CSS压缩器，只要加上--clean-css 插件即可。 直接运行lessc，不带任何参数将可以看到所有的命令行参数或 查看用法. 代码中使用你可以在Node中调用编译器，例如： 12345var less = require('less');less.render('.class &#123; width: (1 + 1) &#125;', function (e, output) &#123; console.log(output.css);&#125;); 将会输出 123.class &#123; width: 2;&#125; 使用编译工具，比如 Koala 挺好用的（当然也有很多在线编译工具） 在项目中使用（比如Vue，需要安装less-loader） 客户端调试（存在跨域问题，不推荐这种方式） 使用link标签引用less.min.js（官网下载），注意rel=”stylesheet/less” 这种方式不生成css文件，直接在浏览器查看 嵌套规则less的嵌套规则类似HTML的结构，使得CSS代码清晰12345678910111213141516171819202122/*css 写法*/div &#123; font-size: 14px;&#125;div p &#123; margin: 0 auto;&#125;div p a &#123; color: red;&#125;// less写法div &#123; font-size: 14px; p &#123; margin: 0 auto; a &#123; color: red; &#125; &#125;&#125; 父元素选择符 &amp; 表示当前选择器的所有父选择器 123456789101112131415161718192021//css写法.bgcolor &#123; background: #fff;&#125;.bgcolor a &#123; color: #888888;&#125;.bgcolor a:hover &#123; color: #ff6600;&#125;//less写法.bgcolor &#123; background: #fff; a &#123; color: #888888; &amp;:hover &#123; color: #ff6600; &#125; &#125;&#125; 改变选择器的顺序 将&amp;放到当前选择器之后，会将当前选择器移到最前面 只需记住 “&amp; 代表当前选择器的所有父选择器” 123456789101112ul &#123; li &#123; .color &amp;&#123; background: #fff; &#125; &#125;&#125;//编译结果.color ul li &#123; background: #fff;&#125; 组合使用 将生成所有可能的选择器列表 1234567891011121314151617.div1, .div2 &#123; color: red; &amp; &amp; &#123; border-top: 1px solid blue; &#125;&#125; //编译结果.div1, .div2 &#123; color: red;&#125;.div1 .div2,.div2 .div1,.div1 .div1,.div2 .div2 &#123; border-top: 1px solid blue;&#125; 变量变量的定义和使用 定义：@name: value; （@black: #000;） 使用场合分3种： 常规使用：@name 作为选择器或属性名：@{name} 作为URL：”@{name}” 123456789101112131415161718192021222324252627282930313233343536/* 1.常规使用 */@black: #000000;div &#123; color: @black&#125;//编译结果div &#123; color: #000000;&#125;/* 2.作用选择器和属性名 */@selName: container;@proName: width;.@&#123;selName&#125; &#123; @&#123;proName&#125;: 100px;&#125;//编译结果.container &#123; width: 100px;&#125;/* 3.作为URL */@imgUrl: "./images/logo.png"div &#123; background: #FFF url("@&#123;imgUrl&#125;")&#125;//编译结果div &#123; background: #FFF url("./images/logo.png")&#125; 注意事项 变量是延迟加载的，可以不预先声明 12345678910div &#123; color: @black&#125;@black: #000000;//编译结果div &#123; color: #000000;&#125; 变量的作用域 less会从当前作用域没找到，将往上查找（类似js） 如果在某级作用域找到多个相同名称的变量，使用最后定义的那个（类似css） 123456789101112131415161718@var: 0;.class &#123; @var: 1; .brass &#123; @var: 2; three: @var; @var: 3; &#125; one: @var; //类似js，无法访问.brass内部&#125;//编译结果.class &#123; one: 1;&#125;.class .brass &#123; three: 3; //使用最后定义的 @var: 3&#125; 混合（mixins） 混合：一种将一系列属性从一个规则集引入（“混入”）到另一个规则集的方式 混合是非常重要的一个概念，内容也偏多，可以尝试多看几遍！ 普通混合123456789101112131415161718192021//混合.border &#123; border-top: solid 1px black; border-bottom: solid 2px black;&#125;#menu a &#123; color: #eee; .border;&#125;//编译结果.border &#123; border-top: solid 1px black; border-bottom: solid 2px black;&#125;#menu a &#123; color: #eee; border-top: solid 1px black; border-bottom: solid 2px black;&#125; 不带参数的混合 从上面的代码发现，混合也被编译输出了 在混合名字后加上括号，编译后不再输出 12345678910111213141516//加括号但不带参数的混合.border() &#123; border-top: solid 1px black; border-bottom: solid 2px black;&#125;#menu a &#123; color: #eee; .border; //加不加括号都可以&#125;//编译结果#menu a &#123; color: #eee; border-top: solid 1px black; border-bottom: solid 2px black;&#125; 带参数的混合12345678910111213141516//带参数的混合.border(@color) &#123; border-top: solid 1px @color; border-bottom: solid 2px @color;&#125;#menu a &#123; color: #eee; .border(#fff);&#125;//编译结果#menu a &#123; color: #eee; border-top: solid 1px #ffffff; border-bottom: solid 2px #ffffff;&#125; 带参数且有默认值的混合12345678910111213141516171819202122232425//带参数且有默认值的混合.border(@color: #fff) &#123; border-top: solid 1px @color; border-bottom: solid 2px @color;&#125;#menu a &#123; color: #eee; .border;&#125;#menu p &#123; .border(#000);&#125;//编译结果#menu a &#123; color: #eee; border-top: solid 1px #ffffff; border-bottom: solid 2px #ffffff;&#125;#menu p &#123; border-top: solid 1px #000000; border-bottom: solid 2px #000000;&#125; 带多个参数 多个参数时，参数之间可以用分号或逗号分隔 注意逗号分隔的是“各个参数”还是“某个列表类型的参数” 两个参数，并且每个参数都是逗号分隔的列表：.name(1,2,3; something, ele) 三个参数，并且每个参数都包含一个数字：.name(1,2,3) 使用分号，调用包含一个逗号分割的css列表（一个参数）： .name(1,2,3; ) 逗号分割默认值（两个参数）：.name(@param1:red, blue) 123456789101112131415161718192021222324252627282930313233//less编写.mixin(@color, @padding: xxx, @margin: 2) &#123; color-3: @color; padding-3: @padding; margin: @margin @margin @margin @margin;&#125;.div &#123; .mixin(1,2,3; something, ele); //2个参数&#125;.div1 &#123; .mixin(1,2,3); //3个参数&#125;.div2 &#123; .mixin(1,2,3; ); //1个参数&#125;//编译输出.div &#123; color-3: 1, 2, 3; padding-3: something, ele; margin: 2 2 2 2;&#125;.div1 &#123; color-3: 1; padding-3: 2; margin: 3 3 3 3;&#125;.div2 &#123; color-3: 1, 2, 3; padding-3: xxx; margin: 2 2 2 2;&#125; 定义多个相同名称的混合 less会根据参数进行调用相应的混合 12345678910111213141516171819202122232425262728293031.mixin(@color) &#123; color-1: @color;&#125;.mixin(@color; @padding: 2) &#123; color-2: @color; padding-2: @padding;&#125;.mixin(@color; @padding: 3; @margin) &#123; color-3: @color; padding-3: @padding; margin: @margin @margin @margin @margin;&#125;.some .selector div &#123; .mixin(#008000); //第二个mixins也被调用了，因为 @padding 有默认值&#125;.some .selector p &#123; .mixin(#008000, 5); //只有第二个mixins被调用&#125;//编译结果.some .selector div &#123; color-1: #008000; color-2: #008000; padding-2: 2;&#125;.some .selector p &#123; color-2: #008000; padding-2: 5;&#125; 命名参数 引用mixin时可以通过参数名称而不是参数的位置来为mixin提供参数值，任何参数都通过名称来引用，这样就不必按照特定的顺序来使用参数 1234567891011121314151617181920212223.mixin(@color: black; @margin: 10px; @padding: 20px) &#123; color: @color; margin: @margin; padding: @padding;&#125;.class1 &#123; .mixin(@margin:20; @color: #33acfe);&#125;.class2 &#123; .mixin(#efca44; @padding: 40px);&#125;//编译输出.class1 &#123; color: #33acfe; margin: 20px; padding: 20px;&#125;.class2 &#123; color: #efca44; margin: 10px; padding: 40px;&#125; @arguments变量 @arguments表示所有可变参数 参数的先后顺序就是括号内的顺序 ，在赋值时，值的位置和个数也是一一对应的 只有一个值，把值赋给第一个，两个值，赋给第一个和第二个…… 若想赋给第一个和第三个，必须把第二个参数的默认值写上 1234567891011121314151617.border(@x: solid, @c: red) &#123; border: 21px @arguments;&#125;.div1 &#123; .border;&#125;.div2 &#123; .border(solid, black)&#125;//编译输出.div1 &#123; border: 21px solid #ff0000;&#125;.div2 &#123; border: 21px solid #000000;&#125; 匹配模式 自定义一个字符，使用时加上那个字符，就调用相应的规则 1234567891011121314151617181920.border(all, @w: 5px) &#123; border-radius: @w;&#125;.border(t_l, @w: 5px) &#123; border-top-left-radius: @w;&#125;.border(b_l, @w: 5px) &#123; border-bottom-left-radius: @w;&#125;.border(b_r, @w: 5px) &#123; border-bottom-right-radius: @w;&#125;.border &#123; .border(all, 50%);&#125;//编译结果.border &#123; border-radius: 50%;&#125; 得到混合中变量的返回值12345678910111213141516171819.average(@x, @y) &#123; @average((@x + @y)/2);&#125;div &#123; .average(16px, 50px); padding: @average;&#125;//编译结果div &#123; padding: 33px;&#125;/*1、将16px 和 50px 赋值给混合 .average进行计算2、计算结果赋值给变量 @average3、然后在div中调用@average的值4、编译后就得到了average的值33px*/ 运算 任何数值、颜色值和变量都可以进行运算 数值类运算 less会自动推算数值的单位，不必每个值都加上单位 运算符之间必须以空格分开，存在优先级问题时注意使用括号 12345678.wp &#123; width: (450px - 50)*2;&#125;//编译输出.wp &#123; width: 900px;&#125; 颜色值运算 先将颜色值转换为rgb模式，运算完后再转换为16进制的颜色值并返回 注意：取值为0-255，所以计算时不能超过这个区间，超过默认使用0或255 注意：不能使用颜色名直接运算 123456789101112.content &#123; color: #000000 + 8;&#125;//rgb(0,0,0) + 8//rgb(8,8,8)//十六进制：#080808//编译输出.content &#123; color: #080808; &#125; 命名空间 有时混合中嵌套了比较多的规则，而我们只需要其中一部分，可使用命名空间获取 使用 “&gt;” 符号123456789101112131415161718192021222324252627282930313233//混合集#bgcolor() &#123; background: #fff; .a() &#123; color: #888; &amp;:hover &#123; color: #ff6600; &#125; .b() &#123; background: #ff0000; &#125; &#125;&#125;.bgcolor1 &#123; background: #fdfee0; #bgcolor&gt;.a; //只使用.a()&#125;.bgcolor2 &#123; #bgcolor&gt;.a&gt;.b; //只使用.b()&#125;//编译输出.bgcolor1 &#123; background: #fdfee0; color: #888;&#125;.bgcolor1:hover &#123; color: #ff6600;&#125;.bgcolor2 &#123; background: #ff0000;&#125; 省略 “&gt;”，换成空格123456789101112131415161718192021222324252627282930313233//混合集#bgcolor() &#123; background: #fff; .a() &#123; color: #888; &amp;:hover &#123; color: #ff6600; &#125; .b() &#123; background: #ff0000; &#125; &#125;&#125;.bgcolor1 &#123; background: #fdfee0; #bgcolor .a; //只使用.a()&#125;.bgcolor2 &#123; #bgcolor .a .b; //只使用.b()&#125;//编译输出.bgcolor1 &#123; background: #fdfee0; color: #888;&#125;.bgcolor1:hover &#123; color: #ff6600;&#125;.bgcolor2 &#123; background: #ff0000;&#125; 引入 引入一个或多个文件，这些文件定义的规则可在当前less文件中使用 使用@import 引入less文件12345678910111213141516171819//main.less@wp: 960px;.color &#123; color: #fff;&#125;//当前less文件@import "main"; //可以不加后缀.content &#123; width: @wp;&#125;//编译输出.color &#123; color: #fff&#125;.content &#123; width: 960px;&#125; 引入css文件 注意：不能混合css的规则到项目中，编译后原样输出“@import xxx.css” 并且引入时不能省略后缀名 1234567891011121314151617//main.css.color &#123; color: #ff6600;&#125;@import "main.css" ;.content &#123; width: @wp; height: @wp;&#125;//编译输出@import "main.css"; //原样输出,但有效，css有这条语句.content &#123; width: 960px; height: 960px;&#125; 带参数的引入 once：默认，只引入一次 reference：使用less文件但不输出，注意对比上面的例子（ 不使用会输出没有加括号的混合） 123456789101112131415@wp: 960px;.color &#123; color: #fff;&#125;//当前less文件@import (reference) "main";.content &#123; width: @wp;&#125;//编译输出.content &#123; width: 960px;&#125; inline：在输出中包含less文件但是不能操作 12345678910111213141516@wp: 960px;.color &#123; color: #fff;&#125;//当前less文件@import (inline) "main"; .content &#123; width: @wp;&#125;//编译输出@wp: 960px; //报错，@wp未知.color &#123; color: #fff;&#125; less：将文件作为less文件对象，无论什么文件扩展名 123456789101112131415161718//main.css文件.color &#123; color: #ff6600;&#125;//当前less@import (less) "main.css"; .content &#123;.color;&#125;//编译输出.color &#123; color: #ff6600;&#125;.content &#123; color: #ff6600;&#125; css：将文件作为css文件对象，无论什么文件扩展名 1234567891011//当前less文件@import (css) "main.less";.content &#123; color: red;&#125;//编译输出@import "main.less";.content &#123; color: red;&#125; multiple：允许引入多次相同文件名的文件 123456789101112131415161718192021//当前less@import (multiple) "main.less";@import (multiple) "main.less";@import (multiple) "main.less";.content &#123; width: @wp;&#125;//编译输出.color &#123; color: #fff;&#125;.color &#123; color: #fff;&#125;.color &#123; color: #fff;&#125;.content &#123; width: 960px;&#125; !important 提升权重优先级为最高（尽量避免使用） 在调用的混合集后面追加 !important 关键字，混合集中所有属性都继承!important 1234567891011121314.foo(@bg: #fdfdfd, @color: #900) &#123; background: @bg; color: @color;&#125;.important &#123; .foo() !important&#125;//编译输出.important &#123; background: #fdfdfd !important; color: #990000 !important;&#125; 条件表达式带条件的混合 比较运算符：&gt;, &gt;=, =, =&lt;, &lt; 格式：when() { } 123456789101112131415161718192021222324252627// lightness() 是检测亮度的函数，用%度量.mixin(@a) when(lightness(@a) &gt;= 50% ) &#123; background-color: black;&#125;.mixin(@a) when(lightness(@a) &lt; 50% ) &#123; background-color: white;&#125;.mixin(@a) &#123; color: @a;&#125;.class1 &#123; .mixin(#ddd);&#125;.class2 &#123; .mixin(#555);&#125;//编译输出.class1 &#123; background-color: black; color: #dddddd;&#125;.class2 &#123; background-color: white; color: #555555;&#125; 类型检测函数 检测值的类型 iscolor isnumber isstring iskeyword isurl 12345678.mixin(@a: #fff; @b: 0) when(isnumber(@b)) &#123; color: @a; font-size: @b;&#125;.mixin(@a; @b: black) when(iscolor(@b)) &#123; font-size: @a; color: @b;&#125; 单位检测函数 检测一个值除了数字是否是一个特定的单位 ispixel ispercentage isem isunit 123456789101112131415161718192021.mixin(@a) when(ispixel(@a)) &#123; width: @a;&#125;.mixin(@a) when(ispercentage(@a)) &#123; width: @a;&#125;.class1 &#123; .mixin(960px);&#125;.class2 &#123; .mixin(95%);&#125;//编译输出.class1 &#123; width: 960px;&#125;.class2 &#123; width: 95%;&#125; 循环 混合可以调用自身，当一个混合递归调用自身就构成循环结构 1234567891011121314151617181920212223242526.loop(@counter) when(@counter &gt; 0) &#123; .h@&#123;counter&#125; &#123; padding: (10px*@counter); &#125; .loop((@counter - 1)); //递归调用自身&#125;div&#123; .loop(5);&#125;//编译输出div .h5 &#123; padding: 50px;&#125;div .h4 &#123; padding: 40px;&#125;div .h3 &#123; padding: 30px;&#125;div .h2 &#123; padding: 20px;&#125;div .h1 &#123; padding: 10px;&#125; 合并属性 将多条规则合并为一条 方式一 在需要合并的属性的冒号之前加上 “+”，合并后用逗号分隔 123456789101112.mixin() &#123; box-shadow+: inset 0 0 10px #555;&#125;.myclass &#123; .mixin; box-shadow+: 0 0 20px black;&#125;//编译输出.myclass &#123; box-shadow: inset 0 0 10px #555, 0 0 20px black; //逗号分隔两个属性值&#125; 方式二 在需要合并的属性的冒号之前加上 “+_”，合并用空格分隔 12345678910111213.mixin() &#123; background+_: #f66; background+_: url("/sss.jpg") &#125;.class &#123; .mixin;&#125;//编译输出.class &#123; background: #f66 url("/sss.jpg"); //空格分隔&#125; 两种方式结合1234567891011121314.mixin() &#123; background+_: #f66; background+: url("/sss.jpg"); background+_: no-repeat; background+: center;&#125;.class &#123; .mixin;&#125;//编译输出.class &#123; background: #f66, url("/sss.jpg") no-repeat, center;&#125; 函数库 less中封装了非常多函数库，例如颜色定义、颜色操作、颜色混合、字符串处理等等 例如color()：用于解析颜色，将代表颜色的字符串转换为颜色值 更多参考：https://less.bootcss.com/functions/#functions-overview 作用域LESS 中的作用域跟其他编程语言非常类似，首先会从本地查找变量或者混合模块，如果没找到的话会去父级作用域中查找，直到找到为止. 123456789101112@var: red;#page &#123; @var: white; #header &#123; color: @var; // white &#125;&#125;#footer &#123; color: @var; // red &#125; 避免编译有时候我们需要输出一些不正确的CSS语法或者使用一些 LESS不认识的专有语法. 要输出这样的值我们可以在字符串前加上一个 ~, 例如: 123456789.class &#123; filter: ~"ms:alwaysHasItsOwnSyntax.For.Stuff()";&#125;//output.class &#123; filter: ms:alwaysHasItsOwnSyntax.For.Stuff();&#125; 注释 /**/ 可以使用，会被编译 // 可以使用，但不会被编译到css中，会自动过滤掉。 less不认识的内容 不会被编译 参考链接官方文档：https://www.html.cn/doc/less/features/ http://www.bootcss.com/p/lesscss/#guide https://www.jianshu.com/p/15ed47ff8b06]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
        <tag>Less</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android混淆(Proguard)详解]]></title>
    <url>%2F2019%2F04%2F12%2FAndroid%E6%B7%B7%E6%B7%86-Proguard-%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[混淆的作用及好处混淆属于整个应用程序开发生命周期偏后期阶段的技术了，所以要考虑应用的安全性及性能的问题，混淆就是为了这种需求产生的一种技术，简单说，混淆就是将关键字和关键类名，修改为无意义的字符以起到迷惑试图反编译去查看源码的人。在一定程度上能过滤掉一些入门反编译者，混淆是保障Android程序源码安全的第一道门槛，以上谈了下混淆的作用，而混淆的好处除了能保证源码安全性之外就大概是通过修改关键字为无意义字符串，或者剔除某些辅助类，比如Log，从而减少文件大小。 混淆的原理proguard官网 Java 是一种跨平台的、解释型语言，Java 源代码编译成中间”字节码”存储于 class 文件中。由于跨平台的需要，Java 字节码中包括了很多源代码信息，如变量名、方法名，并且通过这些名称来访问变量和方法，这些符号带有许多语义信息，很容易被反编译成 Java 源代码。为了防止这种现象，我们可以使用 Java 混淆器对 Java 字节码进行混淆。混淆就是对发布出去的程序进行重新组织和处理，使得处理后的代码与处理前代码完成相同的功能，而混淆后的代码很难被反编译，即使反编译成功也很难得出程序的真正语义。被混淆过的程序代码，仍然遵照原来的档案格式和指令集，执行结果也与混淆前一样，只是混淆器将代码中的所有变量、函数、类的名称变为简短的英文字母代号，在缺乏相应的函数名和程序注释的况下，即使被反编译，也将难以阅读。同时混淆是不可逆的，在混淆的过程中一些不影响正常运行的信息将永久丢失，这些信息的丢失使程序变得更加难以理解。混淆器的作用不仅仅是保护代码，它也有精简编译后程序大小的作用。由于以上介绍的缩短变量和函数名以及丢失部分信息的原因， 编译后 jar 文件体积大约能减少25%，这对当前费用较贵的无线网络传输是有一定意义的。 混淆的具体使用模块(Module)下的build.gradle的配置 1234567891011android&#123; buildTypes&#123; release &#123; // 是否进行混淆 minifyEnabled false // 混淆文件的位置，其中'proguard-android.txt'为sdk默认的混淆配置， //'proguard-rules.pro' 是该模块下的混淆配置 proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro' &#125; &#125;&#125; 以上是proguard在模块下build.gradle文件中的配置信息，其中proguard-android.txt为sdk默认的混淆配置，proguard-rules.pro是在默认配置的基础上针对本模块做出的针对性混淆处理。 proguard-android.txt 这个文件是系统默认混淆文件一般不需要做修改 在 debug 版下也可以开启混淆做为测试 Gradle 2.2 之后，defaultProguardFile 没有使用 SDK 目录下的 proguard-android.txt，而是使用了 gradle 自带的 proguard-android.txt，不同的 gradle 版本带有不同的默认混淆文件，比如在项目根目录的 build/intermediates/proguard-files/proguard-android.txt-2.3.3，即为 gradle 自带的混淆文件。在 proguard-android.txt-2.3.3 文件中也写有说明，Gradle 2.2 之后自带混淆文件 注：proguard-android.txt的位置位于android-sdk/tools/proguard/proguard-android.txt 混淆规则这个语法的作用是定义出 不需要混淆的源代码，那么编译时会自动将未定义的部分全都混淆。而如下是不需要混淆的 Android 四大组件 native方法 Java 反射用到的类 自定义控件 枚举类 JavaBean Parcelable、Serializable 序列化类 WebView 与 JS 交互所用到的类和方法 混淆步骤 proguard分为4个步骤： 压缩（shrink）移除未使用的类、方法、字段等； 优化（optimize）优化字节码、简化代码等操作； 混淆（obfuscate）使用简短的、无意义的名称重全名类名、方法名、字段等； 预校验（preverify）为class添加预校验信息。 混淆基本指令12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667-dontshrink# 声明不进行压缩操作，默认情况下，除了-keep配置（下详）的类及其直接或间接引用到的类，都会被移除。#---------------------------------------------- shrink-dontoptimize# 不对class进行优化，默认开启优化。# 注意：由于优化会进行类合并、内联等多种优化，-applymapping可能无法完全应用，需使用热修复的应用，建议使用此# 配置关闭优化。-optimizationpasses n# 执行优化的次数，默认1次，多次能达到更好的优化效果。-optimizations optimization_filter优化配置，可进行字段优化、内联、类合并、代码简化、算法指令精简等操作。#只进行 移除未使用的局部变量、算法指令精简-optimizations code/removal/variable,code/simplification/arithmetic#进行除 算法指令精简、字段、类合并外的所有优化-optimizations !code/simplification/arithmetic,!field/*,!class/merging/*#---------------------------------------------- optimize-dontobfuscate# 不进行混淆，默认开启混淆。除-keep指定的类及成员外，都会被替换成简短、随机的名称，以达到混淆的目的。-applymapping filename# 根据指定的mapping映射文件进行混淆。-obfuscationdictionary filename# 指定字段、方法名的混淆字典，默认情况下使用abc等字母组合，比如根据自己的喜好指定中文、特殊字符进行混淆命名。-classobfuscationdictionary filename# 指定类名混淆字典。-packageobfuscationdictionary filename# 指定包名混淆字典。-useuniqueclassmembernames# 指定相同的混淆名称对应不同类的相同成员，不同的混淆名称对应不同的类成员。在没有指定这个选项时，不同类的不同方法都可能映射到a,b,c。# 有一种情况，比如两个不同的接口，拥有相同的方法签名，在没有指定这个选项时，这两个接口的方法可能混淆成不同的名称。但如果新增一个类同时实现这两个接口，并且利用-applymapping指定之前的mapping映射文件时，这两个接口的方法必须混淆成相同的名称，这时就和之前的mapping冲突了。# 在某此热修复场景下需要指定此选项。-dontusemixedcaseclassnames# 指定不使用大小写混用的类名，默认情况下混淆后的类名可能同时包含大写小字母。这在某些对大小写不敏感的系统（如windowns）上解压时，可能存在文件被相互覆盖的情况。-keeppackagenames [package_filter]# 指定不混淆指定的包名，多个包名可以用逗号分隔，可以使用? * **通配符，并且可以使用否定符（!）。-keepattributes [attribute_filter]# 指定保留属性，多个属性可以用多个-keepattributes配置，也可以用逗号分隔，可以使用? * **通配符，并且可以使用否定符（!）。# 比如，在混淆ibrary库时，应该至少keep Exceptions, InnerClasses, Signature；如果在追踪代码，还需要keep符号表；使用到注解时也需要keep。-keepattributes Exceptions,InnerClasses,Signature-keepattributes SourceFile,LineNumberTable-keepattributes *Annotation*-keepparameternames# 指定keep已经被keep的方法的参数类型和参数名称，在混淆library库时非常有用，可供IDE帮助用户进行信息提示和代码自动填充。#---------------------------------------------- obfuscate-dontpreverify# 指定不对class进行预校验，默认情况下，在编译版本为micro或者1.6或更高版本时是开启的。但编译成Android版本时，预校验是不必须的，配置这个选项可以节省一点编译时间。（Android会把class编译成dex，并对dex文件进行校验，对class进行预校验是多余的。）#---------------------------------------------- preverify keep配置1234567891011# -keep [,modifier,...] class_specification# 指定类及类成员作为代码入口，保护其不被proguard，如：-keep class com.rush.Test-keep interface com.rush.InterfaceTest-keep class com.rush.** &#123; &lt;init&gt;; public &lt;fields&gt;; public &lt;methods&gt;; public *** get*(); void set*(***);&#125; class表示keep类或接口 interface仅表示keep接口 类名 通配符如下: 通配符 含义 ? 匹配单个字符，包名分隔符（.）除外 * 匹配除（.）外的任意字符 ** 匹配任意字符（包含.），如com.rush.**匹配com.rush包下的所有类及其所有子包的类。 字段和方法 通配符如下： 通配符 含义 &lt;init&gt; 匹配所有构造方法 &lt;fields&gt; 匹配所有字段 &lt;methods&gt; 匹配所有方法 ? 匹配单个字符，包名分隔符（.）除外 * 匹配除（.）外的任意字符 类型 通配符如下： 通配符 含义 % 匹配原始类型，如int, boolean等 ? 匹配任意单个字符 * 匹配除包名分隔符（.）外的任意字符 ** 匹配任意字符，包括包名分隔符（.） *** 匹配任意类型（原始类型、非原始类型、数组或非数组类型） … 匹配任意参数个数，任意参数类型 其中类配置完整定义如下，其中[]表示可选： 123456789101112[@annotationtype] [[!]public|final|abstract|@ ...] [!]interface|class|enum classname [extends|implements [@annotationtype] classname][&#123; [@annotationtype] [[!]public|private|protected|static|volatile|transient ...] &lt;fields&gt; | (fieldtype fieldname); [@annotationtype] [[!]public|private|protected|static|synchronized|native|abstract|strictfp ...] &lt;methods&gt; | &lt;init&gt;(argumenttype,...) | classname(argumenttype,...) | (returntype methodname(argumenttype,...)); [@annotationtype] [[!]public|private|protected|static ... ] *; ...&#125;] 保留 防止被移除或重命名 防止被重命名（未使用的会被移除） 类和类成员 -keep -keepnames 仅类成员 -keepclassmembers -keepclassmembernames 如类含有某成员，保留类及其成员 -keepclasseswithmembers -keepclasseswithmembernames 更多详细指令12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485# 代码混淆压缩比，在 0~7 之间-optimizationpasses 5# 不提示警告-dontwarn# 混合时不使用大小写混合，混合后的类名为小写-dontusemixedcaseclassnames# 指定不忽略非公共库的类和类成员-dontskipnonpubliclibraryclasses-dontskipnonpubliclibraryclassmembers# 这句话能够使我们的项目混淆后产生映射文件# 包含有类名-&gt;混淆后类名的映射关系-verbose# 不做预校验，preverify是proguard的四个步骤之一，Android不需要preverify，去掉这一步能够加快混淆速度-dontpreverify# 保留Annotation不混淆-keepattributes *Annotation*,InnerClasses# 避免混淆泛型-keepattributes Signature# 抛出异常时保留代码行号-keepattributes SourceFile,LineNumberTable# 指定混淆是采用的算法，后面的参数是一个过滤器# 这个过滤器是 Google 推荐的算法，一般不做修改-optimizations !code/simplification/arithmetic,!code/simplification/cast,!field/*,!class/merging/*# 是否允许改变作用域的，可以提高优化效果# 但是，如果你的代码是一个库的话，最好不要配置这个选项，因为它可能会导致一些 private 变量被改成 public，谨慎使用#-allowaccessmodification# 指定一些接口可能会被合并，即使一些子类没有同时实现两个接口的方法。这种情况在java源码中是不允许存在的，但是在java字节码中是允许存在的。# 它的作用是通过合并接口减少类的数量，从而达到减少输出文件体积的效果。仅在 optimize 阶段有效。# 如果在开启后没有任何影响可以使用，这项配置对于一些虚拟机的65535方法数限制是有一定效果的，谨慎使用#-mergeinterfacesaggressively# 输出所有找不到引用和一些其它错误的警告，但是继续执行处理过程。不处理警告有些危险，所以在清楚配置的具体作用的时候再使用-ignorewarnings-include &#123;filename&#125; #从给定的文件中读取配置参数-basedirectory &#123;directoryname&#125; #指定基础目录为以后相对的档案名称-injars &#123;class_path&#125; #指定要处理的应用程序jar,war,ear和目录-outjars &#123;class_path&#125; #指定处理完后要输出的jar,war,ear和目录的名称-libraryjars &#123;classpath&#125; #指定要处理的应用程序jar,war,ear和目录所需要的程序库文件-dontskipnonpubliclibraryclasses #指定不去忽略非公共的库类。-dontskipnonpubliclibraryclassmembers #指定不去忽略包可见的库类的成员。 #保留选项-keep &#123;Modifier&#125; &#123;class_specification&#125; #保护指定的类文件和类的成员-keepclassmembers &#123;modifier&#125; &#123;class_specification&#125; #保护指定类的成员，如果此类受到保护他们会保护的更好-keepclasseswithmembers &#123;class_specification&#125; #保护指定的类和类的成员，但条件是所有指定的类和类成员是要存在。-keepnames &#123;class_specification&#125; #保护指定的类和类的成员的名称（如果他们不会压缩步骤中删除）-keepclassmembernames &#123;class_specification&#125; #保护指定的类的成员的名称（如果他们不会压缩步骤中删除）-keepclasseswithmembernames &#123;class_specification&#125; #保护指定的类和类的成员的名称，如果所有指定的类成员出席（在压缩步骤之后）-printseeds &#123;filename&#125; #列出类和类的成员-keep选项的清单，标准输出到给定的文件 #压缩-dontshrink #不压缩输入的类文件-printusage &#123;filename&#125;-whyareyoukeeping &#123;class_specification&#125; #优化-dontoptimize #不优化输入的类文件-assumenosideeffects &#123;class_specification&#125; #优化时假设指定的方法，没有任何副作用-allowaccessmodification #优化时允许访问并修改有修饰符的类和类的成员 #混淆-dontobfuscate #不混淆输入的类文件-printmapping &#123;filename&#125;-applymapping &#123;filename&#125; #重用映射增加混淆-obfuscationdictionary &#123;filename&#125; #使用给定文件中的关键字作为要混淆方法的名称-overloadaggressively #混淆时应用侵入式重载-useuniqueclassmembernames #确定统一的混淆类的成员名称来增加混淆-flattenpackagehierarchy &#123;package_name&#125; #重新包装所有重命名的包并放在给定的单一包中-repackageclass &#123;package_name&#125; #重新包装所有重命名的类文件中放在给定的单一包中-dontusemixedcaseclassnames #混淆时不会产生形形色色的类名-keepattributes &#123;attribute_name,...&#125; #保护给定的可选属性，例如LineNumberTable, LocalVariableTable, SourceFile, Deprecated, Synthetic, Signature, and #InnerClasses.-renamesourcefileattribute &#123;string&#125; #设置源文件中给定的字符串常量 混淆日志12345678# APK 包内所有 class 的内部结构-dump proguard/class_files.txt# 未混淆的类和成员-printseeds proguard/seeds.txt# 列出从 APK 中删除的代码-printusage proguard/unused.txt# 混淆前后的映射，这个文件在追踪异常的时候是有用的-printmapping proguard/mapping.txt 其他自定义混淆规则123456789101112# JavaBean 实体类不能混淆，一般会将实体类统一放到一个包下，you.package.path 请改成你自己的项目路径-keep public class com.frame.mvp.entity.** &#123; *;&#125;# 网页中的 JavaScript 进行交互，you.package.path 请改成你自己的项目路径#-keepclassmembers class you.package.path.JSInterface &#123;# &lt;methods&gt;;#&#125;# 需要通过反射来调用的类，没有可忽略，you.package.path 请改成你自己的项目路径#-keep class you.package.path.** &#123; *; &#125; 一些不是很常用但比较实用的混淆命令123456789101112131415161718192021222324252627282930313233# 所有重新命名的包都重新打包，并把所有的类移动到所给定的包下面。如果没有指定 packagename，那么所有的类都会被移动到根目录下# 如果需要从目录中读取资源文件，移动包的位置可能会导致异常，谨慎使用# you.package.path 请改成你自己的项目路径-flatternpackagehierarchy# 所有重新命名过的类都重新打包，并把他们移动到指定的packagename目录下。如果没有指定 packagename，同样把他们放到根目录下面。# 这项配置会覆盖-flatternpackagehierarchy的配置。它可以代码体积更小，并且更加难以理解。# you.package.path 请改成你自己的项目路径-repackageclasses you.package.path# 指定一个文本文件用来生成混淆后的名字。默认情况下，混淆后的名字一般为 a、b、c 这种。# 通过使用配置的字典文件，可以使用一些非英文字符做为类名。成员变量名、方法名。字典文件中的空格，标点符号，重复的词，还有以&apos;#&apos;开头的行都会被忽略。# 需要注意的是添加了字典并不会显著提高混淆的效果，只不过是更不利与人类的阅读。正常的编译器会自动处理他们，并且输出出来的jar包也可以轻易的换个字典再重新混淆一次。# 最有用的做法一般是选择已经在类文件中存在的字符串做字典，这样可以稍微压缩包的体积。# 字典文件的格式：一行一个单词，空行忽略，重复忽略-obfuscationdictionary# 指定一个混淆类名的字典，字典格式与 -obfuscationdictionary 相同#-classobfuscationdictionary# 指定一个混淆包名的字典，字典格式与 -obfuscationdictionary 相同-packageobfuscationdictionary# 混淆的时候大量使用重载，多个方法名使用同一个混淆名，但是他们的方法签名不同。这可以使包的体积减小一部分，也可以加大理解的难度。仅在混淆阶段有效。# 这个参数在 JDK 版本上有一定的限制，可能会导致一些未知的错误，谨慎使用-overloadaggressively# 方法同名混淆后亦同名，方法不同名混淆后亦不同名。不使用该选项时，类成员可被映射到相同的名称。因此该选项会增加些许输出文件的大小。-useuniqueclassmembernames# 指定在混淆的时候不使用大小写混用的类名。默认情况下，混淆后的类名可能同时包含大写字母和小写字母。# 这样生成jar包并没有什么问题。只有在大小写不敏感的系统（例如windows）上解压时，才会涉及到这个问题。# 因为大小写不区分，可能会导致部分文件在解压的时候相互覆盖。如果有在windows系统上解压输出包的需求的话，可以加上这个配置。-dontusemixedcaseclassnames Android开发常用不需要混淆指令123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119# Android 四大组件相关-keep public class * extends android.app.Activity-keep public class * extends android.app.Appliction-keep public class * extends android.app.Service-keep public class * extends android.content.BroadcastReceiver-keep public class * extends android.content.ContentProvider-keep public class * extends android.app.backup.BackupAgentHelper-keep public class * extends android.preference.Preference-keep public class * extends android.view.View-keep public class com.android.vending.licensing.ILicensingService# Fragment-keep public class * extends android.support.v4.app.Fragment-keep public class * extends android.app.Fragment# 保留support下的所有类及其内部类-keep class android.support.** &#123; *; &#125;-keep interface android.support.** &#123; *; &#125;-dontwarn android.support.**# 保留 R 下面的资源-keep class **.R$* &#123;*;&#125;-keepclassmembers class **.R$* &#123; public static &lt;fields&gt;;&#125;# 保留本地 native 方法不被混淆-keepclasseswithmembernames class * &#123; native &lt;methods&gt;;&#125;# 保留在 Activity 中的方法参数是 view 的方法，# 这样以来我们在 layout 中写的 onClick 就不会被影响-keepclassmembers class * extends android.app.Activity&#123; public void *(android.view.View);&#125;# 保留枚举类不被混淆-keepclassmembers enum * &#123; public static **[] values(); public static ** valueOf(java.lang.String);&#125;# 保留自定义控件（继承自View）不被混淆-keep public class * extends android.view.View&#123; *** get*(); void set*(***); public &lt;init&gt;(android.content.Context); public &lt;init&gt;(android.content.Context, android.util.AttributeSet); public &lt;init&gt;(android.content.Context, android.util.AttributeSet, int);&#125;# 保留 Parcelable 序列化类不被混淆-keep class * implements android.os.Parcelable &#123; public static final android.os.Parcelable$Creator *;&#125;# 保留 Serializable 序列化的类不被混淆-keepclassmembers class * implements java.io.Serializable &#123; static final long serialVersionUID; private static final java.io.ObjectStreamField[] serialPersistentFields; private void writeObject(java.io.ObjectOutputStream); private void readObject(java.io.ObjectInputStream); java.lang.Object writeReplace(); java.lang.Object readResolve();&#125;# 对于带有回调函数的 onXXEvent 的，不能被混淆-keepclassmembers class * &#123; void *(**On*Event);&#125;# WebView，没有使用 WebView 请注释掉-keepclassmembers class fqcn.of.javascript.interface.for.webview &#123; public *;&#125;-keepclassmembers class * extends android.webkit.webViewClient &#123; public void *(android.webkit.WebView, java.lang.String, android.graphics.Bitmap); public boolean *(android.webkit.WebView, java.lang.String);&#125;-keepclassmembers class * extends android.webkit.webViewClient &#123; public void *(android.webkit.webView, jav.lang.String);&#125;# 不混淆使用了 @Keep 注解相关的类-keep class android.support.annotation.Keep-keep @android.support.annotation.Keep class * &#123;*;&#125;-keepclasseswithmembers class * &#123; @android.support.annotation.Keep &lt;methods&gt;;&#125;-keepclasseswithmembers class * &#123; @android.support.annotation.Keep &lt;fields&gt;;&#125;-keepclasseswithmembers class * &#123; @android.support.annotation.Keep &lt;init&gt;(...);&#125;# 删除代码中 Log 相关的代码，如果删除了一些预料之外的代码，很容易就会导致代码崩溃，谨慎使用-assumenosideeffects class android.util.Log&#123; public static boolean isLoggable(java.lang.String,int); public static int v(...); public static int i(...); public static int w(...); public static int d(...); public static int e(...);&#125;# 删除自定义Log工具-assumenosideeffects class com.example.Log.Logger&#123; public static int v(...); public static int i(...); public static int w(...); public static int d(...); public static int e(...);&#125; proguard配置示例Android默认推荐配置在IDE自动生成的project.properties文件中，有这样一行： 1#proguard.config=$&#123;sdk.dir&#125;/tools/proguard/proguard-android.txt:proguard-project.txt Android Studio默认生成的build.gradle文件有如下配置： 123456buildTypes &#123; release &#123; minifyEnabled false proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro' &#125;&#125; 其中getDefaultProguardFile(‘proguard-android.txt’)获取的也是tools/proguard/proguard-android.txt。 下面看一下这个文件的配置 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152# 不使用大小写混合类名-dontusemixedcaseclassnames# 不路过引用库中的非public类-dontskipnonpubliclibraryclasses# 输出更多信息-verbose# 不进行优化-dontoptimize# 不进行预校验-dontpreverify# keep注解-keepattributes *Annotation*#keep google license服务接口-keep public class com.google.vending.licensing.ILicensingService-keep public class com.android.vending.licensing.ILicensingService# keep native方法及其所属类-keepclasseswithmembernames class * &#123; native &lt;methods&gt;;&#125;# keep自定义view的get/set方法-keepclassmembers public class * extends android.view.View &#123; void set*(***); *** get*();&#125;# keep继续自Activity中所有包含public void *(android.view.View)签名的方法，如onClick-keepclassmembers class * extends android.app.Activity &#123; public void *(android.view.View);&#125;# keep枚举中的values和valueOf方法-keepclassmembers enum * &#123; public static **[] values(); public static ** valueOf(java.lang.String);&#125;# keep Parcelable的CREATOR成员-keepclassmembers class * implements android.os.Parcelable &#123; public static final android.os.Parcelable$Creator CREATOR;&#125;# keep R文件的静态字段-keepclassmembers class **.R$* &#123; public static &lt;fields&gt;;&#125;# 不输出support包中的警告-dontwarn android.support.** 典型library库的配置示例引用自官方文档samples:https://www.guardsquare.com/en/products/proguard/manual/examples#library 123456789101112131415161718192021222324252627282930313233343536# 这个配置未弄清楚，待测试-renamesourcefileattribute SourceFile -keepattributes Exceptions,InnerClasses,Signature,Deprecated, SourceFile,LineNumberTable,*Annotation*,EnclosingMethod # keep所有类的protected成员-keep public class * &#123; public protected *; &#125; # keep在jdk 1.2中编译器插入的代码-keepclassmembernames class * &#123; java.lang.Class class$(java.lang.String); java.lang.Class class$(java.lang.String, boolean); &#125; # keep native方法-keepclasseswithmembernames,includedescriptorclasses class * &#123; native &lt;methods&gt;; &#125; # keep枚举中的values和valueOf方法-keepclassmembers,allowoptimization enum * &#123; public static **[] values(); public static ** valueOf(java.lang.String); &#125; # keep系列化相关方法-keepclassmembers class * implements java.io.Serializable &#123; static final long serialVersionUID; private static final java.io.ObjectStreamField[] serialPersistentFields; private void writeObject(java.io.ObjectOutputStream); private void readObject(java.io.ObjectInputStream); java.lang.Object writeReplace(); java.lang.Object readResolve(); &#125; 一个典型Android App的配置示例引用自官方文档samples:https://www.guardsquare.com/en/products/proguard/manual/examples#androidapplication 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647-dontpreverify -repackageclasses &apos;&apos; -allowaccessmodification # 不优化算法指令-optimizations !code/simplification/arithmetic -keepattributes *Annotation* # keep继承自系统组件的类-keep public class * extends android.app.Activity -keep public class * extends android.app.Application -keep public class * extends android.app.Service -keep public class * extends android.content.BroadcastReceiver -keep public class * extends android.content.ContentProvider# keep自定义view及其构造方法、set方法-keep public class * extends android.view.View &#123; public &lt;init&gt;(android.content.Context); public &lt;init&gt;(android.content.Context, android.util.AttributeSet); public &lt;init&gt;(android.content.Context, android.util.AttributeSet, int); public void set*(...); &#125; -keepclasseswithmembers class * &#123; public &lt;init&gt;(android.content.Context, android.util.AttributeSet); &#125; -keepclasseswithmembers class * &#123; public &lt;init&gt;(android.content.Context, android.util.AttributeSet, int); &#125; -keepclassmembers class * extends android.content.Context &#123; public void *(android.view.View); public void *(android.view.MenuItem); &#125; -keepclassmembers class * implements android.os.Parcelable &#123; static ** CREATOR; &#125; -keepclassmembers class **.R$* &#123; public static &lt;fields&gt;; &#125; # keep javascript注释的方法，使用到webview js回调方法的需要添加此配置-keepclassmembers class * &#123; @android.webkit.JavascriptInterface &lt;methods&gt;; &#125; 关于反射并不是所有会被反射引用的类都必须keep，在progurad过程中能直接分析到引用的类会被proguard做相应的处理： 123456789101112131415# Class.forName的类名&quot;SomeClass&quot;被混淆后自动替换Class.forName(&quot;SomeClass&quot;)SomeClass.class# 以下字段和方法名都会在被混淆后自动替换SomeClass.class.getField(&quot;someField&quot;)SomeClass.class.getDeclaredField(&quot;someField&quot;)SomeClass.class.getMethod(&quot;someMethod&quot;, new Class[] &#123;&#125;)SomeClass.class.getMethod(&quot;someMethod&quot;, new Class[] &#123; A.class &#125;)SomeClass.class.getMethod(&quot;someMethod&quot;, new Class[] &#123; A.class, B.class &#125;)SomeClass.class.getDeclaredMethod(&quot;someMethod&quot;, new Class[] &#123;&#125;)SomeClass.class.getDeclaredMethod(&quot;someMethod&quot;, new Class[] &#123; A.class &#125;)SomeClass.class.getDeclaredMethod(&quot;someMethod&quot;, new Class[] &#123; A.class, B.class &#125;)AtomicIntegerFieldUpdater.newUpdater(SomeClass.class, &quot;someField&quot;)AtomicLongFieldUpdater.newUpdater(SomeClass.class, &quot;someField&quot;)AtomicReferenceFieldUpdater.newUpdater(SomeClass.class, SomeType.class, &quot;someField&quot;) 验证一下： 1234Class&lt;?&gt; clazz = Class.forName("com.rush.test.SimpleClass1");clazz.getDeclaredMethod("Test1");SimpleClass2.class.getDeclaredField("mTestField");SimpleClass2.class.getDeclaredMethod("Test2"); 对以上代码编译并proguard，结果如下： 123Class.forName("com.rush.a.a").getDeclaredMethod("Test1", new Class[0]);b.class.getDeclaredField("a");b.class.getDeclaredMethod("a", new Class[0]); 通过Class.forName反射的class com.rush.test.SimpleClass1”被自动替换成了”com.rush.a.a”； 但通过Class.forName获取的class再去反射方法没有正确处理； 通过完整class.getDeclaredField或者getDeclaredMethod反射时能够把字段名和方法名自动替换掉。 从结果看，反射并不是大家想像的那样必须keep，proguard能自动分析到引用的情况都能正确处理。但有些类是在配置文件里配置，或者动态拼接类名反射的，这些情况需要做好keep。 为了问题追踪的方便，建议所有会被反射引用的代码和library public接口都做好keep。 关于proguard配置的一些建议 所有会被反射引用的类都做好keep（建议，虽然有些反射能被正确处理）。如native方法，四大组件，接口model，枚举，序列化类等。 只keep必须保留的内容，不要过度keep 使用热修复的App，添加-dontoptimize配置 资源混淆AndResGuard是一个帮助你缩小APK大小的工具，他的原理类似Java Proguard，但是只针对资源。他会将原本冗长的资源路径变短，例如将res/drawable/wechat变为r/d/a。 AndResGuard不涉及编译过程，只需输入一个apk(无论签名与否，debug版，release版均可，在处理过程中会直接将原签名删除)，可得到一个实现资源混淆后的apk(若在配置文件中输入签名信息，可自动重签名并对齐，得到可直接发布的apk)以及对应资源ID的mapping文件。 github:https://github.com/shwenzhang/AndResGuard/blob/master/README.zh-cn.md 原理:https://mp.weixin.qq.com/s?__biz=MzAwNDY1ODY2OQ==&amp;mid=208135658&amp;idx=1&amp;sn=ac9bd6b4927e9e82f9fa14e396183a8f#rd 丧心病狂的混淆操作原理：混淆是可以配置词典,原文链接 随便找一个开源项目上手 https://github.com/kingwang666/GetApk 开启混淆 123456buildTypes &#123; debug &#123; minifyEnabled true proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro' &#125;&#125; 可以看到上面配置了混淆文件包含：proguard-rules.pro 和moudule的build.gradle在同一目录，在里面可以添加你的词典配置： 强烈建议，开启混淆后，配置词典前，先打个包运行一下确定可以正常运行。 最后上面的混淆词典，分别来自不同的开源项目： https://github.com/RockyQu/ProguardDictionary 包含使用Java关键词的词典。 https://github.com/o2e/ProguardDictionaryGenerator 包含最后那个全是非常神奇的字符的。 https://github.com/WrBug/FrenziedProguard 包含1il,中文，0oO的。 放一个混淆后的apk地址，如果实在懒得run又想看看效果：http://wanandroid.com/blogimgs/57ed3c61-08ee-4a3f-b859-f3cd1d748437.apk 参考链接https://www.jianshu.com/p/60e82aafcfd0 https://rockycoder.cn/android/2018/03/15/Android-proguard-rules.html https://juejin.im/post/5ae7edc7f265da0b776f7a95 https://www.imooc.com/learn/879 https://mp.weixin.qq.com/s/BP3SIDaxAy4-5rZYMibpmA https://www.guardsquare.com/en/proguard/manual/introduction https://www.guardsquare.com/en/proguard/manual/usage https://www.guardsquare.com/en/proguard/manual/examples]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mac应用程序无法打开或文件损坏的处理方法]]></title>
    <url>%2F2019%2F04%2F12%2FMac%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E6%97%A0%E6%B3%95%E6%89%93%E5%BC%80%E6%88%96%E6%96%87%E4%BB%B6%E6%8D%9F%E5%9D%8F%E7%9A%84%E5%A4%84%E7%90%86%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[今天安装一些软件时遇到了 无法打开或文件损坏的Mac应用程序，所以查了一下解决办法，记录在了博客下。 本人机器系统版本Mojave 10.14.4 方法一大多数用户在安装 Mac 应用时，经常会遇到提示 “ XXX.app 已损坏，打不开。您应该将它移到废纸篓 ” 或 “ 打不开 XXX.app，因为它来自身份不明的开发者 ” ，如下图所示： 1. 打开系统偏好设置界面，进入安全性与隐私 2. 点按左下角的锁头图标，解锁更改权限 3. 将允许从以下位置下载的应用，更改为 “ 任何来源 ” ，然后再打开应用即可 若没有“任何来源”这个选项（macOS Sierra 10.12及以上的用户可能会遇到），按以下步骤执行：打开终端（Terminal.app）拷贝粘贴sudo spctl --master-disable，按回车键 输入你的账户密码，按回车键确认执行（该密码不会显示，直接输入即可） 方法二如安装应用时，出现 “ 打不开 XXX.app，因为它来自身份不明的开发者 ” ，并提示你的软件在什么位置什么时间下载了磁盘影像。如图所示： 1、将软件放入“应用程序”后，点击软件 右键-打开 ，如图所示： 2、弹出以下对话框后，你打开即可。 参考链接http://www.puasu.com/article/share/201805/10.html]]></content>
      <categories>
        <category>程序人生</category>
      </categories>
      <tags>
        <tag>Mac</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[移动端前端开发之viewport]]></title>
    <url>%2F2019%2F04%2F11%2F%E7%A7%BB%E5%8A%A8%E7%AB%AF%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E4%B9%8Bviewport%2F</url>
    <content type="text"><![CDATA[背景浏览器的viewport是可以看到Web内容的窗口区域，通常与渲染出的页面的大小不同，这种情况下，浏览器会提供滚动条以滚动访问所有内容。 窄屏幕设备（如移动设备）在一个虚拟窗口或视口中渲染页面，这个窗口或视口通常比屏幕宽；然后缩小渲染的结果，以便在一屏内显示所有内容。然后用户可以移动、缩放以查看页面的不同区域。例如，如果移动屏幕的宽度为640px，则可能会用980px的虚拟视口渲染页面，然后缩小页面以适应640px的窗口大小。 这样做是因为许多页面没有做移动端优化，在小窗口渲染时会乱掉（或看起来乱）。所以，这种虚拟视口是一种让未做移动端优化的网站在窄屏设备上看起来更好的办法。 移动浏览器的问题当我们将移​​动浏览器与桌面浏览器进行比较时，最明显的区别是屏幕尺寸。移动浏览器显示的桌面优化网站显着少于桌面浏览器; 通过缩小直到文本不可读的小，或者只显示适合屏幕的网站的一小部分。 移动屏幕远小于桌面屏幕; 考虑最大宽度为400px，有时候要少得多。（有些手机报告的宽度较大，但它们正在撒谎 - 或者至少给我们无用的信息。） 平板电脑设备的中间层，如iPad或传闻中的基于HP webOS的平板设备，将弥合桌面和移动设备之间的差距，但这不会改变根本问题。网站也必须在移动设备上运行，因此我们必须让它们在小屏幕上显示。 最重要的问题集中在CSS上，尤其是视口的尺寸。如果我们一对一地复制桌面模型，我们的CSS就会开始惨不忍睹。 让我们回到我们的侧边栏吧width: 10%。如果移动浏览器与桌面浏览器完全相同，那么它们最多只能生成40px宽的元素，而且这个元素太窄了。你的液体布局看起来会非常可怕。 解决问题的一种方法是为移动浏览器构建一个特殊网站。即使除了你是否应该这样做的根本问题之外，实际的问题是只有极少数的网站所有者被充分利用以满足移动设备的需求。 移动浏览器供应商希望为他们的客户提供最佳体验，现在这意味着“尽可能像桌面一样。”因此需要一些技巧。 设备像素和CSS像素讲解viewport视口前先来了解一下这两个概念，这两个概念虽然都是说像素，但是此像素非彼像素。 设备像素设备像素（device pixel）是物理概念，顾名思义，显示屏是由一个个物理像素点组成的，通过控制每个像素点的颜色，使屏幕显示出不同的图像，屏幕从工厂出来那天起，它上面的物理像素点就固定不变了，单位。 pt在css单位中属于真正的绝对单位，1pt = 1/72(inch),inch及英寸，而1英寸等于2.54厘米。pt = 1/72(英寸), px = 1/dpi(英寸) 不同的设备，其图像基本单位是不同的，比如显示器的点距，可以认为是显示器的物理像素。现在的液晶显示器的点距一般在0.25mm到0.29mm之间。而打印机的墨点，也可以认为是打印机的物理像素，300DPI就是0.085mm，600DPI就是0.042mm。 注意，我们通常所说的显示器分辨率，其实是指桌面设定的分辨率，而不是显示器的物理分辨率。只不过现在液晶显示器成为主流，由于液晶的显示原理与CRT不同，只有在桌面分辨率与物理分辨率一致的情况下，显示效果最佳，所以现在我们的桌面分辨率几乎总是与显示器的物理分辨率一致了。 CSS像素CSS像素（css pixel）是Web编程概念，指的是CSS样式代码中使用的逻辑像素。 在CSS规范中，长度单位分为两类：绝对（absolute）单位和相对（relative）单位。而px是一个相对单位，相对于设备像素。 CSS像素的相对性 举个例子理解： 使用PC端浏览器打开一个网页，网页中有一个宽400px的盒子（块级元素）。浏览器宽为800px，那么这个盒子的宽此时应该占据页面的一半。但是我们使用浏览器中页面放大功能，放大200%，也就是原来的两倍，那么此时该盒子宽应该占满了整个页面。但是既没有调整浏览器窗口大小，也没有改变任何的css样式，但是该盒子却看上去放大了一倍。这是因为使用页面放大功能把css像素放大了两倍。 CSS像素与屏幕像素1：1同样大小时： CSS像素(黑色边框)开始被拉伸，此时1个CSS像素大于1个屏幕像素 默认情况下一个CSS像素应该是等同于一个物理像素的，但是浏览器放大的操作让一个CSS像素等于两倍的设备像素。 而在移动端中的高PPI的设备上，CSS像素在默认情况下就相当于多个设备像素，如iPhone5使用的是Retina视网膜屏幕，使用2px * 2px的设备像素代表1px * 1px的CSS像素。所以设备像素为640 * 1136，而CSS像素为320px * 568px。 设备独立像素（Device Independent Pixel）简写DIP或DP 设备独立像素也叫 密度无关像素 ，可以认为是计算机坐标系统中的一个点，这个点表示一个可以由程序使用并控制的虚拟像素，可以由相关系统转换为物理像素。设备独立像素是一个整体概念，包括了css像素，比如:css像素，只是在android /ios机中，css像素不叫 “css像素了”，而叫“设备独立像素”。iOS 中的 pt 和安卓中的单位 dp 本质上是一个概念，设备都是独立像素的意思，只是说法不一样。 所以逻辑上各单位的关系：CSS像素 = 设备独立像素 = 逻辑像素 设备像素与CSS像素的关系了解它们间的关系时，先来了解两个概念：ppi和dpr PPI像素密度(pixel per inch) | DPR设备像素比(device pixel ratio) PPI：屏幕密度ppi:表示每英寸所拥有的像素数目，数值越高，代表显示屏能够以越高的密度显示图像。即每英寸像素取值，更确切的说法应该是像素密度，也就是衡量单位物理面积内拥有像素值的情况。 ppi的计算公式可以查阅资料ppi计算公式。 来算一下数学 图中以屏幕尺寸为4寸的iPhone 5s为例，分辨率为1136 x 640，代入公式像素密度为326PPI。计算结果会有出入。 DPI: 每英寸多少点。如果是在当用于描述显示器设备时，ppi和dpi是同一概念，是相等的。 这里的点是一个抽象的单位，它可以是屏幕像素点、图片像素点也可以是打印机的墨点。 平时你可能会看到使用DPI来描述图片和屏幕，这时的DPI应该和PPI是等价的，DPI最常用的是用于描述打印机，表示打印机每英寸可以打印的点数。 一张图片在屏幕上显示时，它的像素点数是规则排列的，每个像素点都有特定的位置和颜色。 当使用打印机进行打印时，打印机可能不会规则的将这些点打印出来，而是使用一个个打印点来呈现这张图像，这些打印点之间会有一定的空隙，这就是DPI所描述的：打印点的密度 在上面的图像中我们可以清晰的看到，打印机是如何使用墨点来打印一张图像。所以，打印机的DPI越高，打印图像的精细程度就越高，同时这也会消耗更多的墨点和时间。 DPR：设备像素比设备像素比（device pixel ratio）定义了设备像素和设备独立像素（CSS像素）的转换关系，即一个设备像素对应多少个设备独立像素（CSS像素）。 与设备的关系：DPR = 屏幕横向设备像素 / 设备PPI 与设备像素、CSS像素的关系：DPR = 设备像素 / CSS像素 与 理想视口(下文将提到)的关系：DPR = 屏幕横向设备像素 / 理想视口的宽度 在一台移动终端中，设备像素的大小是固定的，不可变的。但是设备独立像素dip是可以被拉长或压缩的。 例如iPhone5s中使用的是Retina视网膜屏幕，即PPI超过300的都叫做超高密度屏幕，只不过苹果公司给了换了个高大上的名字：Retina视网膜屏幕。 但是在普通屏幕下1个设备像素等于一个CSS像素的设备已经很少了，比如 Iphone 5s 设备像素比为2，Iphone 6s 设备像素比为3。至于安卓机中的设备像素比就更多了，有1.3、1.5、2、3等等。 如何理解DPR 设备像素比(dpr) 是指在移动开发中1个css像素占用多少设备像素，如2代表1个css像素用2x2个设备像素来绘制。 设备像素比(dpr)，公式为1px = (dpr)^2 * 1dp，可以理解为1px由多少个设备像素组成； 打开chrome的开发者工具，我们可以模拟各个手机型号的显示情况，每种型号上面会显示一个尺寸，比如iPhone X显示的尺寸是375x812，实际iPhone X的分辨率会比这高很多，这里显示的就是设备独立像素。 设备像素和CSS像素的关系以iPhone6/7/8为例： 设备宽高为375 × 667，可以理解为设备独立像素(或css像素)。dpr为2，根据上面的计算公式，其物理像素就为750 × 1334。 上图中可以看出，对于这样的css样式： 12width: 2px;height: 2px; 在不同的屏幕上(普通屏幕 vs retina屏幕)，css像素所呈现的大小(物理尺寸)是一致的，不同的是1个css像素所对应的物理像素个数是不一致的。 在普通屏幕下，1个css像素 对应 1个物理像素(1:1)。 在retina 屏幕下，1个css像素对应 4个物理像素(1:4)。 window.devicePixelRatiowindow.devicePixelRatio是设备上物理像素和设备独立像素(device-independent pixels (dips))的比例。公式表示就是：window.devicePixelRatio = 物理像素 / dips。 dip或dp,（device independent pixels，设备独立像素）与屏幕密度有关。dip可以用来辅助区分视网膜设备还是非视网膜设备。 所有非视网膜屏幕的iphone在垂直的时候，宽度为320物理像素。当你使用&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width&quot;&gt;的时候，会设置视窗布局宽度（不同于视觉区域宽度，不放大显示情况下，两者大小一致，见下图）为320px, 于是，页面很自然地覆盖在屏幕上。 这样，非视网膜屏幕的iphone上，屏幕物理像素320像素，独立像素也是320像素，因此，window.devicePixelRatio等于1. 而对于视网膜屏幕的iphone，如iphone4s, 纵向显示的时候，屏幕物理像素640像素。同样，当用户设置&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width&quot;&gt;的时候，其视区宽度并不是640像素，而是320像素，这是为了有更好的阅读体验 – 更合适的文字大小。 这样，在视网膜屏幕的iphone上，屏幕物理像素640像素，独立像素还是320像素，因此，window.devicePixelRatio等于2. 在css中，可以通过-webkit-device-pixel-ratio，webkit-min-device-pixel-ratio和-webkit-max-device-pixel-ratio进行媒体查询，对不同dpr的设备，做一些样式适配(这里只针对webkit内核的浏览器和webview)。 兼容性 来自caniuse.com 喜忧参半。好的是Safari, Android WebKit, Chrome 22+(Android), Opera Mobile, BlackBerry WebKit, QQ, Palm WebKit, 及Dolfin都能正确实现该属性。 当然，大部分这些浏览器仍然运行在devicePixelRatio值应该为1的系统上，当它们移动到视网膜类似设备时候，可能就会遇到问题。 注意：你可以为这个 window.devicePixelRatio 重新赋值，但并不会对最终的显示造成任何的影响。 12window.devicePixelRatio = 10;console.log(window.devicePixelRatio); //10 媒体查询min-device-pixel-ratio设备像素比device pixel ratio简称dpr，即物理像素和设备独立像素的比值。 在web中，浏览器为我们提供了window.devicePixelRatio来帮助我们获取dpr。 在css中，可以使用媒体查询min-device-pixel-ratio，区分dpr： 1@media (-webkit-min-device-pixel-ratio: 2),(min-device-pixel-ratio: 2)&#123; &#125; 在React Native中，我们也可以使用PixelRatio.get()来获取DPR。 当然，上面的规则也有例外，iPhone 6、7、8 Plus的实际物理像素是1080 x 1920，在开发者工具中我们可以看到：它的设备独立像素是414 x 736，设备像素比为3，设备独立像素和设备像素比的乘积并不等于1080 x 1920，而是等于1242 x 2208。 实际上，手机会自动把1242 x 2208个像素点塞进1080 * 1920个物理像素点来渲染，我们不用关心这个过程，而1242 x 2208被称为屏幕的设计像素。我们开发过程中也是以这个设计像素为准。 实际上，从苹果提出视网膜屏幕开始，才出现设备像素比这个概念，因为在这之前，移动设备都是直接使用物理像素来进行展示。 设计师和前端工程师之间如何协同视觉稿 在前端开发之前，视觉MM会给我们一个psd文件，称之为视觉稿。 对于移动端开发而言，为了做到页面高清的效果，视觉稿的规范往往会遵循以下两点： 首先，选取一款手机的屏幕宽高作为基准(以前是iphone4的320×480，现在更多的是iphone6的375×667)。对于retina屏幕(如: dpr=2)，为了达到高清效果，视觉稿的画布大小会是基准的2倍，也就是说像素点个数是原来的4倍（对iphone6而言：原先的375×667，就会变成750×1334）。 设计师和前端开发的适配协作基本思路 出自手淘： 选择一种尺寸作为设计和开发基准 定义一套适配规则，自动适配剩下的两种尺寸(其实不仅这两种，你懂的) 特殊适配效果给出设计效果 手淘设计师常选择iPhone6作为基准设计尺寸，交付给前端的设计尺寸是按750px * 1334px为准(高度会随着内容多少而改变)。前端开发人员通过一套适配规则自动适配到其他的尺寸。 分辨率、像素和屏幕尺寸分辨率是指一个块屏幕的像素尺寸。比如说1334 * 750是iPhone6的分辨率。 屏幕尺寸是指显示屏幕对角线的尺寸，一般用英寸来表示。 询问别人一粒像素有多大是一个非常鸡贼的问题（小心面试遇到这样的题），虽然我们说像素是构成屏幕的发光的点，是物理的，但是像素在脱离了屏幕尺寸之后是没有大小可言的，你可以将 1920 * 1080 颗像素放到一台 40 寸的小米电视机里面，也可以将同样多的像素全部塞到一台 5.5 寸的 iPhone7 Plus 手机里面去，那么对于 40 寸的电视而言，每个像素颗粒当然会大于 5.5 寸的手机的像素。 所以光看屏幕的分辨率对于设计师来说是不具备多少实际意义的，通过分辨率计算得出的像素密度（PPI）才是设计师要关心的问题，我们通过屏幕分辨率和屏幕尺寸就能计算出屏幕的像素密度的。 再次使用 iPhone（6~7）作为例子。我们知道该屏幕的横向物理尺寸为 2.3 英寸 ，且横向具有 750 颗像素，根据下面的公式，我们能够算出 iPhone（6~7）的屏幕是 326 PPI，意为每寸存在 326 颗像素。 其实不论我们怎么除，计算得出来的像素密度（PPI）都会是这个数，宽存在像素除以宽物理长度，高存在像素除以高物理长度，得数都接近于 326。 英寸一般用英寸描述屏幕的物理大小，如电脑显示器的17、22，手机显示器的4.8、5.7等使用的单位都是英寸。 需要注意，上面的尺寸都是屏幕对角线的长度 英寸(inch,缩写为in)在荷兰语中的本意是大拇指，一英寸就是指甲底部普通人拇指的宽度。 英寸和厘米的换算：1英寸 = 2.54 厘米 像素像素即一个小方块，它具有特定的位置和颜色。 图片、电子屏幕（手机、电脑）就是由无数个具有特定颜色和特定位置的小方块拼接而成。 像素可以作为图片或电子屏幕的最小组成单位。 屏幕分辨率屏幕分辨率指一个屏幕具体由多少个像素点组成。 iPhone XS Max 和 iPhone SE的分辨率分别为2688 x 1242和1136 x 640。这表示手机分别在垂直和水平上所具有的像素点数。 当然分辨率高不代表屏幕就清晰，屏幕的清晰程度还与尺寸有关。 图像分辨率我们通常说的图片分辨率其实是指图片含有的像素数，比如一张图片的分辨率为800 x 400。这表示图片分别在垂直和水平上所具有的像素点数为800和400。 同一尺寸的图片，分辨率越高，图片越清晰。 viewport视口在移动设备上的浏览器都会认为自己能让所有网站显示，即使不是为移动设备设计的网站。但是以浏览器可视区域为viewport的话，移动设备屏幕都不宽，所以那些为桌面浏览器设计的网站放到移动设备显示的时候，必然会因为viewport太窄而挤作一团，甚至布局也会乱掉。虽然市面上说某某手机分辨率达到768 * 1024，甚至到达2k屏的分辨率，那这么高的分辨率用来显示桌面网站应该没有问题吧。但是在上述文中CSS像素中的1px只是一个相对值，并不能够直接代表等于屏幕上的1px。手机分辨率越大，但是屏幕尺寸不变的情况下，css像素中的1px就回代表更多的物理像素，才能让1px的东西在屏幕上的大小与那些低分辨率的设备差不多，不然会因为太过于小而使得肉眼无法看清。 所以在移动设备下，浏览器的viewport可以分为三个：可视视口（visual viewport）、布局视口（layout viewport）和理想视口（ideal viewport）。（来自ppk大神观点） 视口(viewport)代表当前可见的计算机图形区域。在Web浏览器术语中，通常与浏览器窗口相同，但不包括浏览器的UI， 菜单栏等——即指你正在浏览的文档的那一部分。 可视视口可视视口就是目前在屏幕上显示页面的一部分。用户可以滚动以更改用户自己所看到的部分，或者缩放以更改可视窗口的大小。 但是，CSS布局（尤其是百分比宽度）是相对于布局视口计算的， 布局视口比视觉视口宽得多。 因此，&lt;html&gt;元素最初采用布局视口的宽度，并且您的CSS被解释为屏幕明显比手机屏幕宽。这可确保您网站的布局与桌面浏览器上的布局相同。 布局视口有多宽？这与浏览器不同。Safari iPhone使用980px，Opera使用850px，Android WebKit使用800px和IE使用974px。 可视视口的宽度可以通过window.innerWidth获取，但是在Android 2, Oprea mini 和 UC 8中无法正确获取。 布局视口一般移动设备的浏览器都默认设置了一个 viewport 元标签，定义一个虚拟的布局视口（layout viewport），用于解决早期的页面在手机上显示的问题。iOS, Android 基本都将这个视口分辨率设置为 980px，所以 PC 上的网页基本能在手机上呈现，只不过元素看上去很小，一般默认可以通过手动缩放网页。 完全缩小的情况下：visual viewport = layout viewport 浏览器选择了布局视口的尺寸，使其在完全缩小模式下完全覆盖屏幕（因此等于可视视口）. 不完全缩小的情况下：layout viewport &gt; visual viewport 布局视口的宽度和高度等于在不完全缩小模式下可以在屏幕上显示的任何宽度和高度。当用户放大这些尺寸时保持不变。 在放大和缩小的过程中，visual viewport和layout viewport的宽，高都没发生任何的变化,变化的仅仅就像是用户拿着这个visual viewport去远离或者靠近layout viewport，在远离或者靠近的过程中，就会呈现出缩放的效果来。 布局视口的宽度/高度可以通过document.documentElement.clientWidth / Height获取。 布局视口和可视视口的联系可以把layout viewport理解为一张完全遮住并且不能更边大小的白纸，把visual viewport理解为一个有边框的透视器，你可以通过这个透视器来查看这张白纸的内容。通过这个透视器你可以一点点的看到白纸部分内容，这里所能看到的就是visual viewport。你也可以靠近或者远离的方式来透视白纸（白纸静止不动），你看的内容可以变多或者变少，但是白纸layout viewport自身的大小和形状是不会发生改变的。 理想视口布局视口的默认宽度并不是一个理想的宽度，于是 Apple 和其他浏览器厂商引入了理想视口的概念，它对设备而言是最理想的布局视口尺寸。显示在理想视口中的网站具有最理想的宽度，用户无需进行缩放。 完美适配：首先不需要用户缩放和横向滚动条就能正常的查看网站的所有内容；第二，显示的文字的大小是合适，比如一段14px大小的文字，不会因为在一个高密度像素的屏幕里显示得太小而无法看清，理想的情况是这段14px的文字无论是在何种密度屏幕，何种分辨率下，显示出来的大小都是差不多的。当然，不只是文字，其他元素像图片什么的也是这个道理。 理想视口的值其实就是屏幕分辨率的值，它对应的像素叫做设备逻辑像素（device independent pixel, dip）。dip 和设备的物理像素无关，一个 dip 在任意像素密度的设备屏幕上都占据相同的空间。如果用户没有进行缩放，那么一个 CSS 像素就等于一个 dip。 ideal viewport并没有一个固定的尺寸，不同的设备拥有有不同的ideal viewport。所有的iphone的ideal viewport宽度都是320px，无论它的屏幕宽度是320还是640，也就是说，在iphone中，css中的320px就代表iphone屏幕的宽度。 但是安卓设备就比较复杂了，有320px的，有360px的，有384px的等等，关于不同的设备ideal viewport的宽度都为多少，可以到 http://viewportsizes.com 去查看一下，里面收集了众多设备的理想宽度。 用下面的方法可以使布局视口与理想视口的宽度一致：1&lt;meta name="viewport" content="width=device-width"&gt; 缩放两个视口都以CSS像素为单位进行测量。但是，当视觉视口尺寸随着缩放而变化时（如果放大，屏幕上的CSS像素较少），布局视口尺寸保持不变。（如果他们没有，您的页面将不断重排，因为重新计算百分比宽度。） 缩放是相对于ideal viewport缩放的，缩放值越大，当前viewport的宽度就会越小，反之亦然。例如在iphone中，ideal viewport 的宽度是320px，如果我们设置initial-scale=2，此时 viewport 的宽度会变为只有160px了，这也好理解，放大了一倍嘛，就是原来1px的东西变成2px了，但是1px变为2px并不是把原来的320px变为640px了，而是在实际宽度不变的情况下，1px变得跟原来的2px的长度一样了，所以放大2倍后原来需要320px才能填满的宽度现在只需要160px就做到了。因此，我们可以得出一个公式： 视觉视口和缩放比例的关系为： 123visual viewport宽度 = ideal viewport宽度 / 当前缩放值当前缩放值 = 理想视口宽度 / 视觉视口宽度 所以，当用户放大时，视觉视口将会变小，CSS 像素将跨越更多的物理像素。 获取视口大小 window.innerHeight：获取浏览器视觉视口高度（包括垂直滚动条）。 window.outerHeight：获取浏览器窗口外部的高度。表示整个浏览器窗口的高度，包括侧边栏、窗口镶边和调正窗口大小的边框。 window.screen.Height：获取获屏幕取理想视口高度，这个数值是固定的，`设备的分辨率/设备像素比 window.screen.availHeight：浏览器窗口可用的高度。 document.documentElement.clientHeight：获取浏览器布局视口高度，包括内边距，但不包括垂直滚动条、边框和外边距。 document.documentElement.offsetHeight：包括内边距、滚动条、边框和外边距。 document.documentElement.scrollHeight：在不使用滚动条的情况下适合视口中的所有内容所需的最小宽度。测量方式与clientHeight相同：它包含元素的内边距，但不包括边框，外边距或垂直滚动条。 总结ppk大神把移动设备上的viewport分为 layout viewport 、 visual viewport 和 ideal viewport 三类，其中的ideal viewport是最适合移动设备的viewport，ideal viewport的宽度等于移动设备的屏幕宽度，只要在css中把某一元素的宽度设为ideal viewport的宽度(单位用px)，那么这个元素的宽度就是设备屏幕的宽度了，也就是宽度为100%的效果。ideal viewport 的意义在于，无论在何种分辨率的屏幕下，那些针对ideal viewport而设计的网站，不需要用户手动缩放，也不需要出现横向滚动条，都可以完美的呈现给用户。 利用meta标签对viewport进行控制移动设备默认的viewport是layout viewport，也就是那个比屏幕要宽的viewport，但在进行移动设备网站的开发时，我们需要的是ideal viewport。那么怎么才能得到ideal viewport呢？这就该轮到meta标签出场了。 我们可以使用视口元标签（viewport meta 标签）来进行布局视口的设置。1&lt;meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"&gt; 上述meta标签的作用是让当前viewport的宽度等于设备的宽度，同时不允许用户手动缩放。 meta viewport标签首先是由苹果公司在其safari浏览器中引入的，目的就是解决移动设备的viewport问题。后来安卓以及各大浏览器厂商也都纷纷效仿，引入对meta viewport的支持，事实也证明这个东西还是非常有用的。 在苹果的规范中，meta viewport 有6个属性(暂且把content中的那些东西称为一个个属性和值)，如下： 属性 取值 描述 width 正整数或device-width 定义视口的宽度，单位为像素 height 正整数或device-height 定义视口的高度，单位为像素，一般不用 initial-scale [0.0-10.0] 定义初始缩放值 minimum-scale [0.0-10.0] 定义放大最大比例，它必须小于或等于maximum-scale设置 maximum-scale [0.0-10.0] 定义缩小最小比例，它必须大于或等于minimum-scale设置 user-scalable yes / no 定义是否允许用户手动缩放页面，默认值 yes 有几点需要注意： viewport 标签只对移动端浏览器有效，对 PC 端浏览器是无效的 当缩放比例为 100% 时，dip 宽度 = CSS 像素宽度 = 理想视口的宽度 = 布局视口的宽度 单独设置 initial-scale 或 width 都会有兼容性问题，所以设置布局视口为理想视口的最佳方法是同时设置这两个属性 即使设置了 user-scalable = no，在 Android Chrome 浏览器中也可以强制启用手动缩放 这些属性可以同时使用，也可以单独使用或混合使用，多个属性同时使用时用逗号隔开就行了。 此外，在安卓中还支持target-densitydpi 这个私有属性，它表示目标设备的密度等级，作用是决定css中的1px代表多少物理像素。 属性 取值 描述 target-densitydpi high-dpi,medium-dpi,low-dpi,device-dpi 私有属性，它表示目标设备的密度等级，作用是决定css中的1px代表多少物理像素 特别说明的是，当target-densitydpi=device-dpi时， css中的1px会等于物理像素中的1px。 因为这个属性只有安卓支持，并且安卓已经决定要废弃&lt;strike&gt;target-densitydpi&lt;/strike&gt; 这个属性了，所以这个属性我们要避免进行使用。 动态改变meta viewport标签第一种方式：使用document.write来动态输出meta viewport标签，例如 1document.write('&lt;meta name="viewport" content="width=device-width,initial-scale=1"&gt;') 第二种方式通过setAttribute来改变 12345&lt;meta id="testViewport" name="viewport" content="width = 380"&gt;&lt;script&gt;var mvp = document.getElementById('testViewport');mvp.setAttribute('content','width=480');&lt;/script&gt; 参考资料https://segmentfault.com/a/1190000015884091 https://www.quirksmode.org/mobile/viewports.html https://www.quirksmode.org/mobile/viewports2.html https://www.quirksmode.org/mobile/metaviewport/ https://developer.mozilla.org/zh-CN/docs/Mobile/Viewport_meta_tag https://www.jianshu.com/p/af6dad66e49a http://viewportsizes.com https://juejin.im/post/5bb6c62be51d450e47142c60 https://www.jianshu.com/p/3d28f4959c5a https://stackoverflow.com/questions/6333927/difference-between-visual-viewport-and-layout-viewport]]></content>
      <categories>
        <category>HTML</category>
      </categories>
      <tags>
        <tag>HTML</tag>
        <tag>移动端适配</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android build.gradle配置详解]]></title>
    <url>%2F2019%2F04%2F10%2FAndroid-build-gradle%E9%85%8D%E7%BD%AE%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[AS是采用gradle来进行构建项目，而gradle是基于groovy语言。这里了解一下项目中gradle的详细配置。 Project的build.gradle文件12345678910111213141516171819202122232425262728293031// Top-level build file where you can add configuration options common to all sub-projects/modules.buildscript &#123; repositories &#123; google()//从Android Studio3.0后新增了google()配置，可以引用google上的开源项 jcenter()//是一个类似于github的代码托管仓库，声明了jcenter()配置，可以轻松引用 jcenter上的开源项目 &#125; dependencies &#123; classpath 'com.android.tools.build:gradle:3.3.2' // NOTE: Do not place your application dependencies here; they belong // in the individual module build.gradle files &#125;&#125;allprojects &#123;//这里是项目本身需要的依赖，比如项目所需的maven库 repositories &#123; google() jcenter() &#125;&#125;// 运行gradle clean时，执行此处定义的task任务。// 该任务继承自Delete，删除根目录中的build目录。// 相当于执行Delete.delete(rootProject.buildDir)。// gradle使用groovy语言，调用method时可以不用加（）。task clean(type: Delete) &#123; delete rootProject.buildDir&#125; buildscript{}闭包是gradle脚本执行所需要的依赖，分别是对应的maven库和插件 repositories{}闭包：配置远程仓库,该闭包中声明了jcenter()和google()的配置，其中jcenter是一个代码托管仓库，上面托管了很多Android开源项目，在这里配置了jcenter后我们可以在项目中方便引用jcenter上的开源项目，从Android Studio3.0后新增了google()配置，可以引用google上的开源项目 dependencies{}闭包：配置构建工具,该闭包使用classpath声明了一个Gradle插件，由于Gradle并不只是用来构建Android项目，因此此处引入相关插件来构建Android项目，其中’3.0.0’为该插件的版本号，可以根据最新的版本号来调整 allprojects{}闭包是项目本身需要的依赖，比如项目所需要的maven库 task clean(type: Delete)是运行gradle clean时，执行此处定义的task任务，该任务继承自Delete，删除根目录中的build目录。其中buildscript包含repositories闭包和dependencies闭包 Module的build.gradle文件12345678910111213141516171819202122232425262728apply plugin: 'com.android.application'android &#123; compileSdkVersion 28 defaultConfig &#123; applicationId "cn.net.sweetlover.myapplication" minSdkVersion 15 targetSdkVersion 28 versionCode 1 versionName "1.0" testInstrumentationRunner "android.support.test.runner.AndroidJUnitRunner" &#125; buildTypes &#123; release &#123; minifyEnabled false proguardFiles getDefaultProguardFile('proguard-android-optimize.txt'), 'proguard-rules.pro' &#125; &#125;&#125;dependencies &#123; implementation fileTree(dir: 'libs', include: ['*.jar']) implementation 'com.android.support:appcompat-v7:28.0.0' implementation 'com.android.support.constraint:constraint-layout:1.1.3' testImplementation 'junit:junit:4.12' androidTestImplementation 'com.android.support.test:runner:1.0.2' androidTestImplementation 'com.android.support.test.espresso:espresso-core:3.0.2'&#125; apply plugin12345// 声明是Android程序，//com.android.application 表示这是一个应用程序模块//com.android.library 标识这是一个库模块//而这区别：前者可以直接运行，后着是依附别的应用程序运行apply plugin: 'com.android.application' apply plugin表示应用了一个插件，一般有两种值可选： com.android.application，表示该模块为应用程序模块，可以直接运行，打包得到的是apk文件 com.android.library，表示该模块为库模块，只能作为代码库依附与别的应用程序模块来运行，打包得到的是aar文件 android{}闭包这个闭包主要为了配置项目构建的各种属性： signingConfigs{}1234567891011121314signingConfigs &#123;// 自动化打包配置 release &#123;// 线上环境 keyAlias 'test' keyPassword '123456' storeFile file('test.keystore') storePassword '123456' &#125; debug &#123;// 开发环境 keyAlias 'test' keyPassword '123456' storeFile file('test.keystore') storePassword '123456' &#125; &#125; 可以手动添加签名配置，也可以通过Project Structure-&gt;app-&gt;Singing，点击下面+号填入配置信息即可生成代码配置。 签名配置完成后可以方便带签名打包，在module的Build Variants中有两个Type，分别是debug和release，可以选择任意一个类型进行打包，并且他们会利用各自配置的Key进行打包，执行 Run app或者Build-&gt;Build apk就会自动在module name/app/build/outputs/apk路径下生成Apk文件。另一种打包方式是Build-&gt;Generate Signed APK填写签名信息生成Apk。 compileSdkVersion设置编译时用的Android版本 buildToolsVersion设置编译时使用的构建工具的版本，Android Studio3.0后去除此项配置 defaultConfig{}12345678defaultConfig &#123; applicationId "cn.net.sweetlover.myapplication"//项目的包名 minSdkVersion 16//项目最低兼容的版本 targetSdkVersion 27//项目的目标版本 versionCode 1//版本号 versionName "1.0"//版本名称 testInstrumentationRunner "android.support.test.runner.AndroidJUnitRunner"//表明要使用AndroidJUnitRunner进行单元测试 &#125; applicationId：指定了项目的包名。 minSdkVersion:指定项目最低兼容的版本，如果设备小于这个版本或者大于maxSdkVersion(一般不用)将无法安装这个应用，这里指定为16，表示最低兼容到Android 4.1系统。 targetSdkVersion:指定项目的目标版本，表示在该目标版本上已经做过充分测试，系统会为该应用启动一些对应该目标系统的最新功能特性，Android系统平台的行为变更，只有targetSdkVersion的属性值被设置为大于或等于该系统平台的API版本时，才会生效。例如，若指定targetSdkVersion值为22，则表示该程序最高只在Android5.1版本上做过充分测试，在Android6.0系统上（对应targetSdkVersion为23）拥有的新特性如系统运行时权限等功能就不会被启用。 versionCode:表示版本号，一般每次打包上线时该值只能增加，打包后看不见。 versionName:表示版本名称，展示在应用市场上。 testInstrumentationRunner:&quot;android.support.test.runner.AndroidJUnitRunner&quot;表明要使用AndroidJUnitRunner进行单元测试。 buildTypes{}这个闭包主要指定生成安装文件的主要配置，一般包含两个子闭包，一个是debug闭包，用于指定生成测试版安装文件的配置，可以忽略不写；另一个是release闭包，用于指定生成正式版安装文件的配置。两者能配置的参数相同，最大的区别默认属性配置不一样，两种模式支持的属性配置如下图： 123456789101112131415161718192021222324252627buildTypes &#123;// 生产/测试环境配置 release &#123;// 生产环境 buildConfigField("boolean", "LOG_DEBUG", "false")//配置Log日志 buildConfigField("String", "URL_PERFIX", "\"https://release.cn/\"")// 配置URL前缀 minifyEnabled false//是否对代码进行混淆 proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'//指定混淆的规则文件 signingConfig signingConfigs.release//设置签名信息 pseudoLocalesEnabled false//是否在APK中生成伪语言环境，帮助国际化的东西，一般使用的不多 zipAlignEnabled true//是否对APK包执行ZIP对齐优化，减小zip体积，增加运行效率 applicationIdSuffix 'test'//在applicationId 中添加了一个后缀，一般使用的不多 versionNameSuffix 'test'//在applicationId 中添加了一个后缀，一般使用的不多 &#125; debug &#123;// 测试环境 buildConfigField("boolean", "LOG_DEBUG", "true")//配置Log日志 buildConfigField("String", "URL_PERFIX", "\"https://test.com/\"")// 配置URL前缀 minifyEnabled false//是否对代码进行混淆 proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'//指定混淆的规则文件 signingConfig signingConfigs.debug//设置签名信息 debuggable false//是否支持断点调试 jniDebuggable false//是否可以调试NDK代码 renderscriptDebuggable false//是否开启渲染脚本就是一些c写的渲染方法 zipAlignEnabled true//是否对APK包执行ZIP对齐优化，减小zip体积，增加运行效率 pseudoLocalesEnabled false//是否在APK中生成伪语言环境，帮助国际化的东西，一般使用的不多 applicationIdSuffix 'test'//在applicationId 中添加了一个后缀，一般使用的不多 versionNameSuffix 'test'//在applicationId 中添加了一个后缀，一般使用的不多 &#125; &#125; release{}闭包和debug{}闭包两者能配置的参数相同，最大的区别默认属性配置不一样： minifyEnabled:表明是否对代码进行混淆，true表示对代码进行混淆，false表示对代码不进行混淆，默认的是false。 proguardFiles:指定混淆的规则文件，这里指定了proguard-android.txt文件和proguard-rules.pro文件两个文件，proguard-android.txt文件为默认的混淆文件，里面定义了一些通用的混淆规则。proguard-rules.pro文件位于当前项目的根目录下，可以在该文件中定义一些项目特有的混淆规则。 buildConfigField:用于解决Beta版本服务和Release版本服务地址不同或者一些Log打印需求控制的。 例如：配置buildConfigField(“boolean”, “LOG_DEBUG”, “true”)，这个方法接收三个非空的参数，第一个：确定值的类型，第二个：指定key的名字，第三个：传值，调用的时候BuildConfig.LOG_DEBUG即可调用。 debuggable:表示是否支持断点调试，release默认为false，debug默认为true。 jniDebuggable:表示是否可以调试NDK代码，使用lldb进行c和c++代码调试，release默认为false。 signingConfig:设置签名信息，通过signingConfigs.release或者signingConfigs.debug，配置相应的签名，但是添加此配置前必须先添加signingConfigs闭包，添加相应的签名信息。 renderscriptDebuggable:表示是否开启渲染脚本就是一些c写的渲染方法，默认为false。 renderscriptOptimLevel:表示渲染等级，默认是3。 pseudoLocalesEnabled:是否在APK中生成伪语言环境，帮助国际化的东西，一般使用的不多。 applicationIdSuffix:和defaultConfig中配置是一的，这里是在applicationId 中添加了一个后缀，一般使用的不多。 versionNameSuffix:表示添加版本名称的后缀，一般使用的不多。 zipAlignEnabled:表示是否对APK包执行ZIP对齐优化，减小zip体积，增加运行效率，release和debug默认都为true。 sourceSets{}配置目录指向 12345sourceSets &#123;//目录指向配置 main &#123; jniLibs.srcDirs = ['libs']//指定lib库目录 &#125; &#125; 配置 jniLibs.srcDirs = [&#39;libs&#39;]，可以在Android studio的Android视图下生成jniLibs文件夹，可以方便我们存放jar包和库文件，其中Android视图下的jniLibs和project视图下的libs指向同一文件夹（app→libs），如下图所示： 更多事例： 12345678manifest.srcFile 'AndroidManifest.xml'java.srcDirs = ['src']resources.srcDirs = ['src']aidl.srcDirs = ['src']renderscript.srcDirs = ['src']res.srcDirs = ['res']assets.srcDirs = ['assets']jniLibs.srcDirs = ['libs'] packagingOptions{}打包时的相关配置 当项目中依赖的第三方库越来越多时，有可能会出现两个依赖库中存在同一个（名称）文件。如果这样，Gradle在打包时就会提示错误（警告）。那么就可以根据提示，然后使用以下方法将重复的文件剔除，比较常用的是通过exclude去除重复的文件，例如： 123456789101112packagingOptions&#123; //pickFirsts做用是 当有重复文件时 打包会报错 这样配置会使用第一个匹配的文件打包进入apk // 表示当apk中有重复的META-INF目录下有重复的LICENSE文件时 只用第一个 这样打包就不会报错 pickFirsts = ['META-INF/LICENSE'] //merges何必 当出现重复文件时 合并重复的文件 然后打包入apk //这个是有默认值得 merges = [] 这样会把默默认值去掉 所以我们用下面这种方式 在默认值后添加 merge 'META-INF/LICENSE' //这个是在同时使用butterknife、dagger2做的一个处理。同理，遇到类似的问题，只要根据gradle的提示，做类似处理即可。 exclude 'META-INF/services/javax.annotation.processing.Processor' &#125; productFlavors{}多渠道配置 这个配置是经常会使用到的，通常在适配多个渠道的时候，需要为特定的渠道做部分特殊的处理，比如设置不同的包名、应用名等。场景：当我们使用友盟统计时，通常需要设置一个渠道ID，那么我们就可以利用productFlavors来生成对应渠道信息的包，如： 123456789101112131415161718android &#123; productFlavors &#123; wandoujia &#123; //豌豆荚渠道包配置 manifestPlaceholders = [UMENG_CHANNEL_VALUE: "wandoujia"] //manifestPlaceholders的使用在后续章节（AndroidManifest里的占位符）中介绍 &#125; xiaomi &#123; manifestPlaceholders = [UMENG_CHANNEL_VALUE: "xiaomi"] applicationId "com.wiky.gradle.xiaomi" //配置包名 &#125; _360 &#123; manifestPlaceholders = [UMENG_CHANNEL_VALUE: "_360"] &#125; //... &#125; &#125; 更简洁的方式： 12345678910111213android &#123; productFlavors &#123; wandoujia &#123;&#125; xiaomi &#123;&#125; _360 &#123;&#125; //... &#125; productFlavors.all &#123; //批量修改，类似一个循序遍历 flavor -&gt; flavor.manifestPlaceholders = [UMENG_CHANNEL_VALUE: name] &#125;&#125; 配置完之后，在命令行窗口中（Terminal）中输入gradlew assembleRelease（windows）即可开始打包，在Mac系统中对应指令是./gradlew assembleRelease。当然，如果想要debug版本的包，将指令中assembleRelease改为assembleDebug即可。最后生成的包还是在app/build/outputs/apk中，默认命名格式如app-wandoujia-release-unsigned.apk，在module的Build Variants中可以选择相应的渠道。注：Android Studio3.0需在主app的build.gradle里面的 12345678defaultConfig &#123; targetSdkVersion：*** minSdkVersion ：*** versionCode：*** versionName ：*** //版本名后面添加一句话，意思就是flavor dimension 它的维度就是该版本号，这样维度就是都是统一的了 flavorDimensions "versionCode"&#125; lintOptions{}代码扫描分析 Lint 是Android Studio 提供的 代码扫描分析工具，它可以帮助我们发现代码结构/质量问题，同时提供一些解决方案，而且这个过程不需要我们手写测试用例。 Lint 发现的每个问题都有描述信息和等级（和测试发现 bug 很相似），我们可以很方便地定位问题，同时按照严重程度进行解决。 12345//程序在编译的时候会检查lint，有任何错误提示会停止build，我们可以关闭这个开关 lintOptions &#123; abortOnError false //即使报错也不会停止打包 checkReleaseBuilds false //打包release版本的时候进行检测 &#125; dependencies{}该闭包定义了项目的依赖关系，一般项目都有三种依赖方式：本地依赖、库依赖和远程依赖。本地依赖可以对本地的jar包或目录添加依赖关系，库依赖可以对项目中的库模块添加依赖关系，远程依赖可以对jcener库上的开源项目添加依赖关系。从Android Studio3.0后compile引入库不在使用，而是通过api和implementation，api完全等同于以前的compile，用api引入的库整个项目都可以使用，用implementation引入的库只有对应的Module能使用，其他Module不能使用，由于之前的项目统一用compile依赖，导致的情况就是模块耦合性太高，不利于项目拆解，使用implementation之后虽然使用起来复杂了但是做到降低偶合兴提高安全性。 12345678dependencies &#123; implementation fileTree(include: ['*.jar'], dir: 'libs') implementation 'com.android.support:appcompat-v7:28.0.0' implementation 'com.android.support.constraint:constraint-layout:1.1.3' testImplementation 'junit:junit:4.12' androidTestImplementation 'com.android.support.test:runner:1.0.2' androidTestImplementation 'com.android.support.test.espresso:espresso-core:3.0.2'&#125; implementation fileTree(include: [&#39;*.jar&#39;], dir: &#39;libs&#39;)：implementation fileTree是一个本地依赖声明，表示将libs目录下所有.jar后缀的文件都添加到项目的构建路径当中。 testImplementation和androidTestImplementation：表示声明测试用例库。 完整配置123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111// 声明是Android程序，//com.android.application 表示这是一个应用程序模块//com.android.library 标识这是一个库模块//而这区别：前者可以直接运行，后着是依附别的应用程序运行apply plugin: 'com.android.application'android &#123; signingConfigs &#123;// 自动化打包配置 release &#123;// 线上环境 keyAlias 'test' keyPassword '123456' storeFile file('test.jks') storePassword '123456' &#125; debug &#123;// 开发环境 keyAlias 'test' keyPassword '123456' storeFile file('test.jks') storePassword '123456' &#125; &#125; compileSdkVersion 27//设置编译时用的Android版本 defaultConfig &#123; applicationId "cn.net.sweetlover.myapplication"//项目的包名 minSdkVersion 16//项目最低兼容的版本 targetSdkVersion 27//项目的目标版本 versionCode 1//版本号 versionName "1.0"//版本名称 flavorDimensions "versionCode" testInstrumentationRunner "android.support.test.runner.AndroidJUnitRunner"//表明要使用AndroidJUnitRunner进行单元测试 &#125; buildTypes &#123;// 生产/测试环境配置 release &#123;// 生产环境 buildConfigField("boolean", "LOG_DEBUG", "false")//配置Log日志 buildConfigField("String", "URL_PERFIX", "\"https://release.cn/\"")// 配置URL前缀 minifyEnabled false//是否对代码进行混淆 proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'//指定混淆的规则文件 signingConfig signingConfigs.release//设置签名信息 pseudoLocalesEnabled false//是否在APK中生成伪语言环境，帮助国际化的东西，一般使用的不多 zipAlignEnabled true//是否对APK包执行ZIP对齐优化，减小zip体积，增加运行效率 applicationIdSuffix 'test'//在applicationId 中添加了一个后缀，一般使用的不多 versionNameSuffix 'test'//在applicationId 中添加了一个后缀，一般使用的不多 &#125; debug &#123;// 测试环境 buildConfigField("boolean", "LOG_DEBUG", "true")//配置Log日志 buildConfigField("String", "URL_PERFIX", "\"https://test.com/\"")// 配置URL前缀 minifyEnabled false//是否对代码进行混淆 proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'//指定混淆的规则文件 signingConfig signingConfigs.debug//设置签名信息 debuggable false//是否支持断点调试 jniDebuggable false//是否可以调试NDK代码 renderscriptDebuggable false//是否开启渲染脚本就是一些c写的渲染方法 zipAlignEnabled true//是否对APK包执行ZIP对齐优化，减小zip体积，增加运行效率 pseudoLocalesEnabled false//是否在APK中生成伪语言环境，帮助国际化的东西，一般使用的不多 applicationIdSuffix 'test'//在applicationId 中添加了一个后缀，一般使用的不多 versionNameSuffix 'test'//在applicationId 中添加了一个后缀，一般使用的不多 &#125; &#125; sourceSets &#123;//目录指向配置 main &#123; jniLibs.srcDirs = ['libs']//指定lib库目录 &#125; &#125; packagingOptions&#123;//打包时的相关配置 //pickFirsts做用是 当有重复文件时 打包会报错 这样配置会使用第一个匹配的文件打包进入apk // 表示当apk中有重复的META-INF目录下有重复的LICENSE文件时 只用第一个 这样打包就不会报错 pickFirsts = ['META-INF/LICENSE'] //merges何必 当出现重复文件时 合并重复的文件 然后打包入apk //这个是有默认值得 merges = [] 这样会把默默认值去掉 所以我们用下面这种方式 在默认值后添加 merge 'META-INF/LICENSE' //这个是在同时使用butterknife、dagger2做的一个处理。同理，遇到类似的问题，只要根据gradle的提示，做类似处理即可。 exclude 'META-INF/services/javax.annotation.processing.Processor' &#125; productFlavors &#123; wandoujia &#123;&#125; xiaomi &#123;&#125; _360 &#123;&#125; &#125; productFlavors.all &#123; //批量修改，类似一个循序遍历 flavor -&gt; flavor.manifestPlaceholders = [IFLYTEK_CHANNEL: name] &#125; //程序在编译的时候会检查lint，有任何错误提示会停止build，我们可以关闭这个开关 lintOptions &#123; abortOnError false //即使报错也不会停止打包 checkReleaseBuilds false //打包release版本的时候进行检测 &#125;&#125;dependencies &#123; //项目的依赖关系 implementation fileTree(include: ['*.jar'], dir: 'libs') //本地jar包依赖 implementation 'com.android.support:appcompat-v7:27.1.1' //远程依赖 implementation 'com.android.support.constraint:constraint-layout:1.1.2' testImplementation 'junit:junit:4.12' //声明测试用例库 androidTestImplementation 'com.android.support.test:runner:1.0.2' androidTestImplementation 'com.android.support.test.espresso:espresso-core:3.0.2'&#125; 签名AS一键生成1、AS菜单中Build-&gt;Generate Signed APK点击 2、点击Create New... ”Create new…”新建一个签名文件”Choose existing…”选择一个已经存在的签名文件 3、填写完整的签名信息。 填写完毕点击OK 参数介绍 Key store path : 签名文件路径 Password : 签名密码 Confirm : 确认密码 Alias : 别名 Validity ( years ) : 有限期 （年） First and Last Name : 全名 Organizational Unit : 组织单位 Organization : 组织 City or Locality : 城市或地方 State or Province : 州或省 Country Code(XX) : 国家代码 这里密码统一填写“android”，别名写个“key”即可。其他的信息根据实际情况和需求填写，并不很重要。 4、生成文件名后缀为keystore 选V1打包出来的app是jar的（一般这种就是当做第三方导入项目来用的），选v2打包出来的APP是apk版本的（也就是可以直接在手机上安装的，可是上线的）； 一般情况下两个同时选择即可。然后点击Finish完成生成签名。 原因： v2的用途解释：1.用于验证其完整性的APK的加密签名现在位于ZIP中央目录之前。2.这个签名是在整个APK文件的二进制内容上计算和验证的，而不是在v1的归档文件中解压缩文件内容。3.一个APK可以同时由v1和v2签名同时签署，所以它仍然可以向后兼容以前的Android版本。 但是只设置v2会引起7.0以下会直接安装完显示未安装，7.0以上则使用了V2的方式验证 报错信息为：INSTALL_PARSE_FAILED_NO_CERTIFICATES。 同时设置V1和V2则所有机型都没问题。而只设置v1签名并不会影响什么，但是在7.0上不会使用更安全的验证方式 如果你想在使用Android分级插件时禁用添加v1或v2的签名，你可以将这些行添加到你的signingConfig部分。v1SigningEnabled falsev2SigningEnabled false 命令行生成配置jdk后 运行命令1keytool -genkey -alias forever -keyalg RSA -validity 10000 -keystore forever.keystore 这里关键文字的代表意义： forever：keystore的别名alias 10000：keystore的有效天数 forever.keystore：keystore的名称 1、第一次输入的秘钥库口令即为forever.keystore的密码2、然后填写相关的信息3、生成对应的forever.keystore，文件地址在cmd命令的对应路径下面 题外话Project的setting.gradle文件1include ':app' setting.gradle 文件在 初始化过程中被执行，构建器通过setting.gradle 文件中的内容了解哪些模块将被build。 注意：单模块项目不一定需要有 setting 文件，但一旦有多个模块，必须要有 setting 文件，同时也要写明所有要构建的模块，否则 gradle 不会 build 不包括的模块。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IOS pch预编译头文件使用]]></title>
    <url>%2F2019%2F04%2F08%2FIOS-pch%E9%A2%84%E7%BC%96%E8%AF%91%E5%A4%B4%E6%96%87%E4%BB%B6%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[PCH是什么PCH文件是一个标准的预编译头文件( Pre-Compiled Header)，在Xcode6之前的版本中，系统模板会在Supporting Files文件夹自动创建。但在Xcode6之后的版本中取消了这一文件，如果我们需要使用pch文件，则需要手动创建。去掉的主要的原因: 1、去掉自动导入的系统框架类库的头文件，可以提高原文件的复用性，便于迁移。2、一个体积大的Prefix Header会大大增加编译时间。 再来看看pch的作用： 1.存放一些全局的宏(整个项目中都用得上的宏)。2.用来包含一些头文件(整个项目中都用得上的头文件)。3.能自动打开或者关闭日志输出功能。 如果你的pch文件确实很大，那那肯定影响编译速度，苹果去掉他可能是要加快编译时间增加用户体验。虽然失去了编程的便利性。事实上，正确运用pch文件时预编译后的头文件会被缓存起来，再次编译的时候就不需要重新编译pch文件中导入的内容，编译速度并不会降低很多。很重要的一点就是pch文件确实给我们编程带来便利，我们不用在每个文件内重复引用另一个文件；那怎样才能提高编译速度呢？降低编译速度的罪魁祸首就是大量的共用性不高的宏定义和头文件的引入。编译的时候整个工程范围地查找和替换这些宏定义字段，重复导入这些头文件，不慢就奇怪了。 PCH创建创建 点击创建，输入文件名即可。 配置在项目-&gt;Build Settings下 找到该Precompile Prefix Header项设置为YES,这样的话pch会被预编译，预编译后的pch文件会被缓存起来，从而提高编译速度。当 Precompile Prefix Header 为NO时，那么pch不会被预编译，而是在每一个用到它导入的框架类库的.m文件中编译一次 找到Prefix Header项 双击可弹出输入框，给Prefix Header设置路径，只需要点击pch文件然后按住鼠标左键拖过来就行，但是/Users/zjyzy/WorkPlace/xcode/AllDemo/BarDemo/BarDemo/PrefixHeader.pch代表的是绝对路径，当用别的电脑时就不能识别了，这时就可以用到$(SRCROOT)来替换，在iOS中$(SRCROOT)代表的是项目根目录下，路径形式为：$(SRCROOT)/当前工程名字/需要包含头文件所在文件夹所以把路径改为:$(SRCROOT)/BarDemo/PrefixHeader.pch PCH使用一般来说在你向pch添加全局的头文件之前,必须添加以下代码： 12345#ifdef __OBJC__...#endif 这个宏定义的作用是保证只有oc文件可以调用pch里面的头文件，一些非OC语言不能调用，比如.cpp,.mm。如果不加入，那么如果代码中带有.cpp,.mm文件，那么将报错。NSObjCRuntime.h NSObject.h NSZone.h将会报出编译异常。这样你就可以在pch文件当中添加一些常用头文件、宏定义了。 宏来自定义只能在debug环境下使用输出日志在pch文件下添加如下代码 123456789#ifdef __OBJC__#ifdef DEBUG# define TTLog(...) NSLog(__VA_ARGS__);#else# define TTLog(...);#endif#endif TTLog为自定义名称,在项目中输出则将NSLog替换为TTLog即可。 宏定义的debug /release切换，见下图操作步骤 在选择了Edit Scheme后run info中切换debug/release模式 参考https://my.oschina.net/goboy/blog/1838003 https://www.jianshu.com/p/a1d61f5cc454]]></content>
      <categories>
        <category>Ios</category>
      </categories>
      <tags>
        <tag>Ios</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IOS状态栏、导航栏使用总结]]></title>
    <url>%2F2019%2F04%2F04%2FIOS%E7%8A%B6%E6%80%81%E6%A0%8F%E3%80%81%E5%AF%BC%E8%88%AA%E6%A0%8F%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[状态栏与导航栏的位置如下图 iOS7之前：状态栏与导航栏是分开的；iOS7之后：状态栏与导航栏合在一起；导航部分总高度(64)= 状态栏高度(20) +导航栏内容高度((44） iPhoneX以后：状态栏的高度变为44，导航栏部分总高度(88) = 状态栏(44) + 导航栏内容高度(44) 我们可以通过[UIApplication sharedApplication].statusBarFrame.size获取状态栏的size（一般没有刘海时的高度为20，有刘海时的高度为44）。通过self.navigationController.navigationBar.frame.size来获取导航栏的size。 状态栏状态栏内容包括信号、时间、电量等，只有两种颜色样式（黑或白）。 状态栏显示和隐藏全局控制：通过 info.plist设置，或者调用全局方法。分页控制：在视图控制器里通过 prefersStatusBarHidden方法设置。 全局控制默认设置或者手动设置 info.plist文件中View controller-based status bar appearance设置为NO，此时状态栏需要全局设置，有两种方式设置。 方法1: 依次进入Targets-&gt;General-&gt;Deployment Info，然后可进行进行设置如下: 在info.plist文件中添加Status bar is initially hidden设置为YES，则隐藏启动页状态栏，否则反之。和直接在项目中设置相同。 方法2: 代码设置： 12345//已过时[[UIApplication sharedApplication] setStatusBarHidden:YES];//推荐[UIApplication sharedApplication].statusBarHidden = YES; 注意：使用代码控制全局的状态栏，代码的位置很重要；在AppDelegate中写入可以设置整个App页面的状态栏样式；如果需要单独设置其中一个页面隐藏状态栏，需要在进入页面时设置隐藏，退出页面时设置显示，以保证不影响其他页面的状态栏样式。 分页控制手动设置 info.plist文件中View controller-based status bar appearance设置为YES，此时全局状态设置是无效的，需要分页设置才能修改其样式，即：在每个视图控制器或者控制器基类中使用如下代码： 1234//重写该方法- (BOOL)prefersStatusBarHidden &#123; return NO;//设置显示，YES为隐藏&#125; 状态栏颜色状态栏分前后两个部分，要分清。 文字部分：就是指电池、时间等部分 背景部分：就是显示黑色或者图片的部分 文字部分简单来说，就是设置显示电池电量、时间、网络部分标示的颜色， 这里只能设置两种颜色： 1234//黑色UIStatusBarStyleDefault//白色UIStatusBarStyleLightContent 全局控制：通过 info.plist设置，或者调用全局方法。分页控制：在视图控制器里通过 preferredStatusBarStyle方法设置。 全局设置默认设置或者手动设置 info.plist文件中View controller-based status bar appearance设置为NO，此时状态栏需要全局设置，有两种方式设置。 方法1: 依次进入Targets-&gt;General-&gt;Deployment Info，然后可进行进行设置如下: 方法2: 代码设置: 1234//UIStatusBarStyleDefault | UIStatusBarStyleLightContent//UIStatusBarStyleDefault,黑色(默认)//UIStatusBarStyleLightContent,白色[UIApplication sharedApplication].statusBarStyle = UIStatusBarStyleLightContent; 分页设置手动设置 info.plist文件中View controller-based status bar appearance设置为YES，此时全局状态设置是无效的，需要分页设置才能修改其样式，即：在每个视图控制器或者控制器基类中使用如下代码： 1234//重写该方法- (UIStatusBarStyle)preferredStatusBarStyle &#123; return UIStatusBarStyleLightContent;&#125; 特别注意： 但是，这里存在一个问题：如果当前视图控制器是UINavigationController的子视图控制器，preferredStatusBarStyle方法并不会被调用。这是因为导航控制器里的preferredStatusBarStyle才具有修改状态栏样式的能力。 解决方法： 方法1:添加子类控制器 我们需要使用自定义的子类导航控制器，在其中添加如下的代码： 1234- (UIStatusBarStyle)preferredStatusBarStyle &#123; UIViewController *topVC = self.topViewController; return [topVC preferredStatusBarStyle];&#125; 方法2:放弃preferredStatusBarStyle该方法 直接不使用preferredStatusBarStyle方法，而是直接在当前视图控制器中调用如下方法修改状态栏。 12345//状态栏和导航栏背景色为白色，状态栏文字为黑色self.navigationController.navigationBar.barStyle = UIBarStyleDefault;//状态栏和导航栏背景色为黑色，状态栏文字为白色self.navigationController.navigationBar.barStyle = UIBarStyleBlack; 背景部分背景部分，简单来说，就是状态栏的背景颜色，其实系统状态栏的背景颜色一直是透明的状态，当有导航栏时，导航栏背景是什么颜色，状态栏就是什么颜色，没有导航栏时，状态栏背后的视图时什么颜色，它就是什么颜色。 1234//设置状态栏与到导航栏都是不透明self.navigationController.navigationBar.translucent = NO;// 这个方法是设置导航栏背景颜色，状态栏也会随之变色[self.navigationController.navigationBar setBarTintColor:[UIColor redColor]]; 单独设置 1234567891011/** 设置状态栏背景颜色 @param color 设置颜色 */- (void)setStatusBarBackgroundColor:(UIColor *)color &#123; UIView *statusBar = [[[UIApplication sharedApplication] valueForKey:@"statusBarWindow"] valueForKey:@"statusBar"]; if ([statusBar respondsToSelector:@selector(setBackgroundColor:)]) &#123; statusBar.backgroundColor = color; &#125;&#125; 效果图 如果是单独设置某个页面的状态栏背景色，还需要在离开页面时恢复原样。 状态栏常用宏定义123456789101112131415161718192021#pragma mark - 设备参数//屏幕宽#define ZS_ScreenWidth [[UIScreen mainScreen] bounds].size.width//屏幕高#define ZS_ScreenHeight [[UIScreen mainScreen] bounds].size.height//判断设备类型是否iPhoneX#define ZS_ISIphoneX (([UIScreen mainScreen].bounds.size.height/[UIScreen mainScreen].bounds.size.width) &gt;= 2.16)//导航栏高度#define ZS_NavBarHeight (ZS_ISIphoneX ? 88.f : 64.f)//状态栏高度#define ZS_StatusBarHeight (ZS_ISIphoneX ? 44.f : 20.f)//导航栏内容高度#define ZS_NavBarContentHeight 44.0//标签栏高度#define ZS_TabBarHeight (ZS_ISIphoneX ? 49.f + 34.f : 49.f) 注意：自iOS11之后，Apple引入Safe Area(安全区)的概念，这将是比宏定义更加有效的适配方法。 导航栏导航栏样式设置导航栏样式可分为全局设置或分页设置 全局设置全局设置在AppDelegate中设置，在整个app都会生效 1234567891011121314151617//设置导航栏背景颜色[[UINavigationBar appearance] setBarTintColor:[UIColor redColor]];//设置导航栏背景图片[[UINavigationBar appearance] setBackgroundImage:[UIImage imageNamed:@"bg"] forBarMetrics:UIBarMetricsDefault];//设置导航栏标题样式[[UINavigationBar appearance] setTitleTextAttributes:[NSDictionary dictionaryWithObjectsAndKeys: [UIColor redColor], NSForegroundColorAttributeName, [UIFont boldSystemFontOfSize:25], NSFontAttributeName, nil]];//设置导航栏返回按钮的颜色[[UINavigationBar appearance] setTintColor:[UIColor redColor]];//设置导航栏隐藏[[UINavigationBar appearance] setHidden:YES]; 分页设置全局设置后，但是有几个页面需求不同，则也可以进行单独的分页设置。 分页设置的调用方法变为self.navigationController.navigationBar。并且分页设置需要遵循： 进入页面时修改，离开页面时还原的原则。 1234567891011//进入页面时设置颜色：灰色- (void)viewWillAppear:(BOOL)animated&#123; [super viewWillAppear:animated]; [self.navigationController.navigationBar setBarTintColor:[UIColor grayColor]];&#125;//离开页面时还原为全局设置：橙色- (void)viewWillDisappear:(BOOL)animated&#123; [super viewWillDisappear:animated]; [self.navigationController.navigationBar setBarTintColor:[UIColor orangeColor]];&#125; 导航栏引起的布局问题当导航栏透明时会出现以下情况： 内容偏移属性：automaticallyAdjustsScrollViewInsetsautomaticallyAdjustsScrollViewInsets是视图控制器的一个属性，默认为YES，用于优化滑动类视图(继承于UIScrollView的视图)在视图控制里的显示： iOS系统的导航栏UINavigationBar与标签栏UITabBar默认都是半透明模糊效果，在这种情况下系统会对视图控制器的UI布局进行优化： 视图控制器里面第一个被添加进去的视图是滑动类视图，并且其Frame是整个屏幕大小时，系统会自动调整其contenInset，以保证滑动视图里的内容不被UINavigationBar与UITabBar遮挡。 但是对于普通的视图，此时我们仍然需要注意：非滑动视图的布局仍然要考虑导航栏和标签栏高度，注意不被遮挡，比如布局的时候加上导航栏高度，以免内容被导航栏遮挡。 我们可以通过一段代码来测试一下效果，在默认导航栏(半透明)的视图控制器里添加如下代码： 12345678910111213//UITextView是滑动视图，内容自动向下偏移，不会被导航栏覆盖 UITextView *leftTextView = [[UITextView alloc] init]; leftTextView.frame = CGRectMake(0, 0,100, 675); leftTextView.backgroundColor = [UIColor lightGrayColor]; leftTextView.text = @"君不见，黄河之水天上来，奔流到海不复回。君不见，高堂明镜悲白发，朝如青丝暮成雪。人生得意须尽欢，莫使金樽空对月。天生我材必有用，千金散尽还复来。"; leftTextView.font = [UIFont systemFontOfSize:18]; leftTextView.editable = NO; [self.view addSubview:leftTextView]; //UIView是非滑动视图，内容被导航栏部分覆盖 UIView *rightView= [[UIView alloc] initWithFrame:CGRectMake(150, 0, 100, 100)]; rightView.backgroundColor = [UIColor redColor]; [self.view addSubview:rightView]; 这里会发现非滑动视图会被导航栏遮挡，但是滑动视图即使延伸到了导航栏下，但是其内容部分却自动向下偏移了，没有被导航栏遮挡住，这是因为系统自动优化了其内边距。 其实，这种系统的优化也是可以控制关闭的，关闭优化之后，滑动视图就会和普通视图一样，如果还设置其布局的原点是(0,0),其内容就会被导航栏所覆盖，关键代码如下： 1234567//automaticallyAdjustsScrollViewInsets在11.0后失效，所以需要判断if (@available(iOS 11.0,*)) &#123; scrollView.contentInsetAdjustmentBehavior = UIScrollViewContentInsetAdjustmentNever;&#125;else&#123; //automaticallyAdjustsScrollViewIn，关闭自动偏移的系统优化 self.automaticallyAdjustsScrollViewInsets = NO;&#125; 边缘延伸属性：edgesForExtendedLayoutedgesForExtendedLayout也是视图控制器的布局属性，默认值是UIRectEdgeAll，即：当前视图控制器里各种UI控件会忽略导航栏和标签的存在，布局时若设置其原点设置为(0,0)，视图会延伸显示到导航栏的下面被覆盖。 所以我们可以设置self.edgesForExtendedLayout=UIRectEdgeNone，此时视图控制器里内容就会避开导航栏和标签栏了. 导航栏透明导航栏布局问题都是因为导航栏透明度影响，但是需求没有必要透明，那么视图控制器里的控件就会默认从(0,64)开始布局了，设置导航栏不透明的方法如下: 1self.navigationController.navigationBar.translucent= NO;]]></content>
      <categories>
        <category>Ios</category>
      </categories>
      <tags>
        <tag>Ios</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android中MVC、MVP、MVVM介绍]]></title>
    <url>%2F2019%2F04%2F01%2FAndroid%E4%B8%ADMVC%E3%80%81MVP%E3%80%81MVVM%E4%BB%8B%E7%BB%8D%2F</url>
    <content type="text"><![CDATA[MVC,MVP,MVVM简单介绍 MVCMVC全名是Model-View-Controller，是模型(model)-视图(view)-控制器(controller)的缩写，一种软件设计的典范，用一种业务逻辑、数据、界面显示分离的方式来组织代码，在改进和个性化定制洁面以及用户交互的同时，不需要重新编写业务逻辑。其中Model层处理数据，业务逻辑等。View层处理界面的显示结果。Controller层起到桥梁的作用，来控制View层和Model层通信以此来达到分离视图显示和业务逻辑层。 我们往往把Android中界面部分的实现也理解为采用了MVC框架，常常把Activity理解为MVC模式中的Controller。 看似没有什么特别的地方，但是由几个需要特别关注的关键点： View是把控制权交给Controller，自己不执行业务逻辑。 Controller执行业务逻辑并且操作Model，但不会直接操作View，可以说它是对View无知的。 View和Model的同步消息是通过观察着模式进行，而同步操作是由View自己请求Model的数据然后对视图进行更新。 MVC的优缺点优点 把业务逻辑全部分离到controller中，模块化程度高。当业务逻辑变更的时候，不需要更改view和model，只需要更改controller即可（swappable controller）。 观察者模式可以做到多视图同时更新 缺点 controller测试困难，因为视图同步操作是由view自己执行，而view只能在有UI的环境下运行。在没有UI的环境下对controller进行单元测试的时候，controller业务逻辑的正确性是无法验证的。controller更新model的时候，无法对view的更新操作进行断言。 view无法组件化。view是强依赖特定的model的，如果需要把这个view抽出来作为另外一个应用程序可服用的组件就困难了，因为不同的程序model是不一样的。 MVPMVP其实是MVC的一种演进版本，它更简单，将MVC中的Controller改为了Presenter，View通过接口与Presenter进行交互，降低耦合，方便进行单元测试。 View:负责绘制UI元素，与用户进行交互（Activity、View、Fragment都可以作为View层） Model:对数据的操作、对网络等的操作，和业务相关的逻辑处理 Presenter:作为View与Model交互的中间纽带，处理与用户交互的逻辑。可以把Presenter理解为一个中间层的角色，它接受Model层的数据，并且处理之后传递给View层，还需要处理View层的用户交互等操作。 关键点 View不再负责同步的逻辑，而是由Presenter负责。Presenter中既有业务逻辑也有同步逻辑。 View需要提供操作界面的接口给Presenter进行调用。（关键） 对比在MVC中，Controller是不能操作View的，View也没有提供相应的接口。而在MVP当中，Presenter可以操作View，View需要提供一组对界面操作的接口给Presenter进行调用。Model仍然通过事件广播自己的变更，但由于Presenter监听而不是View。 MVP（Passive View）优缺点优点 便于测试，Presenter对View是通过接口进行，在对Presenter进行不依赖UI环境的单元测试的时候，可以通过Mock一个View对象，这个对象只需要实现了View的接口即可。然后依赖注入到Presenter中，单元测试的时候就可以完整的测试Presenter业务逻辑的正确性。 View可以进行组件化。在MVP当中，View不依赖Model。这样就可以让View从特定的业务场景中脱离出来，可以说View可以做到对业务逻辑完全无知。它只需要提供一系列接口提供给上层接操作。这样就可以做到高度可复用的View组件。 缺点 Presenter中除了业务逻辑意外，还有大量的View-&gt;Model，Model-&gt;View的手动同步逻辑，造成Presenter比较笨重，维护起来会比较困难。 MVVMMVVM模式（Mode-View-ViewModel），和MVP模式相比，MVVM模式用ViewModel替换了Presenter，其他层基本上与MVP模式一直，ViewModel可以理解成是View的数据模型和Presenter的合体。 MVVM采用双向绑定（data-binding）。View的变动，自动反应在ViewModel，反之亦然。这种模式实际上是框架替应用开发者做了一些工作（相当于ViewModel类是由库帮我们生成的），开发者只需要较少代码就能实现比较复杂的交互。 MVVM调用关系 MVVM的调用关系和MVP一样。但是，在ViewModel当中会有一个叫Binder，或者是Data-binding engine的东西。以前全部由Presenter负责的View和Model之间数据同步操作交由给Binder处理。你只需要在View的模版语法当中，指令式地声明View上的显示的内容是和Model的哪一块数据绑定的。当ViewModel对进行Model更新的时候，Binder会自动把数据更新到View上去，当用户对View进行操作（例如表单输入），Binder也会自动把数据更新到Model上去。这种方式称为：Two-way data-binding，双向数据绑定。可以简单而不恰当地理解为一个模版引擎，但是会根据数据变更实时渲染。 关键点 MVVM把View和Model的同步逻辑自动化了。以前Presenter负责的View和Model同步不再手动地进行操作，而是交由框架所提供的Binder进行负责。 只需要告诉Binder，View显示的数据对应的是Model哪一部分即可。 MVVM优缺点优点 提高可维护性。解决了MVP大量的手动View和Model同步的问题，提供双向绑定机制。提高了代码的可维护性。 简化测试。因为同步逻辑是交由Binder做的，View跟着Model同时变更，所以只需要保证Model的正确性，View就正确。大大减少了对View同步更新的测试。 缺点 过于简单的图形界面不适用，或说牛刀杀鸡。 对于大型的图形应用程序，视图状态较多，ViewModel的构建和维护的成本都会比较高。 数据绑定的声明是指令式地写在View的模版当中的，这些内容是没办法去打断点debug的。 总结三者，都是后者解决前者遗留的问题，但每个存在必有其的理由。每种模式并不能因为用而用，而是根据业务的需求来定制。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS经典面试案例详解]]></title>
    <url>%2F2019%2F03%2F28%2FCSS%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E6%A1%88%E4%BE%8B%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[包含块一个元素的尺寸和位置经常受其包含块的影响，大多数情况下，包含块就是这个元素最近的祖先元素的内容去，但是也不是总是这样的。 当一个客户端代理（比如说浏览器）展示一个文档时，对每一个元素，它都产生了一个盒子。每一个盒子都被划分为四个区域。 内容区 内边距区 边框区 外边距区 很多被误导的观念：一个元素的包含块就是他的父元素的内容区，但并非是这样的。 包含块有什么影响？元素的尺寸及位置，常常会受它的包含块所影响。对于一些属性，例如 width, height, padding, margin，绝对定位元素的偏移值 （比如 position 被设置为 absolute 或 fixed），当我们对其赋予百分比值时，这些值的计算值，就是通过元素的包含块计算得来。 什么是包含块有这么大的影响，那么包含块到底是什么？如果对于浮动元素，其包含块定义为最近的块级祖先元素。但是对于定位的元素则行为相对复杂了。 “根元素”的包含块（也被称为初始包含块）由用户代理建立。在HTML中，根元素就是html元素。不过有些浏览器会使用body作为根元素。在大多数浏览器中，初始包含块是一个视窗大小的矩形。但不代表就是视口。 在电脑图形学里面，视口代表了一个可看见的多边形区域（通常来说是矩形）。在浏览器范畴里，它代表的是浏览器中网站可见内容的部分。 对于一个非根元素，如果其position值是relative或static，包含块则由最近的块级框、表单元格或行内块祖先框的内容边界构成。 当时网页中基本不会使用表单元格、行内块来作为页面的基本布局。 对于一个非根元素，如果其position值是absolute，包含块设置为最近的position值不是static的祖先元素（可以是任何类型）。 如果这个祖先元素是块级元素，包含块则设置为该元素的内边距边界，换句话说就是由边框界定的区域。 如果这个祖先元素是行内元素，包含块则设置为该祖先元素的内容边界。在从左向右的语言中，包含块的上边界和左边界是该祖先元素中第一个框内容区的上边界和左边界，包含块的下边界和右边界是最后一个框内容区的下边界和右边界。而从右向左读的语言中，包含块的右边界对应于第一个框的右内容边界，包含块的左边界则取自最后一个框的做内容边界，上下边界也是一样。 如果没有祖先，元素的包含块定义为初始包含块。 看一下案例，对于包含块的影响 初始包含块12345678910111213141516171819202122232425&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;&lt;/title&gt; &lt;style type="text/css"&gt; * &#123; margin: 0; padding: 0; &#125; html &#123; height: 100%; /*margin: 30px;*/ border: 1px red solid; &#125; body &#123; /*margin: 30px;*/ border: 1px pink solid; height: 90%; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt; 案例一123456789101112131415161718192021222324252627282930313233343536&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;meta http-equiv="X-UA-Compatible" content="IE=edge"&gt; &lt;title&gt;Page Title&lt;/title&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1"&gt; &lt;style type="text/css"&gt; * &#123; margin: 0; padding: 0; &#125; #wrap &#123; background-color: beige; width: 400px; height: 800px; &#125; #content &#123; background-color: pink; /* 200px */ width: 50%; /* 200px */ height: 50%; /* 40px */ margin: 10%; /* 40px */ padding: 10%; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="wrap"&gt; &lt;div id="content"&gt;&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; content标签为静态定位，则wrap标签为他的包含块，所以content标签的高和宽的百分比值有wrap包含块的高和宽来决定，margin和padding的百分比值则由wrap包含块的宽来决定。 案例二12345678910111213141516171819202122232425262728293031323334&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;meta http-equiv="X-UA-Compatible" content="IE=edge"&gt; &lt;title&gt;Page Title&lt;/title&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1"&gt; &lt;style type="text/css"&gt; * &#123; margin: 0; padding: 0; &#125; #wrap &#123; background-color: yellow; display: inline; &#125; #content &#123; background-color: pink; /* 200px */ width: 50%; height: 200px; /* 40px */ margin: 10%; /* 40px */ padding: 10%; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="wrap"&gt; &lt;div id="content"&gt;&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 与案例1相似的结构，但是wrap元素变成了内联元素，则wrap不是content的包含块，没有祖先元素能够成为content的包含块，则content的包含块为初始包含块。所以content的宽和高的百分比值将不再由wrap元素决定。 案例三1234567891011121314151617181920212223242526272829303132333435363738394041&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;meta http-equiv="X-UA-Compatible" content="IE=edge"&gt; &lt;title&gt;Page Title&lt;/title&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1"&gt; &lt;style type="text/css"&gt; * &#123; margin: 0; padding: 0; &#125; #wrap &#123; position: absolute; left: 0px; top: 0px; background-color: yellow; width: 500px; height: 500px; padding: 50px 50px; &#125; #content &#123; position: absolute; /* 300px */ width: 50%; /* 150px */ height: 25%; /* 60px */ padding: 10%; /* 60px */ margin: 10%; background-color: pink; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="wrap"&gt; &lt;div id="content"&gt;&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 与案例1相似的结构，wrap和content元素都开启了绝对定位，那么wrap元素则为content元素的包含块，所以content的百分比值有wrap元素来决定，但是注意wrap的盒模型有padding值，计算时需要加上。 如果包含块的 box-sizing 值设置为 border-box ，就没有这个问题。 案例四1234567891011121314151617181920212223242526272829303132333435363738394041&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;meta http-equiv="X-UA-Compatible" content="IE=edge"&gt; &lt;title&gt;Page Title&lt;/title&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1"&gt; &lt;style type="text/css"&gt; * &#123; margin: 0; padding: 0; &#125; #wrap &#123; width: 400px; height: 300px; margin: 50px; padding: 30px; background-color: yellow; &#125; #content &#123; position: fixed; left: 0; top: 0; /* 50% vw */ width: 50%; /* 50% scroll h */ height: 50%; /* 10% vw */ margin: 10%; /* 10% vw */ padding: 10%; background-color: pink; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="wrap"&gt; &lt;div id="content"&gt;&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; content元素的包含块的定位为fixed，所以他的包含块即为初始包含块（屏幕上，也即是viewport）,content元素则会随着浏览器窗口的大小的变化而变化。 案例五12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;meta http-equiv="X-UA-Compatible" content="IE=edge"&gt; &lt;title&gt;Page Title&lt;/title&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1"&gt; &lt;style type="text/css"&gt; * &#123; margin: 0; padding: 0; &#125; body &#123; background: beige; &#125; section &#123; transform: rotate(0deg); width: 400px; height: 160px; background: lightgray; &#125; p &#123; position: absolute; left: 80px; top: 30px; width: 50%; /* == 200px */ height: 25%; /* == 40px */ margin: 5%; /* == 20px */ padding: 5%; /* == 20px */ background: cyan; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;section&gt; &lt;p&gt;This is a paragraph!&lt;/p&gt; &lt;/section&gt;&lt;/body&gt;&lt;/html&gt; 这个示例中，P 元素的 position 为 absolute，所以它的包含块是 ，也就是距离它最近的一个 transform 值不为 none 的父元素。 默认值left、top、right、bottom、width、height默认值为auto。margin、padding默认值为0。 浮动元素层级看一个案例1234567891011121314151617181920212223&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;&lt;/title&gt; &lt;style type="text/css"&gt; div &#123; width: 200px; height: 200px; &#125; #up &#123; background-color: yellow; float: left; &#125; #down &#123; background-color: pink; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="up"&gt;upupup&lt;/div&gt; &lt;div id="down"&gt;downdowndown&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 原来upid的元素不开启浮动的情况下，两个块级元素上下排列，但是开启了upid的元素的浮动后，downid的元素由于收到了up元素的影响顶了上去，但是发现文字并没有跟着上去。解释：在浮动的情况下，元素层级只提升半层，元素分两层，一层与盒模型相关，一层与文字相关。 负margin详解负margin用法权威指南 何为负margin 1#content &#123;margin-left:-100px;&#125; 负margin是标准的CSS，在w3c中，margin属性值是允许出现负值的 负margin不是一种hack方法 不脱离文档流（在不使用浮动的情况下） 完全兼容 浮动会影响负margin的使用 dreamveaver不解析负margin（前端工程师不推荐使用，也不应该在设计视图中检查网站） **作用在static元素上的负margin属性值当static元素没有设定成浮动的元素，上图中说明了负margin对static元素的作用。 当static元素的margin-left/margin-right被赋予负值时，元素将被拉进指定方向。 12#box1 &#123;margin-top : -10px;&#125;/*元素向上移动10px*/ 当static元素的margin-bottom/margin-right被赋予负值时，会将后续的元素拖拉进来，覆盖原来的元素。 12#box1 &#123;margin-bottom : -10px;&#125;/*box1后续的元素将向上移动10px，box1本身不会移动*/ 作用在浮动元素上的负margin属性值 12&lt;div id="mydiv1"&gt;First&lt;/div&gt;&lt;div id="mydiv2"&gt;Second&lt;/div&gt; 12/* 应用在与浮动相反方向的负margin */#mydiv1 &#123;float:left; margin-right:-100px;&#125; 如果给一个浮动元素加上相反方向的负margin，则会使行间距为0且内容重叠。这对于创建1列是100%宽度而其他列是固定宽度（比如100px）的自适应布局来说是非常有用的方法。 若两个元素都为浮动，且#mydiv1的元素设定margin-right为20px。这样#mydiv2会认为#mydiv1的宽度比原来宽度缩短了20px（因此会导致重叠）。但有意思的是，#mydiv1的内容不受影响，保持原有的宽度。 如果负margin等于实际宽度，则元素会被完全覆盖。这是因为元素的完全宽度等于margin，padding，border，width相加而成，所以如果负margin等于余下三者的和，那元素的实际宽度也就变成了0px。 圣杯布局看圣杯布局前，先看看如何实现三列布局 三列布局需求： 两边固定，中间自适应 当中列要完整显示 当中列优先加载 定位实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;meta http-equiv="X-UA-Compatible" content="IE=edge"&gt; &lt;title&gt;Page Title&lt;/title&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1"&gt; &lt;style type="text/css"&gt; * &#123; margin: 0; padding: 0; &#125; body &#123; /* 两倍的left+right */ min-width: 600px; &#125; #content &#123; position: relative; &#125; #left, #right &#123; width: 200px; height: 400px; background-color: yellow; &#125; #left &#123; position: absolute; left: 0; top: 0; &#125; #right &#123; position: absolute; right: 0; top: 0; &#125; #middle &#123; height: 400px; padding: 0 200px; background-color: pink; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="content"&gt; &lt;div id="left"&gt;left&lt;/div&gt; &lt;div id="middle"&gt;middle&lt;/div&gt; &lt;div id="right"&gt;right&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 但是页面的整体布局很少会使用定位来实现，而且定位需要一个容器，容器的定位必须是相对定位，定位会提升元素层级，这样布局会相对复杂。 浮动实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;meta http-equiv="X-UA-Compatible" content="IE=edge"&gt; &lt;title&gt;Page Title&lt;/title&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1"&gt; &lt;style type="text/css"&gt; * &#123; margin: 0; padding: 0; &#125; body &#123; /* 两倍的left+right */ min-width: 600px; &#125; #left, #right &#123; width: 200px; height: 400px; background-color: yellow; &#125; #left &#123; float: left; &#125; #right &#123; float: right; &#125; #middle &#123; height: 400px; background-color: pink; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="left"&gt;left&lt;/div&gt; &lt;div id="right"&gt;right&lt;/div&gt; &lt;div id="middle"&gt;middle&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 可以看到，浮动来实现三列布局比使用定位来实现三列布局更加方便。但是也造成一个问题，中间列按照文档的加载顺序，无法做到中间列优先加载，所以圣杯布局就出现了。 实现圣杯布局完整实现代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;meta http-equiv="X-UA-Compatible" content="IE=edge"&gt; &lt;title&gt;Page Title&lt;/title&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1"&gt; &lt;style type="text/css"&gt; * &#123; margin: 0; padding: 0; &#125; #header, #footer &#123; background-color: gray; text-align: center; line-height: 50px; height: 50px; &#125; #left, #right &#123; background-color: yellow; width: 200px; height: 200px; &#125; #middle &#123; /* 1、中间自适应，给予宽度100%，middle的包含块为container */ width: 100%; background-color: pink; height: 200px; &#125; #middle, #left, #right &#123; /* 2、三个块设置浮动，且middle宽度为100%，则left，和right换行显示 */ float: left; &#125; #left &#123; /* 3、解决left，设置margin-left为-100%，因为left的包含块和middle的包含块是同一个， 则-100%的值等于middle的宽度，则left被拉成与middle同行显示且靠middle左边对齐 */ margin-left: -100%; /* 6、将自己往外拉自身的宽度值 */ position: relative; left: -200px; &#125; #right &#123; /* 4、同理，只需要设置负值为与自身宽度相同，则被拉上与middle同行显示，且右边与middle右边对其 */ margin-left: -200px; /* 7、将自己往外拉自身的宽度值 */ position: relative; right: -200px; &#125; #middle &#123; &#125; #container &#123; /* 5、完成后，但是middle宽度还是整个的100%，left与right其实只是盖着它们，并没有把内容设置到中间，但是这里不能简单的设置padding值， 因为中间的宽度是100&amp;设定死的，而且left的margin也会随之变化， 所以要给它们三个的父元素container设置padding值，然后再将left和right往外拉 */ padding: 0 200px; &#125; /* 0、解决高度塌陷 */ .clearfix &#123; *zoom: 1; &#125; .clearfix::after &#123; content: ""; display: block; clear: both; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="header"&gt;header&lt;/div&gt; &lt;div id="container" class="clearfix"&gt; &lt;div id="middle"&gt;middle&lt;/div&gt; &lt;div id="left"&gt;left&lt;/div&gt; &lt;div id="right"&gt;right&lt;/div&gt; &lt;/div&gt; &lt;div id="footer"&gt;footer&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 圣杯布局结合了浮动、定位等技术，但最重要一点是使用了负margin的用法。 伪等高布局通常我们会遇到一些需求，要求两列高度相同，但是两列内容所撑开的高度不一定相同，伪等高布局就出现了。 实现代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style type="text/css"&gt; #content &#123; margin: 0 400px; border: 1px black solid; /* 父容器设置内容溢出显示 */ overflow: hidden; &#125; #content .left &#123; float: left; width: 400px; background-color: pink; &#125; #content .right &#123; float: left; width: 400px; background-color: gray; &#125; #content .left, #content .right &#123; /* 设置padding，让内容撑开一定高度 */ padding-bottom: 10000px; /*内容边界在收缩回来。*/ margin-bottom: -10000px; &#125; /* 解决高度塌陷 */ .clearfix &#123; *zoom: 1; &#125; .clearfix::after &#123; content: ""; display: block; clear: both; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="content" class="clearfix"&gt; &lt;div class="left"&gt; &lt;h1&gt;left&lt;/h1&gt; &lt;h1&gt;left&lt;/h1&gt; &lt;h1&gt;left&lt;/h1&gt; &lt;h1&gt;left&lt;/h1&gt; &lt;h1&gt;left&lt;/h1&gt; &lt;h1&gt;left&lt;/h1&gt; &lt;h1&gt;left&lt;/h1&gt; &lt;h1&gt;left&lt;/h1&gt; &lt;h1&gt;left&lt;/h1&gt; &lt;h1&gt;left&lt;/h1&gt; &lt;h1&gt;left&lt;/h1&gt; &lt;h1&gt;left&lt;/h1&gt; &lt;/div&gt; &lt;div class="right"&gt; &lt;h1&gt;right&lt;/h1&gt; &lt;h1&gt;right&lt;/h1&gt; &lt;h1&gt;right&lt;/h1&gt; &lt;h1&gt;right&lt;/h1&gt; &lt;h1&gt;right&lt;/h1&gt; &lt;h1&gt;right&lt;/h1&gt; &lt;h1&gt;right&lt;/h1&gt; &lt;h1&gt;right&lt;/h1&gt; &lt;h1&gt;right&lt;/h1&gt; &lt;h1&gt;right&lt;/h1&gt; &lt;h1&gt;right&lt;/h1&gt; &lt;h1&gt;right&lt;/h1&gt; &lt;h1&gt;right&lt;/h1&gt; &lt;h1&gt;right&lt;/h1&gt; &lt;h1&gt;right&lt;/h1&gt; &lt;h1&gt;right&lt;/h1&gt; &lt;h1&gt;right&lt;/h1&gt; &lt;h1&gt;right&lt;/h1&gt; &lt;h1&gt;right&lt;/h1&gt; &lt;h1&gt;right&lt;/h1&gt; &lt;h1&gt;right&lt;/h1&gt; &lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 同样多列也是如此运用，但是原理还是利用了负margin的特性来实现。 双飞翼布局因为圣杯布局外部整体布局还是会使用到定位，这样还是会对页面布局产生比较大的影响，那么双飞翼布局就出现了，对比圣杯，仅仅只是加了一个标签来搭建整体结构，不会使用到定位这些元素来影响到整体的布局。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style type="text/css"&gt; * &#123; margin: 0; padding: 0; &#125; #header, #footer &#123; background-color: yellow; line-height: 50px; text-align: center; &#125; #container .left, #container .right &#123; background-color: pink; width: 200px; height: 200px; &#125; #container .left &#123; float: left; margin-left: -100%; &#125; #container .right &#123; float: left; margin-left: -200px; &#125; #container .middle &#123; float: left; width: 100%; height: 200px; background-color: aqua; &#125; #container .middle .content &#123; padding: 0 200px; &#125; /* 解决高度塌陷 */ .clearfix &#123; *zoom: 1; &#125; .clearfix::after &#123; content: ""; display: block; clear: both; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="header"&gt;header&lt;/div&gt; &lt;div id="container" class="clearfix"&gt; &lt;div class="middle"&gt; &lt;!-- 对比圣杯布局，就是在middle里再加一个元素用来做内容的容器，那么这个容器再设置padding就不会影响到两侧元素了 --&gt; &lt;div class="content"&gt; middle content &lt;/div&gt; &lt;/div&gt; &lt;div class="left"&gt;left&lt;/div&gt; &lt;div class="right"&gt;right&lt;/div&gt; &lt;/div&gt; &lt;div id="footer"&gt;footer&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 滚动条先看一段代码 123456789101112131415161718192021222324252627282930&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style type="text/css"&gt; html &#123; margin: 30px; border: 1px black solid; &#125; body &#123; margin: 30px; border: 1px black solid; &#125; .box &#123; height: 5000px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="box"&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 看看这时候的滚动条作用与谁身上，不是body，也不是html，而是作用与文档上。 再看一个案例 12345678910111213141516171819202122232425262728293031323334&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style type="text/css"&gt; html &#123; height: 100%; margin: 30px; border: 1px black solid; overflow: scroll; &#125; body &#123; height: 100%; margin: 30px; border: 1px black solid; overflow: scroll; &#125; .box &#123; height: 5000px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="box"&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; body和html都添加了高度为100%的属性值，而它俩的包含块为初始包含块，所以它们两个高度为视口的高度。而两个都添加了overflow为scroll时，不仅文档出现了滚动条，而且body身上也出现了滚动条。 静止系统默认滚动条看到上面的例子后，如何静止掉系统的默认滚动条。 1234567891011121314151617181920212223&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style type="text/css"&gt; html,body &#123; height: 100%; overflow: hidden; &#125; body &#123; overflow: auto; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div style="height: 5000px;"&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 解决IE6下fixed固定定位失效问题实现代码 12345678910111213141516171819202122232425262728293031323334353637&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style type="text/css"&gt; /* 隐藏系统滚动条 */ html, body &#123; height: 100%; overflow: hidden; &#125; body &#123; overflow: scroll; &#125; .test &#123; position: absolute; left: 50px; top: 50px; width: 100px; height: 100px; background-color: pink; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="test"&gt;&lt;/div&gt; &lt;div style="height: 5000px;"&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 可以看到test元素仅仅只是设置了绝对定位，但是作用基本等同于固定定位。解释：因为这里隐藏了系统的默认滚动条，body显示的滚动条并不会移动视口，只有系统的滚动条才会移动视口。body的滚动条仅仅只是移动的body内的元素。而test元素的包含块是视口，所以就算滚动条怎么移动，test元素也不会移动，这就是另类解决fixed定位失效的问题解决办法。 粘连布局可能会遇到一种需求，我们有一个内容main 当main的高度足够长的时候，footer应该紧跟在main元素后面 当main元素比较短的时候（比如小于屏幕的高度），我们期望这个footer元素能够粘连在屏幕底部 实现代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style type="text/css"&gt; * &#123; margin: 0; padding: 0; &#125; body, html &#123; height: 100%; &#125; #wrap &#123; background-color: yellow; text-align: center; min-height: 100%; &#125; #wrap .main &#123; padding-bottom: 50px; &#125; #footer &#123; background-color: pink; height: 50px; line-height: 50px; text-align: center; /* 将自己拉上去一个自己的高度 */ margin-top: -50px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="wrap"&gt; &lt;div class="main"&gt; main&lt;br /&gt; main&lt;br /&gt; main&lt;br /&gt; main&lt;br /&gt; main&lt;br /&gt; main&lt;br /&gt; main&lt;br /&gt;&lt;!-- main&lt;br /&gt; main&lt;br /&gt; main&lt;br /&gt; main&lt;br /&gt; main&lt;br /&gt; main&lt;br /&gt; main&lt;br /&gt; main&lt;br /&gt; main&lt;br /&gt; main&lt;br /&gt; main&lt;br /&gt; main&lt;br /&gt; main&lt;br /&gt; main&lt;br /&gt; main&lt;br /&gt; main&lt;br /&gt; main&lt;br /&gt; main&lt;br /&gt; main&lt;br /&gt; main&lt;br /&gt; main&lt;br /&gt; main&lt;br /&gt; main&lt;br /&gt; main&lt;br /&gt; main&lt;br /&gt; main&lt;br /&gt; --&gt; &lt;/div&gt; &lt;/div&gt; &lt;!-- 必须要放在wrap外面 --&gt; &lt;div id="footer"&gt;footer&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 内容少的时候，footer粘在底部，当内容过多时滚动并紧跟内容。也是简单的负margin的运用。 BFC理解BFC是什么前我们先来理解另外两个概念：Box和FC(即formatting context) Box一个页面是由很多个Box组成的，元素的类型和display属性决定了这个Box的类型。不同类型的Box，会参与不同的Formatting Context。 Block Level的box会参与形成BFC，比如display值为block，list-item，table的元素。 Inline Level的box会参与形成IFC，比如display值为inline，inline-table，inline-block的元素。 FC(Formatting Context)它是W3C CSS2.1规范中的一个概念，定义的是页面中的一块渲染区域，并且有一套渲染规则，它 决定了其子元素将如何定位，以及和 其他元素的关系和相互作用。 常见的Formatting Context有：Block Formatting Context(BFC|块级格式化上下文)和Inline Formatting Context(IFC|行内格式化上下文)。 IFC、BFC布局规则IFC布局规则在行内格式化上下文中，框（boxes）一个接一个的水平排列，起点是包含块的顶部。水平方向上的margin，border和padding在框之间得到保留。框在垂直方向上可以以不同的方式对齐：它们的顶部或者底部对其，或根据其中文字的基线对其。包含那些框的长方形区域，会形成一行，叫做行框。 BFC布局规则【重要】 内部的Box会在垂直方向，一个接一个的放置。 Box垂直方向的距离由margin决定。属于同一个BFC的两个相邻Box的margin会发生重叠 每个元素的左外边缘（margin-left），与包含块的左边（contain box left)相接触（对于从左往右的格式化，否则相反）。即使存在浮动也是如此。除非这个元素自己形成了一个新的BFC。 BFC的区域不会与float box重叠。 BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。反之也如此。 计算BFC的高度时，浮动元素也参与计算。 块格式化上下文（Block Formatting Context，BFC）是Web页面的可视化CSS渲染的一部分，是块盒子的布局过程发生的区域，也是浮动元素与其他元素交互的区域。 下列方式会创建 块格式化上下文： 根元素或包含根元素的元素 浮动元素（元素的 float 不是 none） 绝对定位元素（元素的 position 为 absolute 或 fixed） 行内块元素（元素的 display 为 inline-block） 表格单元格（元素的 display为 table-cell，HTML表格单元格默认为该值） 表格标题（元素的 display 为 table-caption，HTML表格标题默认为该值） 匿名表格单元格元素（元素的 display为 table、table-row、 table-row-group、table-header-group、table-footer-group（分别是HTML table、row、tbody、thead、tfoot的默认属性）或 inline-table） overflow 值不为 visible 的块元素 display 值为 flow-root 的元素 contain 值为 layout、content或 strict 的元素 弹性元素（display为 flex 或 inline-flex元素的直接子元素） 网格元素（display为 grid 或 inline-grid 元素的直接子元素） 多列容器（元素的 column-count 或 column-width 不为 auto，包括 column-count 为 1） column-span 为 all 的元素始终会创建一个新的BFC，即使该元素没有包裹在一个多列容器中（标准变更，Chrome bug）。 块格式化上下文包含创建它的元素内部的所有内容. 块格式化上下文对浮动定位（参见 float）与清除浮动（参见 clear）都很重要。浮动定位和清除浮动时只会应用于同一个BFC内的元素。浮动不会影响其它BFC中元素的布局，而清除浮动只能清除同一BFC中在它前面的元素的浮动。外边距折叠（Margin collapsing）也只会发生在属于同一BFC的块级元素之间。 简单来说：BFC就是一个容器，来管理块级元素。 IE下的BFC（hasLayout）IE5、6、7下没有BFC的概念，但有类似于BFC相同的概念hasLayout。 hasLayout可以简单看作是IE5.5/6/7中的BFC(Block Formatting Context)。也就是一个元素要么自己对自身内容进行组织和尺寸计算(即可通过width/height来设置自身的宽高)，要么由其containing block来组织和尺寸计算。而IFC（即没有拥有布局）而言，则是元素无法对自身内容进行组织和尺寸计算，而是由自身内容来决定其尺寸（即仅能通过line-height设置内容行距，通过行距来支撑元素的高度；也无法通过width设置元素宽度，仅能由内容来决定而已）。 当hasLayout为true时(就是所谓的”拥有布局”)，相当于元素产生新BFC，元素自己对自身内容进行组织和尺寸计算; 当hasLayout为false时(就是所谓的”不拥有布局”)，相当于元素不产生新BFC，元素由其所属的containing block进行组织和尺寸计算。 和产生新BFC的特性一样，hasLayout无法通过CSS属性直接设置，而是通过某些CSS属性间接开启这一特性。不同的是某些CSS属性是以不可逆方式间接开启hasLayout为true。并且默认产生新BFC的只有html元素，而默认hasLayout为true的元素就不只有html元素了。 另外我们可以通过object.currentStyle.hasLayout属性来判断元素是否开启了hasLayout特性。 必须说明： **IE8及以上浏览器使用了全新的显示引擎，已经不再使用hasLayout属性，因为hasLayout属性只针对IE7以下。 默认拥有布局的元素 12345&lt;html&gt;, &lt;body&gt;&lt;table&gt;, &lt;tr&gt;, &lt;th&gt;, &lt;td&gt;&lt;img&gt;,&lt;hr&gt;&lt;input&gt;, &lt;button&gt;, &lt;select&gt;, &lt;textarea&gt;, &lt;fieldset&gt;, &lt;legend&gt;&lt;iframe&gt;, &lt;embed&gt;, &lt;object&gt;, &lt;applet&gt;,&lt;marquee&gt; 如何触发hasLayout 1234567display: inline-blockheight: (除 auto 外任何值)width: (除 auto 外任何值)float: (left 或 right)position: absolutewriting-mode: tb-rlzoom: (除 normal 外任意值) IE7还有一些额外的属性可触发hasLayout 12345678min-height: (任意值)min-width: (任意值)max-height: (除 none 外任意值)max-width: (除 none 外任意值)overflow: (除 visible 外任意值，仅用于块级元素)overflow-x: (除 visible 外任意值，仅用于块级元素)overflow-y: (除 visible 外任意值，仅用于块级元素)position: fixed 使用hasLayout就是为了兼容一些项目需要运行在IE7以下版本。 BFC实现自适应两栏布局123456789101112131415161718192021222324252627282930313233343536373839404142&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style type="text/css"&gt; #content .left &#123; float: left; width: 200px; height: 200px; background-color: aquamarine; &#125; #content .middle &#123; height: 200px; background-color: green; overflow: hidden; &#125; .clearfix::after &#123; content: ""; display: block; clear: both; &#125; .clearfix &#123; zoom: 1; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="content" class="clearfix"&gt; &lt;div class="left"&gt;&lt;/div&gt; &lt;div class="middle"&gt;&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 可以使用三列布局的思想来实现两列布局，但是利用BFC的原理可以更简单的实现两列布局。由于left块开启浮动，会使得left显示在middle上层，但是middle还是占满100%，单纯用颜色判断像是两列布局，但是开启left透明度会发现middle占满100%，是浮现在上面，而让middle开启BFC，overflow为hidden即为开启了middle的BFC，BFC的区域并不会和浮动区域重叠，即可实现。 清除浮动解决高度塌陷的方式直接给予高度直接计算内容盒子高度，并赋予父容器高度，简单，但是毫无扩展性。 利用BFC12345678910111213141516171819202122232425262728293031&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style type="text/css"&gt; #content &#123; border: 1px black solid; /* 利用BFC布局原则，BFC块高度，浮动元素也会参与高度计算，只要满足开启BFC的条件即可 */ overflow: hidden; &#125; #content .box &#123; float: left; width: 200px; height: 200px; background-color: aqua; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="content"&gt; &lt;div class="box"&gt;&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; br标签&lt;br clear=&quot;all&#39; /&gt; 12345678910111213141516171819202122232425262728293031&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style type="text/css"&gt; #content &#123; border: 1px black solid; &#125; #content .box &#123; float: left; width: 200px; height: 200px; background-color: aqua; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="content"&gt; &lt;div class="box"&gt;&lt;/div&gt; &lt;!-- 利用br标签 --&gt; &lt;br clear="all" /&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 空标签清除浮动1234567891011121314151617181920212223242526272829303132333435&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style type="text/css"&gt; #content &#123; border: 1px black solid; &#125; #content .box &#123; float: left; width: 200px; height: 200px; background-color: aqua; &#125; .clearfix &#123; clear: both; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="content"&gt; &lt;div class="box"&gt;&lt;/div&gt; &lt;!-- 空标签并清除浮动 --&gt; &lt;div class="clearfix"&gt;&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 伪元素清除浮动123456789101112131415161718192021222324252627282930313233343536373839&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style type="text/css"&gt; #content &#123; border: 1px black solid; &#125; #content .box &#123; float: left; width: 200px; height: 200px; background-color: aqua; &#125; .clearfix &#123; *zoom: 1; &#125; .clearfix::after &#123; content: ""; display: block; clear: both; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="content" class="clearfix"&gt; &lt;div class="box"&gt;&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 垂直水平居中方式1需要已知自身元素高宽。 12345678910111213141516171819202122232425262728293031323334&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style type="text/css"&gt; #wrap &#123; position: relative; width: 600px; height: 600px; background-color: pink; margin: 0 auto; &#125; #inner &#123; position: absolute; left: 50%; top: 50%; margin-left: -50px; margin-top: -50px; width: 100px; height: 100px; background-color: aqua; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="wrap"&gt; &lt;div id="inner"&gt;test&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 方式2需要已知自身元素高宽。 1234567891011121314151617181920212223242526272829303132333435&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style type="text/css"&gt; #wrap &#123; position: relative; width: 600px; height: 600px; background-color: pink; margin: 0 auto; &#125; #inner &#123; position: absolute; left: 0; top: 0; right: 0; bottom: 0; margin: auto auto; width: 100px; height: 100px; background-color: aqua; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="wrap"&gt; &lt;div id="inner"&gt;test&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 原理： 绝对定位盒子特性：高宽有内容撑开下水平方向上：left + right + width + padding + margin = 包含块padding内容区域垂直方向上：top + bottom + width + padding + margin = 包含块padding内容区域 上述例子中：水平方向上：0 + 0 + 100 + 0 + auto = 600垂直方向上：0 + 0 + 100 + 0 + auto = 600则auto等于250，即可居中。 方案3无需知道元素高度，使用transform 123456789101112131415161718192021222324252627282930313233343536&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style type="text/css"&gt; #wrap &#123; position: relative; width: 600px; height: 600px; background-color: pink; margin: 0 auto; &#125; #inner &#123; position: absolute; left: 50%; top: 50%; transform: translate(-50%,-50%); background-color: aqua; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="wrap"&gt; &lt;div id="inner"&gt; testaaaaaaa&lt;br /&gt; testaaaaaa&lt;abr /&gt; testaaaaaa&lt;br /&gt; testaaaaaa&lt;br /&gt; &lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 行高 从上到下四条线分别是顶线、中线、基线、底线，很像才学英语字母时的四线三格 1.行高是指上下文本行的基线间的垂直距离，即图中两条红线间垂直距离。2.行距是指一行底线到下一行顶线的垂直距离，即第一行粉线和第二行绿线间的垂直距离。3.半行距是行距的一半，即区域3垂直距离/2，区域1，2，3，4的距离之和为行高，而区域1，2，4距离之和为字体size，所以半行距也可以这么算：（行高-字体size）/2 内容区：底线和顶线包裹的区域，即下图深灰色背景区域。文本行中的每个元素都会生成一个内容区，这个由字体的大小确定。这个内容区则会生成一个行内框，如果不存在其他因素，这个行内框就完全等于该元素的内容区，由line-height产生的行间距就是增加和减少各行内框高度的因素之一。 行内框 : 行内框是一个浏览器渲染模型中的一个概念，无法显示出来，行内框默认等于内容区域， 将line-height的计算值减去font-size的计算值，这个值就是总行距，这个值可能是个负值，任何将行间距/2 分别应用到内容区的顶部和底部，其结果就是该元素的行内框。 行框（line box），行框是指本行的一个虚拟的矩形框，是浏览器渲染模式中的一个概念，并没有实际显示。默认情况下行框高度等于本行内所有元素中行内框最大的值（一行上垂直对齐时以行高值最大的行内框为基准，其他行内框采用自己的对齐方式向基准对齐，最终计算行框的高度），当有多行内容时，每行都会有自己的行框。 vertical-alignCSS 的属性 vertical-align 用来指定行内元素（inline）或表格单元格（table-cell）元素的垂直对齐方式。 注意 vertical-align 只对行内元素、表格单元格元素生效：不能用它垂直对齐块级元素。 使行内元素盒模型与其行内元素容器垂直对齐。例如，用于垂直对齐一行文本的内的图片&lt;img&gt;：123456789101112131415161718192021222324252627282930313233&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style type="text/css"&gt; #content &#123; width: 600px; height: 600px; border: 1px red solid; text-align: center; &#125; #content::after &#123; content: ""; display: inline-block; height: 50%; width: 0; &#125; #content .icon &#123; vertical-align: middle; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="content"&gt; &lt;img class="icon" src="img/img.png" alt=""&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 代码已放置于github 参考资料https://segmentfault.com/a/1190000009545742 https://developer.mozilla.org/zh-CN/docs/Web/Guide/CSS/Block_formatting_context]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[跨域介绍以及跨域的方式]]></title>
    <url>%2F2019%2F03%2F27%2F%E8%B7%A8%E5%9F%9F%E4%BB%8B%E7%BB%8D%E4%BB%A5%E5%8F%8A%E8%B7%A8%E5%9F%9F%E7%9A%84%E6%96%B9%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[前言前端在与后端进行数据交互时经常会碰到跨域请求，这里在此探讨一下。 什么是跨域什么是同源策略及其限制内容同源策略是一种约定，它是浏览器最核心也是最基本的安全功能，如果少了同源策略，浏览器很容易收到XSS，CSFR等攻击。所谓同源指的是协议+域名+端口三者相同，即便两个不同的域名指向同一个ip地址，也非同源。 同源策略的限制内容有： Cookie、LocalStorage、IndexedDB等存储性内容 DOM节点 AJAX请求发送后，结果被浏览器拦截了 但是有三个标签是允许跨域加载资源 &lt;img src=&quot;...&quot;&gt; &lt;link href=&quot;...&quot;&gt; &lt;script src=&quot;...&quot;&gt; 常见跨域场景当协议、子域名、主域名、端口号中任意一个不相同时，都算作不同域。不同域之间相互请求资源，就算作跨域，常见的跨域场景如下图所示： URL 说明 是否允许通信 http://www.a.com/a.js http://www.a.com/b.js 同一个域名下 允许 http://www.a.com/lab/a.js http://www.a.com/script/b.js 同一域名下不同文件夹 允许 http://www.a.com:8000/a.js http://www.a.com/b.js 同一域名，不同端口 不允许 http://www.a.com/a.js https://www.a.com/b.js 同一域名，不同协议 不允许 http://www.a.com/a.js http://70.32.92.74/b.js 域名和域名对应ip 不允许 http://www.a.com/a.js http://script.a.com/b.js 主域相同，子域不同 不允许 http://www.a.com/a.js http://a.com/b.js 同一域名，不同二级域名 不允许，cookie这种情况下也不允许 http://www.cnblogs.com/a.js http://www.a.com/b.js 不同域名 不允许 特别说明 如果时协议和端口造成的跨域问题，前端时无能为力的 在跨域问题上，仅仅是通过“URL的首部“来识别而不会根据域名对应的IP地址是否相同来判断。“URL的首部”可以理解为“协议、域名和端口必须匹配“。 请求跨域，那么请求有没有发出去？跨域并不是请求发不出去，请求能发出去，服务端能收到请求并正常返回结果，只是结果被浏览器拦截了。，可是通过表单的方式可以发起跨域请求，为什么AJAX就不可以，归根结底，跨域是为了阻止用户读取到另一个域名下的内容，AJAX可以获取响应，浏览器认为这并不安全，所以拦截了响应。但是表单并不会获取新的内容，所以可以发起跨域请求。这同时也说明了跨域并不能完全阻止CSRF，因为请求毕竟是发出去了。 跨域解决方案JSONP原理JSONP原理是利用&lt;script&gt;标签没有跨域限制的漏洞，网页可以得到从其他来源动态产生的JSON数据。JSONP请求一定需要对方的服务器做支持才可以。 JSONP与AJAX对比JSONP与AJAX相同，都是客户端向服务器端发送请求，从服务器端获取数据的方式。但是AJAX属于同源策略，JSONP属于非同源策略（跨域请求） JSONP优缺点JSONP优点是简单兼容性好，可用于解决主流浏览器的跨域数据访问的问题。缺点是仅支持get方法具有局限性，不安全可能会XSS攻击。 JSONP的实现流程 声明一个回调函数，其函数名（如show）当做参数值，要传递给跨域请求数据的服务器，函数形参为要获取目标数据（服务器返回的data）。 创建一个&lt;script&gt;标签，把那个跨域的API数据接口地址，赋值给script的src，还要在这个地址中向服务器传递该参数名（可以通过问好传参：`?callback=show）。 服务器接受到请求后，需要进行特殊的处理：把传递进来的函数名和它需要给你的数据拼接成一个字符串，例如：传递进去的函数名是show，它准备好的数据是show(‘XXX’)。 最后服务器把准备的数据通过HTTP协议返回给客户端，客户端再调用执行之前声明的回调函数show，对返回的数据进行操作。 在开发中可能会遇到多个JSONP请求的回调函数名是相同的，这时候就需要自己封装一个JSONP函数。123456789101112131415161718192021222324// index.htmlfunction jsonp(&#123; url, params, callback &#125;) &#123; return new Promise((resolve, reject) =&gt; &#123; let script = document.createElement('script') window[callback] = function(data) &#123; resolve(data) document.body.removeChild(script) &#125; params = &#123; ...params, callback &#125; // wd=b&amp;callback=show let arrs = [] for (let key in params) &#123; arrs.push(`$&#123;key&#125;=$&#123;params[key]&#125;`) &#125; script.src = `$&#123;url&#125;?$&#123;arrs.join('&amp;')&#125;` document.body.appendChild(script) &#125;)&#125;jsonp(&#123; url: 'http://127.0.01:8000/say', params: &#123; wd: 'Iloveyou' &#125;, callback: 'show'&#125;).then(data =&gt; &#123; console.log(data)&#125;) 上面这段代码相当于向http://127.0.0.1:8000/say?wd=Iloveyou&amp;callback=show这个地址请求数据，然后后台返回show(‘I love you’)，最后会允许show()这个函数，打印出’我不爱你’ 后端nodejs12345678910// server.jslet express = require('express')let app = express()app.get('/say', function(req, res) &#123; let &#123; wd, callback &#125; = req.query console.log(wd) // Iloveyou console.log(callback) // show res.end(`$&#123;callback&#125;('我不爱你')`)&#125;)app.listen(8000) JQuery的jsonp形式JSONP都是GET和异步请求，不存在其他的请求方式和同步请求，且JQuery默认就会给JSONP的请求清除缓存。123456789$.ajax(&#123;url:"http://crossdomain.com/jsonServerResponse",dataType:"jsonp",type:"get",//可以省略jsonpCallback:"show",//-&gt;自定义传递给服务器的函数名，而不是使用jQuery自动生成的，可省略jsonp:"callback",//-&gt;把传递函数名的那个形参callback，可省略success:function (data)&#123;console.log(data);&#125;&#125;); CORSCORS需要浏览器和后端同时支持。IE8 和 9 需要通过XDomainRequest来实现。 浏览器会自动CORS通信，实现CORS通信的关键是后端。只要后端实现了CORS，就实现了跨域。 服务端设置 Access-Control-Allow-Origin 就可以开启 CORS。 该属性表示哪些域名可以访问资源，如果设置通配符则表示所有网站都可以访问资源。 虽然设置 CORS 和前端没什么关系，但是通过这种方式解决跨域问题的话，会在发送请求时出现两种情况，分别为简单请求和复杂请求。 简单请求只要同时满足一下两大条件，就属于简单请求条件1：使用下列方式之一： GET HEAD POST 条件2：Content-Type的值仅限于下列三者之一： text/plain multipart/form-data application/x-www-form-urlencoded 请求中的任意 XMLHttpRequestUpload 对象均没有注册任何事件监听器； XMLHttpRequestUpload 对象可以使用 XMLHttpRequest.upload 属性访问。 复杂请求不符合以上条件的请求就肯定是复杂请求了。复杂请求的CORS请求，会在正式通信之前，增加一次HTTP查询请求，称为”预检”请求,该请求是 option 方法的，通过该请求来知道服务端是否允许跨域请求。 我们用PUT向后台请求时，属于复杂请求，后台需做如下配置：12345678910111213// 允许哪个方法访问我res.setHeader('Access-Control-Allow-Methods', 'PUT')// 预检的存活时间res.setHeader('Access-Control-Max-Age', 6)// OPTIONS请求不做任何处理if (req.method === 'OPTIONS') &#123; res.end() &#125;// 定义后台返回的内容app.put('/getData', function(req, res) &#123; console.log(req.headers) res.end('我不爱你')&#125;) 接下来我们看下一个完整复杂请求的例子，并且介绍下CORS请求相关的字段 12345678910111213141516// index.htmllet xhr = new XMLHttpRequest()document.cookie = 'name=xiamen' // cookie不能跨域xhr.withCredentials = true // 前端设置是否带cookiexhr.open('PUT', 'http://localhost:4000/getData', true)xhr.setRequestHeader('name', 'xiamen')xhr.onreadystatechange = function() &#123; if (xhr.readyState === 4) &#123; if ((xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300) || xhr.status === 304) &#123; console.log(xhr.response) //得到响应头，后台需设置Access-Control-Expose-Headers console.log(xhr.getResponseHeader('name')) &#125; &#125;&#125;xhr.send() 12345//server1.jslet express = require('express');let app = express();app.use(express.static(__dirname));app.listen(3000); 123456789101112131415161718192021222324252627282930313233343536//server2.jslet express = require('express')let app = express()let whitList = ['http://localhost:3000'] //设置白名单app.use(function(req, res, next) &#123; let origin = req.headers.origin if (whitList.includes(origin)) &#123; // 设置哪个源可以访问我 res.setHeader('Access-Control-Allow-Origin', origin) // 允许携带哪个头访问我 res.setHeader('Access-Control-Allow-Headers', 'name') // 允许哪个方法访问我 res.setHeader('Access-Control-Allow-Methods', 'PUT') // 允许携带cookie res.setHeader('Access-Control-Allow-Credentials', true) // 预检的存活时间 res.setHeader('Access-Control-Max-Age', 6) // 允许返回的头 res.setHeader('Access-Control-Expose-Headers', 'name') if (req.method === 'OPTIONS') &#123; res.end() // OPTIONS请求不做任何处理 &#125; &#125; next()&#125;)app.put('/getData', function(req, res) &#123; console.log(req.headers) res.setHeader('name', 'jw') //返回一个响应头，后台需设置 res.end('我不爱你')&#125;)app.get('/getData', function(req, res) &#123; console.log(req.headers) res.end('我不爱你')&#125;)app.use(express.static(__dirname))app.listen(4000) 上述代码由http://localhost:3000/index.html向http://localhost:4000/跨域请求，正如我们上面所说的，后端是实现 CORS 通信的关键。 postMessagepostMessage是HTML5 XMLHttpRequest Level 2中的API，且是为数不多可以跨域操作的window属性之一，它可用于解决以下方面的问题： 页面和其打开的新窗口的数据传递 多窗口之间消息传递 页面与嵌套的iframe消息传递 上面三个场景的跨域数据传递 postMessage()方法允许来自不同源的脚本采用异步方式进行有限的通信，可以实现跨文本档、多窗口、跨域消息传递。 otherWindow.postMessage(message, targetOrigin, [transfer]); message: 将要发送到其他 window的数据。 targetOrigin:通过窗口的origin属性来指定哪些窗口能接收到消息事件，其值可以是字符串”*”（表示无限制）或者一个URI。在发送消息的时候，如果目标窗口的协议、主机地址或端口这三者的任意一项不匹配targetOrigin提供的值，那么消息就不会被发送；只有三者完全匹配，消息才会被发送。 transfer(可选)：是一串和message 同时传递的 Transferable 对象. 这些对象的所有权将被转移给消息的接收方，而发送一方将不再保有所有权。 接下来我们看个例子： http://localhost:3000/a.html页面向http://localhost:4000/b.html传递“我爱你”,然后后者传回”我不爱你”。 123456789101112// a.html &lt;iframe src="http://localhost:4000/b.html" frameborder="0" id="frame" onload="load()"&gt;&lt;/iframe&gt; //等它加载完触发一个事件 //内嵌在http://localhost:3000/a.html &lt;script&gt; function load() &#123; let frame = document.getElementById('frame') frame.contentWindow.postMessage('我爱你', 'http://localhost:4000') //发送数据 window.onmessage = function(e) &#123; //接受返回数据 console.log(e.data) //我不爱你 &#125; &#125; &lt;/script&gt; 12345// b.html window.onmessage = function(e) &#123; console.log(e.data) //我爱你 e.source.postMessage('我不爱你', e.origin) &#125; websocketWebsocket是HTML5的一个持久化的协议，它实现了浏览器与服务器的全双工通信，同时也是跨域的一种解决方案。WebSocket和HTTP都是应用层协议，都基于 TCP 协议。但是 WebSocket 是一种双向通信协议，在建立连接之后，WebSocket 的 server 与 client 都能主动向对方发送或接收数据。同时，WebSocket 在建立连接时需要借助 HTTP 协议，连接建立好了之后 client 与 server 之间的双向通信就与 HTTP 无关了。 原生WebSocket API使用起来不太方便，我们使用Socket.io，它很好地封装了webSocket接口，提供了更简单、灵活的接口，也对不支持webSocket的浏览器提供了向下兼容。 我们先来看个例子：本地文件socket.html向localhost:3000发生数据和接受数据 12345678910// socket.html&lt;script&gt; let socket = new WebSocket('ws://localhost:3000'); socket.onopen = function () &#123; socket.send('我爱你');//向服务器发送数据 &#125; socket.onmessage = function (e) &#123; console.log(e.data);//接收服务器返回的数据 &#125;&lt;/script&gt; 1234567891011// server.jslet express = require('express');let app = express();let WebSocket = require('ws');//记得安装wslet wss = new WebSocket.Server(&#123;port:3000&#125;);wss.on('connection',function(ws) &#123; ws.on('message', function (data) &#123; console.log(data); ws.send('我不爱你') &#125;);&#125;) Node中间件代理(两次跨域)实现原理：同源策略是浏览器需要遵循的标准，而如果是服务器向服务器请求就无需遵循同源策略。代理服务器，需要做以下几个步骤： 接受客户端请求 。 将请求转发给服务器。 拿到服务器响应数据。 将响应转发给客户端。 我们先来看个例子：本地文件index.html文件，通过代理服务器http://localhost:3000向目标服务器http://localhost:4000请求数据。 12345678910111213141516// index.html(http://127.0.0.1:5500) &lt;script src="https://cdn.bootcss.com/jquery/3.3.1/jquery.min.js"&gt;&lt;/script&gt; &lt;script&gt; $.ajax(&#123; url: 'http://localhost:3000', type: 'post', data: &#123; name: 'xiamen', password: '123456' &#125;, contentType: 'application/json;charset=utf-8', success: function(result) &#123; console.log(result) // &#123;"title":"fontend","password":"123456"&#125; &#125;, error: function(msg) &#123; console.log(msg) &#125; &#125;) &lt;/script&gt; 1234567891011121314151617181920212223242526272829303132333435363738// server1.js 代理服务器(http://localhost:3000)const http = require('http')// 第一步：接受客户端请求const server = http.createServer((request, response) =&gt; &#123; // 代理服务器，直接和浏览器直接交互，需要设置CORS 的首部字段 response.writeHead(200, &#123; 'Access-Control-Allow-Origin': '*', 'Access-Control-Allow-Methods': '*', 'Access-Control-Allow-Headers': 'Content-Type' &#125;) // 第二步：将请求转发给服务器 const proxyRequest = http .request( &#123; host: '127.0.0.1', port: 4000, url: '/', method: request.method, headers: request.headers &#125;, serverResponse =&gt; &#123; // 第三步：收到服务器的响应 var body = '' serverResponse.on('data', chunk =&gt; &#123; body += chunk &#125;) serverResponse.on('end', () =&gt; &#123; console.log('The data is ' + body) // 第四步：将响应结果转发给浏览器 response.end(body) &#125;) &#125; ) .end()&#125;)server.listen(3000, () =&gt; &#123; console.log('The proxyServer is running at http://localhost:3000')&#125;) 1234567891011// server2.js(http://localhost:4000)const http = require('http')const data = &#123; title: 'fontend', password: '123456' &#125;const server = http.createServer((request, response) =&gt; &#123; if (request.url === '/') &#123; response.end(JSON.stringify(data)) &#125;&#125;)server.listen(4000, () =&gt; &#123; console.log('The server is running at http://localhost:4000')&#125;) 上述代码经过两次跨域，值得注意的是浏览器向代理服务器发送请求，也遵循同源策略，最后在index.html文件打印出{&quot;title&quot;:&quot;fontend&quot;,&quot;password&quot;:&quot;123456&quot;} nginx反向代理实现原理类似于Node中间件代理，需要你搭建一个中转nginx服务器，用于转发请求。 使用nginx反向代理实现跨域，是最简单的跨域方式。只需要修改nginx的配置即可解决跨域问题，支持所有浏览器，支持session，不需要修改任何代码，并且不会影响服务器性能。 实现思路：通过nginx配置一个代理服务器（域名与domain1相同，端口不同）做跳板机，反向代理访问domain2接口，并且可以顺便修改cookie中domain信息，方便当前域cookie写入，实现跨域登录。 先下载nginx，然后将nginx目录下的nginx.conf修改如下: 1234567891011121314// proxy服务器server &#123; listen 80; server_name www.domain1.com; location / &#123; proxy_pass http://www.domain2.com:8080; #反向代理 proxy_cookie_domain www.domain2.com www.domain1.com; #修改cookie里域名 index index.html index.htm; # 当用webpack-dev-server等中间件代理接口访问nignx时，此时无浏览器参与，故没有同源限制，下面的跨域配置可不启用 add_header Access-Control-Allow-Origin http://www.domain1.com; #当前端只跨域不带cookie时，可为* add_header Access-Control-Allow-Credentials true; &#125;&#125; 最后通过命令行nginx -s reload启动nginx 1234567// index.htmlvar xhr = new XMLHttpRequest();// 前端开关：浏览器是否读写cookiexhr.withCredentials = true;// 访问nginx中的代理服务器xhr.open('get', 'http://www.domain1.com:81/?user=admin', true);xhr.send(); js 123456789101112131415// server.jsvar http = require('http');var server = http.createServer();var qs = require('querystring');server.on('request', function(req, res) &#123; var params = qs.parse(req.url.substring(2)); // 向前台写cookie res.writeHead(200, &#123; 'Set-Cookie': 'l=a123456;Path=/;Domain=www.domain2.com;HttpOnly' // HttpOnly:脚本无法读取 &#125;); res.write(JSON.stringify(params)); res.end();&#125;);server.listen('8080');console.log('Server is running at port 8080...'); window.name + iframewindow.name属性的独特之处：name值在不同的页面（甚至不同域名）加载后依旧存在，并且可以支持非常长的 name 值（2MB）。 其中a.html和b.html是同域的，都是http://localhost:3000;而c.html是http://localhost:4000 1234567891011121314151617// a.html(http://localhost:3000/b.html) &lt;iframe src="http://localhost:4000/c.html" frameborder="0" onload="load()" id="iframe"&gt;&lt;/iframe&gt; &lt;script&gt; let first = true // onload事件会触发2次，第1次加载跨域页，并留存数据于window.name function load() &#123; if(first)&#123; // 第1次onload(跨域页)成功后，切换到同域代理页面 let iframe = document.getElementById('iframe'); iframe.src = 'http://localhost:3000/b.html'; first = false; &#125;else&#123; // 第2次onload(同域b.html页)成功后，读取同域window.name中数据 console.log(iframe.contentWindow.name); &#125; &#125; &lt;/script&gt; b.html为中间代理页，与a.html同域，内容为空。1234// c.html(http://localhost:4000/c.html) &lt;script&gt; window.name = '我不爱你' &lt;/script&gt; 通过iframe的src属性由外域转向本地域，跨域数据即由iframe的window.name从外域传递到本地域。这个就巧妙地绕过了浏览器的跨域访问限制，但同时它又是安全操作。 location.hash + iframe实现原理： a.html欲与c.html跨域相互通信，通过中间页b.html来实现。 三个页面，不同域之间利用iframe的location.hash传值，相同域之间直接js访问来通信。 具体实现步骤：一开始a.html给c.html传一个hash值，然后c.html收到hash值后，再把hash值传递给b.html，最后b.html将结果放到a.html的hash值中。同样的，a.html和b.html是同域的，都是http://localhost:3000;而c.html是http://localhost:4000 1234567// a.html &lt;iframe src="http://localhost:4000/c.html#iloveyou"&gt;&lt;/iframe&gt; &lt;script&gt; window.onhashchange = function () &#123; //检测hash的变化 console.log(location.hash); &#125; &lt;/script&gt; 12345// b.html &lt;script&gt; window.parent.parent.location.hash = location.hash //b.html将结果放到a.html的hash值中，b.html可通过parent.parent访问a.html页面 &lt;/script&gt; 12345// c.htmlconsole.log(location.hash); let iframe = document.createElement('iframe'); iframe.src = 'http://localhost:3000/b.html#idontloveyou'; document.body.appendChild(iframe); document.domain + iframe该方式只能用于二级域名相同的情况下，比如 a.test.com 和 b.test.com 适用于该方式。 只需要给页面添加document.domain =&#39;test.com&#39; 表示二级域名都相同就可以实现跨域。 实现原理：两个页面都通过js强制设置document.domain为基础主域，就实现了同域。 我们看个例子：页面a.zf1.cn:3000/a.html获取页面b.zf1.cn:3000/b.html中a的值 1234567891011// a.html&lt;body&gt; helloa &lt;iframe src="http://b.zf1.cn:3000/b.html" frameborder="0" onload="load()" id="frame"&gt;&lt;/iframe&gt; &lt;script&gt; document.domain = 'zf1.cn' function load() &#123; console.log(frame.contentWindow.a); &#125; &lt;/script&gt;&lt;/body&gt; 12345678/ b.html&lt;body&gt; hellob &lt;script&gt; document.domain = 'zf1.cn' var a = 100; &lt;/script&gt;&lt;/body&gt; 总结 CORS支持所有类型的HTTP请求，是跨域HTTP请求的根本解决方案 JSONP只支持GET请求，JSONP的优势在于支持老式浏览器，以及可以向不支持CORS的网站请求数据。 不管是Node中间件代理还是nginx反向代理，主要是通过同源策略对服务器不加限制。 日常工作中，用得比较多的跨域方案是cors和nginx反向代理 参考http://www.ruanyifeng.com/blog/2016/04/cors.html https://developer.mozilla.org/zh-CN/docs/Web/API/Window/postMessage https://segmentfault.com/a/1190000011145364]]></content>
      <categories>
        <category>HTML</category>
      </categories>
      <tags>
        <tag>HTML</tag>
        <tag>跨域</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IOS中的Web开发]]></title>
    <url>%2F2019%2F03%2F25%2FIOS%E4%B8%AD%E7%9A%84Web%E5%BC%80%E5%8F%91%2F</url>
    <content type="text"><![CDATA[移动开发领域近年来已经逐渐告别了野蛮生长的时期，进入了相对成熟的时代。而一直以来 Native 和 Web 的争论从未停止，通过开发者孜孜不倦的努力，Web 的效率和 Native 的体验也一直在寻求着平衡。本文聚焦 iOS 开发和 Web 开发的交叉点，希望能通过简要的介绍，帮助开发者一窥 Hybrid 和大前端的构想。 IOS中web容器与加载1、IOS中的Web容器目前IOS系统为开发者提供三种方式来展示Web内容 UIWebViewUIWebView 从 iOS2 开始就作为 App 内展示 Web 内容的容器，但是长久以来一直遭受开发者的诟病；系统级的内存泄露、极高内存峰值、较差的稳定性、Touch Delay 以及 Javascript 的运行性能及通信限制等等。在 iOS12 以后已经标记为 Deprecated 不再维护。 WKWebView在 iOS 8 中，Apple 引入了新一代的 WebKit framework，同时提供了 WKWebView 用来替代传统的 UIWebView。它更加的稳定、拥有 60fps 滚动刷新率、丰富的手势、KVO、高效的 Web 和 Native 通信，默认进度条等等功能，而最重要的，是使用了和 safari 相同的 Nitro 引擎极大提升了 Javascript 的运行速度。WKWebView 独立的进程管理，也降低了内存占用及 Crash 对主 App 的影响。 SFSafariViewController在 iOS 9 中，Apple 引入了 SFSafariViewController。其特点就是在 App 内可以打开一个高度标准化的、和 Safari 一样界面和特性的页面。同时 SFSafariViewController 支持和 Safari 共享 Cookie 和表单数据等等。 Web容器选型对于 SFSafariViewController：由于其标准化程度之高，使之界面和交互逻辑无法和 App 统一，基于 App 的整体体验的考虑，一般都使用在相对独立的功能和模块中，最常见的就是在 App 内打开 App Store 或者广告、游戏推广的页面。 对于 UIWebView/WKWebView：如果说之前由于 NSURLProtocol 的问题，好多 App 都在继续使用 UIWebView，那么随着 App 放弃维护 UIWebView（iOS12），全部的 App 应该会陆续的切换到 WKWebView 中来。当然，最初 WKWebView 也为开发者们带来了一些难题，但是随着系统的升级与业务逻辑的适配也逐步的修复，后文会列举几个最为关注的技术点。 UIWebView/WKWebView 对主 App 内存的影响： 2、WebKit 框架与使用WebKit.frameworkWebKit 是一个开源的 Web 浏览器引擎。每当谈到 WebKit，开发者常常迷惑于它和 WebKit2、Safari、iOS 中的 framework、以及 Chromium 等浏览器的关系。 广义的 WebKit 其实就是指 WebCore，它主要包含了 HTML 和 CSS 的解析、布局和定位这类渲染 HTML 的功能逻辑。而狭义的 WebKit 就是在 WebCore 的基础上，不同平台封装 Javascript 引擎、网络层、GPU 相关的技术（WebGL、视频）、绘制渲染技术以及各个平台对应的接口，形成我们可以用的 WebView 或浏览器，也就是所谓的 WebKit Ports。 比如在 Safari 中 JS 的引擎使用 JavascriptCore，而 Chromium 中使用 V8；渲染方面 Safari 使用 CoreGraphics，而 Chromium 中使用 Skia；网络方面 Safari 使用 CFNetwork，而 Chromium 中使用 Chromium stack 等等。而 WebKit2 是相对于狭义上的 WebKit 架构而言，主要变化是在 API 层支持多进程，分离了 UI 和 Web 接口的进程，使之通过 IPC 来进行通讯。 对于 iOS 中的 WebKit.framework 就是在 WebCore、底层桥接、JSCore 引擎等核心模块的基础上，针对 iOS 平台的项目封装。它基于新的 WKWebView，提供了一系列浏览特性的设置，以及简单方便的加载回调。而具体类及使用，开发者可以查阅官方文档: https://developer.apple.com/documentation/webkit Web 容器使用流程与关键节点对于大部分日常使用来说，开发者需要关注的就是 WKWebView 的创建、配置、加载、以及系统回调的接收。 对于 Web 开发者，业务逻辑一般通过基于 Web 页面中 Dom 渲染的关键节点来处理。而对于 iOS 开发者，WKWebView 提供的的注册、加载和回调时机，没有明确的与 Web 加载的关键节点相关联。准确的理解和处理两个维度的加载顺序，选择合理的业务逻辑处理时机，才可以实现准确而高效的应用。 WKWebView 常见问题使用 WKWebView 带来的另外一个好处，就是我们可以通过源码理解部分加载逻辑，为 Crash 提供一些思路，或者使用一些私有方法处理复杂业务逻辑。 NSURLProtocol WKWebView 最为显著的改变，就是不支持 NSURLProtocol。为了兼容旧的业务逻辑，一部分 App 通过 WKBrowsingContextController 中的非公开方法实现了 NSURLProtocol。 12// WKBrowsingContextController + (void)registerSchemeForCustomProtocol:(NSString *)scheme WK_API_DEPRECATED_WITH_REPLACEMENT("WKURLSchemeHandler", macos(10.10, WK_MAC_TBA), ios(8.0, WK_IOS_TBA)); 在 iOS 11 中，系统增加了 setURLSchemeHandler 函数用来拦截自定义的 Scheme。但是不同于 UIWebView，新的函数只能拦截自定义的 Scheme(SchemeRegistry.cpp)，对使用最多的 HTTP/HTTPS 依然不能有效的拦截。 12345678//SchemeRegistry static const StringVectorFunction functions[] &#123; builtinSecureSchemes, // about;data... builtinSchemesWithUniqueOrigins, // javascript... builtinEmptyDocumentSchemes, builtinCanDisplayOnlyIfCanRequestSchemes, builtinCORSEnabledSchemes, //http;https &#125;; 白屏 通常 WKWebView 白屏的原因主要分两种，一种是由于 Web 的进程 Crash（多见于内部进程通信）；一种就是 WebView 渲染时的错误（Debug 一切正常只是没有对应的内容）。对于白屏的检测，前者在 iOS9 之后系统提供了对应 Crash 的回调函数，同时业界也有通过判断 URL/Title 是否为空的方式作为辅助；后者业界通过视图树对比，判断 SubView 是否包含 WKCompsitingView，以及通过随机点截图等方式作为白屏判断的依据。 其他 WKWebView 的系统级问题如 Cookie、POST 参数、异步 Javascript 等等一系列的问题，可以通过业务逻辑的调整重新适配。 由于 WebKit 源码等开放性，我们也可以利用私有方法来简化代码逻辑、实现复杂的产品需求。例如在 WKWebViewPrivate 中可以获得各种页面信息、直接取到 UserAgent、 在 WKBackForwardListPrivate 中可以清理掉全部的跳转历史、以及在 WKContentViewInteraction 中替换方法实现自定义的 MenuItem 等等。 12345678910@interface WKWebView (WKPrivate) @property (nonatomic, readonly) NSString *_userAgent WK_API_AVAILABLE(macosx(10.11), ios(9.0)); ... @interface WKBackForwardList (WKPrivate) - (void)_removeAllItems; ... @interface WKContentView (WKInteraction) - (BOOL)canPerformActionForWebView:(SEL)action withSender:(id)sender; 3、App 中的应用场景WKWebView 系统提供了四个用于加载渲染 Web 的函数。这四个函数从加载的类型上可以分为两类：加载 URL &amp; 加载 HTML\Data。所以基于此也延伸出两种不同的业务场景：加载 URL 的页面直出类和加载数据的模板渲染类，同时两种类型各自也有不同的优化重点及方向。 页面直出类12 // 根据 URL 直接展示 Web 页面- (nullable WKNavigation *)loadRequest:(NSURLRequest *)request; 通常各类 App 中的 Web 页面加载都是通过加载 URL 的方式，比如嵌入的运营活动页面、广告页面等等。 模板渲染类123// 根据模板 &amp; 数据渲染 Web 页面 - (nullable WKNavigation *)loadHTMLString:(NSString *)string baseURL:(nullable NSURL *)baseURL; ... 需要使用 WebView 展示，且交互逻辑较多的页面，最常见的就是资讯类 App 的内容展示页。 iOS 中 Web 与 Native 的通信单纯的使用 Web 容器加载页面已经不能满足复杂的功能，开发者希望数据可以在 Native 和 Web 之间通信传递来实现复杂的功能，而 Javascript 就是通信的媒介。对于有 WebView 的情况，虽然 WKWebView 提供了系统级的方法，但是大部分 App 仍然使用基于 URLScheme 的 WebViewBridge 用以兼容 UIWebView。而脱离了 WebView 容器，系统提供了 JavaScriptCore 的 framework，它也为之后蓬勃发展的跨平台和热修复技术提供了可能。 1. 基于 WebView 的通信基于 WebView 的通信主要有两个 途径，一个是通过系统或私有方法，获取 WebView 当中的 JSContext，使用系统封装的基于 JSCore 的函数通信。另一类就是通过创建自定义 Scheme 的 iframe Dom，客户端在回调中进行拦截实现。 UIWebView &amp; WKWebView 系统级在 UIWebView 时代没有提供系统级的函数进行 Web 与 Native 的交互，绝大部分 App 都是通过 WebViewJavascriptBridge（下节介绍）来进行的通信。但是由于 JavascriptCore 的存在，对于 UIWebView 来说只要有效的获取到内部的 JSContext，也可以达到目的。目前已知有效的几个私有方法获取 Context 的方法如下： 12345// 通过系统废弃函数获取 context - (void)webView:(WebView *)webView didCreateJavaScriptContext:(JSContext *)context forFrame:(WebFrame *)frame; // 通过 valueForKeyPath 获取 context self.jsContext = [_webView valueForKeyPath:@"documentView.webView.mainFrame.javaScriptContext"]; 在 WKWebView 中提供了系统级的 Web 和 Native 通讯机制，通过 Message Handler 的封装使开发效率有了很大的提升。同时系统封装了 JavaScript 对象和 Objective-C 对象的转换逻辑，也进降低了使用的门槛。 12345// js 端发送消息 window.webkit.messageHandlers.&#123;NAME&#125;.postMessage() //Native 在回调中接收 - (void)userContentController:(WKUserContentController *)userContentController didReceiveScriptMessage:(WKScriptMessage *)message; 拦截自定义 Scheme 请求 - WebViewJavascriptBridge由于私有方法的稳定性与审核风险，开发者不愿意使用上文提到的 UIWebView 获取 JSContext 的方式进行通信，所以通常都采用基于 iframe 和自定义 Scheme 的 JavascriptBridge 进行通信。虽然在之后的 WKWebView 提供了系统函数，但是大部分 App 都需要兼容 UIWebView 与 WKWebView，所以目前的使用范围仍然十分广泛。 在 Github 中类似的开源框架有很多，但是无外乎都是 Web 侧根据固定的格式创建包含通信信息的 Request，之后创建隐式 iFrame 节点请求；Native 侧在相应的 WebView 回调中解析 Request 的 Scheme，之后按照格式解析数据并处理。 而对于数据传递和回调处理的问题，在兼容两种 WebView、持续的更新的 WebViewJavascriptBridge 中，iFrame request 没有直接传递数据，而是 Web 和 Native 侧维护共同的参数或回调 Queue，Native 通过 Request 中 Scheme 的解析触发对 Queue 里数据的读取。 脱离 WebView 的通信 JavaScriptCoreJavascriptCoreJavascriptCore 一直作为 WebKit 中内置的 JS 引擎使用，在 iOS7 之后，Apple 对原有的 C/C++ 代码进行了 OC 的封装，成系统级的 framework 供开发者使用。作为一个引擎来讲，JavascriptCore 的词法、语法分析，以及多层次的 JIT 编译技术都是值得深入挖掘和学习的方向，由于篇幅的限制暂且不做深入的讨论。 JavascriptCore.framework虽然 JavascriptCore.framework 只暴露了较少的头文件和系统函数，但却提供了在 App 中脱离 WebView 执行 Javascript 的环境和能力。 JSVirtualMachine：提供了 JS 执行的底层资源及内存。虽然 Java 与 Javascript 没有一点关系，但是同样作为虚拟机，JSVM 和 JVM 做了一部分类似的事情。每个 JSVirtualMachine 独占线程，拥有独立的空间和管理，但是可以包含多个 JSContext。JSContext：提供了 JS 运行的上下文环境和接口。可以不准确的理解为，就是创建了一个 Javascript 中的 Window 对象。JSValue：提供了 OC 和 JS 间数据类型的封装和转换 Type Conversions。除了基本的数据类型，需要注意 OC 中的 Block 转换为 JS 中的 function，Class 转换为 Constructor 等等。 JSManagedValue：Javascript 使用 GC 机制管理内存，而 OC 采用引用计数的方式管理内存。所以在 JavascriptCore 使用过程中，难免会遇到循环引用以及提前释放的问题。JSManagedValue 解决了在两种环境中的内存管理问题。JSExport：提供了类、属性和实例方法的调用接口。内部实现是在 ProtoType &amp; Constructor 中实现对应的属性和方法。 使用 JavascriptCore 进行通信Native - Web: 通过 JavascriptCore，Native 可以直接在 Context 中执行 JS 语句，和 Web 侧进行通信和交互。 1JSValue *value = [self.jsContext evaluateScript:@"document.cookie"]; Web - Native: 对于 Web 侧向 Native 的通信，JavascriptCore 提供 两种 方式，注册 Block &amp; Export 协议。 1234567891011121314151617//Native self.jsContext[@"addMethod"] = ^ NSInteger(NSInteger a, NSInteger b) &#123; return a + b; &#125;; //JS console.log(addMethod(1, 2)); //3 //Native @protocol testJSExportProtocol &lt;JSExport&gt; @property (readonly) NSString *string; ... @interface OCClass : NSObject &lt;testJSExportProtocol&gt; //JS var OCClass = new OCClass(); console.log(OCClass.string); 对于 JavascriptCore 粗浅的理解，可以认为使用 Block 方法，内部是将 Block 保存到保存到一个 Web 环境中的全局的 Object 中，例如 window。而使用 JSExport 方法，则是在 Web 环境中 Object 的 prototype 中创建属性、实例方法；在 constructor 对象中创建类方法，从而实现 Web 中的调用。 App 中的应用场景对于基于 WebView 的通信，主要用于 App 向 H5 页面中注入的 Javascript Open Api，如提供 Native 的拍照、音视频、定位；以及 App 内的登录、分享等等功能。对于 JavaScriptCore，则催生了动态化、跨平台以及热修复等一系列技术的蓬勃发展。 跨平台与热修复近几年来国内外移动端各种方案如雨后春笋般涌现，“Write once, run anywhere”不再是开发者的向往。剥离跨平台技术在 Web 侧 DSL、virtualDom 等方面的优化，以及 Native 侧 Runtime 的应用与封装，对于两端通信的核心，依然是 JavascriptCore。 而不同于国外开发者对跨平台技术的积极探索，国内开发者也对热修复技术产生了极大的热情。同样作为 Native 和 Web 的交叉 - JavascriptCore，依然承担着整个技术结构中的通信任务。 1. 基于 Web 的热修复技术对于国内的 iOS 开发者来说，审核周期、敏感业务、支付分成以及 bug 修复都催生了热修复方向的不断探索。在苹果加强审核之前，几乎所有大型的 App 都把热修复当成了 iOS 开发的基础能力，最近在《移动开发还有救么》中也详细的介绍了相关黑科技的前世今生。在所有 iOS 热修复的方案中，基于 Javascript、同时也是影响最大的就是 JSPatch。 基于上文的分析，对于脱离 WebView 的 Native 和 Web 间的通信，我们只能使用 JavascriptCore。而在 JavascriptCore 中提供了两种方式用于通信，即 Context 注册 Block 的回调，以及 JSExport。对于热修复的场景来说，我们不可能把潜在需要修复的函数都一一使用协议进行注册，更不能对新增方法和删除方法等进行处理，所以在 Native 和 Web 通信这个维度，我们只能采用 Context 注册 Block 的方式。 确定了通信采用 Block 回调的方式后，热修复就面临着如何在 JS 中调用类以及类的方法问题。由于没有使用 JSExport 等方式，JS 是无法找到相应类等属性和方法，在 JSPathc 中，通过简单的字符串替换，将所有方法都替换成通用函数（__c），然后就可以将相关信息传递给 Native，进而使用 runtime 接口调用方法。 123456789101112// 替换全部方法调用 static NSString *_replaceStr = @".__c(\"$1\")("; // 调用方法 __c: function(methodName) &#123; ... return function()&#123; ... var ret = instance ? _OC_callI(instance, selectorName, args, isSuper): _OC_callC(clsName, selectorName, args) return _formatOCToJS(ret) &#125; 当然对于 JSPatch 以及其他热修复的项目来说，Web 和 Native 通信只是整个框架中的一个技术点，更多的实现原理和细节由于篇幅的关系暂且不做介绍。 2. 基于 Web 的跨平台技术随着 Google 开源了基于 Dart 语言的 Flutter，跨平台的技术又进入了一个新的发展阶段。对于传统的跨平台技术来讲，各个公司以 JavascriptCore 作为通信桥梁，围绕着 DSL 的解析、方法表的注册、模块注册通信、参数传递的设计以及 OC Runtime 的运用等不同方向，封装成了一个又一个跨平台的项目。 而在其中，以 Javascript 作为前端 DSL 的跨平台技术方案里，FaceBook 的 react-native 以及阿里 (目前托管给了 Apache) 的 Weex 最为流行。在网络上两者的比较文章有很多，集中在学习成本、框架生态、代码侵入、性能以及包大小等, 各个业务可以根据自己的重点选择合理的技术结构。 而不管是 react-native 还是 Weex,Web 和 Native 的通信桥梁仍然是 JavascriptCore。 123456//weex 举例JSValue* (^callNativeBlock)(JSValue *, JSValue *, JSValue *) = ^JSValue*(JSValue *instance, JSValue *tasks, JSValue *callback)&#123; ... return [JSValue valueWithInt32:(int32_t)callNative(instanceId, tasksArray, callbackId) inContext:[JSContext currentContext]];&#125;;_jsContext[@"callNative"] = callNativeBlock; iOS 中 Web 相关优化策略随着 Web 技术的不断升级以及 App 动态性业务需求的增多，越来越多的 Web 页面加入到了 iOS App 当中。与之对应的，首屏展示速度——这个对于移动客户端 Web 的最重要体验优化，也成为了移动客户端中 Web 业务最重要的优化方向。 这一章节更为详细的设计与实现，请移步 iOS 新闻类 App 内容页技术探索 (https://dequan1331.github.io/hybrid-page-kit.html)。 1. 不同业务场景的优化策略对于单纯的 Web 页面来说，业界早已有了合理的优化方向以及成熟的优化方案，而对于移动客户端中的 Web 来说，开发者在进行单一的 Web 优化同时，还可以通过优化 Web 容器以及 Web 页面中数据加载方式等多个途径做出优化。 所以对于 iOS 开发中的优化来说，就是通过 Native 和 Web 两个维度的优化关键渲染路径，保证 WebView 优先渲染完毕。由此我们梳理了常规 Web 页面整体的加载顺序，从中找出关键渲染路径，继而逐个分析、优化。 2. Web 维度的优化通用 Web 优化对于 Web 的通用优化方案，一般来说在网络层面，可以通过 DNS 和 CDN 技术减少网络延迟、通过各种 HTTP 缓存技术减少网络请求次数、通过资源压缩和合并减少请求内容等。在渲染层面可以通过精简和优化业务代码、按需加载、防止阻塞、调整加载顺序优化等等。对于这个老生常谈的问题，业内已经有十分成熟和完整的总结，例如《Best Practices for Speeding Up Your Web Site》，已经有了很好的整理和总结。 其他脱离较为通用的优化，在对代码侵入宽容度较高的场景中，开发者对 Web 优化有着更为激进的做法。例如在 VasSonic 中，除了 Web 容器复用、数据模板分离、预拉取和通用的优化方式外，还通过自定义 VasSonic 标签将 HTML 页面进行划分，分段进行缓存控制，以达到更高的优化效果。 3. Native 维度的优化容器复用和预热WKWebView 虽然 JIT 大幅优化了 JS 的执行速度，但是单纯的加载渲染 HTML，WKWebView 比 UIWebView 慢了很多。根据渲染的不同阶段分别对耗时进行测试，同时对比 UIWebView，我们发现 WKWebView 在初始化及渲染开始前的耗时较多。 针对这种情况，业界主流的做法就是复用 &amp; 预热。预热即时在 App 启动时创建一个 WKWebView，使其内部部分逻辑预热已提升加载速度。而复用又分为两种，较为复杂的是处理边界条件已达到真正的复用，还有一种较为 Triky 的办法就是常驻一个空 WKWebView 在内存。 HybridPageKit 提供了易于集成的完整 WKWebView 重用机制实现, 开发者可以无需关注复用细节，无缝的体验更为高效的 WKWebView。 Native 并行资源请求 &amp; 离线包由于 Web 页面内请求流程不可控以及网络环境的影响，对于 Web 的加载来说，网络请求一直是优化的重点。开发者较为常用的做法是使用 Native 并行代理数据请求，替代 Web 内核的资源加载。在客户端初始化页面的同时，并行开始网络请求数据；当 Web 页面渲染时向 Native 获取其代理请求的数据。 而将并行加载和预加载做到极致的优化，就是离线包的使用。将常用的需要下载资源（HTML 模板、JS 文件、CSS 文件、占位图片）打包，App 选择合适的时机全部下载到本地，当 Web 页面渲染时向 Native 获取其数据。 通过离线包的使用，Web 页面可以并行（提前）加载页面资源，同时摆脱了网络的影响，提高了页面的加载速度和成功率。当然离线包作为资源动态更新的一个方式，合理的下载时机、增量更新、加密和校验等方面都是需要进行设计和思考的方向，后文会简单介绍。 复杂 Dom 节点 Native 化实现当并行请求资源，客户端代理数据请求的技术方案逐渐成熟时，由于 WKWebView 的限制，开发者不得不面对业务调整和适配。其中保留原有代理逻辑、采用 LocalServer 的方式最为普遍。但是由于 WKWebView 的进程间通信、LocalServer Socket 建立与连接、资源的重复编解码都影响了代理请求的效率。 所以对于一些资讯类 App，通常采用 Dom 节点占位、Native 渲染实现的方式进行优化，如图片、地图、音视频等模块。这样不但能减少通信和请求的建立、提供更加友好的交互、也能并行的进行 View 的渲染和处理，同时减少 Web 页面的业务逻辑。 HybridPageKit 中就提供封装好的功能框架，开发者可以简单的替换 Dom 节点为 NativeView。 按优先级划分业务逻辑从 App 的维度上看，一个 Web 页面从入口点击到渲染完成，或多或少都会有 Native 的业务逻辑并行执行。所以这个角度的优化关键渲染路径，就是优先保证 WebView 以及其他在首屏直接展示的 Native 模块优先渲染。所以承载 Web 页面的 Native 容器，可以根据业务逻辑的优先级，在保证 WebView 模块展示之后，选择合适的时机进行数据加载、视图渲染等。这样就能保证在 Native 的维度上，关键路径优先渲染。 4. 优化整体流程所以整体上对于客户端来说，我们可以从 Native 维度（容器和数据加载）以及 Web 维度两个方向提升加载速度，按照页面的加载流程，整体的优化方向如下： iOS 中 Web 相关延伸业务1. 模板引擎为了达到并行加载数据以及并行处理复杂的展示逻辑，对于非直出类型的 Web 页面，绝大部分 App 都采用数据和模板分离下发的方式。而这样的技术架构，导致在客户端内需要增加替换对应 DSL 的模板标签，形成最终的 HTML 的业务逻辑。简单的字符串替换逻辑不但低效，还无法做到合理的组件化管理，以及组件合理的与 Native 交互，而模板引擎相关技术会使这种逻辑和表现分离的业务场景实现的更加简洁和优雅。 基于模板引擎与数据分离，客户端可以根据数据并行创建子业务模块，同时在子业务模块中处理和 Native 交互的部分如图片裁剪适配、点击跳转等等，生成 HTML 代码片段。之后基于模板进行替换生成完整的页面。这样不但减少了大量的字符串替换逻辑，同时业务也得到了合理拆分。 模板引擎的本质就是字符串的解析和替换拼接。在 Web 端不同的使用场景有很多不同语法的引擎类型，而在客户端较为流行的，有使用较为复杂的 MGTemplateEngine，它类似于 Smarty，支持部分模板逻辑。也有基于 mustache，Logic-less 的 GRMustache 可供选择。 2. 资源动态更新和管理无论是离线包、本地注入的 JS、CSS 文件、以及本地化 Web 中的默认图片，目的都是通过提前下载，替换网络请求为本地读取来优化 Web 的加载体验和成功率。而对于这些资源的管理，开发者需要从下载与更新，以及 Web 中的访问这两个方面进行设计优化。 下载与更新下载与重试：对于资源或是离线包的下载，选择合适的时机、失败重载时机、失败重载次数都要根据业务灵活调整。通常为了增加成功率和及时更新，在冷启动、前后台切换、关键的操作节点，或者采用定时轮循的方式，都需要进行资源版本号或 MD5 的判断，用以触发下载逻辑。当然对于服务端来说，合理的灰度控制，也是保证业务稳定的重要途径。 签名校验：对于动态下载的资源，我们都需要将原文件的签名进行校验，防止在传输过程中被篡改。对于单项加密的办法就是双端对数据进行 MD5 的加密，之后客户端校验 MD5 是否符合预期；而双向加密可以采用 DES 等加密算法，客户端使用公钥对资源验证使用。 增量更新：为了减少资源和离线包的重复下载，业内大部分使用离线包的场景都采用了增量更新的方式。即客户端在触发请求资源时，带上本地已存在资源的标示，服务端根据标示和最新资源做对比，之后只提供新增或修改的 Patch 供客户端下载。 基于 LocalServer 的访问在完成资源的下载与更新后，如何将 Web 请求重定向到本地，大部分 App 都依赖于 NSURLProtocol。上文提到在 WKWebView 中虽然可以使用私有函数实现（或者 iOS11+ 提供系统函数），但是仍然有许多问题。 目前业界一部分 App，都采用了集成 LocalServer 的方式，接管部分 Web 请求，从而达到访问本地资源的目的。同时集成了 LocalServer，通过将本地资源封装成 Response，利用 HTTP 的缓存技术，进一步的优化了读取的时间和性能，实现层次化的缓存结构。而使用了本地资源的 HTTP 缓存，就需要考虑缓存的控制和过期时间。通常可以通过在 URL 上增加本地文件的修改时间、或本地文件的 MD5 来确保缓存的有效性。 GCDWebServer 浅析排除 Socket 类型，业界流行的 Objc 版针对 HTTP 开源的 WebServer，不外乎年久失修的 CocoaHTTPServer 以及 GCDWebServer。GCDWebServer 是一个基于 GCD 的轻量级服务器，简单的四个模块 - Server / Connection / Request / Reponse，以及通过维护 LIFO 的 Handler 队列传入业务逻辑生成响应。在排除了基于 RFC 的 Request/Response 协议设计之外，关键的代码和流程如下： 12345678910111213141516171819//GCDWebServer 端口绑定 bind(listeningSocket, address, length) listen(listeningSocket, (int)maxPendingConnections) //GCDWebServer 绑定 Socket 端口并接收数据源 dispatch_source_t source = dispatch_source_create(DISPATCH_SOURCE_TYPE_READ, listeningSocket, 0, dispatch_get_global_queue(_dispatchQueuePriority, 0)); //GCDWebServer 接收数据并创建 Connection dispatch_source_set_event_handler(source, ^&#123; ... GCDWebServerConnection* connection = [(GCDWebServerConnection*)[self-&gt;_connectionClass alloc] initWithServer:self localAddress:localAddress remoteAddress:remoteAddress socket:socket]; //GCDWebServerConnection 读取数据 dispatch_read(_socket, length, dispatch_get_global_queue(_server.dispatchQueuePriority, 0), ^(dispatch_data_t buffer, int error) &#123; //GCDWebServerConnection 处理 GCDWebServerMatchBlock 和 GCDWebServerAsyncProcessBlock self-&gt;_request = self-&gt;_handler.matchBlock(requestMethod, requestURL, requestHeaders, requestPath, requestQuery); ... _handler.asyncProcessBlock(request, [completion copy]); 在 LocalServer 的使用上，也要注意端口的选择 ports used by Apple，以及前后台切换时 suspendInBackground 的设置和业务处理。 3.Javascript Open Api随着 App 业务的不断发展，单纯的 Web 加载与渲染无法满足复杂的交互逻辑，如拍照、音视频、蓝牙、定位等，同时 App 内也需要统一的登录态，统一的分享逻辑以及支付逻辑等。所以针对第三方的 Web 页面，Native 需要注册相应的 Javascript 接口供 Web 使用。 对于 Api 需要提供的能力、接口设计和文档规范，不同的业务逻辑和团队代码风格会有不同的定义，微信 JS-SDK 说明文档 就是一个很好的例子。而脱离 Javascript Open Api 对外的接口设计和封装，在内部的实现上也有一些通用的关键因素，这里简单列举几个： 注入方式和时机对于 Javascript 文件的注入，最简单的就是将 JS 文件打包到项目中，使用 WKWebView 提供的系统函数进行注入。这种方式无需网络加载，可以合理的选择注入时机，但是无法动态的进行修改和调整。而对于这部分业务需求需要经常调整的 App 来说，也可以把文件存储到 CDN，通过模板替换或者和 Web 合作者约定，在 Web 的 HTML 中通过 URL 的方式进行加载，这种的方式虽然动态化程度较高，但是需要合作方的配合，同时对于 JS Api 也不能做到拆分的注入。 针对上面的两种方式的优点不足，一个较为合理的方式是 Javascript 文件采用本地注入的方式，同时建立资源的动态更新系统（上文）。这样一方面支持了动态更新，同时也无需合作方的配合，对于不同的业务场景也可以拆分不同的 Api 进行注入，保证安全。 安全控制对于 Javascript Open Api 设计实现的另一个重要方面，就是安全性的控制。由于完整的 Api 需要支持 Native 登录、Cookies 等较为敏感的信息获取，同时也支持一些对 UI 和体验影响较多的功能如页面跳转、分享等，所以 App 需要一套权限分级的逻辑控制 Web 相关的接口调用，保证体验和安全。 常规的做法就是对 Javascript Open Api 建立分级的管理，不同权限的 Web 页面只能调用各自权限内的接口。客户端通过 Domain 进行分级，同时支持动态拉取权限 Domain 白名单，灵活的配置 Web 页面的权限。在此基础上 App 内部也可以通过业务逻辑的划分，在 Native 层面使用不同的容器加载页面，而容器根据业务逻辑的不同，注入不同的 JS 文件进行 Api 权限控制。 参考https://github.com/dequan1331/HybridPageKit]]></content>
      <categories>
        <category>Ios</category>
      </categories>
      <tags>
        <tag>Ios</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android Jetpack架构组件介绍]]></title>
    <url>%2F2019%2F03%2F24%2FAndroid-Jetpack%E6%9E%B6%E6%9E%84%E7%BB%84%E4%BB%B6%E4%BB%8B%E7%BB%8D%2F</url>
    <content type="text"><![CDATA[前言Google 为了帮助 Android 开发者更快更好地开发 App，推出了一系列组件，这些组件被打包成了一个整体，称作Android Jetpack，它包含的组件如下图所示： 老的 support 包被整合进了 Jetpack，例如上图 Foundation 模块的 AppCompat，整合进去之后，包名做了一下修改，全部以 androidx 开头。Android Studio 提供的迁移工具（Refactor &gt; Migrate to AndroidX）可以将源码中的旧包名替换成新的，但是如果 Maven 依赖的产物还未迁移到 AndroidX的话，还需要配置一个工具—— Jetifier，只需要在 build.gradle 中加上两行配置即可： 12android.useAndroidX=trueandroid.enableJetifier=true Jetfier 会在编译阶段直接修改依赖产物的字节码，简单粗暴。 架构大图Jetpack 不属于 Android Framework，不是 Android 开发的必需品，它只是应用层开发的一种辅助手段，帮我们解决了一些常见问题，比如版本兼容、API 易用性、生命周期管理等。其中 Architecture 部分的组件（Android Architecture Components，以下简称 AAC）组合起来形成了一套完整的架构解决方案，在没有更好的方案被发明出来之前，我们姑且把 AAC 当做 Android 架构领域的最佳实践，它的出现一定程度上避免了很多不必要的轮子。 官方给出的架构指导非常明确地表达出了每个架构组件的位置： 这张图背后隐含了三大设计思想： 关注点分离（SOC / Separation Of Concerns） 数据驱动UI（Reactive） 唯一真相源（SSOC / Single Source Of Truth） SOC 具体到工程实践中就是分层合理，单层的职责越明确，对上下游的依赖越清晰就意味着它的结构更稳定，也更可测（testable）。一个 App 从全局来看，可以划分为三部分：首先是 UI Controller 层，包含 Activity 和 Fragment；其次是 ViewModel 层，既可以做 MVVM 的 VM、MVP 的 P，也可以做 UI 的数据适配，这一层可以实现数据驱动 UI；最后是 Repository 层，它作为 SSOC，是一个 Facade 模式，对上层屏蔽了数据的来源，可以来自 local，也是来自 remote，数据持久化策略向上透明。 一张架构蓝图，三大设计原则，接下来深入细节，看看组件之间如何配合才能实现这个架构。 Lifecycle与 React/Vue 或者 iOS 相比，Android 的生命周期都比较复杂，如果要监听生命周期，一般情况下只能覆写 Activity / Fragment 的回调方法（onCreate、onResume、onPause、onDestroy 等），样板代码少不了，可维护性也变差。 如果要对生命周期进行简化，可以抽象成一个图，点表示状态，线表示事件： Lifecycle 负责处理这些点（states）和线（events），Activity / Fragment 是 LifecycleOwner，监听者则是 LifecycleObserver，一个非常清晰的观察者模式。 123456789101112class MyObserver : LifecycleObserver &#123; @OnLifecycleEvent(Lifecycle.Event.ON_RESUME) fun connectListener() &#123; ... &#125; @OnLifecycleEvent(Lifecycle.Event.ON_PAUSE) fun disconnectListener() &#123; ... &#125;&#125; 如果我们的组件需要强绑定声明周期，那么只需要借助 Lifecycle 去监听生命周期的状态和事件即可，再也不用覆写各种回调方法了。下面将要讲到的 LiveData 和 ViewModel 都是 Lifecycle-Aware Components，它们都用到了 Lifecycle。 Android 生命周期管理不当带来的最大问题就是内存泄露，举一个我们经常遇到的场景：一个异步任务（比如网络请求）持有了 UI 元素的引用，只要任务没有执行完，所有与这个 UI 元素有强引用关系的元素都没法被 GC，如果这样的场景多发生几次，很可能会引起 OOM。 为了异步对象引用的问题，最早我们使用 AsyncTask，任务执行在 worker thread，执行结果在主线程上发起回调。AsyncTask 的致命缺点是不支持流式数据（stream），而且回调嵌套太深（callback hell），与软件质量衡量指标之一的 maintainable 背道而驰，不好用自然就会慢慢被淘汰。 后来我们开始使用 RxJava，响应式编程，声明式写法，再借助 retrolambda 这种 backport，即使当年 Android 只支持到 JDK7，我们依然可以利用各种 operator 写出非常简洁的代码，“filter map 我闭~着眼”。RxJava 不但完美解决了线程调度的问题，还为我们提供了 OO 之外的抽象——作用在流上的 lambda，基于函数的抽象。但是，即便完美如斯，生命周期的问题依然无法回避，因为 Java 天生的局限性，一个 lambda 无论伪造地再像高阶函数，它本质上还是一个匿名内部类，这个匿名内部类依然持有对 outer class 实例的引用。于是我们必须通过 CompositeDisposable 来管理订阅关系，发起异步操作时记录订阅，离开页面时取消订阅，仍然需要覆写 onDestory 或者 onPause 。 如果我们以 Repository 层为界把架构蓝图分为上下两部分的话，上面的部分是数据展示，下面的部分是数据获取，数据获取部分因为要请求 Remote 数据，必然会依赖到线程调度，而数据展示必然运行在 UI 线程，与生命周期强相关，这个时候就需要 LiveData 登场了。 LiveDataLiveData 也是一个观察者模型，但是它是一个与 Lifecycle 绑定了的 Subject，也就是说，只有当 UI 组件处于 ACTIVE 状态时，它的 Observer 才能收到消息，否则会自动切断订阅关系，不用再像 RxJava 那样通过 CompositeDisposable 来手动处理。 LiveData 的数据类似 EventBus 的 sticky event，不会被消费掉，只要有数据，它的 observer 就会收到通知。如果我们要把 LiveData 用作事件总线，还需要做一些定制，Github 上搜 SingleLiveEvent 可以找到源码实现。 我们没法直接修改 LiveData 的 value，因为它是不可变的（immutable），可变（mutable）版本是 MutableLiveData，通过调用 setValue（主线程）或 postValue（非主线程）可以修改它的 value。如果我们对外暴露一个 LiveData，但是不希望外部可以改变它的值，可以用如下技巧实现： 12private val _waveCode = MutableLiveData&lt;String&gt;()val waveCode: LiveData&lt;String&gt; = _waveCode 内部用 MutableLiveData ，可以修改值，对外暴露成 LiveData 类型，只能获取值，不能修改值 LiveData 有一个实现了中介者模式的子类 —— MediatorLiveData，它可以把多个 LiveData 整合成一个，只要任何一个 LiveData 有数据变化，它的观察者就会收到消息： 123456val liveData1 = ...val liveData2 = ...val liveDataMerger = MediatorLiveData&lt;&gt;();liveDataMerger.addSource(liveData1) &#123; value -&gt; liveDataMerger.setValue(value))liveDataMerger.addSource(liveData2) &#123; value -&gt; liveDataMerger.setValue(value)) 综上，我们汇总一下 LiveData 的使用场景： LiveData - immutable 版本 MutableLiveData - mutable 版本 MediatorLiveData - 可汇总多个数据源 SingleLiveEvent - 事件总线 LiveData 只存储最新的数据，虽然用法类似 RxJava2 的 Flowable，但是它不支持背压（backpressure），所以不是一个流（stream），利用 LiveDataReactiveStreams 我们可以实现 Flowable 和 LiveData 的互换。 如果把异步获取到的数据封装成 Flowable，通过 toLiveData 方法转换成 LiveData，既利用了 RxJava 的线程模型，还消除了 Flowable 与 UI Controller 生命周期的耦合关系，借助 Data Binding 再把 LiveData 绑定到 xml UI 元素上，数据驱动 UI，妥妥的响应式。于是一幅如下模样的数据流向图就被勾勒了出来： 图中右上角的 Local Data 是 AAC 提供的另一个强大武器 —— ORM 框架 Room。 Room数据库作为数据持久层，其重要性不言而喻，当设备处于离线状态时，数据库可用于缓存数据；当多个 App 需要共享数据时，数据库可以作为数据源，但是基于原生 API 徒手写 CRUD 实在是痛苦，虽然 Github 上出现了不少 ORM 框架，但是它们的易用性也不敢让人恭维，直到 Room 出来之后，Android 程序员终于可以像 mybatis 那样轻松地操纵数据库了。 Room 是 SQLite 之上的应用抽象层，而 SQLite 是一个位于 Android Framework 层的内存型数据库。虽然 Realm 也是一个优秀的数据库，但是它并没有内置于 Android 系统，所会增大 apk 的体积，使用 Room 则没有这方面烦恼。 Room 的结构抽象得非常简单，数据对象（表名 + 字段）用 @Entity 注解来定义，数据访问用 @Dao 来注解，db 本身则用 @Database 来定义，如果要支持复杂类型，可以定义 @TypeConverters，然后在编译阶段，apt 会根据这些注解生成代码。Room 与 App 其他部分的交互如下图所示： Entity 是一个数据实体，表示一条记录，它的用法如下： 12345678@Entity(tableName = "actors")data class Actor( @PrimaryKey @ColumnInfo(name = "id") val actorId: String, val name: String, val birthday: Date?, val pictureUrl: String) Actor 是一个用 @Entity 注解的 data class，它会生成一个名字是 actors 的表，注意到有一个字段是 @Date? ，但是 SQLite 本身不支持这种复杂类型（complex type），所以我们还需要写一个可以转换成基础类型的转换器： 1234567class Converters &#123; @TypeConverter fun timestampToDate(value: Long?) = value?.let &#123; Date(it) &#125; @TypeConverter fun dateToTimestamp(date: Date?) = date?.time&#125; 转换器通过 @TypeConverters 可作用于 class、field、method、parameter，分别代表不同的作用域。比如作用在 @Database 类的上，那么它的作用域就是 db 中出现的所有 @Dao 和 @Entity。 12345@Database(entities = [Actor::class], version = 1, exportSchema = false)@TypeConverters(Converters::class)abstract class AppDatabase : RoomDatabase() &#123; abstract fun actorDao(): ActorDao&#125; @Query 中的 SQL 语句可以直接引用方法参数，而且它的返回值可以是 LiveData 类型，也支持 Flowable 类型，也就是说，Room 原生支持响应式，这是对数据驱动最有利的支持，也是 Room 区别于其他 ORM 框架的显著特征。 至此，我们可以确定，无论数据来自 Remote 还是来自本地 DB，架构蓝图中的 Repository 对 ViewModel 提供的数据可以永远是 LiveData 类型，接下来我们看一下 ViewModel 的妙用。 ViewModelViewModel 是一个多面手，因为它的生命周期比较长，可以跨越因为配置变动（configuration changed，比如屏幕翻转）引起的 Activity 重建，因此 ViewModel 不能持有对 Activity / Fragment 的引用。 如果 ViewModel 中要用到 context 怎么办呢？没关系，框架提供了一个 ViewModel 的子类 AndroidViewModel ，它在构造时需要传入 Application 实例。 既然 ViewModel 与 UI Controller 无关，当然可以用作 MVP 的 Presenter 层提供 LiveData 给 View 层，因为 LiveData 绑定了 Lifecycle，所以不存在内存泄露的问题。除此之外，ViewModel 也可以用做 MVVM 模式的 VM 层，利用 Data Binding 直接把 ViewModel 的 LiveData 属性绑定到 xml 元素上，xml 中声明式的写法避免了很多样板代码，数据驱动 UI 的最后一步，我们只需要关注数据的变化即可，UI 的状态会自动发生变化。 ViewModel 配合 Data Binding 的用法与 React 非常相似，ViewModel 实例相当于 state，xml 文件就好比 render 函数，只要 state 数据发生变化，render 就会重新渲染 UI，但是 data binding 还有更强大的一点，它支持双向绑定。举个例子，UI 需要展示一个评论框，允许展示评论，也允许用户修改，那么我们可以直接把 EditText 双向绑定到一个 LiveData 之上，只要用户有输入，我们就可以收到通知，完全不需要通过 Kotlin/Java 来操控 UI： 12&lt;TextInputEditText android:text="@=&#123;viewModel.commentText&#125;" /&gt; 注意，如果要在 xml 中使用 LiveData，需要把 lifecycle owner 赋给 binding： 123val binding: MainBinding = DataBindingUtil.setContentView(this, R.layout.main)// Specify the current activity as the lifecycle owner.binding.setLifecycleOwner(this) 因为 ViewModel 拿到的数据是 Repository 给的，可能不适用于 UI 元素，所以 ViewModel 还承担了数据适配的工作，有时候我们需要汇总 repository 的多个返回值一次性给到 UI，那么就可以使用 LiveData 的“操作符” Transformations.switchMap，用法可以认为等同于 Rx 的 flatMap；如果只想对 LiveData 的 value 做一些映射，可以使用 Transformations.map，目前 Transformations 只有这两个操作符，因为不管 Kotlin 还是 Java8，都提供了很多声明式的操作符，对流的支持都比较友好，而 LiveData本身不是一个流，所以这两个操作符足矣。 除了数据适配之外，ViewModel 还有一个强大的用法 —— Fragment 之间共享数据，这样 ViewModel 又扮演了 FLUX 模式中的 store 这一角色，是多个页面（fragment）之间唯一的数据出口。 ViewModel 的用法也非常简单，通过 ViewModelProviders.of 可以获取 ViewModel 实例： 12val viewModel = ViewModelProviders.of(requireActivity(), factory) .get(ActorViewModel::class.java) 一通操作猛如虎之后，UI controller 层变得薄如蝉翼，它只做了一件事情，把数据从左手（ViewModel）倒给了右手（使用了 Data Binding 的 xml）。 如果把 ViewModel 作为 SSOC（唯一真相源），多个 Fragment 之间共享数据，再利用 SingleLiveEvent 做总线，一个 Activity 配多个 Fragment 的写法就避免了 Activity 之间通过 Intent 传递数据的繁琐。但是 Fragment 的堆栈管理一直是一个让人头疼的问题，AAC 的 Navigation 不但完美解决了这个问题，而且还提供可视化的路由，只需拖拽一下就能生成类型安全的跳转逻辑。 NavigationNavigation 用一个图（graph）来表示页面间的路由关系，图的节点（node）表示页面，边（edge）表示跳转关系。例如下图 8 个页面的跳转关系，一目了然： 页面与页面之间的连线叫 action，它可以配置进离场动画（Animations），也可以配置出栈行为（Pop Behavior），还支持 Single Top 的启动选项（Launch Options）。进离场动画和启动选项很好理解，出栈行为是一个比较强大的功能，action 箭头所指的方向表示目标页面入栈，箭头的反方向则表示目标页面出栈，而出栈的行为在 Navigation 编辑器中完全可控，我们可以指定要出栈到哪个页面，甚至可以指定目标页面是否也需要出栈： 针对页面节点，还可以定义它要接收的参数（arguments），支持默认值，从此 Fragment 之间的参数传递变得非常直观，非常安全。 看一下具体用法，首先在跳转发起页面，通过 apt 生成的跳转函数传入参数： 123val actorId = getSelectedActorId()val direction = ActorListFragmentDirections.showDetail(actorId)findNavController().navigate(direction) 然后利用目标页面生成的 *Args 获取参数： 1然后利用目标页面生成的 *Args 获取参数： 这里的 navArgs 是一个扩展函数，利用了 Kotlin 的 ReadWriteProperty。 几行代码就搞定了页面之间的跳转，而且还是可视化！从没有想过 Android 的页面跳转竟会变得如何简单，但是 Navigation 的方案并不是原创，iOS 的 Storyboard 很早就支持拖拽生成路由。当年 Android 推出 ConstraintLayout 之时，我们都认为是参考了 Storyboard 的页面拖拽，现在再配上 Navigation，从页面到跳转，一个完整的拖拽链路就形成了。平台虽然有差异化，但是使用场景一致的前提下，解决方案也就殊途同归了。 了解完了与生命周期有关的组件，接下来我们来看细节。 PagingUI 没有办法一次性展示所有的数据，端上的系统资源（电量、内存）也有限制，不可能把所有数据都加载到内存中；而且大批量请求数据不但浪费带宽，在某些网络情况（弱网、慢网）下还会导致请求失败，所以分页是很多情景下的刚需。Github 上有各式各样的解决方案，这一次，Google 直接推出了官方的分页组件——Paging。 Paging 将分页逻辑拆解为三部分： 数据源 DataSource 数据块 PagedList 数据展示 PagedListAdapter DataSource 的数据来源于后端服务或者本地数据库，并且用三个子类来表示三种分页模式： PageKeyedDataSource - 单页数据以 page key 为标识，例如当前页的 Response 中包含了下一页的 url，这个 url 就是 page key。 ItemKeyedDataSource - 单页数据以 item key 为标识，比如下一页的请求要带当前页最后一个 item 的 id，这个 itemId 就是 item key。 PositionalDataSource - 单页数据以位置为标识，这种模式比较常见，Room 只支持这一种，因为数据库查询以 OFFSET 和 LIMIT 做分页。 PageKeyedDataSource 和 ItemKeyedDataSource 适用于内存型数据，比如直接从后端获取后需要展示的数据。PositionalDataSource 适用于本地 Room 数据或者使用 Room 做缓存的 Cache 数据。 数据流向的关系图如下所示： LivePagedListBuilder 利用 DataSource.Factory 和 PageList.Config 创建 LiveData，UI Controller 拿到数据之后交给 PagedListAdapter 展示到 RecyclerView。 上图表达了数据的流向，如果从 UI 层往回看，页面展示的数据存储在 PagedList 中，PagedList 只是 DataSource 的数据块（chunk），当 PagedList 需要更多数据时，DataSource 就会给更多，当 DataSource 一无所有时便会触发 BoundaryCallback 获取更多数据，直到数据全部展示完毕。 LivePagedListBuilder 会将 PagedList 包装成 LiveData&lt;PagedList&gt; 给到下游，它在整个数据交互链路中的位置如下图所示： Repository 拿到 Dao 的 DataSource.Factory 之后，调用它的 toLiveData 方法并传入 PagedList.Config，然后生成一个分页的 LiveData 交给 ViewModel 层。 Paging 加上生命周期相关的架构组件解决了数据存储、数据流转和数据展示的问题。除此之外，AAC 还包括一个强大的异步任务执行器 WorkManager，它解决了任务执行的 可靠性，无论 App 退出还是设备重启，交给 WorkerManager 的任务都会被执行。 WorkManagerWorkManager 虽然解决了任务执行可靠性的问题，但是它无法精确控制任务的执行时间，因为 WorkManager 要根据 OS 资源来选择执行任务。Android 自身提供了很多方案来解决后台任务执行的问题，可以根据下图的决策路径选择不同的组件： WorkManager 整体上可分为四部分：任务类型、任务构建、任务监控和任务控制。 一、任务类型WorkManager 提供了一次性任务和周期性任务两种任务类型： OneTimeWorkRequest —— 一次性任务 PeriodicTimeWorkRequest —— 周期性任务 二、任务构建一是执行条件，二是执行顺序。 Constraints —— 通过 Constraints.Builder构建任务执行的条件（网络类型、电量、设备空间等） WorkContinuation —— 可以指定任务的执行顺序，例如可以按照 PERT 图的顺序执行任务： 三、任务监控通过回调来获知任务的当前状态： 四、任务控制包括加入队列，取消任务，其中 UniqueWork 提供了多种加入队列的策略（REPLACE、KEEP、APPEND）： cancelWorkById(UUID) —— 通过 ID 取消单个任务 cancelAllWorkByTag(String) —— 通过 Tag 取消所有任务 cancelUniqueWork(String) —— 通过名字取消唯一任务 除此之外，WorkerManager 还提供了四种不同线程模型的 Worker： Worker —— 基于默认后台线程 CoroutineWorker —— 基于 Kotlin 的协程 RxWorker —— 基于 RxJava2 ListenableWorker —— 基于回调的异步 总结Google 官方架构组件 AAC 为我们提供了太多通用问题的解决方案，使用场景包括数据持久化、异步任务调度、生命周期管理，UI 分页、UI 导航，当然还有强大的 MVVM 框架 Data Binding，这些架构组件不但使代码变得清晰易读，而且独立于 Android SDK 向下兼容，AAC 使我们更加聚焦产品，专注于解决问题，而不是花太多的时间重复造轮子。 资料https://developer.android.google.cn/jetpack/androidx/migrate https://developer.android.google.cn/jetpack/ https://developer.android.google.cn/jetpack/docs/guide https://proandroiddev.com/advanced-data-binding-binding-to-livedata-one-and-two-way-binding-dae1cd68530f]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mysql优化小技巧]]></title>
    <url>%2F2019%2F03%2F24%2FMysql%E4%BC%98%E5%8C%96%E5%B0%8F%E6%8A%80%E5%B7%A7%2F</url>
    <content type="text"><![CDATA[程序嵌入SQL语句优化小技巧 1、比较运算符能用’=’就不用’&lt;&gt;’‘=’增加了索引的使用几率 2、明知只有一条查询结果，那请使用’LIMIT 1’‘LIMIT 1’可以避免全表扫描，找到对应结果就不会再继续扫描了 3、为列选择合适的数据类型能用TINYINT就不用SMALLLINT,能用SMALLINT就不用INT，内存消耗越小越好 4、将大的DELETE，UPDATE或者INSERT查询变成多个小查询为了达到更好的性能以及更好的数据控制，可以将它们变成多个小查询 5、如果结果集允许重复的话，使用UNION ALL代替UNION因为UNION ALL不去重复，效率高于UNION 6、为获得相同结果集的多次执行，请保持SQL语句前后一致目的是为了充分利用查询缓冲，比如根据地域或者产品id查询产品价格，第一次使用了1SELECT price FROM order WHERE id = 123456 and region = 'BEIJING'; 那么第二次同样的查询，请保持以上语句的一致性，比如不要将where语句里面的id和region位置调换顺序。 7、避免使用’SELECT *’如果不查询表中所有的列，尽量避免使用SELECT *，因为这样会进行全表扫描，不能有效利用索引，增大了数据库服务器的负担，以及它与应用程序客户端之间的网络IO开销。 8、WHERE子句里面的列尽量被索引只是’尽量’，并不是说所有的列。因地制宜，根据实际情况进行调整，索引太多也会降低性能。 9、JOIN子句里面的列尽量被索引同样只是’尽量’ 10、ORDER BY的列尽量被索引性能会更好 11、使用LIMIT实现分页逻辑提高性能，减少不必要数据库和应用的网络传输 12、使用EXPLAIN关键字去查看执行计划EXPLAIN可以检查索引使用情况以及扫描的行。 13、不要在MySQL中使用UTF-81.MySQL的“utf8mb4”是真正的“UTF-8”。2.MySQL的“utf8”是一种“专属的编码”，它能够编码的Unicode字符并不多。 使用“utf8”的MySQL和MariaDB用户都应该改用“utf8mb4”，永远都不要再使用“utf8”。 原理介绍：链接 moreSQL调优方法还有很多种，同样的查询结果可以有很多种查询方式，最好的方法就是测试！]]></content>
      <categories>
        <category>DBA</category>
      </categories>
      <tags>
        <tag>Mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS入门]]></title>
    <url>%2F2019%2F03%2F19%2FCSS%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[CSS入门学习Tool: Visual Studio Code 文中元素=标签 外链样式与内链样式外链1&lt;link rel="stylesheet" type="text/css" href="style/main.css"&gt; 内链123&lt;style type="text/css"&gt; ...&lt;/style&gt; 块元素与内联元素块元素概念：独占一行的元素，标签代表有div,p，h1~h6等等 div没有任何语义的标签，而在H5中新增了一些语义标签，具体请看另一片文章关于HTML5的新特性块元素主要作为页面的布局，一般情况块元素用来包含内联元素。p标签不可以包含其他任何块元素 实例证明:1234567891011121314151617&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;meta http-equiv="X-UA-Compatible" content="IE=edge"&gt; &lt;title&gt;Page Title&lt;/title&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1"&gt; &lt;link rel="stylesheet" type="text/css" media="screen" href="main.css"&gt; &lt;script src="main.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;p&gt; 哈哈哈 &lt;div&gt;哈哈&lt;/div&gt; &lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 浏览器上查看内容可以正常显示，但是检查浏览器元素的显示则解析成了 内联元素概念：只占自身内容大小的元素，标签代表有span,a等 a标签可以包含任何内联和块元素，但是除了它本身 实例证明:12345678910111213141516&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;meta http-equiv="X-UA-Compatible" content="IE=edge"&gt; &lt;title&gt;Page Title&lt;/title&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1"&gt; &lt;link rel="stylesheet" type="text/css" media="screen" href="main.css"&gt; &lt;script src="main.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;a href="#"&gt; &lt;a href="#"&gt;&lt;/a&gt; &lt;/a&gt;&lt;/body&gt;&lt;/html&gt; 检查浏览器元素的显示则解析成了 标签间的关系标签之间的关系： 父标签：直接包含子标签的标签 子标签：直接被父标签包含的标签 祖先标签：直接或间接包含后代标签的标签，父标签也是祖先标签 后代标签：直接或间接被祖先标签包含的标签，子标签也是后代标签 兄弟标签：拥有相同父标签的标签 选择器标签选择器12345678910111213141516171819&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style type="text/css"&gt; div &#123; width: 200px; height: 200px; color: red; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div&gt;我是一个div&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; ID选择器12345678910111213141516171819&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style type="text/css"&gt; #d1 &#123; width: 200px; height: 200px; color: red; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="d1"&gt;我是一个div&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 类选择器12345678910111213141516171819&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style type="text/css"&gt; .c1 &#123; width: 200px; height: 200px; color: red; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="c1"&gt;我是一个div&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 选择器分组（并集选择器）语法：选择器1，选择器2，选择器3{} 12345678910111213141516171819&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style type="text/css"&gt; .c1,p,span&#123; color: red; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="c1"&gt;我是一个div&lt;/div&gt; &lt;p&gt;我是一个段落&lt;/p&gt; &lt;span&gt;我是一个span&lt;/span&gt;&lt;/body&gt;&lt;/html&gt; 通配选择器语法：*{} 1234567891011121314151617181920&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style type="text/css"&gt; * &#123; padding: 0; margin: 0; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="c1"&gt;我是一个div&lt;/div&gt; &lt;p&gt;我是一个段落&lt;/p&gt; &lt;span&gt;我是一个span&lt;/span&gt;&lt;/body&gt;&lt;/html&gt; 这个一般用于适配每个浏览器的默认值。 ## 复合选择器（交集选择器) 语法：选择器1选择器2{} 后代选择器选中指定标签的指定后代标签 语法：祖先标签 后代标签 {} 1234567891011121314151617181920&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style type="text/css"&gt; #d1 p&#123; color: red; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="d1"&gt; &lt;p&gt;我是一个在div里的段落&lt;/p&gt; &lt;/div&gt; &lt;p&gt;我是一个段落&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 子代选择器选中父标签的指定子标签 语法：父标签 &gt; 子标签 {} 123456789101112131415161718192021&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style type="text/css"&gt; div &gt; p &gt; span&#123; color: red; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="d1"&gt; &lt;p&gt;我是一个在div里的段落&lt;span&gt;我是span&lt;/span&gt;&lt;/p&gt; &lt;span&gt;我也是span&lt;/span&gt; &lt;/div&gt; &lt;p&gt;我是一个段落&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 伪类选择器伪类：专门用来表示标签的一种特殊状态 hover和active可以被其他标签所使用，不仅只是用于a标签vistited伪类由于涉及到用户隐私问题，所以在该标签内仅仅只能设置color属性，其他设置也无效。也可能还有存在版本问题，IE6可以设置，其余基本测试失败。 1234567891011121314151617181920212223242526&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style type="text/css"&gt; a:link &#123; color: red; &#125; a:visited &#123; color: blue; &#125; a:hover &#123; color: yellow; &#125; a:active &#123; color: orange; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;a href="http://www.baidu.com"&gt;我是超链接&lt;/a&gt;&lt;/body&gt;&lt;/html&gt; 伪元素（伪标签）选择器表示元素中的一些特许位置 12345678910111213141516171819202122&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style type="text/css"&gt; p::first-letter &#123; color: red; &#125; p::first-line &#123; color: yellow; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;p&gt; 我是一个很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长的文字 &lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 属性选择器根据元素中的属性或者属性值来选指定元素。 语法： 标签[属性名]{} 有这个属性的 标签[属性名=”属性值”]{} 以属性为属性值的 标签^[属性名=”属性值”]{} 以属性的属性值为开头的 标签$[属性名=”属性值”]{} 以属性的属性值为结尾的 标签[属性名=”属性值”]{} 以属性的属性值为包含的 我是一个段落，title就是其中一个属性。 title就是一个属性 1234567891011121314151617181920212223&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style type="text/css"&gt; span[class] &#123; color: red; &#125; p[title="content"] &#123; color: orange; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;span class='hh'&gt;我是一个段落&lt;/span&gt; &lt;p title="content"&gt; 我是一个很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长的文字 &lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 结构伪类选择器:first-child {} 选中父元素中第一个子元素:last-child {} 选中父元素中最后一个子元素:nth-child(n) {} 选中父元素中正数第n个子元素:nth-last-child(n) {} 选中父元素中倒数第n个子元素:first-of-type {} 选中第一个元素:last-of-type {} 选中最后一个元素:nth-child(n) {} 选中第n个元素 1234567891011121314151617181920&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style type="text/css"&gt; p:first-child &#123; color: red; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;p&gt;哈哈&lt;/p&gt; &lt;p&gt;哈哈&lt;/p&gt; &lt;p&gt;哈哈&lt;/p&gt; &lt;p&gt;哈哈&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 紧邻同胞选择器选中一个元素后的指定兄弟元素。语法：兄弟元素前 + 兄弟元素后 {} 12345678910111213141516171819202122&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style type="text/css"&gt; p + span &#123; color: red; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;p&gt;哈哈&lt;/p&gt; &lt;p&gt;哈哈&lt;/p&gt; &lt;span&gt;我是兄弟&lt;/span&gt; &lt;p&gt;哈哈&lt;/p&gt; &lt;p&gt;哈哈&lt;/p&gt; &lt;span&gt;我是最后一个span&lt;/span&gt;&lt;/body&gt;&lt;/html&gt; 一般同胞选择器选中一个元素后的所有指定兄弟元素 语法：兄弟元素前 ~ 兄弟元素后 {} 1234567891011121314#r1:checked ~ .s1&#123; margin-left: 0;&#125;#r2:checked ~ .s1&#123; margin-left: -20%;&#125;#r3:checked ~ .s1&#123; margin-left: -40%;&#125;#r4:checked ~ .s1&#123; margin-left: -60%;&#125;#r5:checked ~ .s1&#123; margin-left: -80%; 否定伪类选择器可以从已经选中的元素中剔除某些元素 语法：选择器:not(选择器){} 12345678910111213141516171819202122&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style type="text/css"&gt; p:not(.c) &#123; color: red; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;p&gt;我是p&lt;/p&gt; &lt;p&gt;我是p&lt;/p&gt; &lt;p class="c"&gt;我是p&lt;/p&gt; &lt;p&gt;我是p&lt;/p&gt; &lt;p&gt;我是p&lt;/p&gt; &lt;p&gt;我是p&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 样式的继承祖先的元素会被他的后代所继承。可以利用继承的特性将一些基本的样式继承给祖先元素。但并不是所有样式都会被后代元素所继承。例如一些背景相关的样式，都不会被继承。 选择器的优先级使用不同选择器时，选中了同一个元素并设置了相同的样式，则优先级高的优先显示。 优先级规则(数值为参考值)： 内联样式 优先级 1000 ID选择器 优先级 100 类和伪类 优先级 10 元素选择器 优先级 1 通配选择器 优先级 0 继承样式 无优先级 当选择器有多种选择器时，先将优先级相加再进行比对选择器的优先级不会超过它的最大数量级(虽然很少这样写)如果选择器的优先级相同，谁在代码的位置靠后就用谁。并集选择器的优先级单独计算，并集每个选择器都是独立的。 特殊情况：在样式后添加一个!important，则该样式会获得最高优先级，甚至超过内联样式。(尽量避免使用，多人开发时比较麻烦) 伪类顺序关于a的伪类有四个,:link,:visited,hover,:active，这四个伪类优先级是一样的。 但是特殊情况:hover与:active这两种情况是相同的，都是会同时触发。由于优先级相等，所以看谁在代码后就使用谁。所以写伪类的顺序一般都是有规则的，最好习惯写为:link-&gt;:visited-&gt;:hover-&gt;:active 盒模型CSS 框模型 (Box Model) 规定了元素框处理元素内容、内边距、边框 和 外边距 的方式。 盒模型属性 一个盒子分成这么几个部分 内容部分 内边距 边框 外边距 他们都有各自的简写方式。盒子大小由内容区、内边距、边框共同决定。 内容区css中定义width与height定义的只是内容区的大小 边框元素的边框 (border) 是围绕元素内容和内边距的一条或多条线。CSS border 属性允许你规定元素边框的样式、宽度和颜色。 为元素设定边框必须设置三个属性:width,color,style。但是大部分浏览器都会有边框的默认值。 边框样式：border-style边框的宽度：border-width边框的颜色：border-color 12345678910111213141516171819202122&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;&lt;/title&gt; &lt;style type="text/css"&gt; .box &#123; width: 200px; height: 200px; border-width: 2px; border-color: yellow; border-style: solid; /*简写*/ border: 2px green solid; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="box"&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 内边距元素的内边距在边框和内容区之间。控制该区域最简单的属性是 padding 属性。CSS padding 属性定义元素边框与元素内容之间的空白区域。 padding属性接受长度值或者百分比值，但不允许使用负值。 h1 元素的各边都有 10 像素的内边距h1 {padding: 10px;} 也可以根据上、右、下、左顺序分别赋值h1 {padding: 10px 0.25em 2ex 20%;} 单边属性 padding-top padding-right padding-bottom padding-left 当宽度为auto（默认值）此时指定的内边距不会影响盒子的可见宽度，而是自动修复宽度而适应内边距。 外边距围绕在元素边框的空白区域是外边距。设置外边距会在元素外创建额外的“空白”。设置外边距的最简单的方法就是使用 margin 属性，这个属性接受任何长度单位、百分数值甚至负值。 margin 属性接受任何长度单位，可以是像素、英寸、毫米或 em。margin 可以设置为 auto。但是允许设置为负值。 auto值一般设置水平方向，可以用来设置居中。 用法基本和padding类似。 由于页面元素都是靠左上来进行布局，则设置左，上外边距时会影响自身盒子的位置，相反，设置右，下外边距时会影响其他盒子的位置。 外边距合并外边距合并指的是，当两个垂直外边距相遇时，它们将形成一个外边距。合并后的外边距的高度等于两个发生合并的外边距的高度中的较大者。 两种情况： 第一种：两边为兄弟相邻的元素时 123456789101112131415161718192021222324252627&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;&lt;/title&gt; &lt;style type="text/css"&gt; .box1 &#123; height: 200px; width: 200px; background-color: yellow; margin-bottom: 100px; &#125; .box2 &#123; height: 200px; width: 200px; background-color: green; margin-top: 200px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="box1"&gt;&lt;/div&gt; &lt;div class="box2"&gt;&lt;/div&gt; &lt;!-- 两盒盒子的margin仅仅只有200px，而不是300px，仅取决于最大的那个margin而不是相加的值 --&gt;&lt;/body&gt;&lt;/html&gt; 第二种：两边为父子关系的元素并某个边与边重叠时 1234567891011121314151617181920212223242526&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;&lt;/title&gt; &lt;style type="text/css"&gt; .box2 &#123; width: 200px; height: 100px; background-color: yellow; margin-top: 100px; &#125; .box &#123; width: 200px; height: 300px; background-color: green; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="box"&gt; &lt;div class="box2"&gt;&lt;/div&gt; &lt;!-- 结果会发现box2不是相对于box移动了100px，而是box往下移动了100px，原因是因为box和box2处于父子关系，它们的上边框进行了重叠导致的--&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 解决方式 1、使用padding，但是会影响盒子原来内容大小2、添加一个空的table标签3、使用:before伪类，添加一个display=table属性和属性值，原理与第二点相似，但是不会添加无意义的文档标签。 内联元素的盒模型内联元素无法设置width和height，其余基本和块元素的盒模型相似。 三步走：内容区、padding、margin、border display中的block、inline、inline-block、nonedisplay属性规定元素应该生成的框(盒模型)的类型。 说明 这个属性用于定义建立布局时元素生成的显示框类型。对于 HTML 等文档类型，如果使用 display 不谨慎会很危险，因为可能违反 HTML 中已经定义的显示层次结构。对于 XML，由于 XML 没有内置的这种层次结构，所有 display 是绝对必要的。 主要使用的值： 值 描述 none 此元素不会被显示 block 此元素将显示为块级元素，此元素前后会带有换行符 inline 默认。此元素会被显示为内联元素，元素前后没有换行符 inline-block 行内块元素（CSS2.1新增） 更多的值请参考链接 将一个div设置为内联元素：1234567891011121314151617181920&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;&lt;/title&gt; &lt;style type="text/css"&gt; .box &#123; width: 100px; height: 100px; background-color: yellow; display: inline; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="box"&gt;a&lt;/div&gt; &lt;!-- 会发现div的设置的宽度和高度设置无效，div已经变为内联元素 --&gt;&lt;/body&gt;&lt;/html&gt; box-sizingCSS 中的 box-sizing 属性定义了 user agent 应该如何计算一个元素的总宽度和总高度。可以更改用于计算元素宽度和高度的默认的 CSS 盒子模型。可以使用此属性来模拟不正确支持CSS盒子模型规范的浏览器的行为。 在 CSS 盒子模型的默认定义里，你对一个元素所设置的 width 与 height 只会应用到这个元素的内容区。如果这个元素有任何的 border 或 padding ，绘制到屏幕上时的盒子宽度和高度会加上设置的边框和内边距值。这意味着当你调整一个元素的宽度和高度时需要时刻注意到这个元素的边框和内边距。当我们实现响应式布局时，这个特点尤其烦人。 box-sizing 属性可以被用来调整这些表现: content-box是默认值。如果你设置一个元素的宽为100px，那么这个元素的内容区会有100px 宽，并且任何边框和内边距的宽度都会被增加到最后绘制出来的元素宽度中。 border-box告诉浏览器去理解你设置的边框和内边距的值是包含在width内的。也就是说，如果你将一个元素的width设为100px,那么这100px会包含其它的border和padding，内容区的实际宽度会是width减去border + padding的计算值。大多数情况下这使得我们更容易的去设定一个元素的宽高。 属性值 content-box默认值，标准盒子模型。 width 与 height 只包括内容的宽和高， 不包括边框（border），内边距（padding），外边距（margin）。注意: 内边距, 边框 &amp; 外边距 都在这个盒子的外部。 比如. 如果 .box {width: 350px}; 而且 {border: 10px solid black;} 那么在浏览器中的渲染的实际宽度将是370px; 尺寸计算公式：width = 内容的宽度height = 内容的高度宽度和高度的计算值都不包含内容的边框（border）和内边距（padding）。 border-boxwidth 和 height 属性包括内容，内边距和边框，但不包括外边距。这是当文档处于 Quirks模式 时Internet Explorer使用的盒模型。注意，填充和边框将在盒子内 , 例如, .box {width: 350px; border: 10px solid black;} 导致在浏览器中呈现的宽度为350px的盒子。内容框不能为负，并且被分配到0，使得不可能使用border-box使元素消失。 尺寸计算公式：width = border + padding + 内容的宽度height = border + padding + 内容的高度 padding-box[bad]width 和 height 属性包括内容和内边距，但是不包括边框和外边距。只有Firefox实现了这个值，它在Firefox 50中被删除。 visibility中的hidden、visiblevisibility 属性规定元素是否可见，可以被继承。 值 描述 visible 默认值，元素是可见的 hidden 元素是不可见的 collapse 当在表格元素中使用时，此值可删除一行或一列，但是它不会影响表格的布局。被行或列占据的空间会留给其他内容使用。如果此值被用在其他的元素上，会呈现为 “hidden”。 inherit 规定应该从父元素继承 visibility 属性的值。 使 h2 元素不可见： 1234h2 &#123; visibility:hidden; &#125; overflow解决溢出内容显示,overflow 属性规定当内容溢出元素框时发生的事情。 值 描述 visible 默认值。内容不会被修剪，会呈现在元素框之外。 hidden 内容会被修剪，并且其余内容是不可见的。 scroll 内容会被修剪，但是浏览器会显示滚动条以便查看其余的内容。 auto 如果内容被修剪，则浏览器会显示滚动条以便查看其余的内容。 inherit 规定应该从父元素继承 overflow 属性的值。 在一个狭小的div以滚动条的方式显示一段文本123456789101112131415161718192021&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;&lt;/title&gt; &lt;style type="text/css"&gt; .box &#123; width: 200px; height: 200px; overflow: auto; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="box"&gt; &lt;p&gt;上面这个操作有一些缺陷，不能序列化函数、undefined、循环引用等，详见传送门，但是也能应付一些日常情况了。事实上，在 Props 是引用类型时，单独修改对象、数组的某个属性或下标，Vue 并不会抛出错误。当然，前提是你要非常清楚自己在做什么，并写好注释，防止你的小伙伴们疑惑。有的同学可能知道，在组件上绑定的属性，如果没有在组件内部用 Props 声明，会默认绑定到组件的根元素上去。还是之前的栗子：。&lt;/p&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 文档流文档流出在网页最底层，它表示的是一个网页中的位置，我们所创建的元素默认都处于文档流中。原文是normal flow，至于为何翻译成文档流见仁见智。指语言文本从左到右，从上到下显示。但是浮动、绝对定位、固定定位这些都会导致脱离文档流。 浮动float 属性定义元素在哪个方向浮动。以往这个属性总应用于图像，使文本围绕在图像周围，不过在 CSS 中，任何元素都可以浮动。浮动元素会生成一个块级框，而不论它本身是何种元素。 如果浮动非替换元素，则要指定一个明确的宽度；否则，它们会尽可能地窄。 值 描述 left 元素向左浮动 right 元素向右浮动。 none 默认值。元素不浮动，并会显示在其在文本中出现的位置。 inherit 规定应该从父元素继承 float 属性的值。 设置浮动会脱离文档流，元素会尽量向父元素或者遇到其他元素的左上或者右上靠。如果浮动元素上边是一个块元素，则浮动元素不会浮动超过这个块元素。 浮动的元素不会盖住文字，会自动环绕在浮动元素周围。当块元素设置float脱离文档流后，宽和高则默认是变成被内容撑开。内联元素使用float脱离文档流后，会变成块元素。 清除浮动clear 属性规定元素的哪一侧不允许其他浮动元素。 clear 属性定义了元素的哪边上不允许出现浮动元素。在 CSS1 和 CSS2 中，这是通过自动为清除元素（即设置了 clear 属性的元素）增加上外边距实现的。在 CSS2.1 中，会在元素上外边距之上增加清除空间，而外边距本身并不改变。不论哪一种改变，最终结果都一样，如果声明为左边或右边清除，会使元素的上外边框边界刚好在该边上浮动元素的下外边距边界之下。 值 描述 left 在左侧不允许浮动元素。 right 在右侧不允许浮动元素。 both 在左右两侧均不允许浮动元素。 none 默认值。允许浮动元素出现在两侧。 inherit 规定应该从父元素继承 clear 属性的值。 both是清除影响对当前元素影响最大的元素对兄弟元素有效，父子是无效的。清除浮动clean属性，清除其他浮动元素对当前元素的影响 实例： 1234567891011121314151617181920212223242526272829&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;&lt;/title&gt; &lt;style type="text/css"&gt; .box1 &#123; width: 100px; height: 100px; background-color: yellow; float: right; &#125; .box2 &#123; width: 200px; height: 200px; background-color: blue; clear: right; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="box1"&gt;&lt;/div&gt; &lt;div class="box2"&gt;&lt;/div&gt; &lt;!-- 如果box2不设置clear，则box2的位置将被顶到box1的高度上，2⃣而设置了clear后，box2还在原来的位置 --&gt;&lt;/body&gt;&lt;/html&gt; 高度塌陷问题原因：在文档流中，父元素高度默认是由子元素的高度撑起来的，但是设置浮动后，子元素脱离了文档流，则导致了父元素的高度塌陷。 1234567891011121314151617181920212223242526272829&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;&lt;/title&gt; &lt;style type="text/css"&gt; .parent &#123; border: 2px red solid; &#125; .sun &#123; height: 200px; width: 100px; background-color: yellow; float: right; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="parent"&gt; &lt;div class="sun"&gt; &lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 解决方式一BFC:Block Formatting （IE6以下并不支持）Context，W3C标准中，页面中都有一个隐含的属性。默认是关闭的，当打开的时候，会出现以下特性： 父元素的垂直外边距不会与子元素重叠 开启BFC的元素不会被浮动元素所覆盖 开启BFC的元素可以包含浮动的子元素 如何开启BFC（无法直接开启） 设置元素浮动 开启元素绝对定位 设置元素的display的值为inline-block 设置元素的overflow的值为非visible的值（推荐hidden）【该方式最简单的方式，副作用最小】 兼容IE6 则可以使用相似于BFC的，成为hasLayout，开启方式则设置zoom:1即可。但是该方式仅支持IE8以下。如需完全兼容和其他浏览器，则设置两者同时设置。或者指定元素宽度。 解决方式二利用清除浮动，直接在高度塌陷的父元素的最后，添加一个空白的div，由于该元素没有浮动，所以它是可以撑开父元素的高度的，对其进行清除浮动，消除了上一个元素的浮动影响，即可撑起父元素的高度，且该方案兼容性比方案一更高，影响度最小。但是添加了一个毫无意义的div标签，可读性变差了。 1234567891011121314151617181920212223242526272829303132&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;&lt;/title&gt; &lt;style type="text/css"&gt; .parent &#123; border: 2px red solid; &#125; .sun &#123; height: 200px; width: 100px; background-color: yellow; float: right; &#125; .clearfix &#123; clear: both; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="parent"&gt; &lt;div class="sun"&gt;&lt;/div&gt; &lt;div class="clearfix"&gt;&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 解决方式三利用::after伪元素选择器。 ::after 选择器在被选元素的内容后面插入内容。请使用 content 属性来指定要插入的内容。 通过alter伪元素向元素添加一个空白的块元素，然后对其清除元素。和方式二的原理相同，但是该方式可读性更高。不会在html中添加毫无意义的空白标签。 12345678910111213141516171819202122232425262728293031323334353637&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;&lt;/title&gt; &lt;style type="text/css"&gt; .parent &#123; border: 2px red solid; &#125; .sun &#123; height: 200px; width: 100px; background-color: yellow; float: right; &#125; /*.clearfix &#123; clear: both; &#125;*/ .clearfix::after &#123; content: ""; clear: both; display: block; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="parent clearfix"&gt; &lt;div class="sun"&gt;&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; display的值可以为block，也可以为table。 标准模版 1234567891011.clearfix &#123; *zoom: 1;&#125; .clearfix::after &#123; content: ""; display: block; clear: both; visibility: hidden; height: 0; line-height: 0;&#125; 定位定位指的是将指定的元素摆放在页面中指定的位置，通过定位可以任意的摆放元素。 这个属性定义建立元素布局所用的定位机制。任何元素都可以定位，不过绝对或固定元素会生成一个块级框，而不论该元素本身是什么类型。相对定位元素会相对于它在正常流中的默认位置偏移。默认值static。元素的位置通过 “left”, “top”, “right” 以及 “bottom” 属性进行规定。 值 描述 absolute 生成绝对定位的元素，相对于 static 定位以外的第一个父元素进行定位。 fixed 生成绝对定位的元素，相对于浏览器窗口进行定位。 relative 生成相对定位的元素，相对于其正常位置进行定位。 static 默认值。没有定位，元素出现在正常的流中（忽略 top, bottom, left, right 或者 z-index 声明）。 inherit 规定应该从父元素继承 position 属性的值。 相对定位相对定位设置了，但不设置偏移量则也没有效果相对定位是相对于元素在文档流原来的位置进行定位相对定位不会脱离文档流相对定位会使得元素提升一个层级相对定位不会改变元素的性质，块元素依然是块元素。内联依然也依然是内联。 123456789101112131415161718192021222324252627282930313233&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;&lt;/title&gt; &lt;style type="text/css"&gt; .box1 &#123; width: 200px; height: 200px; background-color: yellow; &#125; .box2 &#123; width: 200px; height: 200px; background-color: green; position: relative; left: 100px; top: 100px; &#125; .box3 &#123; width: 200px; height: 200px; background-color: blue; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="box1"&gt;&lt;/div&gt; &lt;div class="box2"&gt;&lt;/div&gt; &lt;!-- 相对于原来box2的位置进行偏移向右100像素，向下100像素 --&gt; &lt;div class="box3"&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 绝对定位开启绝对定位会使元素脱离文档流绝对定位是相当于离它最近的开启了定位的祖先元素进行定位的如果所有的祖先元素都没有开启定位，则相对于浏览器窗口进行定位绝对定位会使得元素提升一个层级并改变元素的性质 如果祖先元素没有任何一个开启了定位，则是相对于浏览器窗口进行定位 12345678910111213141516171819202122232425262728293031323334353637383940&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;&lt;/title&gt; &lt;style type="text/css"&gt; .box1 &#123; width: 200px; height: 200px; background-color: yellow; &#125; .box2 &#123; width: 200px; height: 200px; background-color: green; &#125; .box3 &#123; width: 200px; height: 200px; background-color: blue; &#125; .box4 &#123; width: 100px; height: 100px; background-color: black; position: absolute; left: 0; top: 0; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="box1"&gt;&lt;/div&gt; &lt;div class="box2"&gt; &lt;div class="box4"&gt;&lt;/div&gt; &lt;!-- 祖先元素都没有开启定位，则box4的原点位置则是浏览器左上角 --&gt; &lt;/div&gt; &lt;div class="box3"&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 开启box2元素的定位，则box4原点的位置发生改变 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;&lt;/title&gt; &lt;style type="text/css"&gt; .box1 &#123; width: 200px; height: 200px; background-color: yellow; &#125; .box2 &#123; width: 200px; height: 200px; background-color: green; position: relative; &#125; .box3 &#123; width: 200px; height: 200px; background-color: blue; &#125; .box4 &#123; width: 100px; height: 100px; background-color: black; position: absolute; left: 0; top: 0; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="box1"&gt;&lt;/div&gt; &lt;div class="box2"&gt; &lt;div class="box4"&gt;&lt;/div&gt; &lt;!-- 最近的祖先元素box2开启了定位，则原点位置发生了改变，为box2块元素的左上角 --&gt; &lt;/div&gt; &lt;div class="box3"&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 一般情况自元素开启绝对定位，则父元素会开启相对定位 固定定位固定定位也是绝对定位的一种，大部分特点和绝对定位一样。但是它永远都相对于浏览器窗口进行定位，不管父元素到底有没有开启定位。而且只会固定在浏览器窗口的位置，不会因为其他因素（滚动条等）而改变元素位置。 1234567891011121314151617181920212223&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;&lt;/title&gt; &lt;style type="text/css"&gt; body &#123; height: 5000px; &#125; .box &#123; height: 500px; width: 80px; position: fixed; background-color: yellow; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="box"&gt;&lt;/div&gt; &lt;!-- 固定定位该元素不会因为浏览器页面滚动而发生位置的改变 --&gt; &lt;p&gt;看看我有没有滚动啊啊啊啊啊啊啊啊啊啊啊&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 应用可以用于底部的返回，导航漂浮菜单 元素层级如果定位元素处于相同层级，则后面的元素会盖住前面的元素（结构上） 也可以通过z-index来修改元素层级，但是没有开启定位的元素不起作用。 父元素的层级就算比子元素高，但是也不会盖住子元素。 1234567891011121314151617181920&lt;html&gt;&lt;head&gt;&lt;style type="text/css"&gt;img.x&#123;position:absolute;left:0px;top:0px;z-index:-1&#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;这是一个标题&lt;/h1&gt;&lt;img class="x" src="/i/eg_mouse.jpg" /&gt; &lt;p&gt;默认的 z-index 是 0。Z-index -1 拥有更低的优先级。&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; opacityopacity 属性设置元素的不透明级别。值为0-1区间。0表示完全透明，1是完全不透明。 在IE8以及以下不支持，需要支持则使用如下属性代替，filter滤镜，值为alpha(opacity=50),区间0-100,相当于opacity=0.5 123456789101112131415161718192021&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;style&gt; body &#123;background-color:yellow;&#125;div&#123;background-color:red;opacity:0.5;filter:Alpha(opacity=50); /* IE8 以及更早的浏览器 */&#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div&gt;本元素的不透明度是 0.5。请注意，文本和背景色都受到不透明级别的影响。&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 背景background 简写属性在一个声明中设置所有的背景属性。 可以设置如下属性： background-color 规定要使用的背景颜色。 background-position 规定背景图像的位置。 background-size 规定背景图片的尺寸。 background-repeat 规定如何重复背景图像。 background-origin 规定背景图片的定位区域。 background-clip 规定背景的绘制区域。 background-attachment 规定背景图像是否固定或者随着页面的其余部分滚动。 background-image 规定要使用的背景图像。 简写属性：没有顺序，也没有规定有多少个值。background: #00FF00 url(bgimage.gif) no-repeat fixed top; IE8 以及更早的浏览器不支持一个元素多个背景图像。IE7 以及更早的浏览器不支持 “inherit”。IE8 需要 !DOCTYPE。IE9 支持 “inherit”。 IE6不支持PNG24在IE6中对图片格式为PNG24的支持度不高，解决方式 将png转为png-8格式即可，但是清晰度会有一点损失。 使用JS第三方库ie6_png 按钮背景闪烁有一个按钮，按钮的状态分别设置了三个背景，上代码 1234567891011121314151617181920212223&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;&lt;/title&gt; &lt;style type="text/css"&gt; .btn &#123; display: block; width: 93px; height: 29px; background: url('img/link.png'); &#125; .btn:hover &#123; background: url('img/hover.png'); &#125; .btn:active &#123; background: url('img/active.png'); &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;a class="btn"&gt;&lt;/a&gt;&lt;/body&gt;&lt;/html&gt; 造成原因：浏览器外部资源不是同时加载，而是资源被使用才会去加载资源，而上述的例子中，link.png被加载了，但是hover和active下状态没有马上触发，所以没有加载该资源图片，当状态被触发的时候该状态的图片才会加载，但是加载图片并不是立刻能够完成的，所以在加载的过程中有一段时间，背景图片无法显示，造成了背景闪烁。为了解决将图片整合成一张图片，利用background-position来分别显示各自的位置，这种图片又称精灵图/雪碧图。 解决方法:123456789101112131415161718192021222324252627&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;&lt;/title&gt; &lt;style type="text/css"&gt; .btn &#123; display: block; width: 93px; height: 29px; background: url('img/btn.png'); &#125; .btn:hover &#123; background: url('img/btn.png'); background-position: 93px 0; &#125; .btn:active &#123; background: url('img/btn.png'); background-position: 186px 0; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;a class="btn"&gt;&lt;/a&gt;&lt;/body&gt;&lt;/html&gt; CSS精灵图/雪碧图CSS Sprite(CSS 精灵), 也称作 雪碧图。 将导航背景图片，按钮背景图片等有规则的合并成一张背景图，即将多张图片合为一张整图，然后用background-position”来实现背景图片的定位技术。 优势 通过图片整合来减少对服务器的请求次数，从而提高 页面的加载速度 通过整合图片来减小图片的体积 图片整合原则： 边切图边整合 定位时避免使用bottom,right等，用具体的数值，为了避免当你的宽度或高度上扩展sprites图时出现位置的错误 将小图标预留足够的空间，因为使用这些图标元素通常会有大量的内容而且可能需要扩展的间距，以至于其它的图片可能会意外出现在本区域内。一般的情况下，会将这些小图标整合到文件的最右侧 单张整合好的sprite图片在100KB以内 按分类整合图片 为了方便计算尺寸，一般情况会将sprites图的坐标计算成整数倍 表格简单用法不介绍了。table标签，tr行标签，td单元格标签，th表头标签。 去除table与td的距离通过border-spacing属性设置这个距离。 表格边框合并通过border-collapse设置为collapse即可，一旦设置border-spacing自动失效。 长表格有一些情况下，表格是非常长的，则这时候需要将表格分为三个部分表头，表主体，表底部。则html提供了三个标签thead,tbody,tfoot来分别表示进行区分。作用就是区分表格的不同部分。如果表格没有写tbody标签，则浏览器会默认添加一个tbody。 CSS Hack有一些特殊情况，，有一些代码只需要运行在特定的浏览器（IE6等），则可以使用CSS Hack来解决，这段代码只在某些浏览器中识别，而其他浏览器等不会识别。 以下列举的只是一小部分，像火狐等浏览器都有自己的HACK，但是相对于一般用于IE更广法。 不到万不得已的情况尽量不要使用 条件Hack用于选择IE浏览器及IE的不同版本if条件Hack是HTML级别的（包含但不仅是CSS的Hack，可以选择任何HTML代码块） 仅对IE10以下有效，其余浏览器解析为html注释。 判断IE123&lt;!--[if IE]&gt; ...&lt;![endif]--&gt; 判断IE6123&lt;!--[if IE 6]&gt; ...&lt;![endif]--&gt; 判断IE9以下（但不包括IE9）123&lt;!--[if lt IE 9]&gt; ...&lt;![endif]--&gt; lt为小于，lte为小于等于，gt为大于，gte为大于等于，!为选择指定版本外的所有IE版本(非) 属性Hack选择不同的浏览器及版本尽可能减少对CSS Hack的使用。Hack有风险，使用需谨慎通常如未作特别说明，本文档所有的代码和示例的默认运行环境都为标准模式。一些CSS Hack由于浏览器存在交叉认识，所以需要通过层层覆盖的方式来实现对不同浏览器进行Hack的。如下面这个例子： 123456789101112_：选择IE6及以下。连接线（中划线）（-）亦可使用，为了避免与某些带中划线的属性混淆，所以使用下划线（_）更为合适。*：选择IE7及以下。诸如：（+）与（#）之类的均可使用，不过业界对（*）的认知度更高\9：选择IE6+\0：选择IE8+和Opera[;property:value;];：选择webkit核心浏览器（Chrome,Safari）。IE7及以下也能识别。中括号内外的3个分号必须保留，第一个分号前可以是任意规则或任意多个规则[;color:#f00;]; 与 [color:#f00;color:#f00;]; 与 [margin:0;padding:0;color:#f00;]; 是等价的。生效的始终是中括号内的最后一条规则，所以通常选用第一种写法最为简洁 案例代码：123456789101112131415161718192021&lt;!DOCTYPE html&gt;&lt;html lang="zh-cn"&gt;&lt;head&gt;&lt;meta charset="utf-8" /&gt;&lt;title&gt;属性级Hack_CSS参考手册_web前端开发参考手册系列&lt;/title&gt;&lt;style&gt;h1&#123;margin:10px 0;font-size:16px;&#125;.test&#123; color:#c30; /* For Firefox */ [;color:#ddd;]; /* For webkit(Chrome and Safari) */ color:#090\0; /* For Opera */ color:#00f\9; /* For IE8+ */ *color:#f00; /* For IE7 */ _color:#ff0; /* For IE6 */&#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div class="test"&gt;在不同浏览器下看看我的颜色吧&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 选择符Hack选择不同的浏览器及版本尽可能减少对CSS Hack的使用。Hack有风险，使用需谨慎通常如未作特别说明，本文档所有的代码和示例的默认运行环境都为标准模式。一些CSS Hack由于浏览器存在交叉认识，所以需要通过层层覆盖的方式来实现对不同浏览器进行Hack的。 用得比较少 1234* html .test&#123;color:#090;&#125; /* For IE6 and earlier */* + html .test&#123;color:#ff0;&#125; /* For IE7 */.test:lang(zh-cn)&#123;color:#f00;&#125; /* For IE8+ and not IE */.test:nth-child(1)&#123;color:#0ff;&#125; /* For IE9+ and not IE */ 参考链接http://www.w3school.com.cn/css]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mac关闭/开启独立显卡]]></title>
    <url>%2F2019%2F03%2F19%2FMac%E5%85%B3%E9%97%AD-%E5%BC%80%E5%90%AF%E7%8B%AC%E7%AB%8B%E6%98%BE%E5%8D%A1%2F</url>
    <content type="text"><![CDATA[本人使用的是2018款15寸的Mbp，每次用迅雷播放器观看总是自动帮我切换到独立显卡，功耗和发热实在是太严重了，所以想单独仅使用集成显卡。 普通的界面中只找到了自动切换模式在设置-节能选项卡中可以找到。 而想单独使用，则终端使用命令123456#强制使用核显(集成显卡)$ sudo pmset -a GPUSwitch 0#强制使用独立显卡$ sudo pmset -a GPUSwitch 1#自动切换$ sudo pmset -a GPUSwitch 2 自由选择切换即可。 或者使用一个gfxCardStatus软件也可实现，但未经尝试。命令更方便。]]></content>
      <categories>
        <category>程序人生</category>
      </categories>
      <tags>
        <tag>Mac</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP预定义变量]]></title>
    <url>%2F2019%2F03%2F19%2FPHP%E9%A2%84%E5%AE%9A%E4%B9%89%E5%8F%98%E9%87%8F%2F</url>
    <content type="text"><![CDATA[PHP预定义变量对于全部脚本而言，PHP 提供了大量的预定义变量。这些变量将所有的外部变量表示成内建环境变量，并且将错误信息表示成返回头。 超全局变量 — 超全局变量是在全部作用域中始终可用的内置变量 $GLOBALS — 引用全局作用域中可用的全部变量 $_SERVER — 服务器和执行环境信息 $_GET — HTTP GET 变量 $_POST — HTTP POST 变量 $_FILES — HTTP 文件上传变量 $_REQUEST — HTTP Request 变量 $_SESSION — Session 变量 $_ENV — 环境变量 $_COOKIE — HTTP Cookies $php_errormsg — 前一个错误信息 $HTTP_RAW_POST_DATA — 原生POST数据 $http_response_header — HTTP 响应头 $argc — 传递给脚本的参数数目 $argv — 传递给脚本的参数数组 参考资料 https://secure.php.net/manual/zh/reserved.variables.php]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mac缺少freetype解决方案]]></title>
    <url>%2F2019%2F03%2F19%2FMac%E7%BC%BA%E5%B0%91freetype%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%2F</url>
    <content type="text"><![CDATA[环境Mac OS X 10.14.3 问题最近在使用thinkphp的验证码模块时，出现了一个异常Call to undefined function think\captcha\imagettftext()没有imagettftext()这个函数，原因是因为php缺少gd库中的freetype模块导致的。 知道了原因后，查询了网上大致的方法，大概这么几种 重新编译PHP 用brew重新安装新的PHP https://php-osx.liip.ch 一句话脚本 在尝试了很多遍后，都没有成功。有一篇文章讲到了这些方案比较过时，在Macos10.14版本下更改了安全策略，新增了Rootless机制，具体请看我博客中另一篇文章关于Rootless的介绍。 解决方案一（便携）使用第三方集成环境例如MAMP,MAMP PRO,XAMPP等 方案二（推荐）首先关闭Rootless关闭步骤1231、重启 Mac 并按住 Command+R，进入恢复模式2、打开终端 Terminal3、输入csrutil disable 开启步骤 1231、重启 Mac 并按住 Command+R，进入恢复模式2、打开终端 Terminal3、输入csrutil enable 重新brew安装php这里我试过关闭rootless后使用一句话脚本也没有办法安装成功。也试过一些网上的方案例如1$ brew install php56 --with-apche --with-freetype 但是运行出现Error: invalid option: --with-apche此错误，寻思没有解决办法。 成功的方案 1$ brew install php@7.1 --build-from-source 记住添加--build-from-source参数 php 版本可自行通过brew search php来查看需要安装所需，运行后出现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697==&gt; Installing dependencies for php@7.1: pkg-config==&gt; Installing php@7.1 dependency: pkg-config==&gt; Downloading https://homebrew.bintray.com/bottles/pkg-config-0.29.2.mojave.bo######################################################################## 100.0%==&gt; Pouring pkg-config-0.29.2.mojave.bottle.tar.gz🍺 /usr/local/Cellar/pkg-config/0.29.2: 11 files, 627.2KB==&gt; Installing php@7.1==&gt; Downloading https://php.net/get/php-7.1.26.tar.xz/from/this/mirror==&gt; Downloading from https://secure.php.net/distributions/php-7.1.26.tar.xz # # # # -=O=- ==&gt; Patchingpatching file acinclude.m4Hunk #1 succeeded at 444 (offset 3 lines).Hunk #2 succeeded at 459 (offset 3 lines).Hunk #3 succeeded at 494 (offset 3 lines).Hunk #4 succeeded at 506 (offset 3 lines).Hunk #5 succeeded at 2507 (offset 88 lines).==&gt; ./buildconf --force==&gt; ./configure --prefix=/usr/local/Cellar/php@7.1/7.1.26 --localstatedir=/usr/l==&gt; make==&gt; make install==&gt; /usr/local/Cellar/php@7.1/7.1.26/bin/pear config-set php_ini /usr/local/etc/==&gt; /usr/local/Cellar/php@7.1/7.1.26/bin/pear config-set php_dir /usr/local/shar==&gt; /usr/local/Cellar/php@7.1/7.1.26/bin/pear config-set doc_dir /usr/local/shar==&gt; /usr/local/Cellar/php@7.1/7.1.26/bin/pear config-set ext_dir /usr/local/lib/==&gt; /usr/local/Cellar/php@7.1/7.1.26/bin/pear config-set bin_dir /usr/local/opt/==&gt; /usr/local/Cellar/php@7.1/7.1.26/bin/pear config-set data_dir /usr/local/sha==&gt; /usr/local/Cellar/php@7.1/7.1.26/bin/pear config-set cfg_dir /usr/local/shar==&gt; /usr/local/Cellar/php@7.1/7.1.26/bin/pear config-set www_dir /usr/local/shar==&gt; /usr/local/Cellar/php@7.1/7.1.26/bin/pear config-set man_dir /usr/local/shar==&gt; /usr/local/Cellar/php@7.1/7.1.26/bin/pear config-set test_dir /usr/local/sha==&gt; /usr/local/Cellar/php@7.1/7.1.26/bin/pear config-set php_bin /usr/local/opt/==&gt; /usr/local/Cellar/php@7.1/7.1.26/bin/pear update-channels==&gt; CaveatsTo enable PHP in Apache add the following to httpd.conf and restart Apache: LoadModule php7_module /usr/local/opt/php@7.1/lib/httpd/modules/libphp7.so &lt;FilesMatch \.php$&gt; SetHandler application/x-httpd-php &lt;/FilesMatch&gt;Finally, check DirectoryIndex includes index.php DirectoryIndex index.php index.htmlThe php.ini and php-fpm.ini file can be found in: /usr/local/etc/php/7.1/php@7.1 is keg-only, which means it was not symlinked into /usr/local,because this is an alternate version of another formula.If you need to have php@7.1 first in your PATH run: echo 'export PATH="/usr/local/opt/php@7.1/bin:$PATH"' &gt;&gt; ~/.bash_profile echo 'export PATH="/usr/local/opt/php@7.1/sbin:$PATH"' &gt;&gt; ~/.bash_profileFor compilers to find php@7.1 you may need to set: export LDFLAGS="-L/usr/local/opt/php@7.1/lib" export CPPFLAGS="-I/usr/local/opt/php@7.1/include"To have launchd start php@7.1 now and restart at login: brew services start php@7.1Or, if you don't want/need a background service you can just run: php-fpm==&gt; Summary🍺 /usr/local/Cellar/php@7.1/7.1.26: 508 files, 63MB, built in 5 minutes 46 seconds==&gt; Caveats==&gt; php@7.1To enable PHP in Apache add the following to httpd.conf and restart Apache: LoadModule php7_module /usr/local/opt/php@7.1/lib/httpd/modules/libphp7.so &lt;FilesMatch \.php$&gt; SetHandler application/x-httpd-php &lt;/FilesMatch&gt;Finally, check DirectoryIndex includes index.php DirectoryIndex index.php index.htmlThe php.ini and php-fpm.ini file can be found in: /usr/local/etc/php/7.1/php@7.1 is keg-only, which means it was not symlinked into /usr/local,because this is an alternate version of another formula.If you need to have php@7.1 first in your PATH run: echo 'export PATH="/usr/local/opt/php@7.1/bin:$PATH"' &gt;&gt; ~/.bash_profile echo 'export PATH="/usr/local/opt/php@7.1/sbin:$PATH"' &gt;&gt; ~/.bash_profileFor compilers to find php@7.1 you may need to set: export LDFLAGS="-L/usr/local/opt/php@7.1/lib" export CPPFLAGS="-I/usr/local/opt/php@7.1/include"To have launchd start php@7.1 now and restart at login: brew services start php@7.1Or, if you don't want/need a background service you can just run: php-fpm 主要查看后面的提示信息并配置环境12$ echo 'export PATH="/usr/local/opt/php@7.1/bin:$PATH"' &gt;&gt; ~/.bash_profile$ echo 'export PATH="/usr/local/opt/php@7.1/sbin:$PATH"' &gt;&gt; ~/.bash_profile 然后source ~/.bash_profire 再次重新运行thinkphp中的验证码模块，实验成功 参考资料https://blog.csdn.net/leiflyy/article/details/53016769 https://blog.csdn.net/liaobangxiang/article/details/79460290 https://github.com/EricLi404/notes/issues/1 https://stackoverflow.com/questions/50259893/home-brew-php-7-2-5-install-with-curl https://hackycy.github.io/2019/03/19/Mac-OS-X-10-11-Rootless-介绍]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>环境搭建</tag>
        <tag>Homebrew</tag>
        <tag>Mac</tag>
        <tag>PHP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mac OS X 10.11+ Rootless 介绍]]></title>
    <url>%2F2019%2F03%2F19%2FMac-OS-X-10-11-Rootless-%E4%BB%8B%E7%BB%8D%2F</url>
    <content type="text"><![CDATA[RootlessMac OS X 10.11+ (El Capitan) 以后，引入了 Rootless 安全机制，该机制限制了 root 用户的权限，有部分操作即使是 root 也无法执行。在搭建php环境时遇到了这个，所以记录了下来。 该机制的详细介绍，请参考：Wikipedia: System Integrity ProtectionApple: System Integrity Protection Guide 主要限制有：以下目录无法修改：/System, /bin, /sbin, 或者 /usr (/usr/local 除外)，以及内置 App 和系统工具 Utilities。具体的限制名单在 /System/Library/Sandbox/rootless.conf 文件中有定义，该文件行首的 * 表示该行记录不在限制之列无法追踪调试系统进程无法加载未经验证的内核扩展 可能引起的问题和解决方案 修改受限制的文件或文件夹 123sudo cp -f FILE /usr/bin/# 报错： cp: /usr/bin/FILE: Operation not permitted 执行部分命令受挫 123456sudo gem install posix-spawn -v '0.3.11'# 报错：Building native extensions. This could take a while...ERROR: While executing gem ... (Errno::EPERM) Operation not permitted - /usr/bin/posix-spawn-benchmark 关闭/开启Rootless如果遇到的问题难以解决，也可以关闭 rootless 功能，彻底解决引起的权限问题，但是关闭 rootless 将会严重降低系统安全性，必须尽快重新开启。 关闭1、重启 Mac 并按住 Command+R，进入恢复模式2、打开终端 Terminal3、输入csrutil disable 开启1、重启 Mac 并按住 Command+R，进入恢复模式2、打开终端 Terminal3、输入csrutil enable]]></content>
      <categories>
        <category>程序人生</category>
      </categories>
      <tags>
        <tag>Mac</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo博客Next主题不蒜子失效解决]]></title>
    <url>%2F2019%2F03%2F17%2Fhexo%E5%8D%9A%E5%AE%A2Next%E4%B8%BB%E9%A2%98%E4%B8%8D%E8%92%9C%E5%AD%90%E5%A4%B1%E6%95%88%E8%A7%A3%E5%86%B3%2F</url>
    <content type="text"><![CDATA[2018年底发现不蒜子开始失效，但是没有管，现在看了官网 原因官网解释：因七牛强制过期『dn-lbstatics.qbox.me』域名，与客服沟通无果，只能更换域名到『busuanzi.ibruce.info』！ 解决方案直接根据提示替换即可 替换路径themes/next/layout/_third-party/analytics/busuanzi-counter.swig，打开文件 找到&lt;script async src=&quot;https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js&quot;&gt;&lt;/script&gt;替换&lt;script async src=&quot;//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js&quot;&gt;&lt;/script&gt;]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP之魔术常量]]></title>
    <url>%2F2019%2F03%2F14%2FPHP%E4%B9%8B%E9%AD%94%E6%9C%AF%E5%B8%B8%E9%87%8F%2F</url>
    <content type="text"><![CDATA[魔术常量PHP 向它运行的任何脚本提供了大量的预定义常量。不过很多常量都是由不同的扩展库定义的，只有在加载了这些扩展库时才会出现，或者动态加载后，或者在编译时已经包括进去了。 有八个魔术常量它们的值随着它们在代码中的位置改变而改变。例如 __LINE__的值就依赖于它在脚本中所处的行来决定。这些特殊的常量不区分大小写，如下： 几个php的魔术常量 名称 说明 LINE 文件中的当前行号 FILE 文件的完整路径和文件名。如果用在被包含文件中，则返回被包含的文件名。自PHP4.0.2起，FILE总是包含一个绝对路径（如果是符号连接，则是解析后的绝对路径），而在此之前的版本有时会包含一个相对路径。 DIR 文件所在的目录。如果用在被包含的文件中，则返回被包含的文件所在的目录，它等价于dirname(_FILE)。除非是根目录，否则目录名不包括末尾的斜杠。（PHP5.3.0中新增）。 FUNCTION 函数名称（PHP 4.3.0 新加）。自 PHP 5 起本常量返回该函数被定义时的名字（区分大小写）。在 PHP 4 中该值总是小写字母的。 CLASS 类的名称（PHP 4.3.0 新加）。自 PHP 5 起本常量返回该类被定义时的名字（区分大小写）。在 PHP 4 中该值总是小写字母的。类名包括其被声明的作用区域（例如 Foo\Bar）。注意自 PHP 5.4 起 CLASS 对 trait 也起作用。当用在 trait 方法中时，CLASS 是调用 trait 方法的类的名字。 TRAIT Trait 的名字（PHP 5.4.0 新加）。自 PHP 5.4 起此常量返回 trait 被定义时的名字（区分大小写）。Trait 名包括其被声明的作用区域（例如 Foo\Bar）。 METHOD 类的方法名（PHP 5.0.0 新加）。返回该方法被定义时的名字（区分大小写）。 NAMESPACE 当前命名空间的名称（区分大小写）。此常量是在编译时定义的（PHP 5.3.0 新增）。 参考资料https://secure.php.net/manual/zh/language.constants.predefined.php]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mysql命令行导入/出数据库]]></title>
    <url>%2F2019%2F03%2F11%2FMysql%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%AF%BC%E5%85%A5-%E5%87%BA%E6%95%B0%E6%8D%AE%E5%BA%93%2F</url>
    <content type="text"><![CDATA[通常开发都会使用Navicat或者PhpMyAdmin来进行数据库管理，即使方便，但是用于部署时就需要知道原生的一些命令。 mysqldump导出数据库1mysqldump -u 数据库用户名 -p 数据库名称 &gt; 导出数据库名称.sql 如：mysqldump -u root -p 1111 &gt; 1111_bak.sql，回车后输入密码导出到当前目录。 mysql导入数据库1mysql -u 数据库用户名 -p 导入数据库名称 &lt; 导入数据库源文件名称.sql 如：mysql -u root -p 1111 &lt; 1111_bak.sql，回车后输入密码从当前目录导入。]]></content>
      <categories>
        <category>DBA</category>
      </categories>
      <tags>
        <tag>Mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android无法获取本地服务器(Localhost)解决方案]]></title>
    <url>%2F2019%2F03%2F10%2FAndroid%E6%97%A0%E6%B3%95%E8%8E%B7%E5%8F%96%E6%9C%AC%E5%9C%B0%E6%9C%8D%E5%8A%A1%E5%99%A8-Localhost-%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%2F</url>
    <content type="text"><![CDATA[在Android开发中通过localhost或127.0.0.1访问本地服务器时，会报java.net.ConnectException: localhost/127.0.0.1:8083 -Connection refused异常。 为什么会报这个异常呢？因为Android模拟器本身把自己当做了localhost或127.0.0.1，而此时我们又通过localhost或127.0.0.1访问本地服务器，所以会抛出异常了。 解决方案： 使用10.0.2.2来代替localhost和127.0.0.1即可]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mac显示隐藏文件/文件夹]]></title>
    <url>%2F2019%2F03%2F08%2FMac%E6%98%BE%E7%A4%BA%E9%9A%90%E8%97%8F%E6%96%87%E4%BB%B6-%E6%96%87%E4%BB%B6%E5%A4%B9%2F</url>
    <content type="text"><![CDATA[Mac下一些隐藏文件夹是没有办法可见的，终端下也不会进行显示，例如用户文件下下的.m2 终端执行命令设置隐藏文件可见1$ defaults write com.apple.finder AppleShowAllFiles TRUE 设置隐藏文件不可见1$ defaults write com.apple.finder AppleShowAllFiles FALSE 重启Finder生效1$ killall Finder]]></content>
      <categories>
        <category>程序人生</category>
      </categories>
      <tags>
        <tag>Mac</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS3新特性]]></title>
    <url>%2F2019%2F03%2F07%2FCSS3%E6%96%B0%E7%89%B9%E6%80%A7%2F</url>
    <content type="text"><![CDATA[CSS3【控制样式，网页布局】CSS3中新特性样式篇 背景123456789101112131415161718background-origin： 规定背景图片的定位区域。 ☞ padding-box 背景图像相对内边距定位（默认值） ☞ border-box 背景图像相对边框定位【以边框左上角为参照进行位置设置】 ☞ content-box 背景图像相对内容区域定位【以内容区域左上角为参照进行位置设置】 备注： 1. 默认盒子的背景图片是在盒子的内边距左上角对齐设置。background-clip： 规定背景的绘制区域。 ☞ border-box 背景被裁切到边框盒子位置 【将背景图片在整个容器中显示】 ☞ padding-box 背景被裁切到内边距区域【将背景图片在内边距区域（包含内容区域）显示】 ☞ content-box 背景被裁切到内容区域【将背景图片在内容区域显示】background-size： 规定背景图片的尺寸。 ☞ cover ☞ contain 边框1234567891011121314151617box-shadow： 盒子阴影border-radius： 边框圆角border-image: 边框图片 /* 设置边框图片 */ border-image-source: url("2.png"); /* 边框图片裁切 : 不需要带单位*/ border-image-slice: 20; /* 设置边框图片的平铺方式 */ /* border-image-repeat: stretch; */ border-image-repeat: round; /* border-image-repeat: repeat; */ border-image-width: 20px; 文本1☞text-shadow： 设置文本阴影 CSS3新特性之选择器篇123456789101112131415161718192021222324252627☞ 属性选择器： [属性名=值] &#123;&#125; [属性名] &#123;&#125; 匹配对应的属性即可 [属性名^=值] &#123;&#125; 以值开头 [属性名*=值] &#123;&#125; 包含 [属性名$=值] &#123;&#125; 以值结束 ☞ 结构伪类选择器： :first-child &#123;&#125; 选中父元素中第一个子元素 :last-child &#123;&#125; 选中父元素中最后一个子元素 :nth-child(n) &#123;&#125; 选中父元素中正数第n个子元素 :nth-last-child(n) &#123;&#125; 选中父元素中倒数第n个子元素 备注； n 的取值大于等于0 n 可以设置预定义的值 odd[选中奇数位置的元素] even【选中偶数位置的元素】 n 可以是一个表达式： an+b的格式☞ 其他选择器： :target 被锚链接指向的时候会触发该选择器 ::selection 当被鼠标选中的时候的样式 ::first-line 选中第一行 ::first-letter 选中第一个字符 CSS3新特性之颜色渐变12345678910111213141516171819202122232425☞ 线性渐变： 1. 开始颜色和结束颜色 2. 渐变的方向 3. 渐变的范围 background-image: linear-gradient( to right, red, blue ); 备注： 表示方向： 1. to + right | top | bottom | left 2. 通过角度表示一个方向 0deg [从下向上渐变] 90deg【从左向右】☞ 径向渐变： /* 径向渐变 */ background-image: radial-gradient( 100px at center, red, blue ); 2D转换1234567891011121314151617181920☞ 位移 transform: translate(100px,100px); 备注： 位移是相对元素自身的位置发生位置改变☞ 旋转 transform: rotate(60deg); 备注： 取值为角度☞ 缩放 transform: scale(0.5,1); 备注： 取值为倍数关系，缩小大于0小于1，放大设置大于1 ☞ 倾斜 transform: skew(30deg,30deg); 备注： 第一个值代表沿着x轴方向倾斜 第二个值代表沿着y轴方向倾斜 3D转换12345678910111213☞ 位移 transform: translateX() translateY() translateZ()☞ 旋转 transform: rotateX(60deg) rotateY(60deg) rotateZ(60deg);☞ 缩放 transform: scaleX(0.5) scaleY(1) scaleZ(1);☞ 倾斜 transform: skewX(30deg) skewY();☞ transform-style: preserve-3d; 将平面图形转换为立体图形 CSS3新特性之动画篇过渡1234567891011121314151617https://www.cnblogs.com/afighter/p/5731293.html补间动画 /* 设置哪些属性要参与到过渡动画效果中： all */ transition-property: all; /* 设置过渡执行时间 */ transition-duration: 1s; /* 设置过渡延时执行时间 */ transition-delay: 1s; /* 设置过渡的速度类型 */ transition-timing-function: linear; 动画12345678910111213141516171819 /* 1定义动画集 */ @keyframes rotate &#123; /* 定义开始状态 0%*/ from &#123; transform: rotateZ(0deg); &#125; /* 结束状态 100%*/ to &#123; transform: rotateZ(360deg); &#125; &#125;注意： 1. 如果设置动画集使用的是百分比，那么记住百分比是相对整个动画执行时间的。 CSS3新特性之网页布局篇伸缩布局或者弹性布局【响应式布局】12345678910111213141516171819202122232425262728293031323334353637383940414243☞ 设置父元素为伸缩盒子【直接父元素】 display： flex 为什么在伸缩盒子中，子元素会在一行上显示？ 1. 子元素是按照伸缩盒子中主轴方向显示 2. 只有伸缩盒子才有主轴和侧轴 3. 主轴： 默认水平从左向右显示 4。 侧轴： 始终要垂直于主轴☞ 设置伸缩盒子主轴方向（flex-direction） flex-direction: row; 【默认值】 flex-direction: row-reverse; flex-direction: column; flex-direction: column-reverse;☞ 设置元素在主轴的对齐方式( justify-content) /* 设置子元素在主轴方向的对齐方式 */ justify-content: flex-start; justify-content: flex-end; justify-content: center; justify-content: space-between; justify-content: space-around;☞ 设置元素在侧轴的对齐方式 （align-items） align-items: flex-start; align-items: flex-end; align-items: center; /* 默认值 */ align-items: stretch;☞ 设置元素是否换行显示（flex-wrap） 1. 在伸缩盒子中所有的元素默认都会在一行上显示 2. 如果希望换行： flex-wrap: wrap | nowrap;☞ 设置元素换行后的对齐方式（ align-content） align-content: flex-start; align-content: flex-end; align-content: center; align-content: space-around; align-content: space-between; /* 换行后的默认值 */ align-content: stretch;]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IOS中JSON序列化与反序列化]]></title>
    <url>%2F2019%2F03%2F06%2FIOS%E4%B8%ADJSON%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8E%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%2F</url>
    <content type="text"><![CDATA[序列化与反序列化序列化： 将数据结构或对象转换成二进制串的过程。反序列化：将在序列化过程中所生成的二进制串转换成数据结构或者对象的过程。 NSJSONSerializationjson-&gt;oc一段服务器的json数据 12345&#123; "data":"hello", "code":200, "msg":"success"&#125; 二进制数据转json,方法123456789/* * 第一个参数：json的二进制数据 * 第二个参数： * NSJSONReadingMutableContainers = (1UL &lt;&lt; 0),得到OC对象是可变的 * NSJSONReadingMutableLeaves = (1UL &lt;&lt; 1), 字典和数组中的字符串都是可变的，iOS7以后出现很多问题，一般不会用到 * NSJSONReadingAllowFragments = (1UL &lt;&lt; 2) 既不是字典也不是数组，则必须使用该枚举值 如果返回数据为@“\"hahahahaha\"” * 第三个参数：错误信息 */ NSDictionary *dic = [NSJSONSerialization JSONObjectWithData:data options:kNilOptions error:nil]; 举例 12345678910111213141516171819202122NSURL *url = [NSURL URLWithString:@"http://127.0.0.1:8000/hello/name"]; NSURLRequest *request = [NSURLRequest requestWithURL:url]; [NSURLConnection sendAsynchronousRequest:request queue:[NSOperationQueue mainQueue] completionHandler:^(NSURLResponse * _Nullable response, NSData * _Nullable data, NSError * _Nullable connectionError) &#123; if (connectionError) &#123; NSLog(@"%@", connectionError); return; &#125; NSHTTPURLResponse *res = (NSHTTPURLResponse *) response; if (res.statusCode == 200) &#123; //开始解析json NSError *error = nil; id json = [NSJSONSerialization JSONObjectWithData:data options:NSJSONReadingMutableContainers error:&amp;error]; if (error) &#123; NSLog(@"%@", error); return; &#125; NSLog(@"%@", json); &#125;else&#123; NSLog(@"服务器错误"); &#125; &#125;]; 输出结果123452019-03-06 17:44:34.480939+0800 JsonDemo[5349:107008] &#123; code = 200; data = hello; msg = success;&#125; oc-&gt;json举例1234567891011121314151617181920212223242526/* 注意：并不是所有的OC对象都可以转化为json 例如字符串 * 顶层必须是NSArray或者NSDictionnary * 所有的元素必须是 NSString, NSNumber, NSArray, NSDictionary, or NSNull * 字典中所有的key必须是NSStrings类型的 * NSNumbers 不能是无穷大 */ // 1、提供转化的OC字典 NSDictionary *dic = @&#123; @"code":@200, @"data":[NSNull null], @"msg":@"oh my json" &#125;; // 2、判断OC对象是否可以转换为json对象 BOOL isVaild = [NSJSONSerialization isValidJSONObject:dic]; if (isVaild) &#123; /* * 第一个参数：需要序列化的数据 * 第二个参数：如果添加就输出排版美观效果 如果不添加按照默认输出 * NSJSONWritingPrettyPrinted = (1UL &lt;&lt; 0) */ NSData *data = [NSJSONSerialization dataWithJSONObject:dic options:NSJSONWritingPrettyPrinted error:nil]; NSLog(@"%@",[[NSString alloc] initWithData:data encoding:NSUTF8StringEncoding]); &#125;else&#123; NSLog(@"该对象无法转换"); &#125; 控制台输出123452019-03-06 17:57:27.734633+0800 JsonDemo[6202:131086] &#123; &quot;msg&quot; : &quot;oh my json&quot;, &quot;data&quot; : null, &quot;code&quot; : 200&#125; MJExtension安装CocoaPods1pod 'MJExtension' 手动导入github链接 使用字典转模型模型USER123456789@interface User : NSObject@property(copy, nonatomic)NSString *name;@property(copy, nonatomic)NSString *zhiye;@property(copy, nonatomic)NSString *money;@end 1234567NSDictionary *dict = @&#123; @"name":@"ycy", @"zhiye":@"程序员", @"money":@"-4000" &#125;; User *user = [User mj_objectWithKeyValues:dict]; NSLog(@"%@",user.name); JSONString转模型123456789// 1.Define a JSONStringNSString *jsonString = @"&#123;\"name\":\"Jack\", \"icon\":\"lufy.png\", \"age\":20&#125;";// 2.JSONString -&gt; UserUser *user = [User mj_objectWithKeyValues:jsonString];// 3.Print user's propertiesNSLog(@"name=%@, icon=%@, age=%d", user.name, user.icon, user.age);// name=Jack, icon=lufy.png, age=20 more查看官方文档即可链接]]></content>
      <categories>
        <category>Ios</category>
      </categories>
      <tags>
        <tag>Ios</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IOS9以上中的ATS问题]]></title>
    <url>%2F2019%2F03%2F06%2FIOS9%E4%BB%A5%E4%B8%8A%E4%B8%AD%E7%9A%84ATS%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[WWDC 15 提出的 ATS (App Transport Security) 是 Apple 在推进网络通讯安全的一个重要方式。在 iOS 9 和 OS X 10.11 中，默认情况下非 HTTPS 的网络访问是被禁止的。 作为参考，这里将有效的 NSAppTransportSecurity 字典结构 123456789101112131415NSAppTransportSecurity : Dictionary &#123; NSAllowsArbitraryLoads : Boolean NSAllowsArbitraryLoadsForMedia : Boolean NSAllowsArbitraryLoadsInWebContent : Boolean NSAllowsLocalNetworking : Boolean NSExceptionDomains : Dictionary &#123; &lt;domain-name-string&gt; : Dictionary &#123; NSIncludesSubdomains : Boolean NSExceptionAllowsInsecureHTTPLoads : Boolean NSExceptionMinimumTLSVersion : String NSExceptionRequiresForwardSecrecy : Boolean // Default value is YES NSRequiresCertificateTransparency : Boolean &#125; &#125;&#125; ATS设定的参照表格 如果网站内没有启用https，如何关闭，在info.plist文件中加入source code下12345&lt;key&gt;NSAppTransportSecurity&lt;/key&gt;&lt;dict&gt; &lt;key&gt;NSAllowsArbitraryLoads&lt;/key&gt; &lt;true/&gt;&lt;/dict&gt; plist下添加NSAppTransportSecurity字典-&gt;并添加键值对NSAllowsArbitraryLoads=YES来禁用ATS 参照链接https://onevcat.com/2016/06/ios-10-ats/ https://stackoverflow.com/questions/31254725/transport-security-has-blocked-a-cleartext-http]]></content>
      <categories>
        <category>Ios</category>
      </categories>
      <tags>
        <tag>Ios</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IOS模拟器截图/录制屏幕]]></title>
    <url>%2F2019%2F03%2F06%2FIOS%E6%A8%A1%E6%8B%9F%E5%99%A8%E6%88%AA%E5%9B%BE-%E5%BD%95%E5%88%B6%E5%B1%8F%E5%B9%95%2F</url>
    <content type="text"><![CDATA[截图 iOS 的模拟器截图，按 Command + S或者通过 File 菜单都可以完成。 录制屏幕终端下运行该命令， 1xcrun simctl io booted recordVideo &lt;filename&gt;.&lt;extension&gt; 运行命令后没有报错则已经开始录制屏幕了，如果想要停止则直接Ctrl + C 停止结束命令即可。默认视频会保存在终端的当前目录下，当然你也可以指定当前目录。 xcrun unable to find simctl解决方法如果出现命令无法执行并报出这个错误xcrun: error: unable to find utility &quot;simctl&quot;, not a developer tool or in PATH 修改一下打开Xcode &gt; Preferences &gt; Locations 更改一下 Command Line Tools选项就可以了,如图]]></content>
      <categories>
        <category>Ios</category>
      </categories>
      <tags>
        <tag>Ios</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android P/9.0 http网络请求异常问题]]></title>
    <url>%2F2019%2F03%2F06%2FAndroid-P-9-0-http%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82%E5%BC%82%E5%B8%B8%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[使用Android P系统时，app使用http请求出现异常。 异常原因 Google表示，为保证用户数据和设备的安全，针对下一代 Android 系统(Android P)的应用程序，将要求默认使用加密连接，这意味着 Android P 将禁止 App使用所有未加密的连接，因此运行 Android P系统的安卓设备无论是接收或者发送流量，未来都不能明码传输，需要使用下一代(Transport LayerSecurity)传输层安全协议，而 Android Nougat 和 Oreo 则不受影响。 因此在Android P中使用HttpUrlConnection时会报出次异常 1W/System.err: java.io.IOException: Cleartext HTTP traffic to **** not permitted 而使用OKHttp时，同样也会报出异常 1java.net.UnknownServiceException: CLEARTEXT communication ** not permitted by network security policy 在Android P系统的设备上，如果应用使用的是非加密的明文流量的http网络请求，则会导致该应用无法进行网络请求，https则不会受影响，同样地，如果应用嵌套了webview，webview也只能使用https请求。有人认为 Android P 上所有的 App 都需要使用 TLS 加密会降低上网体验，事实上这是一种误解，至于 App 对于少数旧服务器的连接如果非要使用明码传输，开发者需要更改 App 的网络安全配置以允许此类连接。 解决方案APP内所有请求更改为Https将targetSdkVersion改为27以下开启/允许http请求方法一在res下新增一个xml目录，然后创建一个名为：network_security_config.xml 文件（名字自定） ，内容如下，大概意思就是允许开启http请求 1234567&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;network-security-config&gt; &lt;base-config cleartextTrafficPermitted="true" /&gt;&lt;/network-security-config&gt; 然后在AndroidManifest.xml文件中的Application标签下增加一行属性 12345678&lt;application ... android:networkSecurityConfig="@xml/network_security_config" ...&gt; ...&lt;/application&gt; 方法二在清单文件中加入 android:usesCleartextTraffic=”true” 属性 12345678910&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;manifest ...&gt; &lt;uses-permission android:name="android.permission.INTERNET" /&gt; &lt;application android:usesCleartextTraffic="true" &gt; &lt;/application&gt;&lt;/manifest&gt; 更多参数修改：https://developer.android.com/training/articles/security-config#trust-anchors 参考链接https://www.jianshu.com/p/57047a84e559 https://android-developers.googleblog.com/2018/04/protecting-users-with-tls-by-default-in.html https://android-developers.googleblog.com/2018/04/dns-over-tls-support-in-android-p.html]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Html5新特性]]></title>
    <url>%2F2019%2F03%2F04%2FHtml5%E6%96%B0%E7%89%B9%E6%80%A7%2F</url>
    <content type="text"><![CDATA[01-HTML5基础了解HTML5 12345678910111213141516☞HTML5属于上一代HTML的新迭代语言，设计HTML5最主要的目的是为了在移动设备上支持多媒体！！！ 例如： video 标签和 audio 及 canvas 标记☞ 新特性： 1. 取消了过时的显示效果标记 &lt;font&gt;&lt;/font&gt; 和 &lt;center&gt;&lt;/center&gt; ... 2. 新表单元素引入 3. 新语义标签的引入 4. canvas标签（图形设计） 5. 本地数据库（本地存储） 6. 一些API☞ 好处： 1. 跨平台 例如：比如你开发了一款HTML5的游戏，你可以很轻易地移植到UC的开放平台、Opera的游戏中心、Facebook应用平台，甚至可以通过封装的技术发放到App Store或Google Play上，所以它的跨平台性非常强大，这也是大多数人对HTML5有兴趣的主要原因。☞ 缺点： 1. pc端浏览器支持不是特别友好，造成用户体验不佳 新语义标签网页布局结构标签及兼容处理12345678&lt;header&gt;&lt;/header&gt;&lt;footer&gt;&lt;/footer&gt;&lt;article&gt;&lt;/article&gt;&lt;aside&gt;&lt;/aside&gt;&lt;nav&gt;&lt;/nav&gt;&lt;section&gt;&lt;/section&gt;....http://www.w3school.com.cn/html/html5_semantic_elements.asp 多媒体标签及属性介绍12345678910111213141516☞ &lt;video&gt;&lt;/video&gt; 视频 属性：controls 显示控制栏 属性：autoplay 自动播放 属性：loop 设置循环播放☞ &lt;audio&gt;&lt;/audio&gt; 音频 属性：controls 显示控制栏 属性：autoplay 自动播放 属性：loop 设置循环播放☞ video标签支持的格式 http://www.w3school.com.cn/html5/html_5_video.asp☞ 多媒体标签在网页中的兼容效果方式 &lt;video&gt; &lt;source src="code/多媒体标签/trailer.mp4"&gt; &lt;source src="trailer.ogg"&gt; &lt;source src="trailer.WebM"&gt; &lt;/video&gt; 新表单元素及属性智能表单控件1234567891011 &lt;input type="email"&gt; email: 输入合法的邮箱地址 url： 输入合法的网址 number： 只能输入数字 range： 滑块 color： 拾色器 date： 显示日期 month： 显示月份 week ： 显示第几周 time： 显示时间 表单属性12345678910111213141516171819202122232425262728 ◆form属性： autocomplete=on | off 自动完成 novalidate=true | false 是否关闭校验 ◆ input属性： *autofocus ： 自动获取焦点 form： list： &lt;input type="text" list="abc"/&gt; &lt;datalist id="abc"&gt; &lt;option value="123"&gt;12312&lt;/option&gt; &lt;option value="123"&gt;12312&lt;/option&gt; &lt;option value="123"&gt;12312&lt;/option&gt; &lt;option value="123"&gt;12312&lt;/option&gt; &lt;/datalist&gt; multiple： 实现多选效果 *placeholder ： 占位符 （提示信息） *required： 必填项作业： ◆自己解决required自定义提示信息 ◆预习和复习留下的疑问： ◆ 如何修改表单控件中的默认提示信息 1. 表单验证触发oninvalid事件 2. 通过setCustomValidity方法设置修改内容 HTMl5中的API获取页面元素及类名操作和自定义属性123456789101112131415161718192021222324252627282930313233343536☞ document.querySelector("选择器")； 备注： 选择器： 可以是css中的任意一种选择器 通过该选择器只能选中第一个元素。☞ document.querySelectorAll("选择器"); 备注： 与document.querySelector区别： querySelectorAll 可以选中所有符合选择器规则的元素，返回的是一个列表。querySelector返回的只是单独的一个元素 ☞ Dom.classList.add("类名"): 给当前dom元素添加类样式☞ Dom.classList.remove("类名"); 给当前dom元素移除类样式☞ classList.contains("类名"); 检测是否包含类样式☞ classList.toggle("active"); 切换类样式（有就删除，没有就添加）☞ 自定义属性 （小案例分析体验自定义属性） data-自定义属性名 备注： 在标签中，以data-自定义名称 1. 获取自定义属性 Dom.dataset 返回的是一个对象 Dom.dataset.属性名 或者 Dom.dataset[属性名] 注意： 属性名是不包含data- 2. 设置自定义属性 Dom.dataset.自定义属性名=值 或者 Dom.dataset[自定义属性名]=值； 文件读取123456789101112131415 ☞ FileReader FileReader 接口有3个用来读取文件方法返回结果在result中 readAsBinaryString ---将文件读取为二进制编码 readAsText ---将文件读取为文本 readAsDataURL ---将文件读取为DataURL☞ FileReader 提供的事件模型 onabort 中断时触发 onerror 出错时触发 onload 文件读取成功完成时触发 onloadend 读取完成触发，无论成功或失败 onloadstart 读取开始时触发 onprogress 读取中☞ 分析读取图片小案例 获取网络状态123456☞ 获取当前网络状态 window.navigator.onLine 返回一个布尔值☞ 网络状态事件 1. window.ononline 2. window.onoffline 获取地理定位12345678910☞ 获取一次当前位置 window.navigator.geolocation.getCurrentPosition(success,error); 1. coords.latitude 维度 2. coords.longitude 经度☞ 实时获取当前位置 window.navigator.geolocation.watchPosition(success,error);☞ 分析地理定位小案例 本地存储12345678910111213141516171819202122☞发展： 随着互联网的快速发展，基于网页的应用越来越普遍，同时也变的越来越复杂，为了满足各种各样的需求，会经常性在本地存储大量的数据，传统方式我们以document.cookie来进行存储的，但是由于其存储大小只有4k左右，并且解析也相当的复杂，给开发带来诸多不便，HTML5规范则提出解决方案，使用sessionStorage和localStorage存储数据。 ☞ localStorage： 1. 永久生效 2. 多窗口共享 3. 容量大约为20M ◆window.localStorage.setItem(key,value) 设置存储内容 ◆window.localStorage.getItem(key) 获取内容 ◆window.localStorage.removeItem(key) 删除内容 ◆window.localStorage.clear() 清空内容 ☞ sessionStorage： 1. 生命周期为关闭当前浏览器窗口 2. 可以在同一个窗口下访问 3. 数据大小为5M左右 ◆window.sessionStorage.setItem(key,value) ◆window.sessionStorage.getItem(key) ◆window.sessionStorage.removeItem(key) ◆window.sessionStorage.clear() 操作多媒体1234http://www.w3school.com.cn/html5/html5_ref_audio_video_dom.asp作业： 完成一个在线音乐播放器或者视频播放器 Canvas画布绘图工具12345☞ 介绍canvas画布☞ 设置画布大小： 使用属性方式设置☞ 解决画布重绘问题 1. 设置一次描边 2. 开启新的图层 绘图方法123456789101112131415161718192021ctx.moveTo(x,y) 落笔ctx.lineTo(x,y) 连线ctx.stroke() 描边ctx.beginPath()； 开启新的图层演示： strokeStyle="值"线宽： linewidth="值" 备注：不需要带单位线连接方式： lineJoin: round | bevel | miter (默认)线帽（线两端的结束方式）： lineCap: butt(默认值) | round | square 闭合路径： ctx.closePath()--绘制一条直线演示代码--作业： 1. 从200,100的位置绘制宽为200高为150的矩形 2. 准备一个600*400的画布，三等分这个画布，分别绘制正方形。直角三角形，梯形 渐变方案1234567891011121314151617181920212223242526272829☞ 线性渐变 var grd=ctx.createLinearGradient(x0,y0,x1,y1); x0--&gt;渐变开始的x坐标 y0--&gt;渐变开始的y坐标 x1--&gt;渐变结束的x坐标 y1--&gt;渐变结束的y坐标 grd.addColorStop(0,&quot;black&quot;); 设置渐变的开始颜色 grd.addColorStop(0.1,&quot;yellow&quot;); 设置渐变的中间颜色 grd.addColorStop(1,&quot;red&quot;); 设置渐变的结束颜色 ctx.strokeStyle=grd; ctx.stroke(); 备注： addColorStop(offse,color); 中渐变的开始位置和结束位置介于0-1之间，0代表开始，1代表结束。中间可以设置任何小数 ☞ 径向渐变 ctx.createradialGradient(x0,y0,r0,x1,y1,r1); (x0,y0)：渐变的开始圆的 x,y 坐标 r0：开始圆的半径 (x1,y1)：渐变的结束圆的 x,y 坐标 r1：结束圆的半径 填充效果12ctx.fill(); 设置填充效果ctx.fillstyle=&quot;值&quot;; 设置填充颜色 非零环绕原则1☞ 绘制一个如下图形 1234567☞ 非零环绕原则： 1. 任意找一点，越简单越好 2. 以点为圆心，绘制一条射线，越简单越好（相交的边越少越好） 3. 以射线为半径顺时针旋转，相交的边同向记为+1，反方向记为-1，如果相加的区域等于0，则不填充。 4. 非零区域填充 ☞ 非零环绕原则案例： 绘制虚线12345678910111213141516171819202122原理： 设置虚线其实就是设置实线与空白部分直接的距离,利用数组描述其中的关系 例如： [10,10] 实线部分10px 空白部分10px 例如： [10,5] 实线部分10px 空白部分5px 例如： [10,5,20] 实线部分10px 空白5px 实线20px 空白部分10px 实线5px 空白20px....绘制： ctx.setLineDash(数组); ctx.stroke(); 例如： ctx.moveTo(100, 100); ctx.lineTo(300, 100); ctx.setLineDash([2,4]); ctx.stroke();注意： 如果要将虚线改为实线，只要将数组改为空数组即可。 绘制动画效果123456789☞ 绘制一个描边矩形： content.strokeRect(x,y,width,height) ☞ 绘制一个填充矩形： content.fillRect(x,y,width,height) ☞ 清除： content.clearRect(x,y,width,height) ☞ 实现动画效果： 1. 先清屏 2. 绘制图形 3. 处理变量 绘制文本123456789101112131415161718192021222324☞ 绘制填充文本 content.fillText(文本的内容,x,y)☞ 绘制镂空文本 content.strokeText(); ☞ 设置文字大小： content.font=&quot;20px 微软雅黑&quot; 备注： 该属性设置文字大小，必须按照cssfont属性的方式设置 ☞ 文字水平对齐方式【文字在圆心点位置的对齐方式】 content.textalign=&quot;left | right | center&quot;☞文字垂直对齐方式 content.textBaseline=&quot;top | middle | bottom | alphabetic(默认)&quot;☞文字阴影效果 ctx.shadowColor=&quot;red&quot;; 设置文字阴影的颜色 ctx.ShadowOffsetX=值; 设置文字阴影的水平偏移量 ctx.shadowOffsetY=值; 设置文字阴影的垂直偏移量 ctx.shadowBlur=值; 设置文字阴影的模糊度 绘制图片12345678910111213141516171819☞ //将图片绘制到画布的指定位置 content.drawImage(图片对象,x,y);☞ //将图片绘制到指定区域大小的位置 x,y指的是矩形区域的位置，width和height指的是矩形区域的大小 content.drawImage(图片对象,x,y,width,height); ☞ //将图片的指定区域绘制到指定矩形区域内 content.drawImage(图片对象,sx,sy,swidth,sheight,dx,dy,dwidth,dheight); sx,sy 指的是要从图片哪块区域开始绘制，swidth，sheight 是值 截取图片区域的大小 dx,dy 是指矩形区域的位置，dwidth,dheight是值矩形区域的大小 ☞ 解决图片绘制到某一个区域的按原比例缩放绘制： 绘制宽：绘制高==原始宽：原始高 绘制圆弧123456789101112131415161718192021222324252627282930313233343536373839404142434445464748☞ content.arc(x,y,radius,startradian,endradian[,direct]); x,y 圆心的坐标 radius 半径 startradian 开始弧度 endradian 结束弧度 direct 方向（默认顺时针 false） true 代表逆时针 ☞ 0度角在哪？ 以圆心为中心向右为0角 顺时针为正，逆时针为负 ☞ 备注： 角度 和 弧度的关系： 角度:弧度= 180:pi 特殊值 0度 = 0弧度 30度 = π/6 (180度的六分之一) 45度 = π/4 60度 = π/3 90度 = π/2 180度 = π 360度 = 2π ☞ 绘制圆上任意点： 公式： x=ox+r*cos( 弧度 ) y=oy+r*sin( 弧度 ) ox: 圆心的横坐标 oy: 圆心的纵坐标 r： 圆的半径 平移【坐标系圆点的平移】12345678910111213ctx.translate(x,y); 特点： 通过该方法可以将原点的位置进行重新设置。 注意： 1. translate(x,y) 中不能设置一个值 2. 与moveTo(x,y) 的区别： moveTo(x,y) 指的是将画笔的落笔点的位置改变，而坐标系中的原点位置并没有发生改变 translate(x,y) 是将坐标系中的原点位置发生改变 旋转【坐标系旋转】1ctx.rotate(弧度) 伸缩123456ctx.scale(x,y) 备注： 沿着x轴和y轴缩放 x,y 为倍数 例如： 0.5 1]]></content>
      <categories>
        <category>HTML</category>
      </categories>
      <tags>
        <tag>HTML</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IOS之自动布局AutoLayout]]></title>
    <url>%2F2019%2F03%2F04%2FIOS%E4%B9%8B%E8%87%AA%E5%8A%A8%E5%B8%83%E5%B1%80AutoLayout%2F</url>
    <content type="text"><![CDATA[AutoLayout自动布局介绍UI布局对于iOS开发者来说并不陌生，在iOS6之前，大家都是通过UI控件的Frame属性和Autoresizing Mask来进行UI布局的。AutoLayout则是苹果公司在iOS6推出的一种基于约束的，描述性的布局系统。自从AutoLayout问世以来，逐步得到了iOS开发者们的青睐，尤其是iPhone6机型尺寸的出现。 AutoLayout占据UI布局的主要领导位置依赖于它的特殊性： 基于约束：和以往定义frame的位置和尺寸不同，AutoLayout的位置确定是以所谓相对位置的约束来定义的，比如x坐标为superView的中心，y坐标为屏幕底部上方10像素等 描述性： 约束的定义和各个view的关系使用接近自然语言或者可视化语言（稍后会提到）的方法来进行描述 布局系统：即字面意思，用来负责界面的各个元素的位置。 AutoLayout使用原理创建约束IOS6中新加入了一个类，NSLayoutConstraint,它的约束满足一个公式 1item1.attribute = multiplier ⨉ item2.attribute + constant 相应公式的代码为12345678//view_1(红色)top 距离self.view的topNSLayoutConstraint *view_1TopToSuperViewTop = [NSLayoutConstraint constraintWithItem:view_1 attribute:NSLayoutAttributeTop relatedBy:NSLayoutRelationEqual toItem:self.view attribute:NSLayoutAttributeTop multiplier:1 constant:30]; 这里对应的约束是“view_1的顶部（y）＝ self.view的顶部(y)*1 + 30”。 添加约束在创建约束后，需要将其添加到作用的view上。UIView添加约束的实例方法 12- (void)addConstraint:(NSLayoutConstraint *)constraint NS_AVAILABLE_IOS(6_0);- (void)addConstraints:(NSArray&lt;__kindof NSLayoutConstraint *&gt; *)constraints NS_AVAILABLE_IOS(6_0); UIView中的一个属性translatesAutoresizingMaskIntoConstraints 1234//如果你定义的view想用autolayout，就将translatesAutoresizingMaskIntoConstraints = NO;//如果你使用的不是autolayout，就将translatesAutoresizingMaskIntoConstraints = YES; 约束的属性 当然，如何添加也有相应的规则。 对其他的view没有任何关系时，添加到自己的view上比如说添加一个按钮的宽和高的约束，对其他的view没有任何关系，则将约束添加到自己身上。 为按钮添加一个宽和高为两百的约束1234567891011121314151617181920#import "ViewController.h"@interface ViewController ()@property (strong, nonatomic) IBOutlet UIButton *btn1;@end@implementation ViewController- (void)viewDidLoad &#123; [super viewDidLoad]; // Do any additional setup after loading the view, typically from a nib. NSLayoutConstraint *c1 = [NSLayoutConstraint constraintWithItem:self.btn1 attribute:NSLayoutAttributeWidth relatedBy:NSLayoutRelationEqual toItem:nil attribute:NSLayoutAttributeWidth multiplier:1 constant:200]; NSLayoutConstraint *c2 = [NSLayoutConstraint constraintWithItem:self.btn1 attribute:NSLayoutAttributeHeight relatedBy:NSLayoutRelationEqual toItem:nil attribute:NSLayoutAttributeHeight multiplier:1 constant:200]; self.btn1.translatesAutoresizingMaskIntoConstraints = NO; [self.btn1 addConstraint:c1]; [self.btn1 addConstraint:c2];&#125;@end 对于两个同层级view之间的约束关系，则添加到他们的父View上例如3.1与3.2为同层级view，约束关系则添加到父view2.1上。 添加了一个蓝色view的上边线与绿色view的下边线对其的约束，两个view为同级约束，则添加到了父view上。 对于两个不同层级的view之间的约束关系，则添加到他们最近的共同的父view上。例如3.3与3.5为同层级view，约束关系则添加到父view1上。 但是相对于这种情况应该用的很少。 刷新约束可以通过setNeedsUpdateConstraints和layoutIfNeeded两个方法来刷新约束，使得UIView重新布局。 Masonry框架最后说明一下，在Masonry中能够添加autolayout约束有三个函数： 123456789- (NSArray *)mas_makeConstraints:(void(^)(MASConstraintMaker *make))block;- (NSArray *)mas_updateConstraints:(void(^)(MASConstraintMaker *make))block;- (NSArray *)mas_remakeConstraints:(void(^)(MASConstraintMaker *make))block;/*mas_makeConstraints 只负责新增约束 Autolayout不能同时存在两条针对于同一对象的约束 否则会报错 mas_updateConstraints 针对上面的情况 会更新在block中出现的约束 不会导致出现两个相同约束的情况mas_remakeConstraints 则会清除之前的所有约束 仅保留最新的约束三种函数善加利用 就可以应对各种情况了*/ 常用属性 123456//乘以- (MASConstraint * (^)(CGFloat multiplier))multipliedBy;//除以- (MASConstraint * (^)(CGFloat divider))dividedBy;//优先级- (MASConstraint * (^)(MASLayoutPriority priority))priority;]]></content>
      <categories>
        <category>Ios</category>
      </categories>
      <tags>
        <tag>Ios</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTML5语义性标签兼容解决]]></title>
    <url>%2F2019%2F03%2F02%2FHTML5%E8%AF%AD%E4%B9%89%E6%80%A7%E6%A0%87%E7%AD%BE%E5%85%BC%E5%AE%B9%E8%A7%A3%E5%86%B3%2F</url>
    <content type="text"><![CDATA[前言现在大部分的浏览器都能够很好的支持H5，但还是不免得有一些浏览器是不能够支持HTML5的新特性及其一些新标签，特别是在IE8以下的浏览器。 兼容办法第一种通过document.createElement(&quot;nav&quot;);的办法来逐个创建标签元素，但是通过其办法还需要定义好其元素的CSS样式。 第二种使用js插件，这里使用的是html5shiv，BootCDN有提供,链接 1&lt;script src="https://cdn.bootcss.com/html5shiv/r29/html5.js"&gt;&lt;/script&gt; 终极解决办法单纯使用第二种的时候，有一些浏览器本身就能够支持，所以在代码中进行判断是否需要该js使用条件Hack 1234&lt;!-- 终极解决方案 --&gt; &lt;!--[if lte IE 8]&gt; &lt;script src="https://cdn.bootcss.com/html5shiv/r29/html5.js"&gt;&lt;/script&gt; &lt;![endif]--&gt; 是否需要兼容可以看业务是否需要，也可以提示用户进行更换浏览器，毕竟IE是个坑爹的浏览器。]]></content>
      <categories>
        <category>HTML</category>
      </categories>
      <tags>
        <tag>HTML</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Objective-C之Block]]></title>
    <url>%2F2019%2F03%2F01%2FObjective-C%E4%B9%8BBlock%2F</url>
    <content type="text"><![CDATA[关于Block在iOS4.0之后，block横空出世，它本身封装了一段代码并将这段代码当做变量，通过block()的方式进行回调。 block的代码是内联的，效率高于函数调用block对于外部变量默认是只读属性block被Objective-C看成是对象处理 对于block的底层实现在网上已经有很多资料了，其源码更是可以在opensource.apple.com上下载，因此，本文更着重于对于block的基本应用。 认识Block Block：带有自动变量的匿名函数，它是C语言的拓展功能，之所以是扩展，是因为C语言不允许存在这样的匿名函数 匿名函数：匿名函数是指不带函数名称的函数 带有自动变量 这是因为Block拥有捕获外部变量的功能，在Block中访问一个外部的局部变量，Block会持有它的临时状态，自动捕获变量值，外部局部变量的变化不会影响它的状态 123456int val = 10;void (^blk)(void) = ^&#123; printf("val=%d\n", val);&#125;;val = 2;blk(); // 这里输出的值是10，而不是2，因为block在实现时就会对它所在方法中定义的栈变量进行一次只读拷贝 为了解决block不能修改自动变量的值，可以使用 __block 修饰 123456__block int val = 10;void (^blk)(void) = ^&#123; printf("val=%d\n", val);&#125;;val = 2;blk(); // 这里输出的值是2 一个简单的block，实现两个数之和 1234int(^sum)(int a, int b) = ^(int a, int b)&#123; return a + b;&#125;;NSLog(@"%d",sum(3,5)); 代码左边是一个block的生命，int为block的返回值类型，^符号后面为block的名称，后面括号里面为参数列表，该block的参数列表有两个，两个都是int类型参数。右边为block的定义。用网上一张图来更好的认识到block。 语法： 由于 Block 的语法是如此的晦涩难记，以至于出现了 fuckingblocksyntax 这样的网站专门用于记录 block 的语法，翻译并摘录如下： 作为变量: 1returnType (^blockName)(parameterTypes) = ^returnType(parameters) &#123;...&#125;; 作为属性: 1@property (nonatomic, copy) returnType (^blockName)(parameterTypes); 作为函数声明中的参数: 1- (void)someMethodThatTakesABlock:(returnType (^)(parameterTypes))blockName; 作为函数调用中的参数: 1[someObject someMethodThatTakesABlock:^returnType (parameters) &#123;...&#125;]; 作为 typedef: 12typedef returnType (^TypeName)(parameterTypes);TypeName blockName = ^returnType(parameters) &#123;...&#125;; Block访问外部基本类型数据静态变量 和 全局变量在加和不加__block都会直接引用变量地址。也就意味着 可以修改变量的值。在没有加__block参数的情况下。 基本类型常量时，看一段代码 1234567891011int main(int argc, const char * argv[]) &#123; @autoreleasepool &#123; // insert code here... CGPoint p = CGPointMake(10, 10); void(^bt)(void) = ^()&#123; NSLog(@"%f , %f", p.x, p.y); &#125;; bt(); &#125; return 0;&#125; 输出122019-03-01 11:35:15.244937+0800 BlockDemo[866:40789] 10.000000 , 10.000000Program ended with exit code: 0 可以看到block可以直接访问到外部的局部变量。但是block内使用外部的变量相当于拷贝了一份外部变量来使用，并不能直接修改外部变量的值，例如 编译器直接进行报错，但是如果想直接修改外部的局部变量的值，那就需要在外部的局部变量前面加上__block的声明。 Block访问外部常量变量NSString *a = @&quot;hello&quot;; a 为常量变量，@“hello”为常量。）—–不加block类型 block 会引用常量的地址（浅拷贝）。加block类型 block会去引用常量变量（如：a变量，a = @”abc”.可以任意修改a 指向的内容。）的地址。 block 会拷贝变量内容到自己的栈内存上，以便执行时可以调用。 但并不是对str 内容做了深拷贝，重新申请内存。 因为str 是栈内存上的变量，指向 一个常量区的@“hello”. 编译器做的优化是 当block 去拷贝str 指向内容时发现是个常量， 所以会去引用 @“hello” 的指针，没必要再取申请一块内存。 Block访问外部对象变量如（MyClass class、Block block）。 这里block 也是”类“对象（类似对象，其包含isa指针,clang 反编译可以查看。因为它不像从NSObject 继承下来的对象都支持 retain、copy、release）。* Block的copy、retain、release操作不同于NSObjec的copy、retain、release操作： Block_copy与copy等效，Block_release与release等效； Block_copy与copy等效，Block_release与release等效； 对Block不管是retain、copy、release都不会改变引用计数retainCount，retainCount始终是1； NSGlobalBlock：retain、copy、release操作都无效； NSStackBlock：retain、release操作无效，必须注意的是，NSStackBlock在函数返回后，Block内存将被回收。即使retain也没用。容易犯的错误是[[mutableAarry addObject:stackBlock]，在函数出栈后，从mutableAarry中取到的stackBlock已经被回收，变成了野指针。正确的做法是先将stackBlock copy到堆上，然后加入数组：[mutableAarry addObject:[[stackBlock copy] autorelease]]。支持copy，copy之后生成新的NSMallocBlock类型对象 NSMallocBlock支持retain、release，虽然retainCount始终是1，但内存管理器中仍然会增加、减少计数。copy之后不会生成新的对象，只是增加了一次引用，类似retain； 尽量不要对Block使用retain操作 Block的使用场景 声明Block属性 利用Block属性响应事件或传递数据 UIViewController 需要监听TableView中Cell的某个按钮的点击事件，既可以通过Delegate回调，也可以利用Block回调 Block回调的思路： 声明一个Block属性，注意这里要用copy。 利用Block属性进行回调。 方法参数为Block 利用Block实现回调 以 [UIView animateWithDuration:animations:] 为例，animations是一个block对象，利用block实现调用者与UIView之间的数据传递 链式语法 链式编程思想：将block作为方法的返回值，且返回值的类型为调用者本身，并将该方法以setter的形式返回，从而实现连续调用 12345678910111213141516171819202122232425262728293031323334353637// CaculateMaker.h// ChainBlockTestApp#import &lt;Foundation/Foundation.h&gt;#import &lt;UIKit/UIKit.h&gt;@interface CaculateMaker : NSObject@property (nonatomic, assign) CGFloat result;/** 返回类型 CaculateMaker* 传入参数 CGFloat num*/- (CaculateMaker *(^)(CGFloat num))add;@end// CaculateMaker.m// ChainBlockTestApp#import "CaculateMaker.h"@implementation CaculateMaker- (CaculateMaker *(^)(CGFloat num))add;&#123; return ^CaculateMaker *(CGFloat num)&#123; _result += num; return self; &#125;;&#125;@end// 使用CaculateMaker *maker = [[CaculateMaker alloc] init];maker.add(20).add(30); 为什么Block属性需要用copy修饰？因为在MRC情况下如果Block属性不使用copy修饰，在使用中会出现崩溃，在ARC情况下，Block属性使用strong修饰会被默认进行copy，所以ARC情况下，Block属性可以使用strong或copy修饰，不然会出现崩溃。 Block在内存中的位置分为三种类型： NSGlobalBlock 是位于全局区的block，它是设置在程序的数据区中。 NSStackBlock 是位于栈区，当超出变量作用域时，栈上的Block以及__block变量都会被销毁。 NSMallocBlock 是位于堆区，在变量作用域结束时不受影响。 这三种类型对应以下三种情况： Block中没有截获自动变量时Block类型是__NSGlobalBlock__ Block中截获自动变量时Block类型是__NSStackBlock__ 堆中的Block无法直接创建，当对__NSStackBlock__类型的Block进行copy时，会将Block放到堆中，Block类型变为__NSMallocBlock 当Block类型是__NSStackBlock__时，一旦超出了变量作用域，栈上的Block以及__block变量就会被销毁，从而导致调用Block回调时崩溃。因此，Block属性需要用copy修饰来避免这种情况。 123456789101112131415161718192021222324252627282930313233343536- (void)click:(id)sender &#123; TestClass *test = [[TestClass alloc] init]; __block int a = 1; // 弱引用，block类型是__NSStackBlock__ 当TestClass执行回调时必崩 EXC_BAD_ACCESS test.weakBlock = ^() &#123; NSLog(@"ok"); a = 2; &#125;; // block类型是__NSStackBlock__ 当TestClass执行回调时必崩 EXC_BAD_ACCESS test.assignBlock = ^() &#123; NSLog(@"ok"); a = 3; &#125;; // block类型是__MallocBlock__ 正常执行 test.copyBlock = ^() &#123; NSLog(@"ok"); a = 4; &#125;; // block类型是__MallocBlock__ 正常执行 test.strongBlock = ^() &#123; NSLog(@"ok"); a = 5; &#125;; NSLog(@"copy property: %@", test.copyBlock); NSLog(@"assign property: %@", test.assignBlock); NSLog(@"weak property: %@", test.weakBlock); NSLog(@"strong property: %@", test.strongBlock); [test start];&#125; Block循环引用我们先看一段block导致循环引用的代码： 123@interface XYZBlockKeeper : NSObject@property (copy) void (^block)(void);@end 123456789@implementation XYZBlockKeeper- (void)configureBlock &#123; self.block = ^&#123; [self doSomething]; // capturing a strong reference to self // creates a strong reference cycle &#125;;&#125;...@end block 在捕获外部变量的时候，会保持一个强引用，当在 block 中捕获 self 时，由于对象会对 block 进行 copy，于是便形成了强引用循环： 为了避免强引用循环，最好捕获一个 self 的弱引用： 1234567- (void)configureBlock &#123; XYZBlockKeeper * __weak weakSelf = self; self.block = ^&#123; [weakSelf doSomething]; // capture the weak reference // to avoid the reference cycle &#125;&#125; 使用弱引用会带来另一个问题，weakSelf 有可能会为 nil，如果多次调用 weakSelf 的方法，有可能在 block 执行过程中 weakSelf变为 nil。因此需要在 block 中将 weakSelf “强化“ 12345678__weak __typeof__(self) weakSelf = self;NSBlockOperation *op = [[[NSBlockOperation alloc] init] autorelease];[ op addExecutionBlock:^ &#123; __strong __typeof__(self) strongSelf = weakSelf; [strongSelf doSomething]; [strongSelf doMoreThing];&#125; ];[someOperationQueue addOperation:op]; __strong 这一句在执行的时候，如果 WeakSelf 还没有变成 nil，那么就会 retain self，让 self 在 block 执行期间不会变为 nil。这样上面的 doSomething 和 doMoreThing 要么全执行成功，要么全失败，不会出现一个成功一个失败，即执行到中间 self 变成 nil 的情况。 并非所有的block都存在循环引用，下面列举一些常见的block使用的示例： 12345678910111213141516171819202122// self--&gt;requestModel--&gt;block--&gt;self [self.requestModel requestData:^(NSData *data) &#123; self.name = @"leafly";&#125;];// 虽然存在引用环，但是通过主动释放requestModel打破了循环[self.requestModel requestData:^(NSData *data) &#123; self.name = @"leafly"; self.requestModel = nil;&#125;];// t--&gt;block--&gt;self 不存在循环引用Test *t = [[Test alloc] init];[t requestData:^(NSData *data) &#123; self.name = @"leafly";&#125;];// AFNetworking--&gt;block--&gt;self 不存在循环引用[AFNetworking requestData:^(NSData *data) &#123; self.name = @"lealfy";&#125;]; 总结Block的特性也赋予了它许多的灵活性，但是也会出现很多的一些内存泄漏，不易调试的问题，还要多多深入探究。]]></content>
      <categories>
        <category>Ios</category>
      </categories>
      <tags>
        <tag>Ios</tag>
        <tag>Objective-C</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IOS基础 - WKWebView使用]]></title>
    <url>%2F2019%2F02%2F28%2FIOS%E5%9F%BA%E7%A1%80-WKWebView%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[WKWebView对比UIWebView的优势 1.WKWebView的内存开销要比UIWebView小很多2.拥有高达60FPS滚动刷新率及内置手势3.支持了更多的HTML5特性4.html页面和WKWebView交互更方便5.Safari相同的JavaScript引擎6.提供常用的属性，如加载网页进度的属性estimatedProgress 基本使用倒入库 引入头文件#import &lt;WebKit/WebKit.h&gt; 初始化123456789101112131415161718192021222324@interface MainViewController () &lt;WKNavigationDelegate&gt;@property(strong, nonatomic) WKWebView *webview;@end@implementation MainViewController- (void)viewDidLoad &#123; [super viewDidLoad]; // Do any additional setup after loading the view. WKWebView *wv = [[WKWebView alloc] init]; wv.navigationDelegate = self; [self.view addSubview:wv]; [wv mas_makeConstraints:^(MASConstraintMaker *make) &#123; make.top.equalTo(wv.superview.mas_top).with.offset(0); make.left.equalTo(wv.superview.mas_left).with.offset(0); make.right.equalTo(wv.superview.mas_right).with.offset(0); make.bottom.equalTo(wv.superview.mas_bottom).with.offset(0); &#125;]; self.webview = wv; //加载网页 [self.webview loadRequest:[NSURLRequest requestWithURL:[NSURL URLWithString:@"https://www.baidu.com"]]];&#125; 关于WKWebView的代理WKNavigationDelegate12345678910111213141516171819202122#pragma mark - WKNavigationDelegate// 页面开始加载时调用- (void)webView:(WKWebView *)webView didStartProvisionalNavigation:(WKNavigation *)navigation;// 当内容开始到达时调用- (void)webView:(WKWebView *)webView didCommitNavigation:(WKNavigation *)navigation;// 页面加载完成之后调用- (void)webView:(WKWebView *)webView didFinishNavigation:(WKNavigation *)navigation;// 页面加载失败时调用- (void)webView:(WKWebView *)webView didFailProvisionalNavigation:(WKNavigation *)navigation withError:(NSError *)error;//收到服务器重定向请求后调用- (void)webView:(WKWebView *)webView didReceiveServerRedirectForProvisionalNavigation:(WKNavigation *)navigation;// 在收到响应开始加载后，决定是否跳转- (void)webView:(WKWebView *)webView decidePolicyForNavigationResponse:(WKNavigationResponse *)navigationResponse decisionHandler:(void (^)(WKNavigationResponsePolicy))decisionHandler;// 在请求开始加载之前调用，决定是否跳转- (void)webView:(WKWebView *)webView decidePolicyForNavigationAction:(WKNavigationAction *)navigationAction decisionHandler:(void (^)(WKNavigationActionPolicy))decisionHandler; WKUIDelegate12345678910- (nullable WKWebView *)webView:(WKWebView *)webView createWebViewWithConfiguration:(WKWebViewConfiguration *)configuration forNavigationAction:(WKNavigationAction *)navigationAction windowFeatures:(WKWindowFeatures *)windowFeatures;// 在js中调用alert函数时，会调用该方法。- (void)webView:(WKWebView *)webView runJavaScriptAlertPanelWithMessage:(NSString *)message initiatedByFrame:(WKFrameInfo *)frame completionHandler:(void (^)(void))completionHandler;// 在js中调用confirm函数时，会调用该方法- (void)webView:(WKWebView *)webView runJavaScriptConfirmPanelWithMessage:(NSString *)message initiatedByFrame:(WKFrameInfo *)frame completionHandler:(void (^)(BOOL result))completionHandler;// 在js中调用prompt函数时，会调用该方法- (void)webView:(WKWebView *)webView runJavaScriptTextInputPanelWithPrompt:(NSString *)prompt defaultText:(nullable NSString *)defaultText initiatedByFrame:(WKFrameInfo *)frame completionHandler:(void (^)(NSString * __nullable result))completionHandler;]]></content>
      <categories>
        <category>Ios</category>
      </categories>
      <tags>
        <tag>Ios</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[解决AndroidStudio导入项目在 Building gradle project info 一直卡住]]></title>
    <url>%2F2019%2F02%2F28%2F%E8%A7%A3%E5%86%B3AndroidStudio%E5%AF%BC%E5%85%A5%E9%A1%B9%E7%9B%AE%E5%9C%A8-Building-gradle-project-info-%E4%B8%80%E7%9B%B4%E5%8D%A1%E4%BD%8F%2F</url>
    <content type="text"><![CDATA[Android studio一个小小的痛点 解决AndroidStudio导入项目在 Building gradle project info 一直卡住Android Studio导入项目的时候，一直卡在Building gradle project info这一步，主要原因还是因为被墙的结果。gradle官网虽然可以访问，但是速度连蜗牛都赶不上… 三种解决办法离线包下载导入方式查看所需gradle版本：打开C:\Users\用户名\.gradle\wrapper\dists\gradle-x.xx-all\xxxxxxxxxxxx，如果里面的gradle-xx-all.zip不完整（如0KB），则说明下载不成功，需要下载离线包放置到该目录下。 下载地址：https://services.gradle.org/distributions/ 修改gradle-wrapper.properties方式1、随便找一个你之前能够运行的AS项目 2、打开项目的/gradle/wrapper/gradle-wrapper.properties文件 3、复制最后一行distributionUrl这一整行的内容，例如：distributionUrl=https\://services.gradle.org/distributions/gradle-2.8-all.zip，替换到你要导入的项目里的gradle-wrapper.properties文件中。 4、重启Android Studio，重新导入项目就可以了~~ 翻墙翻开中国伟大的墙就可以了。本人一直用的蓝灯。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Android Studio</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mac安装Mysql教程]]></title>
    <url>%2F2019%2F02%2F25%2FMac%E5%AE%89%E8%A3%85Mysql%E6%95%99%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[环境 MacOS10以上 下载Mysql这里以Mysql5.7为例 官网为了方便开发，推荐直接选择dmg文件下载安装 安装Mysql直接双击即可，傻瓜式操作。 注意，安装成功后会弹出一个对话框，你直接忽略了可以看通知面板，这个就是Mysql的初始密码如图 启动Mysql安装完毕后系统偏好设置会多出一个选项 点击进去 安装之后，默认MySQL的状态是stopped，关闭的，需要点击“Start MySQL Server”按钮来启动它，启动之后，状态会变成running。下方还有一个复选框按钮，可以设置是否在系统启动的时候自动启动MySQL，默认是勾选的，建议取消，节省开机时间。 终端连接Mysql1vim ~/.bash_profile 添加export PATH=${PATH}:/usr/local/mysql/bin即可 登陆Mysql1mysql -uroot -p 输入刚开始安装对话框中提示的初始密码，登陆成功后请修改密码，否则无法执行其他命令。 1ALTER USER 'root'@'localhost' IDENTIFIED BY 'newpassword';]]></content>
      <categories>
        <category>DBA</category>
      </categories>
      <tags>
        <tag>Mysql</tag>
        <tag>环境搭建</tag>
        <tag>Mac</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mac使用HomeBrew安装Composer]]></title>
    <url>%2F2019%2F02%2F25%2FMac%E4%BD%BF%E7%94%A8HomeBrew%E5%AE%89%E8%A3%85Composer%2F</url>
    <content type="text"><![CDATA[环境 MacOS10以上 安装HomeBrewhomebrew官网 链接 1/usr/bin/ruby -e "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)" 回车安装即可 安装Composer1brew install composer 安装完毕后composer可能不是最新版本，也可以升级 1composer self-update 修改Packagist 镜像修改 composer 的全局配置文件 打开命令行窗口（windows用户）或控制台（Linux、Mac 用户）并执行如下命令：1composer config -g repo.packagist composer https://packagist.phpcomposer.com 使用composer举例我要引用phalcon的开发工具包。在项目文件夹下新建文件composer.json，并添加如下代码 12345&#123; &quot;require&quot;: &#123; &quot;phalcon/devtools&quot;: &quot;dev-master&quot; &#125;&#125; 运行 1composer update 项目文件夹下就会有vendor文件夹，依赖文件都在这下面啦。使用时直接包含autoload.php就可以了 1require 'vendor/autoload.php'; 更多命令可以直接查看官方文档http://docs.phpcomposer.com/03-cli.html 参考链接： https://www.jianshu.com/p/2b96cc9f593e https://pkg.phpcomposer.com/ https://getcomposer.org/]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>环境搭建</tag>
        <tag>Homebrew</tag>
        <tag>Mac</tag>
        <tag>Composer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mac使用HomeBrew安装Maven]]></title>
    <url>%2F2019%2F02%2F20%2FMac%E4%BD%BF%E7%94%A8HomeBrew%E5%AE%89%E8%A3%85Maven%2F</url>
    <content type="text"><![CDATA[环境 MacOS10以上 jdk1.6或以上 安装HomeBrewhomebrew官网 链接 1/usr/bin/ruby -e "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)" 回车安装即可 安装Maven12345678$ brew search maven==&gt; Formulaemaven ✔ maven-shell maven@3.3maven-completion maven@3.2 maven@3.5==&gt; Caskshomebrew/cask-fonts/font-maven-pro$ brew install maven 验证maven是否安装成功1mvn -v 配置Maven仓库setting.xml路径为/usr/local/Cellar/maven/3.5.0/libexec/conf/settings.xml修改即可。 可将settings.xml直接拷贝到.m2文件夹下，进行配置。 ~~如果没有.m2文件夹时,运行命令1$ mvn help:system 然后打开当前用户的目录，可以在其中找到.m2文件夹~~]]></content>
      <categories>
        <category>Maven</category>
      </categories>
      <tags>
        <tag>环境搭建</tag>
        <tag>Homebrew</tag>
        <tag>Mac</tag>
        <tag>Maven</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CocoaPods简单安装和使用]]></title>
    <url>%2F2019%2F01%2F18%2FCocoaPods%E7%AE%80%E5%8D%95%E5%AE%89%E8%A3%85%E5%92%8C%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[什么是CocoaPodsCocoaPods是专门为iOS工程提供对第三方库的依赖的管理工具，通过CocoaPods，我们可以更方便地管理每个第三方库的版本，而且不需要我们做太多的配置。直观、集中和自动化地管理我们项目的第三方库。 安装CocoaPods更新gem1sudo gem update --system 更换镜像删除自带镜像1gem sources --remove https://rubygems.org/ 更换1gem sources -a https://gems.ruby-china.com/ 查看1gem sources -l 如图显示即为替换镜像成功 安装1sudo gem install cocoapods 配置1pod setup 到这里CocoaPods就已经安装完毕了。 使用CocoaPods查找第三方库比如说要查找某个库，直接在终端输入 1pod search QMUIKit 完成后他会自动进入一个新的页面显示搜索结果，上下滑动查看更多，要退出的话按wq就可以了。以后再搜索就不需要建索引了。 引入第三方库到项目中这里演示第三方库为QMUIKit 打开xcode新建一个项目，打开终端，进入项目路径中。 输入1pod init 将自动生成一个Podfile文件，也可以自己生成，命令生成有默认模板 vim编写,添加qmuikit 安装第三方库1pod install 查看项目目录变化 在访达中 原本使用xcodeproj打开项目，但是现在要改变成xcworkspace打开项目了。 这样就可以正常使用该库啦。但是有时候没有只能提示时候，需要更改Build Settings中的User header search paths添加$(SRCROOT)并选择recursive 增加第三方继续编写Podfile文件添加第三方库然后在执行pod install就可以了 更新第三方第三方库们都有人在维护升级，我们需要隔断时间就要更新下我们工程中第三方库的版本。只需要终端输入命令pod update就可以了。如果遇到pod install或者pod update慢的问题，原因在于当执行以上两个命令的时候会升级CocoaPods的spec仓库，加一个参数可以省略这一步，然后速度就会提升不少。加参数的命令如下： 12pod install --verbose --no-repo-updatepod update --verbose --no-repo-update 删除第三方当我们需要去掉某个第三方库时，只需要在Podfile删除该引入该库的语句，然后执行pod update或者pod install就可以了。 升级CocoaPods升级CocoaPods版本的命令和安装CocoaPods的命令一样，都是1sudo gem install cocoapods 卸载CocoaPods卸载CocoaPods的命令是1sudo gem uninstall cocoapods CocoaPods Mac AppCocoaPods桌面应用版下载地址：https://cocoapods.org/app 参考 https://juejin.im/entry/5c067eb56fb9a04a0a5ef583?utm_source=gold_browser_extension https://guides.cocoapods.org/syntax/podfile.html#podfile]]></content>
      <categories>
        <category>Ios</category>
      </categories>
      <tags>
        <tag>Ios</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Tomcat基本使用]]></title>
    <url>%2F2018%2F11%2F21%2FTomcat%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[下载安装到apache官网。www.apache.org http://jakarta.apache.org(产品的主页) 安装版：window （exe、msi） linux（rmp）压缩版：window（rar，zip） linux（tar，tar.gz） 学习时候使用 运行和关闭tomcat启动软件a）找到%tomcat%/bin/startup.bat ，双击这个文件b）弹出窗口，显示信息（不要关闭次窗口）c）打开浏览器，输出以下地址 http://localhost:8080d）看到一只猫画面，证明软件启动成功！ 关闭软件a）找到%tomcat%/bin/shutdown.bat，双击这个文件即可！b）打开浏览器，输出以下地址。看到“无法连接”（最好先清空浏览器缓存） Tomcat目录结构bin存放常用tomcat命令 conf存放server配置文件 lib自带jar包 logs存放日志 temp存放临时文件 webapps存放共享资源目录 work工作空间 Tomcat常见问题一闪而过配置好JDK环境即可，即JAVA_HOME,PATH，CLASSPATH环境变量即可。 端口占用的错误原因： tomcat启动所需的端口被其他软件占用了！解决办法：a）关闭其他软件程序，释放所需端口b）修改tomcat软件所需端口找到并修改%tomcat%/conf/server.xml文件 123&lt;Connector port="8081" protocol="HTTP/1.1" connectionTimeout="20000" redirectPort="8443" /&gt; CATALINA环境变量问题原因： tomcat软件启动后，除了查找JAVA_HOME后，还会再查找一个叫CATALINA_HOME变量，这个变量的作用是设置tomcat的根目录。解决办法：建议不要设置CATALINA_HOME变量。检查如果有的话，清除掉！！！]]></content>
      <categories>
        <category>Tomcat</category>
      </categories>
      <tags>
        <tag>环境搭建</tag>
        <tag>Tomcat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[单例模式-JAVA实现]]></title>
    <url>%2F2018%2F11%2F20%2F%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F-JAVA%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[单例模式什么是单例？就是保证在一个jvm当中只能由一个实例。（区分不是在多个jvm当中。） 单例模式有七种写法。 本文只提出两种，一种懒汉式和饿汉式。 懒汉式123456789101112131415161718192021222324252627public class Single &#123; public static void main(String[] args) &#123; System.out.println(Singleton.getInstance()); System.out.println(Singleton.getInstance()); System.out.println(Singleton.getInstance()); System.out.println(Singleton.getInstance()); &#125;&#125;class Singleton &#123; private static Singleton mSingleton; private Singleton()&#123;&#125; public static Singleton getInstance() &#123; if (mSingleton == null) &#123; synchronized (Singleton.class) &#123; //加锁，线程不安全，故加上 mSingleton = new Singleton(); &#125; &#125; return mSingleton; &#125;&#125; 1234cn.net.sweetlover.patern.Singleton@1540e19dcn.net.sweetlover.patern.Singleton@1540e19dcn.net.sweetlover.patern.Singleton@1540e19dcn.net.sweetlover.patern.Singleton@1540e19d 被需要时才进行初始化，且只有同一个实例，但会发生线程不安全。 饿汉式12345678910111213141516171819202122public class Single &#123; public static void main(String[] args) &#123; System.out.println(Singleton.getInstance()); System.out.println(Singleton.getInstance()); System.out.println(Singleton.getInstance()); System.out.println(Singleton.getInstance()); &#125;&#125;class Singleton &#123; private final static Singleton mSingleton = new Singleton(); private Singleton()&#123;&#125; public static Singleton getInstance() &#123; return mSingleton; &#125;&#125; 1234cn.net.sweetlover.patern.Singleton@1540e19dcn.net.sweetlover.patern.Singleton@1540e19dcn.net.sweetlover.patern.Singleton@1540e19dcn.net.sweetlover.patern.Singleton@1540e19d 这两者的区分：懒汉式不是线程安全的，且效率比饿汉式要低（因为加了同步），但是节约内存。但饿汉式是天生线程安全的，因为当class被加载的时候就已经被初始化了。]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>JAVA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[kafka简单入门(概念)]]></title>
    <url>%2F2018%2F11%2F05%2Fkafka%E7%AE%80%E5%8D%95%E5%85%A5%E9%97%A8-%E6%A6%82%E5%BF%B5%2F</url>
    <content type="text"><![CDATA[kafka简介Kafka是目前主流的流处理平台，同时作为消息队列家族的一员，其高吞吐性作为很多场景下的主流选择。 什么是Kafka LinkedIn开发 2011年初开源，加入Apache基金会 2012年从Apache Incubator毕业 Apache顶级开源 Apache Kafka是一个分布式流媒体平台。这到底是什么意思呢？ 流媒体平台有三个关键功能： 发布和订阅记录流，类似于消息队列或者企业消息传递系统。 以容错的持久方式存储记录流。 记录发生时处理流。 Kafka通常用于两大类应用： 构建可在系统或应用程序之间可靠获取数据的实时流数据管道 构建转换或响应数据流的实时流应用程序 Kafka概念Producer消息和数据的生产者，向Kafka的一个topic发布消息的进程/代码/服务。 Consumer消息和数据的消费者，订阅数据（topic）并且处理其发布的消息的进程/代码/服务。 Consumer Group对于同一个topic，会广播给不同的group，一个group中，只有 一个consumer 可以消费该消息。 Broker物理概念，Kafka集群中每个kafka节点。 Topic逻辑概念，Kafka消息的类别，对数据进行区分、隔离。 Partition物理概念，Kafka下数据存储的基本单元。一个Topic数据，会被分散存储到多个Partition，每个Partition是 有序的 。 每一个Topic被切分为多个Partitions 消费者数目少于或者等于Partition的数目 Broker Group中的每一个Broker保存Topic的一个或多个Partitions Consumer Group的仅有一个Consumer读取Topic的一个或者多个Partitions，并且是唯一的Consumer Replication一个partition的多个副本。同一个Partition可能有多个Replica，多个Replica之间数据是一样的，相当于备份一样。 当集群中有Broker挂掉的情况，系统可以主动的使Replicas提供服务 系统默认设置每一个Topic的Replication系数为1，可以在创建Topic单独设置 特点 基本单位是Topic的Partition 所有的读和写都从Leader进，Followers只是作为备份 Follower必须能够及时复制Leader的数据 增加容错性和可扩展性。 Replication Leader一个Partition的多个Replica上，需要一个Leader负责该Partition上的Producer和Consumer交互。且有且只有一个。 ReplicaManager负责管理当前Broker所有分区的副本的信息，处理KafkaController发起的一些请求，副本状态的切换、添加/读取消息等。]]></content>
      <categories>
        <category>消息队列</category>
      </categories>
      <tags>
        <tag>kafka</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android点击两次返回退出应用]]></title>
    <url>%2F2018%2F10%2F30%2FAndroid%E7%82%B9%E5%87%BB%E4%B8%A4%E6%AC%A1%E8%BF%94%E5%9B%9E%E9%80%80%E5%87%BA%E5%BA%94%E7%94%A8%2F</url>
    <content type="text"><![CDATA[在一些app中，一般都是主页面都会有一个连续点击两次返回键就能够退出，也是防止返回键误触导致直接退出了应用。示例没有复杂的activity管理，点击两次后直接finish就完成了。 思路直接判断用户两次按键的时间差是否在一个预期值之内，是则退出，否则应该出现一些提示来提醒用户。 12345678910111213141516171819202122232425262728293031public class MainActivity extends BaseActivity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); &#125; //记录用户首次点击返回键的时间 private long mExitFirstTime = 0; //双击间隔 private long mExitIntervalMs = 2000; @Override public boolean onKeyUp(int keyCode, KeyEvent event) &#123; switch (keyCode)&#123; case KeyEvent.KEYCODE_BACK: long secondTime = System.currentTimeMillis(); if(secondTime - mExitFirstTime &gt; mExitIntervalMs)&#123; mExitFirstTime = secondTime; Toast.makeText(MainActivity.this, R.string.exit_tip, Toast.LENGTH_SHORT) .show(); return true; //消费掉该事件 &#125;else&#123; finish(); &#125; break; &#125; return super.onKeyUp(keyCode, event); &#125;&#125; 重写onKeyDown()和onBackPressed()方法都能捕获Back的点击事件，]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[正则表达式]]></title>
    <url>%2F2018%2F09%2F28%2F%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[参考链接: https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Regular_Expressions 特殊字符 字符 含义 \ 匹配规则将依照下列规则：在非特殊字符之前的反斜杠表示下一个字符是特殊的，不能从字面上解释。例如，没有前面’\’的’b’通常匹配小写’b’，无论它们出现在哪里。如果加了’\’,这个字符变成了特殊意义的字符，意思是匹配一个字符边界。反斜杠也可以将其后的特殊字符，转义为字面量。例如，模式 /a/ 代表会匹配0个或者多个a。相反，模式 /a\/ 将 ‘‘ 的特殊性移除，从而可以匹配像 “a“ 这样的字符串。 ^ 匹配输入的开始，如果多行标志被设置为true，那么也匹配换行符后紧跟的位置。例如, /^A/ 并不匹配 “an A” 中的 ‘A’，但是会匹配 “An E”中的 ‘A’。当 ‘^’ 作为第一个字符出现在一个字符集合模式时，它将会有不同的含义。 $ 匹配输入的结束。如果多行标志被设置为true，那么也匹配换行符前的位置。例如， /t$/ 并不会匹配 “eater” 中的 ‘t’,但是会匹配 “eat” 中的 ‘t’。 * 匹配前一个表达式0次或者多次。等价于{0,}。例如，/bo*/ 会匹配”A ghost boooooed”中的 ‘booooo’ 和 “A bird warbled” 中的 ‘b’，但是在”A goat grunted” 中将不会匹配任何东西。 + 匹配前面一个表达式1次或者多次。等价于{1,}。例如，/a+/匹配了在”candy”中的’a’，和在”caaaaaaandy”中所有的’a’。 ? 匹配前面一个表达式0次或者1次。等价于{0,1}。例如，/e?le?/ 匹配”angel”中的’el’，和”angel”中的’el’，和”angle”中的’le’以及”oslo”中的’l’。如果紧跟在任何量词*、+、?或者{}的后面，将会使变量变为非贪婪的（匹配尽量少的字符），和缺省使用的贪婪模式（匹配尽可能多的字符）正好相反。例如，对”123abc”应用 /\d+/ 将会返回’123’，如果使用/\d+?/，则只会匹配到’1’。还可以运用先行断言。 . (小数点)匹配除换行符之外的任何单个字符。例如，/.n/将会匹配”nay, an apple is on the tree”中的’an’和’on’，但是不会匹配’nay’。 (x) 匹配’x’并且记住匹配项，就像下面的例子展示的那样。括号被称为捕获括号。模式 /(foo) (var) \1 \2/中的’(foo)’和’(bar)’匹配并记住字符串”foo bar foo bar”中的前两个单词，模式中的\1 和 \2 匹配字符串的后两个单词。注意\1、\2、\n是用在正则表达式的匹配环节。 (?:x) 匹配’x’但是不记住匹配项。这种叫做非捕获括号，使得你能够定义为正则表达式运算符一起使用的子表达式。来看表达式/(?:foo){1,2}/。如果表达式是/foo{1,2}/，{1,2}将只对’foo’的最后一个字符’o’生效。如果使用非捕获括号，则{1,2}会匹配整个’foo’单词。 x(?=y) 匹配’x’仅仅当’x’后面跟着’y’，这种叫做正向肯定查找。例如，/Jack(?=Spart)/会匹配到’Jack’仅仅当他后面跟着’Spart’。/Jack(?=Spart&#124;Frost)/匹配’Jack’仅仅当它后面跟着’Spart’或者是’Frost’。但是’Spart’和’Frost’都不是匹配结果的一部分。 x(?!y) 匹配’x’仅仅当’x’后面不跟着’y’，这个叫做正向否定查找。例如，/\d+(?!.)/匹配一个数字仅仅当这个数字后面没有跟小数点的时候。 x&#124;y 匹配’x’或者’y’。例如，/green&#124;red/匹配”green apple”中的’green’和”red apple”中的’red’ {n} n是一个正整数，匹配了前面一个字符刚好发生n次。 比如，/a{2}/不会匹配”candy”中的’a’，但是会匹配”caandy”中的所有a，以及”caaandy”中的前两个a。 {n,m} n,m都是整数。匹配前面的字符至少n次，最多m次。如果n和m的值为0，这个值被忽略。例如，/a{1,3}/ 并不匹配”cndy”中的任意字符，匹配”candy”中的’a’，匹配”caandy”中的前两个’a’，也匹配”caaaaaaaandy”中的前三个a。 [xyz] 一个字符集合。匹配方括号中的任意字符，包括转义字符。你可以使用破折号( - )来指定一个字符范围。对于( . )和星号( * )这样的特许符号在一个字符集中没有特殊的意义/他们不必进行转义，不过转义也是起作用的。例如，[abcd]和[a-d]是一样的。他们都匹配”brisket”中的’b’，也都匹配”city”中的’c’。/[a-z.]+/和/[\w.]+/都匹配”test.i.ng”中的所有字符。 [^xyz] 反向字符集。也就是说，它匹配任何没有包含在反括号中的字符。你可以使得破折号( - )来指定一个字符范围。任何普通字符在这里都是起作用的。例如，[^abc]和[^a-c]是一样的。他们匹配”brisker”中的’r’，也匹配”chop”中的’h’。 [\b] 匹配一个退格（U+0008）。不要和\b混淆了。 \b 匹配一个词的边界。一个词的边界就是一个词不被另外一个“字”字符跟随的位置或者没有其他“字”字符在其前面的位置。注意，一个匹配的词的边界并不包含在匹配的内容中。换句话说，一个匹配的词的边界的内容的长度为0.（不要和[\b]混淆了）。例如，/\bm/匹配”moon”中的”m”，/oo\b/并不匹配”oo”，因为’oo’被一个字符’n’紧跟着。/oon\b/匹配”moon”中的’oon’，因为’oon’是这个字符串的结束部分，这样他没有被一个字符紧跟着。/\w\b\w/将不能匹配任何字符串，因为在一个单词中间的字符永远不可能同时满足没有字符跟随和有字符跟随的两种跟随情况。 \B 匹配一个非单词边界。他匹配一个前后字符都是相同类型的位置：都是字符或者都不是字符。一个字符串的开始和结尾都被认为不是字符或者空字符串。例如，/\B../匹配”noonday”中的’oo’，而/y\B../则会匹配”possibly yestarday”中的’yes’。 \cX 当X是处于A到Z之间的字符的时候。匹配字符串中的一个控制符。例如，/\cM/匹配字符串中的”control-M”(U+000D)。 \d 匹配一个数字，相当于[0-9]。例如，/\d/或者/[0-9]/匹配”B2 is the bigjj”中的’2’。 \D 匹配一个非数字字符。相当于[^0-9]。例如，/\D/或者/[^0-9]/匹配”B2 is a jj”中的B。 \f 匹配一个换页符(U+000C)。 \n 匹配一个换行符(U+000A)。 \r 匹配一个回车符(U+000D)。 \s 匹配一个空白字符，包括空格、制表符、换页符和换行符。等价于[\f\n\r\t\v\u00a0\u1680\u1680\u180e\u2000-\u200a\u2028\u2029\u202f\u205f\u3000\ufeff]。例如，/\s\w*/匹配”foo bar.”中的’bar’。 \S 匹配一个非空白字符。等价于[^\f\n\r\t\v\u00a0\u1680\u1680\u180e\u2000-\u200a\u2028\u2029\u202f\u205f\u3000\ufeff]。例如，/\S\w*/匹配”foo bar.”中的’foo’。 \t 匹配一个水平制表符(U+0009)。 \v 匹配一个垂直制表符(U+000B)。 \w 匹配一个单字字符(字母、数字或者下划线)。等价于[A-Za-Z0-9_]。例如，/\w/匹配”apple”中的’a’，”$5.28”中的’5’和”3D”中的’3’。 \W 匹配一个非单字字符。等价于[^A-Za-z0-9_]。例如，/\W/或者/[^A-Za-z0-9_]/匹配”50%”中的’%’。 \n 在正则表达式中，它返回最后的第n个子捕获匹配的子字符串(捕获的数目以左括号计数)。比如/apple(,)\sorange\1/匹配”apple, orange, cherry, peach.”中的’apple, orange’。 \0 匹配NULL(U+0000)字符，不要在这后面跟其它小数，因为0&lt;digits&gt;是一个八进制转义序列。 \xhh 与代码hh匹配字符(两个十六进制数字)。 \uhhhh 与代码hhhh匹配字符(四个十六进制数字)。 \u{hhhh} (仅当设置了u标志时)使用Unicode值hhhh匹配字符(十六进制数字)。 正则表达式标志 标志 描述 g 全局搜索。 i 不区分大小写搜索。 m 多行搜索。 y 执行“粘性”搜索,匹配从目标字符串的当前位置开始，可以使用y标志。 常用正则表达式校验数字的表达式 数字：^[0-9]*$ n位的数字：^\d{n}$ 至少n位的数字：^\d{n,}$ m-n位的数字：^\d{m,n}$ 零和非零开头的数字：^(0|[1-9][0-9]*)$ 非零开头的最多带两位小数的数字：^([1-9][0-9]*)+(.[0-9]{1,2})?$ 带1-2位小数的正数或负数：^(-)?\d+(.\d{1,2})$ 正数、负数、和小数：^(-|+)?\d+(.\d+)?$ 有两位小数的正实数：^[0-9]+(.[0-9]{2})?$ 有1~3位小数的正实数：^[0-9]+(.[0-9]{1,3})?$ 非零的正整数：^[1-9]\d$ 或 ^([1-9][0-9]){1,3}$ 或 ^+?[1-9][0-9]*$ 非零的负整数：^-[1-9][]0-9”$ 或 ^-[1-9]\d$ 非负整数：^\d+$ 或 ^[1-9]\d*|0$ 非正整数：^-[1-9]\d*|0$ 或 ^((-\d+)|(0+))$ 非负浮点数：^\d+(.\d+)?$ 或 ^[1-9]\d.\d|0.\d[1-9]\d|0?.0+|0$ 非正浮点数：^((-\d+(.\d+)?)|(0+(.0+)?))$ 或 ^(-([1-9]\d.\d|0.\d[1-9]\d))|0?.0+|0$ 正浮点数：^[1-9]\d.\d|0.\d[1-9]\d$ 或 ^(([0-9]+.[0-9][1-9][0-9])|([0-9][1-9][0-9].[0-9]+)|([0-9][1-9][0-9]))$ 负浮点数：^-([1-9]\d.\d|0.\d[1-9]\d)$ 或 ^(-(([0-9]+.[0-9][1-9][0-9])|([0-9][1-9][0-9].[0-9]+)|([0-9][1-9][0-9])))$ 浮点数：^(-?\d+)(.\d+)?$ 或 ^-?([1-9]\d.\d|0.\d[1-9]\d|0?.0+|0)$ 校验字符的表达式 汉字：^[\u4e00-\u9fa5]{0,}$ 英文和数字：^[A-Za-z0-9]+$ 或 ^[A-Za-z0-9]{4,40}$ 长度为3-20的所有字符：^.{3,20}$ 由26个英文字母组成的字符串：^[A-Za-z]+$ 由26个大写英文字母组成的字符串：^[A-Z]+$ 由26个小写英文字母组成的字符串：^[a-z]+$ 由数字和26个英文字母组成的字符串：^[A-Za-z0-9]+$ 由数字、26个英文字母或者下划线组成的字符串：^\w+$ 或 ^\w{3,20}$ 中文、英文、数字包括下划线：^[\u4E00-\u9FA5A-Za-z0-9_]+$ 中文、英文、数字但不包括下划线等符号：^[\u4E00-\u9FA5A-Za-z0-9]+$ 或 ^[\u4E00-\u9FA5A-Za-z0-9]{2,20}$ 可以输入含有^%&amp;’,;=?$\”等字符：[^%&amp;’,;=?$\x22]+ 禁止输入含有~的字符：[^~\x22]+ 特殊需求表达式 Email地址：^\w+([-+.]\w+)@\w+([-.]\w+).\w+([-.]\w+)*$ 域名：[a-zA-Z0-9][-a-zA-Z0-9]{0,62}(/.[a-zA-Z0-9][-a-zA-Z0-9]{0,62})+/.? InternetURL：[a-zA-z]+://[^\s] 或 ^http://([\w-]+.)+[\w-]+(/[\w-./?%&amp;=])?$ 手机号码：^(13[0-9]|14[5|7]|15[0|1|2|3|5|6|7|8|9]|18[0|1|2|3|5|6|7|8|9])\d{8}$ 电话号码(“XXX-XXXXXXX”、”XXXX-XXXXXXXX”、”XXX-XXXXXXX”、”XXX-XXXXXXXX”、”XXXXXXX”和”XXXXXXXX)：^((\d{3,4}-)|\d{3.4}-)?\d{7,8}$ 国内电话号码(0511-4405222、021-87888822)：\d{3}-\d{8}|\d{4}-\d{7} 电话号码正则表达式（支持手机号码，3-4位区号，7-8位直播号码，1－4位分机号）: ((\d{11})|^((\d{7,8})|(\d{4}|\d{3})-(\d{7,8})|(\d{4}|\d{3})-(\d{7,8})-(\d{4}|\d{3}|\d{2}|\d{1})|(\d{7,8})-(\d{4}|\d{3}|\d{2}|\d{1}))$) 身份证号(15位、18位数字)，最后一位是校验位，可能为数字或字符X：(^\d{15}$)|(^\d{18}$)|(^\d{17}(\d|X|x)$) 帐号是否合法(字母开头，允许5-16字节，允许字母数字下划线)：^[a-zA-Z][a-zA-Z0-9_]{4,15}$ 密码(以字母开头，长度在6~18之间，只能包含字母、数字和下划线)：^[a-zA-Z]\w{5,17}$ 强密码(必须包含大小写字母和数字的组合，不能使用特殊字符，长度在 8-10 之间)：^(?=.\d)(?=.[a-z])(?=.*[A-Z])[a-zA-Z0-9]{8,10}$ 强密码(必须包含大小写字母和数字的组合，可以使用特殊字符，长度在8-10之间)：^(?=.\d)(?=.[a-z])(?=.*[A-Z]).{8,10}$ 日期格式：^\d{4}-\d{1,2}-\d{1,2} 一年的12个月(01～09和1～12)：^(0?[1-9]|1[0-2])$ 一个月的31天(01～09和1～31)：^((0?[1-9])|((1|2)[0-9])|30|31)$ xml文件：^([a-zA-Z]+-?)+[a-zA-Z0-9]+\.[x|X][m|M][l|L]$ 中文字符的正则表达式：[\u4e00-\u9fa5] 双字节字符：[^\x00-\xff] (包括汉字在内，可以用来计算字符串的长度(一个双字节字符长度计2，ASCII字符计1)) 空白行的正则表达式：\n\s*\r (可以用来删除空白行) HTML标记的正则表达式：&lt;(\S?)[^&gt;]&gt;.?|&lt;.? /&gt; ( 首尾空白字符的正则表达式：^\s|\s$或(^\s)|(\s$) (可以用来删除行首行尾的空白字符(包括空格、制表符、换页符等等)，非常有用的表达式) 腾讯QQ号：[1-9][0-9]{4,} (腾讯QQ号从10000开始) 中国邮政编码：[1-9]\d{5}(?!\d) (中国邮政编码为6位数字) IP地址：((?:(?:25[0-5]|2[0-4]\d|[01]?\d?\d)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d?\d)) 钱的输入格式 有四种钱的表示形式我们可以接受:”10000.00” 和 “10,000.00”, 和没有 “分” 的 “10000” 和 “10,000”：^[1-9][0-9]*$ 这表示任意一个不以0开头的数字,但是,这也意味着一个字符”0”不通过,所以我们采用下面的形式：^(0|[1-9][0-9]*)$ 一个0或者一个不以0开头的数字.我们还可以允许开头有一个负号：^(0|-?[1-9][0-9]*)$ 这表示一个0或者一个可能为负的开头不为0的数字.让用户以0开头好了.把负号的也去掉,因为钱总不能是负的吧。下面我们要加的是说明可能的小数部分：^[0-9]+(.[0-9]+)?$ 必须说明的是,小数点后面至少应该有1位数,所以”10.”是不通过的,但是 “10” 和 “10.2” 是通过的：^[0-9]+(.[0-9]{2})?$ 这样我们规定小数点后面必须有两位,如果你认为太苛刻了,可以这样：^[0-9]+(.[0-9]{1,2})?$ 这样就允许用户只写一位小数.下面我们该考虑数字中的逗号了,我们可以这样：^[0-9]{1,3}(,[0-9]{3})*(.[0-9]{1,2})?$ 1到3个数字,后面跟着任意个 逗号+3个数字,逗号成为可选,而不是必须：^([0-9]+|[0-9]{1,3}(,[0-9]{3})*)(.[0-9]{1,2})?$ “+”可以用”*”替代如果你觉得空字符串也可以接受的话(奇怪,为什么?)最后,别忘了在用函数时去掉去掉那个反斜杠,一般的错误都在这里]]></content>
      <categories>
        <category>程序人生</category>
      </categories>
      <tags>
        <tag>正则表达式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Go并发之channel]]></title>
    <url>%2F2018%2F09%2F25%2FGo%E5%B9%B6%E5%8F%91%E4%B9%8Bchannel%2F</url>
    <content type="text"><![CDATA[channel是什么channel是Go中一个非常重要的特性，在Go并发之goroutine里有介绍了CSP模型，CSP 是 Communicating Sequential Process 的简称，中文可以叫做通信顺序进程，是一种并发编程模型。Go实现了CSP部分的理论，goroutine对应CSP中并发执行的实体，channel也就对应着CSP中的channel。 channel操作符操作符 &lt;- 1234567ch := make(chan int)//读x &lt;- chan//写chan &lt;- 10 channel创建必须使用make创建channel 12bufChan := make(chan int, 10) //1、带缓冲channelnoBufChan := make(chan string) //2、无缓冲channel 和map类似，channel也是一个对应make创建的底层数据结构的引用，当我们复制一个channel或者用于函数参数传递时，只是拷贝了一个channel的引用，channel的零值为nil。 以方式1创建的channel是带缓冲的，方式2即为无缓冲的。 示例代码1：12345678910111213141516package mainimport "fmt"func main() &#123; channel := make(chan int) //创建一个int类型的channel //匿名函数 go func() &#123; channel &lt;- 10 fmt.Println("chan &lt;-") //子协程 &#125;() &lt;- channel //没有数据前阻塞 fmt.Println("&lt;- chan")&#125; 运行结果： 再来看一下下面这个例子 12345678910111213141516package mainimport "fmt"func main() &#123; var channel chan int go func() &#123; channel &lt;- 10 fmt.Println("chan &lt;-") &#125;() &lt;- channel fmt.Println("&lt;- chan")&#125; 运行结果： 为什么会deadlock，因为channel并没有创建。 不带缓冲channel一个基于无缓存的channel的发送操作将导致发送者goroutine阻塞，直到另一个goroutine在相同的channel上执行接收操作，当发送的值通过channel成功传输之后，两个goroutine可以继续执行后面的语句。反之，如果接受操作先发生，那么接收者goroutine也将阻塞，直到有另一个goroutine在相同的channel上执行发送操作。 基于无缓存channel的发送和接收操作将导致两个goroutine做一次同步操作。因为这个原因，无缓存channel有时候也被成为同步channel。当通过一个无缓存channel发送数据时，接收者收到数据发生在唤醒发送者goroutine之前。 channel接受和发送数据都是阻塞的，除非另一端已经准备好，这样使得goroutine同步变得更加的简单，不用显式的lock。 谓阻塞就是读取，会被阻塞，直到有数据接收。其次，任何发送将会被阻塞，直到数据被读出。 无缓冲的channel是多个goroutine之间同步很棒的工具。 示例代码：12345678910111213141516171819202122package mainimport "fmt"func sum(a []int, ch chan int)&#123; total := 0 fmt.Println(a) for _,v := range a &#123; total += v &#125; ch&lt;- total&#125;func main() &#123; ch := make(chan int) a := []int&#123;1,2,3,4,5,6&#125; go sum(a[:3], ch) go sum(a[3:], ch) x := &lt;-ch y := &lt;-ch fmt.Println(x, y)&#125; 运行结果： 结果有两种，这只是其中一种。 带缓冲的channel在Go中也允许指定channel的缓冲大小 1ch := make(chan type, value) 当 value = 0 时，channel就是无缓冲的channel，当 value &gt; 0 时， channel有缓冲、是非阻塞的，直到写满value个元素后才阻塞写入。 示例代码：123456789101112package mainimport "fmt"func main() &#123; ch := make(chan int, 2) //缓冲大小为2 ch&lt;- 10 ch&lt;- 20 fmt.Println(&lt;-ch) fmt.Println(&lt;-ch)&#125; 运行结果： 如果代码中将缓存区域设置为1，则会出现deadlock错误。fatal error: all goroutines are asleep - deadlock! 单向channel默认情况下是双向的，即可读可写，读代表receive，写代表send。 通常情况我们会将一个通道作为函数参数传递过去，但是默认是双向的，我只想让该参数只能进行读或者写，那就用到了单向channel。 123var ch1 chan int //默认双向var ch2 chan&lt;- int //单向，只读var ch3 &lt;-chan int //单项，只写 双向channel可以隐式转换为单向channel，反之则不行。 关闭channel关闭channel只需要close函数即可，可以使用多返回值的方式 v,ok := &lt;-ch方式来判断channel是否被关闭。 示例代码：1234567891011121314151617181920package mainimport "fmt"func foreach(arr []int, b chan bool)&#123; for i,v := range arr &#123; fmt.Printf("i=%d, v=%d \n", i, v) &#125; b&lt;- true close(b)&#125;func main() &#123; arr := []int&#123;12,4,6,7,9,2&#125; ch := make(chan bool, 10) go foreach(arr, ch) if v, ok := &lt;-ch; !ok &#123; fmt.Println(v) &#125;&#125; 当一个channel被关闭后，再向该channel发送数据将导致panic异常。 其实你并不需要关闭每一个channel。只要当需要告诉接收者goroutine，所有的数据已经全部发送时才需要关闭channel。不管一个channel是否被关闭，当它没有被引用时将会被Go语言的垃圾自动回收器回收。（不要将关闭一个打开文件的操作和关闭一个channel操作混淆。对于每个打开的文件，都需要在不使用的使用调用对应的Close方法来关闭文件。）试图重复关闭一个channel将导致panic异常，试图关闭一个nil值的channel也将导致panic异常。关闭一个channels还会触发一个广播机制 Range遍历channel可以通过range，像操作slice或者map一样操作缓存类型的channel 使用range实现斐波那契数列 示例代码：1234567891011121314151617181920package mainimport "fmt"func fibonacci(n int, f chan int)&#123; x, y := 1, 1 for i:=0; i&lt;n; i++ &#123; f &lt;- x x, y = y, x+y &#125; close(f)&#125;func main() &#123; ch := make(chan int, 10) go fibonacci(cap(ch), ch) for v := range ch &#123; fmt.Printf("%d ", v) &#125;&#125; SelectGo提供了一个关键字select，通过select可以监听channel上的数据流动。 语法和恶switch非常相似，每个条件由case来描述。但是select有很多限制，其中一条就是每个case语句里必须是一个IO操作。 大致结构12345678selct &#123; case &lt;-ch: //如果读数据，则执行 case ch&lt;- 1: //如果写数据，则执行 default: //默认处理流程，但是一般情况select不用该条件，因为无意义&#125; 在一个select语句中，Go会按顺序从头到尾评估每一条发送和接收的语句。 但是其中任意一语句都可以，是任意都可以(即没有被堵塞)，那么就从那么可以执行的语句中任意选择来使用。 如果没有任意一条语句可以执行，那么可能有两种情况。 如果给出了default语句，则会执行default语句，同时程序的执行会从select语句后的语句中恢复。 如果没有default语句，那么select语句将被阻塞，直到有一个通信可以进行下去。 使用select实现斐波那契数列示例代码：12345678910111213141516171819202122232425262728293031323334package mainimport "fmt"func fibonacci(n chan int, b chan bool) &#123; x, y := 1, 1 for &#123; select &#123; case n&lt;- x: x, y = y, x+y case &lt;-b: fmt.Println("end") return &#125; &#125;&#125;//使用select实现斐波那契func main() &#123; n := make(chan int, 10) b := make(chan bool) go func() &#123; for i := 0; i &lt; cap(n); i++ &#123; fmt.Println(&lt;-n) &#125; b&lt;- true &#125;() fibonacci(n, b)&#125; 运行结果：]]></content>
      <categories>
        <category>Golang</category>
      </categories>
      <tags>
        <tag>Golang基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Go并发之goroutine]]></title>
    <url>%2F2018%2F09%2F24%2FGo%E5%B9%B6%E5%8F%91%E4%B9%8Bgoroutine%2F</url>
    <content type="text"><![CDATA[Go语言并发优势作为云计算时代的C语言之称的Go语言，第一是因为Go语言设计简单，第二21实际最重要的就是并发程序设计，而Go在语言层面上就支持了并发。在此同时，并发程序的内存管理有时候是非常复杂的，而Go自身也提供了自动垃圾回收机制。 Go语言为并发编程而内置的上层API是基于CSP模型，这里引用了知乎原文链接,CSP(Communicating Sequential Process)模型和Actor模型是两门非常复古且外形接近的并发模型。但CSP与Actor有以下几点比较大的区别： CSP并不Focus发送消息的实体/Task，而是关注发送消息时消息所使用的载体，即channel。 在Actor的设计中，Actor与信箱是耦合的，而在CSP中channel是作为first-class独立存在的。 另外一点在于，Actor中有明确的send/receive的关系，而channel中并不区分这样的关系，执行块可以任意选择发送或者取出消息。 另外默认情况下的channel是无缓存的,对channel的send动作是同步阻塞的，直到另外一个持有该channel引用的执行块取出消息(channel为空)，反之，receive动作亦然。藉此，我们可以得到一个基本确定的事实，by default时，实际的receive操作只会在send之后才被发生。而Actor中，由于send这个动作是异步的，因此Actor的receive会按照信箱接受到消息的顺序来进行处理。当然，除此以外，channel还有种Buffered Channel的模式，在默认情况的基础上，你可以确定channel内的消息数量，当channel中消息数量不满足于初始化时Buffer数目时，send动作不会被阻塞，写入操作会立即完成(因此Buffered Channel在很大程度上与Actor非常接近)，直到Buffer数目已满，则send动作开始阻塞。 这也意味着显示锁都是可以避免的，因为Go语言通过安全的通道发送和接受以实现同步，也简化了并发程序的编写。 而一般情况下，桌面计算机跑十几二十个线程就有点负载了，而同样的一台计算机，却可以轻松跑起成百上千甚至万个goroutine进行资源竞争。 goroutine是什么goroutine是Go并行设计的设置核心，它其实就是协程，但是它比线程更小，十几个goroutine可能体现在底层就是五六个线程，Go语言内部帮你实现了这些goroutine之间的内存共享。执行goroutine只需极少的栈内存，当然会根据相应的数据伸缩。也正是如此，可以同时运行成千上万个并发任务。goroutine比thread更易用、更高效、更轻便。 goroutine的创建只需要函数调用前加一个 go 关键字，就可以创建并发执行单元。无需了解其他细节，调度器会自动安排到合适的系统线程上执行。 像java语言一样，go也有其main函数，有着其main thread。在go语言中，main函数既在一个单独的goroutine中运行，也可以成为main goroutine。新的goroutine用go语句来创建。 示例代码1：12345678910111213package mainimport ( "fmt" "time")func main() &#123; for &#123; //死循环 fmt.Println("this is main goroutine") time.Sleep(time.Second) &#125;&#125; 运行结果： 手动退出，这是一个主协程，那么再看下面一个代码示例代码2：1234567891011121314151617181920212223package mainimport ( "fmt" "time")func newTask()&#123; for &#123; fmt.Println("this is a new Task") time.Sleep(time.Second) &#125;&#125;func main() &#123; for &#123; fmt.Println("this is main goroutine") time.Sleep(time.Second) &#125; newTask()&#125; 运行结果： 毫无疑问示例2与示例1中运行结果没有区别，而如何让他们同时执行呢 示例代码3：12345678910111213141516171819202122232425package mainimport ( "fmt" "time")func newTask()&#123; for &#123; fmt.Println("this is a new Task") time.Sleep(time.Second) &#125;&#125;func main() &#123; go newTask() //新建一个协程 //需要将代码放置前面，如果放置后面，死循环同样没办法执行这条语句 for &#123; fmt.Println("this is main goroutine") time.Sleep(time.Second) &#125;&#125; 运行结果： 一个新的协程只需要一个关键字go就已经完成了。 main goroutine先退出我们再看一个奇怪的现象 示例代码4：12345678910111213141516171819package mainimport ( "fmt" "time")func newTask()&#123; for &#123; fmt.Println("this is a new Task") time.Sleep(time.Second) &#125;&#125;func main() &#123; go newTask()&#125; 运行结果： 为什么结果什么都没有，我们明明已经开了一个新的协程来进行执行newTask函数，这就是go中main函数执行的太快了，也就是main goroutine已经执行完了，所有的goroutine都会直接打断，程序退出。 为了防止main goroutine过快的结束，123456789101112131415161718192021package mainimport ( "fmt" "time")func newTask()&#123; for &#123; fmt.Println("this is a new Task") time.Sleep(time.Second) &#125;&#125;func main() &#123; go newTask() time.Sleep(5 * time.Second)&#125; 运行结果： 让main goroutine睡了5秒，而newTask也刚好执行了5次，也解释了当main goroutine结束时，所有的goroutine都会直接打断，程序退出。]]></content>
      <categories>
        <category>Golang</category>
      </categories>
      <tags>
        <tag>Golang基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Go环境搭建]]></title>
    <url>%2F2018%2F09%2F22%2FGo%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[Go语言优势GO语言（Golang）是云计算时代的C语言。它不仅有着更高的生产效率，也对多处理器系统应用程序的编程进行了优化，语言层面支持并发，内置runtime，支持GC，并且语法简单易学，并不像java有着那么复杂的语法。 Go可以做什么 服务器编程 分布式系统 网络编程 内存数据库 云平台 and so on 环境搭建教程基于win10，linux等系统请参考其他文章官网，自行下载msi文件，傻瓜式安装，安装路径不要出现中文避免出差错。需要翻墙，没有可以选择Golang中文网测试安装：打开终端输入12$ go versiongo version go1.11 windows/amd64 即可完成安装 环境配置打开终端输入123456789101112131415161718192021222324252627$ go envset GOARCH=amd64set GOBIN=set GOCACHE=C:\Users\Administrator\AppData\Local\go-buildset GOEXE=.exeset GOFLAGS=set GOHOSTARCH=amd64set GOHOSTOS=windowsset GOOS=windowsset GOPATH=E:\Goset GOPROXY=set GORACE=set GOROOT=G:\Golangset GOTMPDIR=set GOTOOLDIR=G:\Golang\pkg\tool\windows_amd64set GCCGO=gccgoset CC=gccset CXX=g++set CGO_ENABLED=1set GOMOD=set CGO_CFLAGS=-g -O2set CGO_CPPFLAGS=set CGO_CXXFLAGS=-g -O2set CGO_FFLAGS=-g -O2set CGO_LDFLAGS=-g -O2set PKG_CONFIG=pkg-configset GOGCCFLAGS=-m64 -mthreads -fno-caret-diagnostics -Qunused-arguments -fmessage-length=0 -fdebug-prefix-map=C:\Users\ADMINI~1\AppData\Local\Temp\go-build669911038=/tmp/go-build -gno-record-gcc-switches msi包基本会把环境配置完成，但要配置GOPATH目录，不要用默认配置的计算机(右键)-属性-高级系统设置-环境变量在 用户变量 下添加 GOPATH 值为你想要的路径即可。在配置目录下创建三个文件夹，分别是 src目录 此目录是自己在GoPath目录下手动创建的，用于放源代码文件。 pkg目录 此目录是在src的源文件目录下对.go文件通过go install之后自动生成的，放编译后的包文件。 bin目录 此目录是在src的源文件目录下对 .go文件通过go build和go install之后自动生成的，.go文件要调用pkg下的包文件。 环境基本搭建完成。再次输入1$ go env 发现修改了即可。]]></content>
      <categories>
        <category>Golang</category>
      </categories>
      <tags>
        <tag>环境搭建</tag>
        <tag>Golang基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Maven配置]]></title>
    <url>%2F2018%2F09%2F22%2FMaven%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[Maven基础环境搭建 环境 window10 jdk1.6或以上 下载Maven官网 直接选择 apache-maven-3.5.4-bin.zip格式下载解压即可 配置环境变量MAVEN_HOME我的解压存放的目录是 G:\Maven ，下面目录自行替换 计算机(右键)-属性-高级系统设置-环境变量 新建系统变量 MAVEN_HOME 变量值： G:\Maven 编辑系统变量 Path 添加变量值： G:\Maven\bin 检测是否安装成功git-bash或者命令提示符下，输入123456$ mvn --versionApache Maven 3.5.4 (1edded0938998edf8bf061f1ceb3cfdeccf443fe; 2018-06-18T02:33:14+08:00)Maven home: G:\MavenJava version: 1.8.0_131, vendor: Oracle Corporation, runtime: G:\Java\jreDefault locale: zh_CN, platform encoding: GBKOS name: "windows 10", version: "10.0", arch: "amd64", family: "windows" 出现类似即可。 Maven配置修改本地仓库地址Maven缺省的本地仓库路径 用户目录/.m2/repository 打开maven安装目录下的conf目录中的 settings.xml 文件 搜索 localRepository取消注释，修改成想要存放的路径保存即可，如图所示 IDEA配置 Eclipse配置]]></content>
      <categories>
        <category>Maven</category>
      </categories>
      <tags>
        <tag>环境搭建</tag>
        <tag>Maven</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[架构参考]]></title>
    <url>%2F2018%2F09%2F22%2F%E6%9E%B6%E6%9E%84%E5%8F%82%E8%80%83%2F</url>
    <content type="text"><![CDATA[架构参考，原文来自(https://blog.52itstyle.com/architecture.html) 技术选型网关：Nginx、Kong、Zuul缓存：Redis、MemCached、OsCache、EhCache搜索：ElasticSearch、Solr熔断：Hystrix 负载均衡：DNS、F5、LVS、Nginx、OpenResty、HAproxy注册中心：Eureka、Zookeeper、Redis、Etcd、Consul认证鉴权：JWT消费队列：RabbitMQ、ZeroMQ、Redis、ActiveMQ、Kafka 日志收集：ELK、Redis系统监控：GPE、PinPoint、Zipkin文件系统：OSS、NFS、FastDFS、MogileFSRPC框架： Dubbo、Motan、Thrift、grpc 构建工具：Maven、Gradle集成部署：Docker、Jenkins、Git、Maven 数据库：MySql、Redis、MongoDB、PostgreSQL、Memcache、HBase网络：专用网络VPC、弹性公网IP、CDN数据库中间件：DRDS （阿里云）、Mycat、360 Atlas、Cobar (不维护了)分布式框架：Dubbo、Motan、Spring-Could 架构必备负载均衡（负载均衡算法）反向代理服务隔离服务限流服务降级（自动优雅降级）失效转移超时重试（代理超时、容器超时、前端超时、中间件超时、数据库超时、NoSql超时）回滚机制（上线回滚、数据库版本回滚、事务回滚） 高并发应用缓存HTTP缓存多级缓存分布式缓存连接池异步并发 分布式事务二阶段提交(强一致)三阶段提交(强一致)消息中间件(最终一致性)，推荐阿里的RocketMQ 队列任务队列消息队列请求队列 扩容单体垂直扩容单体水平扩容应用拆分数据库拆分数据库分库分表数据异构分布式任务 网络安全SQL注入XSS攻击CSRF攻击拒绝服务（DoS，Denial of Service）攻击]]></content>
      <categories>
        <category>架构之路</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[开源协议介绍]]></title>
    <url>%2F2018%2F09%2F22%2F%E5%BC%80%E6%BA%90%E5%8D%8F%E8%AE%AE%E4%BB%8B%E7%BB%8D%2F</url>
    <content type="text"><![CDATA[一些开源协议的介绍，考古。分别是MIT,Apache,LGPL,GPL,BSD,MPL 现今存在的开源协议很多，而经过Open Source Initiative组织通过批准的开源协议目前有58种（http://www.opensource.org/licenses /alphabetical）。 Apache Licene 2.0Apache Licence是著名的非盈利开源组织Apache采用的协议。该协议和BSD类似，同样鼓励代码共享和尊重原作者的著作权，同样允许代码修改，再发布（作为开源或商业软件）。需要满足的条件也和BSD类似： 需要给代码的用户一份Apache Licence 如果你修改了代码，需要在被修改的文件中说明。 在延伸的代码中（修改和有源代码衍生的代码中）需要带有原来代码中的协议，商标，专利声明和其他原来作者规定需要包含的说明。 如果再发布的产品中包含一个Notice文件，则在Notice文件中需要带有Apache Licence。你可以在Notice中增加自己的许可，但不可以表现为对Apache Licence构成更改。 Apache Licence也是对商业应用友好的许可。使用者也可以在需要的时候修改代码来满足需要并作为开源或商业产品发布/销售。 12345678910111213Apache Licence是著名的非盈利开源组织Apache采用的协议。该协议和BSD类似，同样鼓励代码共享和尊重原作者的著作权，同样允许代码修改，再发布（作为开源或商业软件）。需要满足的条件也和BSD类似： （1）需要给代码的用户一份Apache Licence （2）如果你修改了代码，需要再被修改的文件中说明。 （3）在延伸的代码中（修改和有源代码衍生的代码中）需要带有原来代码中的协议，商标，专利声明和其他原来作者规定需要包含的说明。 （4）如果再发布的产品中包含一个Notice文件，则在Notice文件中需要带有Apache Licence。你可以在Notice中增加自己的许可，但不可以表现为对Apache Licence构成更改。 Apache Licence也是对商业应用友好的许可。使用者也可以在需要的时候修改代码来满足需要并作为开源或商业产品发布/销售。 Apache Licence 2.0版本授予了用户大量的权利。这些权利可以应用于拷贝权，也可以用于专利权。因为很多许可协议只能适用于拷贝权，不适用于专利权，所以这个灵活性就成了让想有专利的开发者们选择许可协议时的一个显著参考因素。 下面是关于Apache许可协议所允许的事项的详细说明： （1）权利永恒。一旦被授权，权利永久不失。 （2）权利无疆界。在一个国家里被授权，形同于在所有国家被授权。例如，你在美国，但许可权最初在印度被授予，你同样可以使用这个被授权的程序。 （3）授权无需付费和支付酬劳。你既不需要在使用之前支付任何的费用，也无需在每次使用时支付任何的费用，或者其它类似情况。 （4）权利不排他。使用这种许可协议下的软件时，不妨碍你使用其它软件。 （5）权利不可变更。 权利一旦授予，不可剥夺。也就是说，你在使用这个软件的过程中，你无需担心这种情况：当你开发出了令人羡慕的基于这种授权软件的衍生产品时，有人突然跳出来对你说，“抱歉，你将不再被允许使用这个程序。”（在这个协议里有个条款声明：如果你控告别人在这个许可协议下的产品有侵犯专利的行为，那你的授权将会自动终止，但这只是适用于有专利权的作品。只要你不搞有专利作品的诉讼，你永远无需担心这种问题。） 英文原文：http://www.apache.org/licenses/LICENSE-2.0.html MPL (Mozilla Public License)MPL是The Mozilla Public License的简写，是1998年初Netscape的 Mozilla小组为其开源软件项目设计的软件许可证。MPL许可证出现的最重要原因就是，Netscape公司认为GPL许可证没有很好地平衡开发者对 源代码的需求和他们利用源代码获得的利益。同著名的GPL许可证和BSD许可证相比，MPL在许多权利与义务的约定方面与它们相同（因为都是符合OSIA 认定的开源软件许可证）。但是，相比而言MPL还有以下几个显著的不同之处: MPL虽然要求对于经MPL许可证发布的源代码的修改也要以MPL许可证的方式再许可出来，以保证其他人可以在MPL的条款下共享源代码。但是，在MPL 许可证中对“发布”的定义是“以源代码方式发布的文件”，这就意味着MPL允许一个企业在自己已有的源代码库上加一个接口，除了接口程序的源代码以MPL 许可证的形式对外许可外，源代码库中的源代码就可以不用MPL许可证的方式强制对外许可。这些，就为借鉴别人的源代码用做自己商业软件开发的行为留了一个 豁口。 MPL许可证第三条第7款中允许被许可人将经过MPL许可证获得的源代码同自己其他类型的代码混合得到自己的软件程序。 对软件专利的态度，MPL许可证不像GPL许可证那样明确表示反对软件专利，但是却明确要求源代码的提供者不能提供已经受专利保护的源代码（除非他本人是 专利权人，并书面向公众免费许可这些源代码），也不能在将这些源代码以开放源代码许可证形式许可后再去申请与这些源代码有关的专利。 对源代码的定义而在MPL（1.1版本）许可证中，对源代码的定义是:“源代码指的是对作品进行修改最优先择 取的形式，它包括:所有模块的所有源程序，加上有关的接口的定义，加上控制可执行作品的安装和编译的‘原本’（原文为‘Script’），或者不是与初始 源代码显著不同的源代码就是被源代码贡献者选择的从公共领域可以得到的程序代码。” MPL许可证第3条有专门的一款是关于对源代码修改进行描述的规定，就是要求所有再发布者都得有一个专门的文件就对源代码程序修改的时间和修改的方式有描述。 英文原文：http://www.mozilla.org/MPL/MPL-1.1.html BSDBSD开源协议是一个给于使用者很大自由的协议。基本上使用者可以”为所欲为”,可以自由的使用，修改源代码，也可以将修改后的代码作为开源或者专有软件再发布。 但”为所欲为”的前提当你发布使用了BSD协议的代码，或则以BSD协议代码为基础做二次开发自己的产品时，需要满足三个条件： 如果再发布的产品中包含源代码，则在源代码中必须带有原来代码中的BSD协议。 如果再发布的只是二进制类库/软件，则需要在类库/软件的文档和版权声明中包含原来代码中的BSD协议。 不可以用开源代码的作者/机构名字和原来产品的名字做市场推广。 BSD 代码鼓励代码共享，但需要尊重代码作者的著作权。BSD由于允许使用者修改和重新发布代码，也允许使用或在BSD代码上开发商业软件发布和销售，因此是对 商业集成很友好的协议。而很多的公司企业在选用开源产品的时候都首选BSD协议，因为可以完全控制这些第三方的代码，在必要的时候可以修改或者二次开发。 123456BSD开源协议是一个给于使用者很大自由的协议。基本上使用者可以”为所欲为”,可以自由的使用，修改源代码，也可以将修改后的代码作为开源或者专有软件再发布。但”为所欲为”的前提当你发布使用了BSD协议的代码，或则以BSD协议代码为基础做二次开发自己的产品时，需要满足三个条件： （1）如果再发布的产品中包含源代码，则在源代码中必须带有原来代码中的BSD协议。 （2）如果再发布的只是二进制类库/软件，则需要在类库/软件的文档和版权声明中包含原来代码中的BSD协议。 （3）不可以用开源代码的作者/机构名字和原来产品的名字做市场推广。 BSD代码鼓励代码共享，但需要尊重代码作者的著作权。BSD由于允许使用者修改和重新发布代码，也允许使用或在BSD代码上开发商业软件发布和销售，因此是对商业集成很友好的协议。 而很多的公司企业在选用开源产品的时候都首选BSD协议，因为可以完全控制这些第三方的代码，在必要的时候可以修改或者二次开发。 新BSD协议（“3条款许可协议”）无任何限制的允许你以任何目的二次分发这种软件，唯一的要求是必须保留拷贝权的声明和协议里的软件权利放弃条款。这种协议还有一个限制，未经许可不得使用这个作品的所有曾经捐助者的署名。 新BSD协议和简化BSD协议的最主要的区别是后者删除了署名条款。 GPL（GNU General Public License）我们很熟悉的Linux就是采用了GPL。GPL协议和BSD, Apache Licence等鼓励代码重用的许可很不一样。GPL的出发点是代码的开源/免费使用和引用/修改/衍生代码的开源/免费使用，但不允许修改后和衍生的代 码做为闭源的商业软件发布和销售。这也就是为什么我们能用免费的各种linux，包括商业公司的linux和linux上各种各样的由个人，组织，以及商 业软件公司开发的免费软件了。 GPL协议的主要内容是只要在一个软件中使用(”使用”指类库引用，修改后的代码或者衍生代码)GPL 协议的产品，则该软件产品必须也采用GPL协议，既必须也是开源和免费。这就是所谓的”传染性”。GPL协议的产品作为一个单独的产品使用没有任何问题， 还可以享受免费的优势。 由于GPL严格要求使用了GPL类库的软件产品必须使用GPL协议，对于使用GPL协议的开源代码，商业软件或者对代码有保密要求的部门就不适合集成/采用作为类库和二次开发的基础。 其它细节如再发布的时候需要伴随GPL协议等和BSD/Apache等类似。 GPL V2 、 V3GPL同其它的自由软件许可证一样，许可社会公众享有：运行、复制软件的自由，发行传播软件的自由，获得软件源码的自由，改进软件并将自己作出的改进版本向社会发行传播的自由。GPL还规定：只要这种修改文本在整体上或者其某个部分来源于遵循GPL的程序，该修改文本的 整体就必须按照GPL流通，不仅该修改文本的源码必须向社会公开，而且对于这种修改文本的流通不准许附加修改者自己作出的限制。因此，一项遵循GPL流通 的程序不能同非自由的软件合并。GPL所表达的这种流通规则称为copyleft，表示与copyright(版权)的概念“相左”。 GPL协议最主要的几个原则： 确保软件自始至终都以开放源代码形式发布，保护开发成果不被窃取用作商业发售。任何一套软 件，只要其中使用了受 GPL 协议保护的第三方软件的源程序，并向非开发人员发布时，软件本身也就自动成为受 GPL 保护并且约束的实体。也就是说，此时它必须开放源代码。 GPL 大致就是一个左侧版权（Copyleft，或译为“反版权”、“版权属左”、“版权所无”、“版责”等）的体现。你可以去掉所有原作的版权 信息，只要你保持开源，并且随源代码、二进制版附上 GPL 的许可证就行，让后人可以很明确地得知此软件的授权信息。GPL 精髓就是，只要使软件在完整开源 的情况下，尽可能使使用者得到自由发挥的空间，使软件得到更快更好的发展。 无论软件以何种形式发布，都必须同时附上源代码。例如在 Web 上提供下载，就必须在二进制版本（如果有的话）下载的同一个页面，清楚地提供源代码下载的链接。如果以光盘形式发布，就必须同时附上源文件的光盘。 开发或维护遵循 GPL 协议开发的软件的公司或个人，可以对使用者收取一定的服务费用。但还是一句老话——必须无偿提供软件的完整源代码，不得将源代码与服务做捆绑或任何变相捆绑销售。 LGPL（GNU Lesser General Public License）LGPL是GPL的一个为主要为类库使用设计的开源协议。和GPL要求任何使用/修改/衍生之GPL类库的的软件必须采用GPL协议不同。 LGPL 允许商业软件通过类库引用(link)方式使用LGPL类库而不需要开源商业软件的代码。这使得采用LGPL协议的开源代码可以被商业软件作为类库引用并 发布和销售。 但是如果修改LGPL协议的代码或者衍生，则所有修改的代码，涉及修改部分的额外代码和衍生的代码都必须采用LGPL协议。因此LGPL协议的开源 代码很适合作为第三方类库被商业软件引用，但不适合希望以LGPL协议代码为基础，通过修改和衍生的方式做二次开发的商业软件采用。 GPL/LGPL都保障原作者的知识产权，避免有人利用开源代码复制并开发类似的产品 MITMIT是和BSD一样宽范的许可协议,作者只想保留版权,而无任何其他了限制.也就是说,你必须在你的发行版里包含原许可协议的声明,无论你是以二进制发布的还是以源代码发布的。 相关资料 http://www.open-open.com/solution/view/1319814738108 http://www.open-open.com/solution/view/1405088577732 http://www.open-open.com/solution/view/1319816219625]]></content>
      <categories>
        <category>程序人生</category>
      </categories>
      <tags>
        <tag>开源协议</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Go fmt包的格式化输出]]></title>
    <url>%2F2018%2F09%2F14%2FGo-fmt%E5%8C%85%E7%9A%84%E6%A0%BC%E5%BC%8F%E5%8C%96%E8%BE%93%E5%87%BA%2F</url>
    <content type="text"><![CDATA[golang 的fmt 包实现了格式化I/O函数，类似于C的 printf 和 scanf 普通占位符 占位符 说明 %v 相应值的默认格式，基本万能 %+v 打印结构体时，会添加字段名 %#v 响应值的Go语法表示 %T 响应值的类型的Go语法表示 %% 字面上的百分号，并非值的占位符 布尔占位符 占位符 说明 %t true 或者 false 整数占位符 占位符 说明 %b 二进制表示 %c 相应unicode码所表示的字符 %d 十进制表示 %o 八进制表示 %q 单引号围绕的字符字面值，由Go语法安全的转义，如Printf(%q, 0x4E2E)输出’中’ %x 十六进制表示，字母形式为小写a-f %X 十六进制表示，字母形式为A-F %U unicode格式，U+1234 等同于 U+%04X 浮点数和复数的组成部分（实部和虚部） 占位符 说明 %b 无小数部分的，指数为二的幂的科学记数法 %e 科学记数法 %E 科学计数法 %f 有小数点而无指数 %g 根据情况选择%e 或者 %f 以产生更紧凑的输出 %G 根据情况选择%E 或者 %f 以产生更紧凑的输出 字符串和字节切片 占位符 说明 %s 输出字符串表示（字符串类型或[]byte类型） %q 双引号围绕的字符串，由Go语法安全地转义 %x 十六进制，小写字母，每字节两个字符 %X 十六进制，大写字母，每字节两个字符 指针 占位符 说明 %p 十六进制表示，前缀0x 其他 占位符 说明 + 总打印数值的正负号；对于%q（%+q）保证只输出ASCII编码的字符。 - 在右侧而非左侧填充空格（左对齐该区域） # 备用格式：为八进制添加前导 0（%#o） ‘ ‘ (空格)为数值中省略的正负号留出空白（% d） 0 填充前导的0而非空格；对于数字，这会将填充移到正负号之后 golang没有 ‘%u’ 点位符，若整数为无符号类型，默认就会被打印成无符号的。 宽度与精度的控制格式以Unicode码点为单位。宽度为该数值占用区域的最小宽度；精度为小数点之后的位数。操作数的类型为int时，宽度与精度都可用字符 ‘*’ 表示。 对于 %g/%G 而言，精度为所有数字的总数，例如：123.45，%.4g 会打印123.5，（而 %6.2f 会打印123.45）。 %e 和 %f 的默认精度为6 对大多数的数值类型而言，宽度为输出的最小字符数，如果必要的话会为已格式化的形式填充空格。 而以字符串类型，精度为输出的最大字符数，如果必要的话会直接截断。]]></content>
      <categories>
        <category>Golang</category>
      </categories>
      <tags>
        <tag>Golang基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Go标准命令]]></title>
    <url>%2F2018%2F09%2F14%2FGo%E6%A0%87%E5%87%86%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[Go命令Go语言自带有一套完整的命令操作工具，你可以通过在命令行中执行go来查看它们： 图1.3 Go命令显示详细的信息 这些命令对于我们平时编写的代码非常有用，接下来就让我们了解一些常用的命令。 go build 这个命令主要用于编译代码。在包的编译过程中，若有必要，会同时编译与之相关联的包。 如果是普通包，就像我们在1.2节中编写的mymath包那样，当你执行go build之后，它不会产生任何文件。如果你需要在$GOPATH/pkg下生成相应的文件，那就得执行go install。 如果是main包，当你执行go build之后，它就会在当前目录下生成一个可执行文件。如果你需要在$GOPATH/bin下生成相应的文件，需要执行go install，或者使用go build -o 路径/a.exe。 如果某个项目文件夹下有多个文件，而你只想编译某个文件，就可在go build之后加上文件名，例如go build a.go；go build命令默认会编译当前目录下的所有go文件。 你也可以指定编译输出的文件名。例如1.2节中的mathapp应用，我们可以指定go build -o astaxie.exe，默认情况是你的package名(非main包)，或者是第一个源文件的文件名(main包)。 （注：实际上，package名在Go语言规范中指代码中“package”后使用的名称，此名称可以与文件夹名不同。默认生成的可执行文件名是文件夹名。） go build会忽略目录下以“_”或“.”开头的go文件。 如果你的源代码针对不同的操作系统需要不同的处理，那么你可以根据不同的操作系统后缀来命名文件。例如有一个读取数组的程序，它对于不同的操作系统可能有如下几个源文件： array_linux.goarray_darwin.goarray_windows.goarray_freebsd.go go build的时候会选择性地编译以系统名结尾的文件（Linux、Darwin、Windows、Freebsd）。例如Linux系统下面编译只会选择array_linux.go文件，其它系统命名后缀文件全部忽略。 参数的介绍 -o 指定输出的文件名，可以带上路径，例如 go build -o a/b/c -i 安装相应的包，编译+go install -a 更新全部已经是最新的包的，但是对标准包不适用 -n 把需要执行的编译命令打印出来，但是不执行，这样就可以很容易的知道底层是如何运行的 -p n 指定可以并行可运行的编译数目，默认是CPU数目 -race 开启编译的时候自动检测数据竞争的情况，目前只支持64位的机器 -v 打印出来我们正在编译的包名 -work 打印出来编译时候的临时文件夹名称，并且如果已经存在的话就不要删除 -x 打印出来执行的命令，其实就是和-n的结果类似，只是这个会执行 -ccflags &#39;arg list&#39; 传递参数给5c, 6c, 8c 调用 -compiler name 指定相应的编译器，gccgo还是gc -gccgoflags &#39;arg list&#39; 传递参数给gccgo编译连接调用 -gcflags &#39;arg list&#39; 传递参数给5g, 6g, 8g 调用 -installsuffix suffix 为了和默认的安装包区别开来，采用这个前缀来重新安装那些依赖的包，-race的时候默认已经是-installsuffix race,大家可以通过-n命令来验证 -ldflags &#39;flag list&#39; 传递参数给5l, 6l, 8l 调用 -tags &#39;tag list&#39; 设置在编译的时候可以适配的那些tag，详细的tag限制参考里面的 Build Constraints go clean 这个命令是用来移除当前源码包和关联源码包里面编译生成的文件。这些文件包括 _obj/ 旧的object目录，由Makefiles遗留 _test/ 旧的test目录，由Makefiles遗留 _testmain.go 旧的gotest文件，由Makefiles遗留 test.out 旧的test记录，由Makefiles遗留 build.out 旧的test记录，由Makefiles遗留 *.[568ao] object文件，由Makefiles遗留 DIR(.exe) 由go build产生 DIR.test(.exe) 由go test -c产生 MAINFILE(.exe) 由go build MAINFILE.go产生 *.so 由 SWIG 产生 我一般都是利用这个命令清除编译文件，然后github递交源码，在本机测试的时候这些编译文件都是和系统相关的，但是对于源码管理来说没必要。 $ go clean -i -n cd /Users/astaxie/develop/gopath/src/mathapp rm -f mathapp mathapp.exe mathapp.test mathapp.test.exe app app.exe rm -f /Users/astaxie/develop/gopath/bin/mathapp 参数介绍 -i 清除关联的安装的包和可运行文件，也就是通过go install安装的文件 -n 把需要执行的清除命令打印出来，但是不执行，这样就可以很容易的知道底层是如何运行的 -r 循环的清除在import中引入的包 -x 打印出来执行的详细命令，其实就是-n打印的执行版本 go fmt 有过C/C++经验的读者会知道,一些人经常为代码采取K&amp;R风格还是ANSI风格而争论不休。在go中，代码则有标准的风格。由于之前已经有的一些习惯或其它的原因我们常将代码写成ANSI风格或者其它更合适自己的格式，这将为人们在阅读别人的代码时添加不必要的负担，所以go强制了代码格式（比如左大括号必须放在行尾），不按照此格式的代码将不能编译通过，为了减少浪费在排版上的时间，go工具集中提供了一个go fmt命令 它可以帮你格式化你写好的代码文件，使你写代码的时候不需要关心格式，你只需要在写完之后执行go fmt &lt;文件名&gt;.go，你的代码就被修改成了标准格式，但是我平常很少用到这个命令，因为开发工具里面一般都带了保存时候自动格式化功能，这个功能其实在底层就是调用了go fmt。接下来的一节我将讲述两个工具，这两个工具都自带了保存文件时自动化go fmt功能。 使用go fmt命令，其实是调用了gofmt，而且需要参数-w，否则格式化结果不会写入文件。gofmt -w -l src，可以格式化整个项目。 所以go fmt是gofmt的上层一个包装的命令，我们想要更多的个性化的格式化可以参考 gofmt gofmt的参数介绍 -l 显示那些需要格式化的文件 -w 把改写后的内容直接写入到文件中，而不是作为结果打印到标准输出。 -r 添加形如“a[b:len(a)] -&gt; a[b:]”的重写规则，方便我们做批量替换 -s 简化文件中的代码 -d 显示格式化前后的diff而不是写入文件，默认是false -e 打印所有的语法错误到标准输出。如果不使用此标记，则只会打印不同行的前10个错误。 -cpuprofile 支持调试模式，写入相应的cpufile到指定的文件 go get 这个命令是用来动态获取远程代码包的，目前支持的有BitBucket、GitHub、Google Code和Launchpad。这个命令在内部实际上分成了两步操作：第一步是下载源码包，第二步是执行go install。下载源码包的go工具会自动根据不同的域名调用不同的源码工具，对应关系如下： BitBucket (Mercurial Git) GitHub (Git) Google Code Project Hosting (Git, Mercurial, Subversion) Launchpad (Bazaar) 所以为了go get 能正常工作，你必须确保安装了合适的源码管理工具，并同时把这些命令加入你的PATH中。其实go get支持自定义域名的功能，具体参见go help remote。 参数介绍： -d 只下载不安装 -f 只有在你包含了-u参数的时候才有效，不让-u去验证import中的每一个都已经获取了，这对于本地fork的包特别有用 -fix 在获取源码之后先运行fix，然后再去做其他的事情 -t 同时也下载需要为运行测试所需要的包 -u 强制使用网络去更新包和它的依赖包 -v 显示执行的命令 go install 这个命令在内部实际上分成了两步操作：第一步是生成结果文件(可执行文件或者.a包)，第二步会把编译好的结果移到$GOPATH/pkg或者$GOPATH/bin。 参数支持go build的编译参数。大家只要记住一个参数-v就好了，这个随时随地的可以查看底层的执行信息。 go test 执行这个命令，会自动读取源码目录下面名为*_test.go的文件，生成并运行测试用的可执行文件。输出的信息类似 ok archive/tar 0.011s FAIL archive/zip 0.022s ok compress/gzip 0.033s ... 默认的情况下，不需要任何的参数，它会自动把你源码包下面所有test文件测试完毕，当然你也可以带上参数，详情请参考go help testflag 这里我介绍几个我们常用的参数： -bench regexp 执行相应的benchmarks，例如 -bench=. -cover 开启测试覆盖率 -run regexp 只运行regexp匹配的函数，例如 -run=Array 那么就执行包含有Array开头的函数 -v 显示测试的详细命令 go toolgo tool下面下载聚集了很多命令，这里我们只介绍两个，fix和vet go tool fix . 用来修复以前老版本的代码到新版本，例如go1之前老版本的代码转化到go1,例如API的变化 go tool vet directory|files 用来分析当前目录的代码是否都是正确的代码,例如是不是调用fmt.Printf里面的参数不正确，例如函数里面提前return了然后出现了无用代码之类的。 go generate这个命令是从Go1.4开始才设计的，用于在编译前自动化生成某类代码。go generate和go build是完全不一样的命令，通过分析源码中特殊的注释，然后执行相应的命令。这些命令都是很明确的，没有任何的依赖在里面。而且大家在用这个之前心里面一定要有一个理念，这个go generate是给你用的，不是给使用你这个包的人用的，是方便你来生成一些代码的。 这里我们来举一个简单的例子，例如我们经常会使用yacc来生成代码，那么我们常用这样的命令： go tool yacc -o gopher.go -p parser gopher.y -o 指定了输出的文件名， -p指定了package的名称，这是一个单独的命令，如果我们想让go generate来触发这个命令，那么就可以在当然目录的任意一个xxx.go文件里面的任意位置增加一行如下的注释： //go:generate go tool yacc -o gopher.go -p parser gopher.y 这里我们注意了，//go:generate是没有任何空格的，这其实就是一个固定的格式，在扫描源码文件的时候就是根据这个来判断的。 所以我们可以通过如下的命令来生成，编译，测试。如果gopher.y文件有修改，那么就重新执行go generate重新生成文件就好。 $ go generate $ go build $ go test godoc在Go1.2版本之前还支持go doc命令，但是之后全部移到了godoc这个命令下，需要这样安装go get golang.org/x/tools/cmd/godoc 很多人说go不需要任何的第三方文档，例如chm手册之类的（其实我已经做了一个了，chm手册），因为它内部就有一个很强大的文档工具。 如何查看相应package的文档呢？ 例如builtin包，那么执行godoc builtin 如果是http包，那么执行godoc net/http 查看某一个包里面的函数，那么执行godoc fmt Printf 也可以查看相应的代码，执行godoc -src fmt Printf 通过命令在命令行执行 godoc -http=:端口号 比如godoc -http=:8080。然后在浏览器中打开127.0.0.1:8080，你将会看到一个golang.org的本地copy版本，通过它你可以查询pkg文档等其它内容。如果你设置了GOPATH，在pkg分类下，不但会列出标准包的文档，还会列出你本地GOPATH中所有项目的相关文档，这对于经常被墙的用户来说是一个不错的选择。 其它命令 go还提供了其它很多的工具，例如下面的这些工具 go version 查看go当前的版本 go env 查看当前go的环境变量 go list 列出当前全部安装的package go run 编译并运行Go程序 以上这些工具还有很多参数没有一一介绍，用户可以使用go help 命令获取更详细的帮助信息。]]></content>
      <categories>
        <category>Golang</category>
      </categories>
      <tags>
        <tag>Golang基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL错误集]]></title>
    <url>%2F2018%2F09%2F13%2FMySQL%E9%94%99%E8%AF%AF%E9%9B%86%2F</url>
    <content type="text"><![CDATA[MYSQL错误集记录 ERROR 1215-Cannot add foreign key constraint先看俩个表结构 对reader表进行添加外键约束book表12mysql&gt; ALTER TABLE reader ADD CONSTRAINT fk_book_reader FOREIGN key -&gt; reader(book_id) REFERENCES book(book_id); 报错：1215-Cannot add foreign key constraint问题分析： 主外键更多的是某表的主键与子表的某个列进行关联，要求是具备相同的数据类型和属性 要求：具备相同的数据类型和约束发现：unsigned，数字的字符长度不一致。修改reader表book_id列属性1mysql&gt; ALTER TABLE reader MODIFY book_id INT UNSIGNED; 再次进行添加外键约束，问题解决。 ERROR 1075 (42000): Incorrect table definition; there can be only one auto column and it must be defined as a key引发原因，建表语句：12345mysql&gt; create table if not exists user( -&gt; id int unsigned auto_increment, -&gt; uuid varchar(30) not null, -&gt; primary key (uuid,id) -&gt; ) engine=InnoDB default charset=utf8; 解决方法：当有一个自增键和另外一个字段需要作为主键时，一定要在定义primary key中先定义自增键，否则报错。12345mysql&gt; create table if not exists user( -&gt; id int unsigned auto_increment, -&gt; uuid varchar(30) not null, -&gt; primary key (id,uuid) -&gt; ) engine=InnoDB default charset=utf8;]]></content>
      <categories>
        <category>DBA</category>
      </categories>
      <tags>
        <tag>Mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Centos7搭建FTP服务器]]></title>
    <url>%2F2018%2F09%2F11%2FCentos7%E6%90%AD%E5%BB%BAFTP%E6%9C%8D%E5%8A%A1%E5%99%A8%2F</url>
    <content type="text"><![CDATA[之前部署阿里云服务器需要上传一些文件，所以搭建了FTP服务器，便记录一下。 环境 Centos7 安装VSFTPD1$ yum install vsftpd -y 配置VSFTPDvsftpd的配置文件是 /etc/vsftpd/vsftpd.conf ，直接用vim打开编辑即可。使用vim编辑器打开vsftpd配置文件：1$ vim /etc/vsftpd/vsftpd.conf 关键修改 anonymous_enable=YES 是否允许匿名用户登陆FTP。 为了安全起见关闭这个功能（将等号后的YES改成NO即可）。 dirmessage_enable=YES 切换目录时，显示目录下.message文件中的内容 默认是开启的 local_umask=022 FTP上本地的文件权限，默认是077，不过vsftpd安装后的配置文件里默认是022. 没有什么特殊情况不用修改。 xferlog_enable=YES 启用上传和下载的日志功能，默认开启。 ftpd_banner=XXXX FTP的欢迎信息。 data_connection_timeout=120 数据连接超时时间。 启动VSFTPD开机启动12$ systemctl enable vsftpd.service$ systemctl start vsftpd.service 创建FTP用户修改完vsftpd的配置文件之后我们还是不能使用vsftpd，因为我们还没有设置ftp的用户。添加一个名为ftpuser的用户，用户文件夹位置为：/home/ftpdir，且禁止此用户登陆服务器：12$ useradd -d /home/ftpdir -s /sbin/nologin ftpuser$ passwd ftpuser 这时候系统会要求您输入新的密码并且重复一遍。顺便一提在SSH中，密码一般不会回显，所以初学者可能会觉得输进去没反应，其实是已经输进去了。调整文件夹权限123$ chmod 777 /home/ftpdir$ cd /home$ ls -l 调整防火墙我这里用的是传统的管理方式在CentOS 7或RHEL 7或Fedora中防火墙由firewalld来管理，需要还原12$ systemctl stop firewalld $ systemctl mask firewalld 并且安装iptables-services：1$ yum install iptables-services -y 设置开机启动：12$ systemctl enable iptables$ systemctl start iptables 开放端口 主动模式 使用Vim编辑器打开iptables配置文件：1$ vim /etc/sysconfig/iptables 添加1-A INPUT -m state --state NEW -m tcp -p tcp --dport 21 -j ACCEPT 重启服务1$ systemctlrestart iptables.service 被动模式(未测试) 如果ftp处于被动模式下，除了需要修改iptables的配置文件以外，还需要修改vsftpd的配置文件。首先是修改vsftpd的配置文件：使用Vim编辑器打开vsftpd配置文件：1$ vim /etc/vsftpd/vsftpd.conf 现在配置文件中找到 “connect_from_port_20=YES” 并将它修改为 “connect_from_port_20=NO” ，关闭掉vsftpd的主动模式。 然后在配置文件的末尾追加： 使vsftpd运行在被动模式 pasv_enable=YES 被动模式最小端口号30000 pasv_min_port=30000 被动模式最大端口号31000 pasv_max_port=31000 保存配置文件并退出。然后重启vsftpd服务：1$ systemctl restart vsftpd.service 然后再使用Vim编辑器打开iptables配置文件：1$ vim /etc/sysconfig/iptables 添加这两句话：（“#”开头的是注释，可以不添加）1234#开放ftp协议21端口，允许接受来自21端口的新建TCP连接-A INPUT -p tcp -m state --state NEW -m tcp --dport 21 -j ACCEPT#开放30000-31000号端口，允许接受来自此端口号段的新建TCP连接 **-A INPUT -p tcp --dport 30000:31000 -j ACCEPT 保存并退出，然后重启iptables服务：1$ systemctl restart iptables.service]]></content>
      <categories>
        <category>FTP</category>
      </categories>
      <tags>
        <tag>Centos7</tag>
        <tag>FTP</tag>
        <tag>服务器运维</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[电脑小技巧]]></title>
    <url>%2F2018%2F09%2F10%2F%E7%94%B5%E8%84%91%E5%B0%8F%E6%8A%80%E5%B7%A7%2F</url>
    <content type="text"><![CDATA[日常电脑使用小技巧 不用截图工具截取整个网页打开浏览器(测试chrome可用)并调出控制台，快捷键 f12 然后选择快捷键ctrl + shift + p调出,如图(我也忘记叫什么了),Mac下是shift + command + p 输入capt，出现一下选择，选择如图 即可截取整张网页，并自动下载至浏览器默认下载目录测试图太长就不放了，可以自行测试，应该浏览器都通用(国外)]]></content>
      <categories>
        <category>程序人生</category>
      </categories>
      <tags>
        <tag>chrome</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL入门]]></title>
    <url>%2F2018%2F09%2F10%2FMySQL%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[MySql入门教程,Sql语句复习 环境 centos7 virtualbox MySQL 5.7 教程 SQL语言分类 DQL(数据查询语言) 数据查询语言DQL基本结构是由SELECT子句，FROM子句，WHERE DML(数据操纵语言) 数据操纵语言DML主要有三种形式：插入：INSERT，更新：UPDATE，删除：DELETE DDL(数据定义语言) 数据定义语言DDL用来创建数据库中的各种对象—–表、视图、索引、同义词、聚簇等 DCL(数据控制语言) 数据控制语言DCL用来授予或回收访问数据库的某种特权，并控制数据库操纵事务发生的时间及效果，对数据库实行监视 Centos下Mysq显示方式设置 使用more 1mysql&gt; pager more 使用less 1mysql&gt; pager less less模式下按下键盘q退出 还原 1mysql&gt; nopager 使用\G按行垂直显示结果如果一行很长，需要这行显示的话，看起结果来就非常的难受。在SQL语句或者命令后使用\G而不是分号结尾，可以将每一行的值垂直输出。这个可能也是大家对于MySQL最熟悉的区别于其他数据库工具的一个特性了。 1234mysql&gt; use mysql;Database changedmysql&gt; select * from user\G MySQL用户设置如果你需要添加 MySQL 用户，你只需要在 mysql 数据库中的 user 表添加新用户即可。 以下为添加用户的的实例，用户名为guest，密码为guest123，并授权用户可进行 SELECT, INSERT 和 UPDATE操作权限：1234567891011121314151617181920mysql&gt; use mysql;Database changedmysql&gt; INSERT INTO user (host, user, password, select_priv, insert_priv, update_priv) VALUES ('localhost', 'guest', PASSWORD('guest123'), 'Y', 'Y', 'Y');Query OK, 1 row affected (0.20 sec)mysql&gt; FLUSH PRIVILEGES;Query OK, 1 row affected (0.01 sec)mysql&gt; SELECT host, user, password FROM user WHERE user = 'guest';+-----------+---------+------------------+| host | user | password |+-----------+---------+------------------+| localhost | guest | 6f8c114b58f2ce9e |+-----------+---------+------------------+1 row in set (0.00 sec) 注意：在 MySQL5.7 中 user 表的 password 已换成了authentication_string。 error 这种方式出现过mysql插入用户的时候，突然出现了 Field ‘ssl_cipher’ doesn’t have a default value 的错误，现已解决，步骤如下：在mysql的user表中增加连接用户帐号：这里不要直接使用INSERT语句添加user记录，使用INSERT可能出现：ERROR 1364 (HY000): Field ‘ssl_cipher’ doesn’t have a default value错误。 你可以在创建用户时，为用户指定权限，在对应的权限列中，在插入语句中设置为 ‘Y’ 即可，用户权限列表如下： Select_priv Insert_priv Update_priv Delete_priv Create_priv Drop_priv Reload_priv Shutdown_priv Process_priv File_priv Grant_priv References_priv Index_priv Alter_priv 另外一种添加用户的方法为通过SQL的 GRANT 命令，以下命令会添加用户 zara ，密码为 zara123 。123mysql&gt;GRANT SELECT ON *.* TO 'zara'@'localhost' IDENTIFIED BY 'zara123' -&gt;WITH GRANT OPTION;Query OK 为数据库TUTORIALS添加用户 zara ，密码为 zara1231234mysql&gt; GRANT SELECT,INSERT,UPDATE,DELETE,CREATE,DROP -&gt; ON TUTORIALS.* -&gt; TO 'zara'@'localhost' -&gt; IDENTIFIED BY 'zara123'; 管理数据库命令USE (dbname);选择要操作的数据库，之后所执行的mysql命令都是针对该数据库1mysql&gt; use mysql; SHOW DATABASES;列出Mysql数据库管理系统的数据库列表1mysql&gt; SHOW DATABASES; SHOW TABLES;显示指定数据库的所有表，使用该命令前需要使用 use 命令来选择要操作的数据库。1mysql&gt; SHOW TABLES; SHOW COLUMNS FROM (tablename):显示数据表的属性，属性类型，主键信息 ，是否为 NULL，默认值等其他信息。 SHOW INDEX FROM (tablename):显示数据表的详细索引信息，包括PRIMARY KEY（主键）。1mysql&gt; SHOW INDEX FROM user; SHOW TABLE STATUS LIKE [FROM db_name] [LIKE ‘pattern’] \G:该命令将输出Mysql数据库管理系统的性能及统计信息。 1mysql&gt; SHOW TABLE STATUS FROM mysql; 创建数据库登陆 MySQL 服务后，使用 create 命令创建数据库，语法如下:1CREATE DATABASE booklib; 删除数据库如果使用普通用户可能需要权限来进行删除数据库，登陆root账户，拥有最高权限，删除数据库需要谨慎，一旦删除，数据将会消失。语法如下1DROP DATABASE (dbname); MySQL数据类型 数字类型 整数: tinyint、smallint、mediumint、int、bigint 浮点数: float、double、real、decimal 日期和时间: date、time、datetime、timestamp、year 字符串类型 字符串: char、varchar 文本: tinytext、text、mediumtext、longtext 二进制(可用来存储图片、音乐等): tinyblob、blob、mediumblob、longblob 字符串类型 类型 单位 最大 特性 CHAR 字符 最大为255字符 存储定长，容易造成空间的浪费 VARCHAR 字符 可以超过255个字符 存储变长，节省存储空间 TEXT 字节 总大小为65535字节，约为64KB - TEXT在MySQL内部大多存储格式为溢出页，效率不如CHAR Mysql默认为utf-8，那么在英文模式下1个字符=1个字节，在中文模式下1个字符=3个字节。 数字类型整形 type Storage Minumun Value Maximum Value (Bytes) (Signed/Unsigned) (Signed/Unsigned) TINYINT 1 -128 127 0 255 SMALLINT 2 -32768 32767 0 65535 MEDIUMINT 3 -8388608 8388607 0 16777215 INT 4 -2147483648 2147483647 0 4294967295 BIGINT 8 -9223372036854775808 9223372036854775807 0 18446744073709551615 浮点型 属性 存储空间 精度 精确性 说明 FLOAT(M, D) 4 bytes 单精度 非精确 单精度浮点型，m总个数，d小数位 DOUBLE(M, D) 8 bytes 双精度 比Float精度高 双精度浮点型，m总个数，d小数位 FLOAT容易造成精度丢失 定点数DECIMAL 高精度的数据类型，常用来存储交易相关的数据 DECIMAL(M,N).M代表总精度，N代表小数点右侧的位数（标度） 1 &lt; M &lt; 254, 0 &lt; N &lt; 60; 存储空间变长 时间类型 类型 字节 例 精确性 DATE 三字节 2015-05-01 精确到年月日 TIME 三字节 11:12:00 精确到时分秒 DATETIME 八字节 2015-05-01 11::12:00 精确到年月日时分秒 TIMESTAMP 2015-05-01 11::12:00 精确到年月日时分秒 MySQL在5.6.4版本之后，TIMESTAMP和DATETIME支持到微秒。 TIMESTAMP会根据系统时区进行转换，DATETIME则不会 存储范围的区别 TIMESTAMP存储范围：1970-01-01 00::00:01 to 2038-01-19 03:14:07 DATETIME的存储范围：1000-01-01 00:00:00 to 9999-12-31 23:59:59 一般使用TIMESTAMP国际化 如存时间戳使用数字类型BIGINT 创建数据表创建MYSQL数据以下信息 表名 表字段名 定义表每个字段 语法1CREATE TABLE (tablename) (column name column type, ...) 例子：创建一个书本表，书本有编号,名字，出版社，作者名称，价格，出版日期12345678mysql&gt; CREATE TABLE IF NOT EXISTS book( &gt; book_id INT UNSIGNED AUTO_INCREMENT, &gt; book_name VARCHAR(50) NOT NULL, &gt; author VARCHAR(10) NOT NULL, &gt; pub VARCHAR(100), &gt; pub_date DATE, &gt; PRIMARY KEY (book_id) &gt; ) ENGINE=InnoDB DEFAULT CHARSET=utf8; 解析： 如果不想字段为NULL，可以设置字段为NOT NULL，但是一旦字段该数值为null，则会报错。 AUTO_INCREMENT定义列为自增的属性，一般用于主键，数值会自动加1。 PRIMARY KEY关键字用于定义列为主键。 您可以使用多列来定义主键，列间以逗号分隔。 ENGINE 设置存储引擎，CHARSET 设置编码。 删除数据表MySQL删除数据表，语法1DROP TABLE (tablename); 示例:1mysql&gt; DROP TABLE book; 插入数据使用 INSERT INTO 语句来插入数据,语法123INSERT INTO table_name ( field1, field2,...fieldN ) VALUES ( value1, value2,...valueN ); 如果数据是字符型，必须使用单引号或者双引号，如：”value”。 示例:12mysql&gt; INSERT INTO book(book_name, author, pub, pub_date) -&gt; VALUES('Android Coder', 'bitch', 'english', NOW()) 一次插入多行语句1234mysql&gt; INSERT INTO book(book_name, author, pub, pub_date) -&gt; VALUES -&gt; ('python', 'pp', 'english', DATE('2010-08-10')), -&gt; ('kotlin', 'kk', 'amearica', DATE('2013-07-10')); 查询数据使用SQL SELECT 查询数据,语法1234SELECT column_name,column_nameFROM table_name[WHERE Clause][LIMIT N][ OFFSET M] 查询语句中你可以使用一个或者多个表，表之间使用逗号(,)分割，并使用WHERE语句来设定查询条件。 SELECT 命令可以读取一条或者多条记录。 你可以使用星号（*）来代替其他字段，SELECT语句会返回表的所有字段数据 你可以使用 WHERE 语句来包含任何条件。 你可以使用 LIMIT 属性来设定返回的记录数。 你可以通过OFFSET指定SELECT语句开始查询的数据偏移量。默认情况下偏移量为0。 1mysql&gt; SELECT * FROM book; WHERE 字句我们知道从 MySQL 表中使用 SQL SELECT 语句来读取数据。如需有条件地从表中选取数据，可将 WHERE 子句添加到 SELECT 语句中。语法12SELECT field1, field2,...fieldN FROM table_name1, table_name2...[WHERE condition1 [AND [OR]] condition2..... 查询语句中你可以使用一个或者多个表，表之间使用逗号, 分割，并使用WHERE语句来设定查询条件。 你可以在 WHERE 子句中指定任何条件。 你可以使用 AND 或者 OR 指定一个或多个条件。 WHERE 子句也可以运用于 SQL 的 DELETE 或者 UPDATE 命令。 WHERE 子句类似于程序语言中的 if 条件，根据 MySQL 表中的字段值来读取指定的数据。 操作符 描述 实例 = 等号，检测两边值是否相等，相等返回true A = B 返回true &lt;&gt;, != 不等于，检测两边值是否相等，相等返回false A != B 返回false &gt; 大于，检测左边值是否大于右边值，大于则返回true A &gt; B 返回true &lt; 小于，检测左边值是否小于右边值，小于则返回true A &lt; B 返回true &gt;= 大于等于，检测左边值是否大于等于右边值，同上 A &gt;= B 返回true &lt;= 大于等于，检测左边值是否大于等于右边值，同上 A &lt;= B 返回true 如果我们想在 MySQL 数据表中读取指定的数据，WHERE 子句是非常有用的。使用主键来作为 WHERE 子句的条件查询是非常快速的。如果给定的条件在表中没有任何匹配的记录，那么查询不会返回任何数据。 1mysql&gt; SELECT * FROM book WHERE author='bitch' UPDATE 查询使用SQL UPDATE语句修改或更新数据库中数据 语法12UPDATE table_name SET field1=new-value1, field2=new-value2[WHERE Clause] 你可以同时更新一个或多个字段。 你可以在 WHERE 子句中指定任何条件。 你可以在一个单独表中同时更新数据。 1mysql&gt; UPDATE book SET author = 'jack' WHERE book_id = 4; DELETE 删除SQL 的 DELETE FROM 命令来删除 MySQL 数据表中的记录。语法1DELETE FROM table_name [WHERE Clause] 如果没有指定 WHERE 子句，MySQL 表中的所有记录将被删除。 你可以在 WHERE 子句中指定任何条件 您可以在单个表中一次性删除记录。 请谨慎 1mysql&gt; DELETE FROM book WHERE book_name = 'TEST'; LIKE 子句MySQL 中使用 SQL SELECT 命令来读取数据， 同时我们可以在 SELECT 语句中使用 WHERE 子句来获取指定的记录。WHERE 子句中可以使用等号 = 来设定获取数据的条件，如 “runoob_author = ‘RUNOOB.COM’”。但是有时候我们需要获取 runoob_author 字段含有 “COM” 字符的所有记录，这时我们就需要在 WHERE 子句中使用 SQL LIKE 子句。SQL LIKE 子句中使用百分号 %字符来表示任意字符，类似于UNIX或正则表达式中的星号 *。如果没有使用百分号 %, LIKE 子句与等号 = 的效果是一样的。 语法123SELECT field1, field2,...fieldN FROM table_nameWHERE field1 LIKE condition1 [AND [OR]] filed2 = 'somevalue' 你可以在 WHERE 子句中指定任何条件。 你可以在 WHERE 子句中使用LIKE子句。 你可以使用LIKE子句代替等号 =。 LIKE 通常与 % 一同使用，类似于一个元字符的搜索。 你可以使用 AND 或者 OR 指定一个或多个条件。 你可以在 DELETE 或 UPDATE 命令中使用 WHERE…LIKE 子句来指定条件。 like 匹配/模糊匹配，会与 % 和 _ 结合使用。‘%a’ //以a结尾的数据‘a%’ //以a开头的数据‘%a%’ //含有a的数据‘_a_’ //三位且中间字母是a的‘a’ //两位且结尾字母是a的‘a‘ //两位且开头字母是a的 1mysql&gt; SELECT * FROM book WHERE pub LIKE 'a%'; UNION 操作符MySQL UNION 操作符用于连接两个以上的 SELECT 语句的结果组合到一个结果集合中。多个 SELECT 语句会删除重复的数据。 语法1234567SELECT expression1, expression2, ... expression_nFROM tables[WHERE conditions]UNION [ALL | DISTINCT]SELECT expression1, expression2, ... expression_nFROM tables[WHERE conditions]; expression1, expression2, … expression_n: 要检索的列。 tables: 要检索的数据表。 WHERE conditions: 可选， 检索条件。 DISTINCT: 可选，删除结果集中重复的数据。默认情况下 UNION 操作符已经删除了重复数据，所以 DISTINCT 修饰符对结果没啥影响。 ALL: 可选，返回所有结果集，包含重复数据。 案例 排序读取的数据进行排序，我们就可以使用 MySQL 的 ORDER BY 子句来设定你想按哪个字段哪种方式来进行排序，再返回搜索结果。 语法12SELECT field1, field2,...fieldN table_name1, table_name2...ORDER BY field1, [field2...] [ASC [DESC]] 你可以使用任何字段来作为排序的条件，从而返回排序后的查询结果。 你可以设定多个字段来排序。 你可以使用 ASC 或 DESC 关键字来设置查询结果是按升序或降序排列。 默认情况下，它是按升序排列。 你可以添加 WHERE…LIKE 子句来设置条件。 1mysql&gt; SELECT * FROM book ORDER BY pub_date ASC; 分组GROUP BY 语句根据一个或多个列对结果集进行分组。在分组的列上我们可以使用 COUNT, SUM, AVG,等函数。 语法1234SELECT column_name, function(column_name)FROM table_nameWHERE column_name operator valueGROUP BY column_name; 1mysql&gt; SELECT COUNT(*), book_name FROM book GROUP BY book_name; 注意 group by 语句用法有一个注意点，在 select 语句中，所查询的字段除了聚合函数（SUM ,AVG,COUNT…)以外 必须只能是分组的字段，举例：1SELECT book_id,book_name,count(*) FROM book GROUP BY book_name; 以上会报错,纠正1SELECT book_id,book_name,count(*) FROM book GROUP BY book_id,book_name; 分组后的条件使用 HAVING 来限定，WHERE 是对原始数据进行条件限制。几个关键字的使用顺序为 where 、group by 、having、order by 连接使用 MySQL 的 JOIN 在两个或多个表中查询数据。你可以在 SELECT, UPDATE 和 DELETE 语句中使用 Mysql 的 JOIN 来联合多表查询。JOIN 按照功能大致分为如下三类： INNER JOIN（内连接,或等值连接）：获取两个表中字段匹配关系的记录。 LEFT JOIN（左连接）：获取左表所有记录，即使右表没有对应匹配的记录。 RIGHT JOIN（右连接）： 与 LEFT JOIN 相反，用于获取右表所有记录，即使左表没有对应匹配的记录。 实例 NULL 值处理我们已经知道 MySQL 使用 SQL SELECT 命令及 WHERE 子句来读取数据表中的数据,但是当提供的查询条件字段为 NULL 时，该命令可能就无法正常工作。为了处理这种情况，MySQL提供了三大运算符: IS NULL: 当列的值是 NULL,此运算符返回 true。 IS NOT NULL: 当列的值不为 NULL, 运算符返回 true。 &lt;=&gt;: 比较操作符（不同于=运算符），当比较的的两个值为 NULL 时返回 true。 关于 NULL 的条件比较运算是比较特殊的。你不能使用 = NULL 或 != NULL 在列中查找 NULL 值 。在 MySQL 中，NULL 值与任何其它值的比较（即使是 NULL）永远返回 false，即 NULL = NULL 返回false 。MySQL 中处理 NULL 使用 IS NULL 和 IS NOT NULL 运算符。 实例:表中有一行有NULL值的数据，如果使用1mysql&gt; SELECT * FROM book WHERE pub = NULL; 会出现判断NULL， =和！=是不起作用的12mysql&gt; SELECT * FROM book WHERE author IS NULL;mysql&gt; SELECT * FROM book WHERE author IS NOT NULL; 正则表达式案例 事务MySQL 事务主要用于处理操作量大，复杂度高的数据。比如说，在人员管理系统中，你删除一个人员，你即需要删除人员的基本资料，也要删除和该人员相关的信息，如信箱，文章等等，这样，这些数据库操作语句就构成一个事务！ 在 MySQL 中只有使用了 Innodb 数据库引擎的数据库或表才支持事务。 事务处理可以用来维护数据库的完整性，保证成批的 SQL 语句要么全部执行，要么全部不执行。 事务用来管理 insert,update,delete 语句 一般来说，事务是必须满足4个条件（ACID）：：原子性（Atomicity，或称不可分割性）、一致性（Consistency）、隔离性（Isolation，又称独立性）、持久性（Durability）。 原子性：一个事务（transaction）中的所有操作，要么全部完成，要么全部不完成，不会结束在中间某个环节。事务在执行过程中发生错误，会被回滚（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。 一致性：在事务开始之前和事务结束以后，数据库的完整性没有被破坏。这表示写入的资料必须完全符合所有的预设规则，这包含资料的精确度、串联性以及后续数据库可以自发性地完成预定的工作。 隔离性：数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。事务隔离分为不同级别，包括读未提交（Read uncommitted）、读提交（read committed）、可重复读（repeatable read）和串行化（Serializable）。 持久性：事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。 在 MySQL 命令行的默认设置下，事务都是自动提交的，即执行 SQL 语句后就会马上执行COMMIT 操作。因此要显式地开启一个事务务须使用命令 BEGIN 或 STARTTRANSACTION，或者执行命令 SET AUTOCOMMIT=0，用来禁止使用当前会话的自动提交。 事务控制语句： BEGIN或START TRANSACTION；显式地开启一个事务； COMMIT；也可以使用COMMIT WORK，不过二者是等价的。COMMIT会提交事务，并使已对数据库进行的所有修改成为永久性的； ROLLBACK；有可以使用ROLLBACK WORK，不过二者是等价的。回滚会结束用户的事务，并撤销正在进行的所有未提交的修改； SAVEPOINT identifier；SAVEPOINT允许在事务中创建一个保存点，一个事务中可以有多个SAVEPOINT； RELEASE SAVEPOINT identifier；删除一个事务的保存点，当没有指定的保存点时，执行该语句会抛出一个异常； ROLLBACK TO identifier；把事务回滚到标记点； SET TRANSACTION；用来设置事务的隔离级别。InnoDB存储引擎提供事务的隔离级别有READ UNCOMMITTED、READ COMMITTED、REPEATABLE READ和SERIALIZABLE。 案例 ALTER命令当我们需要修改数据表名或者修改数据表字段时，就需要使用到MySQL ALTER命令。 ALTER TABLE：添加，修改，删除表的列，约束等表的定义。 查看列：desc 表名; 修改表名：alter table t_book rename to bbb; 添加列：alter table 表名 add column 列名 varchar(30); 删除列：alter table 表名 drop column 列名; 修改列名MySQL： alter table bbb change nnnnn hh int; 修改列属性：alter table t_book modify name varchar(22); sp_rename：SQLServer 内置的存储过程，用与修改表的定义。 案例 约束MySQL 查看约束，添加约束，删除约束 添加列，修改列，删除列 查看表的字段信息：desc 表名; 查看表的所有信息：show create table 表名; 添加主键约束：alter table 表名 add constraint 主键 （形如：PK_表名） primary key 表名(主键字段); 添加外键约束：alter table 从表 add constraint 外键（形如：FK_从表_主表） foreign key 从表(外键字段) references 主表(主键字段); 删除主键约束：alter table 表名 drop primary key; 删除外键约束：alter table 表名 drop foreign key 外键（区分大小写）; 修改表名：alter table t_book rename to bbb; 添加列：alter table 表名 add column 列名 varchar(30); 删除列：alter table 表名 drop column 列名; 修改列名： alter table bbb change nnnnn hh int; 修改列属性：alter table t_book modify name varchar(22); 12mysql&gt; desc book;mysql&gt; desc reader; 添加book_id列到reader表，并添加外键约束(book表中的book_id)12mysql&gt; ALTER TABLE reader ADD book_id INT UNSIGNED;mysql&gt; desc reader; 12mysql&gt; ALTER TABLE reader ADD CONSTRAINT fk_book_reader FOREIGN key -&gt; reader(book_id) REFERENCES book(book_id); 出现1215详情见另一篇文章[MySQL错误集] 索引MySQL索引的建立对于MySQL的高效运行是很重要的，索引可以大大提高MySQL的检索速度。打个比方，如果合理的设计且使用索引的MySQL是一辆兰博基尼的话，那么没有设计和使用索引的MySQL就是一个人力三轮车。索引分单列索引和组合索引。单列索引，即一个索引只包含单个列，一个表可以有多个单列索引，但这不是组合索引。组合索引，即一个索引包含多个列。创建索引时，你需要确保该索引是应用在 SQL 查询语句的条件(一般作为 WHERE 子句的条件)。实际上，索引也是一张表，该表保存了主键与索引字段，并指向实体表的记录。上面都在说使用索引的好处，但过多的使用索引将会造成滥用。因此索引也会有它的缺点：虽然索引大大提高了查询速度，同时却会降低更新表的速度，如对表进行INSERT、UPDATE和DELETE。因为更新表时，MySQL不仅要保存数据，还要保存一下索引文件。建立索引会占用磁盘空间的索引文件。 显示索引1mysql&gt; SHOW INDEX FROM table_name\G 普通索引创建索引这是最基本的索引，它没有任何限制。它有以下几种创建方式：1CREATE INDEX indexName ON mytable(cname(length)); 如果是CHAR，VARCHAR类型，length可以小于字段实际长度；如果是BLOB和TEXT类型，必须指定 length。 修改表结构(添加索引)1ALTER table tableName ADD INDEX indexName(columnName) 创建表的时候直接指定12345CREATE TABLE mytable( ID INT NOT NULL, username VARCHAR(16) NOT NULL, INDEX [indexName] (username(length)) ); 删除索引的语法1DROP INDEX [indexName] ON mytable; 为book表中book_name建立基本的索引1mysql&gt; CREATE INDEX INDEX_BOOKNAME ON book(book_name(50)); 唯一索引它与前面的普通索引类似，不同的就是：索引列的值必须唯一，但允许有空值。如果是组合索引，则列值的组合必须唯一。它有以下几种创建方式： 创建索引1CREATE UNIQUE INDEX indexName ON mytable(username(length)) 修改表结构1ALTER table mytable ADD UNIQUE [indexName] (username(length)) 创建表的时候直接指定12345CREATE TABLE mytable( ID INT NOT NULL, username VARCHAR(16) NOT NULL, UNIQUE [indexName] (username(length)) ); 使用ALTER 命令添加和删除索引有四种方式来添加数据表的索引： ALTER TABLE tbl_name ADD PRIMARY KEY (column_list): 该语句添加一个主键，这意味着索引值必须是唯一的，且不能为NULL。 ALTER TABLE tbl_name ADD UNIQUE index_name (column_list): 这条语句创建索引的值必须是唯一的（除了NULL外，NULL可能会出现多次）。 ALTER TABLE tbl_name ADD INDEX index_name (column_list): 添加普通索引，索引值可出现多次。 ALTER TABLE tbl_name ADD FULLTEXT index_name (column_list):该语句指定了索引为 FULLTEXT ，用于全文索引。 例子：1mysql&gt; ALTER TABLE reader ADD INDEX (reader_name); 你还可以在 ALTER 命令中使用 DROP 子句来删除索引。尝试以下实例删除索引:1mysql&gt; ALTER TABLE reader DROP INDEX (reader_name); 使用 ALTER 命令添加和删除主键 主键只能作用于一个列上，添加主键索引时，你需要确保该主键默认不为空（NOT NULL）。实例如下：12mysql&gt; ALTER TABLE testalter_tbl MODIFY i INT NOT NULL;mysql&gt; ALTER TABLE testalter_tbl ADD PRIMARY KEY (i); 你也可以使用 ALTER 命令删除主键：1mysql&gt; ALTER TABLE testalter_tbl DROP PRIMARY KEY; 删除主键时只需指定PRIMARY KEY，但在删除索引时，你必须知道索引名。 临时表MySQL 临时表在我们需要保存一些临时数据时是非常有用的。临时表只在当前连接可见，当关闭连接时，Mysql会自动删除表并释放所有空间。临时表在MySQL 3.23版本中添加，如果你的MySQL版本低于 3.23版本就无法使用MySQL的临时表。不过现在一般很少有再使用这么低版本的MySQL数据库服务了。MySQL临时表只在当前连接可见，如果你使用PHP脚本来创建MySQL临时表，那每当PHP脚本执行完成后，该临时表也会自动销毁。如果你使用了其他MySQL客户端程序连接MySQL数据库服务器来创建临时表，那么只有在关闭客户端程序时才会销毁临时表，当然你也可以手动销毁。 语法和建表差不多，只不过 TABLE 关键字改成 TEMPORARY TABLE 即可。 删除和普通删除表语法没区别。 复制表使用 SHOW CREATE TABLE 命令获取创建数据表(CREATE TABLE) 语句，该语句包含了原数据表的结构，索引等。1mysql&gt; SHOW CREATE TABLE book\G 复制表的内容，你就可以使用 INSERT INTO … SELECT 语句来实现案例 note:来给大家区分下mysql复制表的两种方式。第一、只复制表结构到新表create table 新表 select from 旧表 where 1=2或者create table 新表 like 旧表第二、复制表结构及数据到新表create table新表 select from 旧表 序列使用MySQL 序列是一组整数：1, 2, 3, …，由于一张数据表只能有一个字段自增主键， 如果你想实现其他字段也实现自动增加，就可以使用MySQL序列来实现。 前面也有用到过的 AUTO_INCREMENT 来定义列既可以实现序列 重置序列如果你删除了数据表中的多条记录，并希望对剩下数据的AUTO_INCREMENT列进行重新排列，那么你可以通过删除自增的列，然后重新添加来实现。 不过该操作要非常小心，如果在删除的同时又有新记录添加，有可能会出现数据混乱。操作如下所示：1234mysql&gt; ALTER TABLE insect DROP id;mysql&gt; ALTER TABLE insect -&gt; ADD id INT UNSIGNED NOT NULL AUTO_INCREMENT FIRST, -&gt; ADD PRIMARY KEY (id); 序列的开始值创建表时12345678mysql&gt; CREATE TABLE insect -&gt; ( -&gt; id INT UNSIGNED NOT NULL AUTO_INCREMENT, -&gt; PRIMARY KEY (id), -&gt; name VARCHAR(30) NOT NULL, -&gt; date DATE NOT NULL, -&gt; origin VARCHAR(30) NOT NULL)engine=innodb auto_increment=100 charset=utf8; ALTER修改1mysql&gt; ALTER TABLE t AUTO_INCREMENT = 100; 处理重复数据防止表中出现重复数据你可以在MySQL数据表中设置指定的字段为 PRIMARY KEY（主键） 或者 UNIQUE（唯一） 索引来保证数据的唯一性。 统计重复数据以下我们将统计表中 first_name 和 last_name的重复记录数：1234mysql&gt; SELECT COUNT(*) as repetitions, last_name, first_name -&gt; FROM person_tbl -&gt; GROUP BY last_name, first_name -&gt; HAVING repetitions &gt; 1; 以上查询语句将返回 person_tbl 表中重复的记录数。 一般情况下，查询重复的值，请执行以下操作： 确定哪一列包含的值可能会重复。 在列选择列表使用COUNT(*)列出的那些列。 在GROUP BY子句中列出的列。 HAVING子句设置重复数大于1。 过滤重复数据如果你需要读取不重复的数据可以在 SELECT 语句中使用 DISTINCT 关键字来过滤重复数据。你也可以使用 GROUP BY 来读取数据表中不重复的数据： 导出数据更多 导出 SQL 格式的数据12$ mysqldump -u root -p (dbName) (tableName) &gt; dump.txtpassword ****** 表名可不加，不加则导出整个数据库实例:1$ mysqldump -u root -p booklib &gt; /tmp/booklib.txt 导入数据更多 source命令导入先登录进数据库1234mysql&gt; create database booklib; # 创建数据库mysql&gt; use booklib; # 使用已创建的数据库 mysql&gt; set names utf8; # 设置编码mysql&gt; source /tmp/booklib.sql # 导入备份数据库]]></content>
      <categories>
        <category>DBA</category>
      </categories>
      <tags>
        <tag>Mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Centos7安装Mysql5.7]]></title>
    <url>%2F2018%2F09%2F07%2FCentos7%E5%AE%89%E8%A3%85Mysql5-7%2F</url>
    <content type="text"><![CDATA[环境 centos7 virtualbox 安装centos7需要检查是否已经安装了Mariadb在安装MySQL之前要检查当前环境中是否已经装了Mariadb，如果存在则需要卸载，否则可能导致MySQL安装失败1$ rpm -qa | grep mariadb 如果输出maraidb等的信息则需要进行卸载，如图需要进行强制卸载1$ rpm -e --nodeps mariadb-libs-5.5.56-2.el7.x86_64 Yum Repo官方指导点击链接查看最新的Yum Repository123// 设置rpm$ rpm -Uvh https://dev.mysql.com/get/mysql80-community-release-el7-1.noarch.rpm$ yum repolist all | grep mysql 如图需要安装5.7版本，则需要选择发布系列,编辑/etc/yum.repos.d/mysql-community.repo 文件来选择系列 。这是文件中发布系列的子存储库的典型条目：123456[mysql80-community]name=MySQL 8.0 Community Serverbaseurl=http://repo.mysql.com/yum/mysql-8.0-community/el/6/$basearch/enabled=1gpgcheck=1gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-mysql 找到要配置的子存储库的条目，然后编辑该enabled选项。指定enabled=0禁用子存储库，或 enabled=1启用子存储库。例如，要安装MySQL 5.7，请确保您拥有enabled=0,MySQL 8.0的上述子存储库条目，并且具有 enabled=1,5.7系列的条目：1234567# Enable to use MySQL 5.7[mysql57-community]name=MySQL 5.7 Community Serverbaseurl=http://repo.mysql.com/yum/mysql-5.7-community/el/6/$basearch/enabled=1gpgcheck=1gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-mysql 您应该只在任何时候为一个发布系列启用子存储库。当启用多个版本系列的子存储库时，Yum将使用最新的系列。 通过运行以下命令并检查其输出来验证是否已启用和禁用了正确的子存储库（对于启用dnf的系统，请使用dnf替换 命令中的 yum）：1$ yum repolist enabled | grep mysql 安装mysql1$ yum install -y mysql-community-server 启动使用以下命令启动MySQL服务器：1$ systemctl start mysqld.service 检查MySQL服务器的状态1$ systemctl status mysqld.service MySQL服务器初始化（从MySQL5.7开始）：在服务器初始启动时，如果服务器的数据目录为空，则会发生以下情况： 服务器已初始化。 在数据目录中生成SSL证书和密钥文件。 该validate_password插件安装并启用。 将‘root‘@’localhost’ 创建一个超级用户帐户。设置超级用户的密码并将其存储在错误日志文件中。要显示它，请使用以下命令：1$ grep 'temporary password' /var/log/mysqld.log 通过上面命令获取生成的临时密码登录并为超级用户帐户设置自定义密码，尽快更改root密码：1$ mysql -uroot -p 修改root本地登录密码1$ ALTER USER 'root'@'localhost' IDENTIFIED BY 'MyNewPass4!'; 注意MySQL的 validate_password 插件默认安装。这将要求密码包含至少一个大写字母，一个小写字母，一个数字和一个特殊字符，并且密码总长度至少为8个字符。 实例]]></content>
      <categories>
        <category>DBA</category>
      </categories>
      <tags>
        <tag>Mysql</tag>
        <tag>Centos7</tag>
        <tag>环境搭建</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo + github 搭建个人博客]]></title>
    <url>%2F2018%2F09%2F07%2Fhexo-github-%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[我的历史上第一篇教程，Hexo+github搭建个人博客。虽然网上有很多，但是想从这一篇开始我的写作之路。 一些前戏搭建此博客时，百度了很多资料，但是上手还是从官方资料开始上手这是官方链接HexoNext主题图标库 开始使用前提Hexo博客的前提需要在本地先安装nodejs与git推荐一下使用淘宝NPM，本人是windows环境下搭建，建议用git-bash NodeJs Git以上的安装就不写在文章里了，不会可自行百度 部署 安装Hexo 1$ npm install -g hexo-cli 搭建安装Hexo完成后，请执行以下命令，hexo会在指定文件夹中创建文件1234$ cd e:/ $ hexo init &lt;folder&gt;$ cd &lt;folder&gt;$ npm install 新建完成后会生成hexo所需要的一些文件_config.yml网站的一些主要配置信息都在这文件下进行配置详细参数可点击链接进行查看config Hexo命令init1$ hexo init [folder] 新建一个网站。如果没有设置 folder ，Hexo 默认在目前的文件夹建立网站 new1$ hexo new [post|draft|page] &lt;title&gt; 新建一篇文章。如果没有设置 layout 的话，默认使用 _config.yml 中的 default_layout 参数代替。如果标题包含空格的话，请使用引号括起来。 generate1$ hexo g 生成静态文件。 server1$ hexo s 启动服务器。默认情况下，访问网址为： http://localhost:4000/。 deploy1$ hexo d 部署网站。 clean1$ hexo clean 清除缓存文件 (db.json) 和已生成的静态文件 (public)。 Hexo美化主题安装这里安装的是比较热门的Next主题里面也有中文文档，安装说明都很详细，具体安装不在本教程说明,但是具体说明主题中的 _config.yml 文件和站点中的 _config.yml 文件配置是有区别之分的，请详细查看清楚具体是配置哪个配置文件。 启用主题修改站点配置文件 _config.yml 1234# Extensions## Plugins: https://hexo.io/plugins/## Themes: https://hexo.io/themes/theme: next 主题设定选择 Scheme Scheme 是 NexT 提供的一种特性，借助于 Scheme，NexT 为你提供多种不同的外观。同时，几乎所有的配置都可以 在 Scheme 之间共用。目前 NexT 支持三种 Scheme，他们是： Muse - 默认 Scheme，这是 NexT 最初的版本，黑白主调，大量留白 Mist - Muse 的紧凑版本，整洁有序的单栏外观 Pisces - 双栏 Scheme，小家碧玉似的清新 Gemini - 左侧网站信息及目录，块+片段结构布局Scheme 的切换通过更改 主题配置文件，搜索 scheme 关键字。 你会看到有四行 scheme 的配置，将你需用启用的 scheme 前面注释 # 去除即可。 动态背景 目前NexT主题最新的是V6.0版本，这个版本中可以有4种动态背景： Canvas-nest three_waves canvas_lines canvas_sphere在 _config.yml 文件中即可配置，但是需要下载配置栗子 点击出现桃心效果浏览器输入：http://7u2ss1.com1.z0.glb.clouddn.com/love.js 拷贝所有代码，在/themes/next/source/js/src里面新建love.js，然后在\themes\next\layout_layout.swig文件末尾添加以下代码： 12&lt;!-- 页面点击小红心 --&gt; &lt;script type="text/javascript" src="/js/src/love.js"&gt;&lt;/script&gt; 设置网站图标默认的网站图标是一个N，当然是需要制定一个图了，在网上找到图后，将其放在 /themes/next/source/images 里面,找到主题配置文件中的favicon关键字，进行替换,如图 实现统计功能 实现效果图 具体实现方法在博客根目录下,git-bash1$ npm install hexo-wordcount --save 然后在主题的配置文件中，配置如下：123# Post wordcount display settings# Dependencies: https://github.com/willin/hexo-wordcountword_count: true 修改主题 swig 布局 为了能在文章信息处显示字数，我们需要修改 themes/next/layout/_macro/post.swig ，在 class 为 post-meta 的 div 中的添加如下内容：12345678910&#123;% if theme.word_count %&#125; &lt;span class=&quot;post-letters-count&quot;&gt; &amp;nbsp; | &amp;nbsp; &lt;i class=&quot;fa fa-align-right&quot;&gt;&lt;/i&gt; &lt;span&gt;字数统计:&#123;&#123; wordcount(post.content) &#125;&#125;字&lt;/span&gt; &amp;nbsp; | &amp;nbsp; &lt;i class=&quot;fa fa-align-left&quot;&gt;&lt;/i&gt; &lt;span&gt;阅读时长:&#123;&#123; min2read(post.content) &#125;&#125;分&lt;/span&gt; &lt;/span&gt;&#123;% endif %&#125; 修改文章内链接文本样式修改文件 themes\next\source\css_common\components\post\post.styl ，在末尾添加如下css样式，：1234567891011// 文章内链接文本样式.post-body p a&#123; color: #0593d3; border-bottom: none; border-bottom: 1px solid #0593d3; &amp;:hover &#123; color: #fc6423; border-bottom: none; border-bottom: 1px solid #fc6423; &#125;&#125; 其中选择 .post-body 是为了不影响标题，选择 p 是为了不影响首页“阅读全文”的显示样式,颜色可以自己定义。 添加背景在 theme/next/source/css/_custom 文件夹下打开 custom.styl 文件，往里面添加以下代码：1234567body&#123; background:url(图片链接); background-size:cover; background-repeat:no-repeat; background-attachment:fixed; background-position:center; &#125; 本地图片将图片放至主题目录下 source\images 修改文章底部的那个带#号的标签 具体实现方法 修改模板 /themes/next/layout/_macro/post.swig ，搜索 rel=”tag”&gt;# ，将 # 换成 在网站底部加上访问量 具体实现方法 打开 \themes\next\layout_partials\footer.swig 文件,在 copyright 前加上画红线这句话：1&lt;script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"&gt;&lt;/script&gt; 然后再合适的位置添加显示统计的代码，如图：1234567&lt;div class="powered-by"&gt; &lt;i class="fa fa-user-md"&gt;&lt;/i&gt; &lt;span id="busuanzi_container_site_uv"&gt; 本站访客数:&lt;span id="busuanzi_value_site_uv"&gt;&lt;/span&gt; &lt;/span&gt; &amp;nbsp|&amp;nbsp&lt;/div&gt; 在这里有两中不同计算方式的统计代码： pv的方式，单个用户连续点击n篇文章，记录n次访问量 123&lt;span id="busuanzi_container_site_pv"&gt; 本站总访问量&lt;span id="busuanzi_value_site_pv"&gt;&lt;/span&gt;次&lt;/span&gt; uv的方式，单个用户连续点击n篇文章，只记录1次访客数 123&lt;span id="busuanzi_container_site_uv"&gt; 本站总访问量&lt;span id="busuanzi_value_site_uv"&gt;&lt;/span&gt;次&lt;/span&gt; 文章加密访问打开 themes\next\layout_partials\head 文件,在以下位置插入这样一段代码：1234567891011121314&lt;script&gt; (function () &#123; if ('&#123;&#123; page.password &#125;&#125;') &#123; if (prompt('请输入文章密码') !== '&#123;&#123; page.password &#125;&#125;') &#123; alert('密码错误！'); if (history.length === 1) &#123; location.replace("http://xxxxxxx.xxx"); // 这里替换成你的首页 &#125; else &#123; history.back(); &#125; &#125; &#125; &#125;)();&lt;/script&gt; 然后在文章上写成类似这样：就ok啦，不过很容易被破解掉噢 当然还有另一种方式 guide1guide2按照指引就可以啦~ 部署首先需要进行创建您个人的github账户 创建公钥打开git-bash,执行1ssh-keygen -t rsa -C "your_email@youremail.com" github官方命令 链接 直接按三次回车，可不用输入密码，然后打开C盘查找Users/当前用户目录(Administrator),找到.ssh文件夹，打开文件夹下的id_rsa.pub文件，可用记事本文件打开将里面文字全部复制 打开github个人主页 (https://github.com/settings/ssh) ,点击 Add SSH Key 按钮，粘贴进去保存即可 安装 hexo-deployer-git。 1$ npm install hexo-deployer-git --save 创建github仓库仓库名中填写&lt;github的用户名&gt;.github.io 修改 _config.yml 文件12345deploy: type: git repo: &lt;repository url&gt; branch: [branch] message: [message] repository url使用ssh url即可，message不填也可branch用master分支即可 执行1$ hexo d 或者1$ hexo g -d 进入博客的github所在仓库，进入仓库设置,查看GitHub Pages即可完成部署 基本操作这里只提到一些编写过程中遇到的问题 markdown语法 插入图片这里涉及到资源文件夹 绝对路径当Hexo项目中只用到少量图片时，可以将图片统一放在 source/images 文件夹中，通过markdown语法访问它们。1![](/images/image.jpg) 相对路径图片除了可以放在统一的 source/images 文件夹中，还可以放在文章自己的目录中。文章的目录可以通过配置 config.yml 来生成。1post_asset_folder: true 把 _config.yml 中配置post_asset_folder设置为true后，通过命令hexo new &lt;文章名字&gt;，hexo就会在文章的目录下建立一个和文章同名的文件夹，然后把图片资源放进该文件夹下，即可通过1![](images/image.jpg) 记住和第一点绝对路径有区别，别在路径前面加/，否则会出错 文档格式假设我们的文章名为 “hello hexo markdwon”，在命令行键入以下命令即可： 12345---title: hello hexo markdowndate: 2016-11-16 18:11:25tags:--- 这些内容是干嘛的呢？事实上，他们就是用于设置 MarkDown 文档在被解析为静态网页文件时的相关配置，这些配置参数一般位于文件中最上方以 — 分隔的区域。 其中，title 的值是当前文档名，也是将来在网页中显示的文章标题。 date 值是我们新建文档时的当地时区时间。 tags 值是文档的标签，我们可以随意赋值为文档贴标签。其用法如下：12345678---title: hello hexo markdowndate: 2016-11-16 18:11:25tags:- hello- hexo- markdown--- 文章分类categories 是用来给文章分类的，它跟 tags 不同的是其具有顺序性和层次性。 categories 的用法同 tags 一样，只不过斗个 categories 值是分先后顺序的。12categories:- hexo 文章摘要有的时候，主题模板配置的不够好的话，Hexo 最终生成的静态站点是不会自动生成文章摘要的。 所以，为了保险起见，我们也自己手动设置文章摘要，这样也方便避免自动生成的摘要不优雅的情况。 设置文章摘要，我们只需在想显示为摘要的内容之后添 &lt;!-- more --&gt; 即可。像下面这样：1234567891011---title: hello hexo markdowndate: 2016-11-16 18:11:25tags:- hello- hexo- markdown---我是短小精悍的文章摘要(๑•̀ㅂ•́)و✧&lt;!-- more --&gt;紧接着文章摘要的正文内容 这样， 之前、文档配置参数之后中的内容便会被渲染为站点中的文章摘要。 注意！文章摘要在文章详情页是正文中最前面的内容。]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F09%2F07%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment Warn使用win10记事本编辑会出现乱码问题.]]></content>
  </entry>
</search>
