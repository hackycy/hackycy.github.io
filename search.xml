<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[深入浅出CSS原理]]></title>
    <url>%2F2019%2F03%2F28%2F%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BACSS%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"><![CDATA[浏览器渲染浏览器的渲染过程，如图 浏览器渲染过程分为两条主线 一、HTML Parser生成的DOM树二、CSS Parser生成的Style Rules 在这之后，DOM树与Style Rules会生成一个新的对象，也就是我们常说的Render Tree 渲染树，结合Layout绘制在屏幕上，从而展现出来。 Webkit CSS 解析器浏览器CSS模块负责CSS脚本解析，并为每个Element计算出样式，CSS模块虽小，但是计算量大，设计不好往往成为浏览器性能的瓶颈。 CSS模块在实现上有几个特点：CSS对象总多（颗粒小而多），计算频繁（为每个Element计算样式）。这些特性决定了webkit在实现CSS引擎上采取的设计，算法。 Webkit使用Flex和Bison解析生成器从CSS语法文件中自动生成解析器。 它们都是将每个CSS文件解析为样式表对象，每个对象包含CSS规则，CSS规则对象包含选择器和声明对象，以及其他一些符合CSS语法的对象。 Webkit使用了自动代码生成工具生成了相应的代码，也就是说词法分析和语法分析这部分代码都是自动生成的，而Webkit中实现的CAllBack函数就是在CSS Parser中。 CSS的一些解析功能的入口也是在此处，他们会调用lex，parse等生成代码。相对的，生成代码中需要的CallBack也需要在这里实现。 举例来说，现在我们来看其中一个回调函数的实现，createStyleRule(),该函数将在一般性的规则需要被建立的时候调用，代码如下： 123456789101112CSSRule* CSSParser::createStyleRule(CSSSelector* selector) &#123; CSSStyleRule* rule = 0; if (selector) &#123; rule = new CSSStyleRule(styleElement); m_parsedStyleObjects.append(rule); rule-&gt;setSelector(sinkFloatingSelector(selector)); rule-&gt;setDeclaration(new CSSMutableStyleDeclaration(rule, parsedProperties, numParsedProperties)); &#125; clearProperties(); return rule; &#125; 从该函数的实现可以很清楚的看到，解析器达到某条件需要创建一个 CSSStyleRule 的时候将调用该函数，该函数的功能是创建一个 CSSStyleRule ，并将其添加已解析的样式对象列表 m_parsedStyleObjects 中去，这里的对象就是指的 Rule 。 那么如此一来，经过这样一番解析后，作为输入的样式表中的所有 Style Rule 将被转化为 Webkit 的内部模型对象 CSSStyleRule 对象，存储在 m_parsedStyleObjects 中，它是一个 Vector。 解析的结果是什么？ 1、通过调用 CSSStyleSheet 的 parseString 函数，将上述 CSS 解析过程启动，解析完一遍后，把 Rule 都存储在对应的 CSSStyleSheet 对象中； 2、由于目前规则依然是不易于处理的，还需要将之转换成 CSSRuleSet。也就是将所有的纯样式规则存储在对应的集合当中，这种集合的抽象就是 CSSRuleSet； 3、CSSRuleSet 提供了一个 addRulesFromSheet 方法，能将 CSSStyleSheet 中的 rule 转换为 CSSRuleSet 中的 rule ； 4、基于这些个 CSSRuleSet 来决定每个页面中的元素的样式； CSS选择器解析顺序CSS 选择器时是从右往左解析，原因： 1、HTML 经过解析生成 DOM Tree（这个我们比较熟悉）；而在 CSS 解析完毕后，需要将解析的结果与 DOM Tree 的内容一起进行分析建立一棵 Render Tree，最终用来进行绘图。Render Tree 中的元素（WebKit 中称为「renderers」，Firefox 下为「frames」）与 DOM 元素相对应，但非一一对应：一个 DOM 元素可能会对应多个 renderer，如文本折行后，不同的「行」会成为 render tree 种不同的 renderer。也有的 DOM 元素被 Render Tree 完全无视，比如 display:none 的元素。 2、在建立 Render Tree 时（WebKit 中的「Attachment」过程），浏览器就要为每个 DOM Tree 中的元素根据 CSS 的解析结果（Style Rules）来确定生成怎样的 renderer。对于每个 DOM 元素，必须在所有 Style Rules 中找到符合的 selector 并将对应的规则进行合并。选择器的「解析」实际是在这里执行的，在遍历 DOM Tree 时，从 Style Rules 中去寻找对应的 selector。 3、因为所有样式规则可能数量很大，而且绝大多数不会匹配到当前的 DOM 元素（因为数量很大所以一般会建立规则索引树），所以有一个快速的方法来判断「这个 selector 不匹配当前元素」就是极其重要的。 4、如果正向解析，例如「div div p em」，我们首先就要检查当前元素到 html 的整条路径，找到最上层的 div，再往下找，如果遇到不匹配就必须回到最上层那个 div，往下再去匹配选择器中的第一个 div，回溯若干次才能确定匹配与否，效率很低。 看一个例子12345678&lt;div&gt; &lt;div class="jartto"&gt; &lt;p&gt;span&gt; 111 span&gt;&lt;p&gt; &lt;p&gt;span&gt; 222 span&gt;&lt;p&gt; &lt;p&gt;&lt;span&gt; 333 &lt;span&gt;&lt;p&gt; &lt;p&gt;&lt;span class='yellow'&gt; 444 &lt;span&gt;&lt;p&gt; &lt;div&gt;&lt;div&gt; 123div &gt; div.jartto p span.yellow&#123; color:yellow;&#125; 对于上述例子，如果按从左到右的方式进行查找： 1、先找到所有 div 节点；2、在 div 节点内找到所有的子 div ,并且是 class = “jartto”；3、然后再依次匹配 p span.yellow 等情况；4、遇到不匹配的情况，就必须回溯到一开始搜索的 div 或者 p 节点，然后去搜索下个节点，重复这样的过程。 这样的搜索过程对于一个只是匹配很少节点的选择器来说，效率是极低的，因为我们花费了大量的时间在回溯匹配不符合规则的节点。 如果换个思路，我们一开始过滤出跟目标节点最符合的集合出来，再在这个集合进行搜索，大大降低了搜索空间。来看看从右到左来解析选择器： 1、首先就查找到 的元素；2、紧接着我们判断这些节点中的前兄弟节点是否符合 P 这个规则，这样就又减少了集合的元素，只有符合当前的子规则才会匹配再上一条子规则。 结果显而易见了，众所周知，在 DOM 树中一个元素可能有若干子元素，如果每一个都去判断一下显然性能太差。而一个子元素只有一个父元素，所以找起来非常方便。 试想一下，如果采用 从左至右 的方式读取 CSS 规则，那么大多数规则读到最后（最右）才会发现是不匹配的，这样会做费时耗能，最后有很多都是无用的；而如果采取 从右向左 的方式，那么只要发现最右边选择器不匹配，就可以直接舍弃了，避免了许多无效匹配。 浏览器 CSS 匹配核心算法的规则是以从右向左方式匹配节点的。这样做是为了减少无效匹配次数，从而匹配快、性能更优。 CSS语法解析过程CSS 样式表解析过程中讲解的很细致，这里我们只看 CSS 语法解释器，大致过程如下： 1、先创建 CSSStyleSheet 对象。将 CSSStyleSheet 对象的指针存储到 CSSParser 对象中。2、CSSParser 识别出一个 simple-selector ，形如 “div” 或者 “.class”。创建一个 CSSParserSelector 对象。3、CSSParser 识别出一个关系符和另一个 simple-selecotr ，那么修改之前创建的 simple-selecotr, 创建组合关系符。4、循环第3步直至碰到逗号或者左大括号。5、如果碰到逗号，那么取出 CSSParser 的 reuse vector，然后将堆栈尾部的 CSSParserSelector 对象弹出存入 Vecotr 中，最后跳转至第2步。如果碰到左大括号，那么跳转至第6步。6、识别属性名称，将属性名称的 hash 值压入解释器堆栈。7、识别属性值，创建 CSSParserValue 对象，并将 CSSParserValue 对象存入解释器堆栈。8、将属性名称和属性值弹出栈，创建 CSSProperty 对象。并将 CSSProperty 对象存入 CSSParser 成员变量m_parsedProperties 中。9、如果识别处属性名称，那么转至第6步。如果识别右大括号，那么转至第10步。10、将 reuse vector 从堆栈中弹出，并创建 CSSStyleRule 对象。CSSStyleRule 对象的选择符就是 reuse vector, 样式值就是 CSSParser 的成员变量 m_parsedProperties 。11、把 CSSStyleRule 添加到 CSSStyleSheet 中。12、清空 CSSParser 内部缓存结果。13、如果没有内容了，那么结束。否则跳转值第2步。 内联样式解析当 CSS Parser 解析完 CSS 脚本后，会生成 CSSStyleSheetList ，他保存在Document 对象上。为了更快的计算样式，必须对这些 CSSStyleSheetList 进行重新组织。 计算样式就是从 CSSStyleSheetList 中找出所有匹配相应元素的 property-value 对。匹配会通过CSSSelector 来验证，同时需要满足层叠规则。 将所有的 declaration 中的 property 组织成一个大的数组。数组中的每一项纪录了这个 property 的selector，property 的值，权重（层叠规则）。 12345678910p &gt; a &#123; color : red; background-color:black;&#125; a &#123; color : yellow&#125; div &#123; margin : 1px;&#125; 重新组织之后的数组数据为(weight我只是表示了他们之间的相对大小，并非实际值。） selector selector weight a color:yellow 1 p &gt; a color:red 2 p &gt; a background-color:black 2 div margin:1px 3 要明确，内敛样式只是 CSS 三种加载方式之一；其次，浏览器解析分为两个分支，HTML Parser 和 CSS Parser，两个 Parser 各司其职，各尽其责；最后，不同的 CSS 加载方式产生的 Style rule ，通过权重来确定谁覆盖谁； 內联样式与其他的加载样式方式唯一的区别就是权重不同。深入了解，请阅读Webkit CSS引擎分析 https://blog.csdn.net/scusyq/article/details/7059063 computedStyle浏览器还有一个非常棒的策略，在特定情况下，浏览器会共享 computedStyle，网页中能共享的标签非常多，所以能极大的提升执行效率！如果能共享，那就不需要执行匹配算法了，执行效率自然非常高。 也就是说：如果两个或多个 element 的 computedStyle 不通过计算可以确认他们相等，那么这些 computedStyle 相等的 elements 只会计算一次样式，其余的仅仅共享该 computedStyle 。 那么有哪些规则会共享 computedStyle 呢？ 该共享的element不能有id属性且CSS中还有该id的StyleRule.哪怕该StyleRule与Element不匹配。 tagName和class属性必须一样; mappedAttribute必须相等; 不能使用sibling selector，譬如:first-child, :last-selector, + selector; 不能有style属性。哪怕style属性相等，他们也不共享; 12span&gt;p style="color:red"&gt;paragraph1span&gt;p&gt;span&gt;p style="color:red"&gt;paragraph2span&gt;p&gt; 深入了解，请参考：Webkit CSS 引擎分析 - 高效执行的 CSS 脚本https://blog.csdn.net/scusyq/article/details/7059063 CSS选择器组合解析速度 speed/validity selectors test for frameworks 总结 使用 id selector 非常的高效。在使用 id selector 的时候需要注意一点：因为 id 是唯一的，所以不需要既指定 id 又指定 tagName： 1234Badp#id1 &#123;color:red;&#125; Good #id1 &#123;color:red;&#125; 避免深层次的节点 1234Bad div &gt; div &gt; div &gt; p &#123;color:red;&#125; Good p-class&#123;color:red;&#125; 慎用 ChildSelector 万不得已不要使用 attribute selector，如：p[att1=”val1”]。这样的匹配非常慢。更不要这样写：p[id=”id1”]。这样将 id selector 退化成 attribute selector。 1234567891011Bad p[id="id1"]&#123;color:red;&#125; p[class="class1"]&#123;color:red;&#125; Good #id1&#123;color:red;&#125; .class1&#123;color:red;&#125; 理解依赖继承，如果某些属性可以继承，那么自然没有必要在写一遍； 规范真的很重要，不仅仅是可读性，也许会影响你的页面性能 原文参考https://segmentfault.com/a/1190000017986912]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[跨域介绍以及跨域的方式]]></title>
    <url>%2F2019%2F03%2F27%2F%E8%B7%A8%E5%9F%9F%E4%BB%8B%E7%BB%8D%E4%BB%A5%E5%8F%8A%E8%B7%A8%E5%9F%9F%E7%9A%84%E6%96%B9%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[前言前端在与后端进行数据交互时经常会碰到跨域请求，这里在此探讨一下。 什么是跨域什么是同源策略及其限制内容同源策略是一种约定，它是浏览器最核心也是最基本的安全功能，如果少了同源策略，浏览器很容易收到XSS，CSFR等攻击。所谓同源指的是协议+域名+端口三者相同，即便两个不同的域名指向同一个ip地址，也非同源。 同源策略的限制内容有： Cookie、LocalStorage、IndexedDB等存储性内容 DOM节点 AJAX请求发送后，结果被浏览器拦截了 但是有三个标签是允许跨域加载资源 &lt;img src=&quot;...&quot;&gt; &lt;link href=&quot;...&quot;&gt; &lt;script src=&quot;...&quot;&gt; 常见跨域场景当协议、子域名、主域名、端口号中任意一个不相同时，都算作不同域。不同域之间相互请求资源，就算作跨域，常见的跨域场景如下图所示： URL 说明 是否允许通信 http://www.a.com/a.js http://www.a.com/b.js 同一个域名下 允许 http://www.a.com/lab/a.js http://www.a.com/script/b.js 同一域名下不同文件夹 允许 http://www.a.com:8000/a.js http://www.a.com/b.js 同一域名，不同端口 不允许 http://www.a.com/a.js https://www.a.com/b.js 同一域名，不同协议 不允许 http://www.a.com/a.js http://70.32.92.74/b.js 域名和域名对应ip 不允许 http://www.a.com/a.js http://script.a.com/b.js 主域相同，子域不同 不允许 http://www.a.com/a.js http://a.com/b.js 同一域名，不同二级域名 不允许，cookie这种情况下也不允许 http://www.cnblogs.com/a.js http://www.a.com/b.js 不同域名 不允许 特别说明 如果时协议和端口造成的跨域问题，前端时无能为力的 在跨域问题上，仅仅是通过“URL的首部“来识别而不会根据域名对应的IP地址是否相同来判断。“URL的首部”可以理解为“协议、域名和端口必须匹配“。 请求跨域，那么请求有没有发出去？跨域并不是请求发不出去，请求能发出去，服务端能收到请求并正常返回结果，只是结果被浏览器拦截了。，可是通过表单的方式可以发起跨域请求，为什么AJAX就不可以，归根结底，跨域是为了阻止用户读取到另一个域名下的内容，AJAX可以获取响应，浏览器认为这并不安全，所以拦截了响应。但是表单并不会获取新的内容，所以可以发起跨域请求。这同时也说明了跨域并不能完全阻止CSRF，因为请求毕竟是发出去了。 跨域解决方案JSONP原理JSONP原理是利用&lt;script&gt;标签没有跨域限制的漏洞，网页可以得到从其他来源动态产生的JSON数据。JSONP请求一定需要对方的服务器做支持才可以。 JSONP与AJAX对比JSONP与AJAX相同，都是客户端向服务器端发送请求，从服务器端获取数据的方式。但是AJAX属于同源策略，JSONP属于非同源策略（跨域请求） JSONP优缺点JSONP优点是简单兼容性好，可用于解决主流浏览器的跨域数据访问的问题。缺点是仅支持get方法具有局限性，不安全可能会XSS攻击。 JSONP的实现流程 声明一个回调函数，其函数名（如show）当做参数值，要传递给跨域请求数据的服务器，函数形参为要获取目标数据（服务器返回的data）。 创建一个&lt;script&gt;标签，把那个跨域的API数据接口地址，赋值给script的src，还要在这个地址中向服务器传递该参数名（可以通过问好传参：`?callback=show）。 服务器接受到请求后，需要进行特殊的处理：把传递进来的函数名和它需要给你的数据拼接成一个字符串，例如：传递进去的函数名是show，它准备好的数据是show(‘XXX’)。 最后服务器把准备的数据通过HTTP协议返回给客户端，客户端再调用执行之前声明的回调函数show，对返回的数据进行操作。 在开发中可能会遇到多个JSONP请求的回调函数名是相同的，这时候就需要自己封装一个JSONP函数。123456789101112131415161718192021222324// index.htmlfunction jsonp(&#123; url, params, callback &#125;) &#123; return new Promise((resolve, reject) =&gt; &#123; let script = document.createElement('script') window[callback] = function(data) &#123; resolve(data) document.body.removeChild(script) &#125; params = &#123; ...params, callback &#125; // wd=b&amp;callback=show let arrs = [] for (let key in params) &#123; arrs.push(`$&#123;key&#125;=$&#123;params[key]&#125;`) &#125; script.src = `$&#123;url&#125;?$&#123;arrs.join('&amp;')&#125;` document.body.appendChild(script) &#125;)&#125;jsonp(&#123; url: 'http://127.0.01:8000/say', params: &#123; wd: 'Iloveyou' &#125;, callback: 'show'&#125;).then(data =&gt; &#123; console.log(data)&#125;) 上面这段代码相当于向http://127.0.0.1:8000/say?wd=Iloveyou&amp;callback=show这个地址请求数据，然后后台返回show(‘I love you’)，最后会允许show()这个函数，打印出’我不爱你’ 后端nodejs12345678910// server.jslet express = require('express')let app = express()app.get('/say', function(req, res) &#123; let &#123; wd, callback &#125; = req.query console.log(wd) // Iloveyou console.log(callback) // show res.end(`$&#123;callback&#125;('我不爱你')`)&#125;)app.listen(8000) JQuery的jsonp形式JSONP都是GET和异步请求，不存在其他的请求方式和同步请求，且JQuery默认就会给JSONP的请求清除缓存。123456789$.ajax(&#123;url:"http://crossdomain.com/jsonServerResponse",dataType:"jsonp",type:"get",//可以省略jsonpCallback:"show",//-&gt;自定义传递给服务器的函数名，而不是使用jQuery自动生成的，可省略jsonp:"callback",//-&gt;把传递函数名的那个形参callback，可省略success:function (data)&#123;console.log(data);&#125;&#125;); CORSCORS需要浏览器和后端同时支持。IE8 和 9 需要通过XDomainRequest来实现。 浏览器会自动CORS通信，实现CORS通信的关键是后端。只要后端实现了CORS，就实现了跨域。 服务端设置 Access-Control-Allow-Origin 就可以开启 CORS。 该属性表示哪些域名可以访问资源，如果设置通配符则表示所有网站都可以访问资源。 虽然设置 CORS 和前端没什么关系，但是通过这种方式解决跨域问题的话，会在发送请求时出现两种情况，分别为简单请求和复杂请求。 简单请求只要同时满足一下两大条件，就属于简单请求条件1：使用下列方式之一： GET HEAD POST 条件2：Content-Type的值仅限于下列三者之一： text/plain multipart/form-data application/x-www-form-urlencoded 请求中的任意 XMLHttpRequestUpload 对象均没有注册任何事件监听器； XMLHttpRequestUpload 对象可以使用 XMLHttpRequest.upload 属性访问。 复杂请求不符合以上条件的请求就肯定是复杂请求了。复杂请求的CORS请求，会在正式通信之前，增加一次HTTP查询请求，称为”预检”请求,该请求是 option 方法的，通过该请求来知道服务端是否允许跨域请求。 我们用PUT向后台请求时，属于复杂请求，后台需做如下配置：12345678910111213// 允许哪个方法访问我res.setHeader('Access-Control-Allow-Methods', 'PUT')// 预检的存活时间res.setHeader('Access-Control-Max-Age', 6)// OPTIONS请求不做任何处理if (req.method === 'OPTIONS') &#123; res.end() &#125;// 定义后台返回的内容app.put('/getData', function(req, res) &#123; console.log(req.headers) res.end('我不爱你')&#125;) 接下来我们看下一个完整复杂请求的例子，并且介绍下CORS请求相关的字段 12345678910111213141516// index.htmllet xhr = new XMLHttpRequest()document.cookie = 'name=xiamen' // cookie不能跨域xhr.withCredentials = true // 前端设置是否带cookiexhr.open('PUT', 'http://localhost:4000/getData', true)xhr.setRequestHeader('name', 'xiamen')xhr.onreadystatechange = function() &#123; if (xhr.readyState === 4) &#123; if ((xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300) || xhr.status === 304) &#123; console.log(xhr.response) //得到响应头，后台需设置Access-Control-Expose-Headers console.log(xhr.getResponseHeader('name')) &#125; &#125;&#125;xhr.send() 12345//server1.jslet express = require('express');let app = express();app.use(express.static(__dirname));app.listen(3000); 123456789101112131415161718192021222324252627282930313233343536//server2.jslet express = require('express')let app = express()let whitList = ['http://localhost:3000'] //设置白名单app.use(function(req, res, next) &#123; let origin = req.headers.origin if (whitList.includes(origin)) &#123; // 设置哪个源可以访问我 res.setHeader('Access-Control-Allow-Origin', origin) // 允许携带哪个头访问我 res.setHeader('Access-Control-Allow-Headers', 'name') // 允许哪个方法访问我 res.setHeader('Access-Control-Allow-Methods', 'PUT') // 允许携带cookie res.setHeader('Access-Control-Allow-Credentials', true) // 预检的存活时间 res.setHeader('Access-Control-Max-Age', 6) // 允许返回的头 res.setHeader('Access-Control-Expose-Headers', 'name') if (req.method === 'OPTIONS') &#123; res.end() // OPTIONS请求不做任何处理 &#125; &#125; next()&#125;)app.put('/getData', function(req, res) &#123; console.log(req.headers) res.setHeader('name', 'jw') //返回一个响应头，后台需设置 res.end('我不爱你')&#125;)app.get('/getData', function(req, res) &#123; console.log(req.headers) res.end('我不爱你')&#125;)app.use(express.static(__dirname))app.listen(4000) 上述代码由http://localhost:3000/index.html向http://localhost:4000/跨域请求，正如我们上面所说的，后端是实现 CORS 通信的关键。 postMessagepostMessage是HTML5 XMLHttpRequest Level 2中的API，且是为数不多可以跨域操作的window属性之一，它可用于解决以下方面的问题： 页面和其打开的新窗口的数据传递 多窗口之间消息传递 页面与嵌套的iframe消息传递 上面三个场景的跨域数据传递 postMessage()方法允许来自不同源的脚本采用异步方式进行有限的通信，可以实现跨文本档、多窗口、跨域消息传递。 otherWindow.postMessage(message, targetOrigin, [transfer]); message: 将要发送到其他 window的数据。 targetOrigin:通过窗口的origin属性来指定哪些窗口能接收到消息事件，其值可以是字符串”*”（表示无限制）或者一个URI。在发送消息的时候，如果目标窗口的协议、主机地址或端口这三者的任意一项不匹配targetOrigin提供的值，那么消息就不会被发送；只有三者完全匹配，消息才会被发送。 transfer(可选)：是一串和message 同时传递的 Transferable 对象. 这些对象的所有权将被转移给消息的接收方，而发送一方将不再保有所有权。 接下来我们看个例子： http://localhost:3000/a.html页面向http://localhost:4000/b.html传递“我爱你”,然后后者传回”我不爱你”。 123456789101112// a.html &lt;iframe src="http://localhost:4000/b.html" frameborder="0" id="frame" onload="load()"&gt;&lt;/iframe&gt; //等它加载完触发一个事件 //内嵌在http://localhost:3000/a.html &lt;script&gt; function load() &#123; let frame = document.getElementById('frame') frame.contentWindow.postMessage('我爱你', 'http://localhost:4000') //发送数据 window.onmessage = function(e) &#123; //接受返回数据 console.log(e.data) //我不爱你 &#125; &#125; &lt;/script&gt; 12345// b.html window.onmessage = function(e) &#123; console.log(e.data) //我爱你 e.source.postMessage('我不爱你', e.origin) &#125; websocketWebsocket是HTML5的一个持久化的协议，它实现了浏览器与服务器的全双工通信，同时也是跨域的一种解决方案。WebSocket和HTTP都是应用层协议，都基于 TCP 协议。但是 WebSocket 是一种双向通信协议，在建立连接之后，WebSocket 的 server 与 client 都能主动向对方发送或接收数据。同时，WebSocket 在建立连接时需要借助 HTTP 协议，连接建立好了之后 client 与 server 之间的双向通信就与 HTTP 无关了。 原生WebSocket API使用起来不太方便，我们使用Socket.io，它很好地封装了webSocket接口，提供了更简单、灵活的接口，也对不支持webSocket的浏览器提供了向下兼容。 我们先来看个例子：本地文件socket.html向localhost:3000发生数据和接受数据 12345678910// socket.html&lt;script&gt; let socket = new WebSocket('ws://localhost:3000'); socket.onopen = function () &#123; socket.send('我爱你');//向服务器发送数据 &#125; socket.onmessage = function (e) &#123; console.log(e.data);//接收服务器返回的数据 &#125;&lt;/script&gt; 1234567891011// server.jslet express = require('express');let app = express();let WebSocket = require('ws');//记得安装wslet wss = new WebSocket.Server(&#123;port:3000&#125;);wss.on('connection',function(ws) &#123; ws.on('message', function (data) &#123; console.log(data); ws.send('我不爱你') &#125;);&#125;) Node中间件代理(两次跨域)实现原理：同源策略是浏览器需要遵循的标准，而如果是服务器向服务器请求就无需遵循同源策略。代理服务器，需要做以下几个步骤： 接受客户端请求 。 将请求转发给服务器。 拿到服务器响应数据。 将响应转发给客户端。 我们先来看个例子：本地文件index.html文件，通过代理服务器http://localhost:3000向目标服务器http://localhost:4000请求数据。 12345678910111213141516// index.html(http://127.0.0.1:5500) &lt;script src="https://cdn.bootcss.com/jquery/3.3.1/jquery.min.js"&gt;&lt;/script&gt; &lt;script&gt; $.ajax(&#123; url: 'http://localhost:3000', type: 'post', data: &#123; name: 'xiamen', password: '123456' &#125;, contentType: 'application/json;charset=utf-8', success: function(result) &#123; console.log(result) // &#123;"title":"fontend","password":"123456"&#125; &#125;, error: function(msg) &#123; console.log(msg) &#125; &#125;) &lt;/script&gt; 1234567891011121314151617181920212223242526272829303132333435363738// server1.js 代理服务器(http://localhost:3000)const http = require('http')// 第一步：接受客户端请求const server = http.createServer((request, response) =&gt; &#123; // 代理服务器，直接和浏览器直接交互，需要设置CORS 的首部字段 response.writeHead(200, &#123; 'Access-Control-Allow-Origin': '*', 'Access-Control-Allow-Methods': '*', 'Access-Control-Allow-Headers': 'Content-Type' &#125;) // 第二步：将请求转发给服务器 const proxyRequest = http .request( &#123; host: '127.0.0.1', port: 4000, url: '/', method: request.method, headers: request.headers &#125;, serverResponse =&gt; &#123; // 第三步：收到服务器的响应 var body = '' serverResponse.on('data', chunk =&gt; &#123; body += chunk &#125;) serverResponse.on('end', () =&gt; &#123; console.log('The data is ' + body) // 第四步：将响应结果转发给浏览器 response.end(body) &#125;) &#125; ) .end()&#125;)server.listen(3000, () =&gt; &#123; console.log('The proxyServer is running at http://localhost:3000')&#125;) 1234567891011// server2.js(http://localhost:4000)const http = require('http')const data = &#123; title: 'fontend', password: '123456' &#125;const server = http.createServer((request, response) =&gt; &#123; if (request.url === '/') &#123; response.end(JSON.stringify(data)) &#125;&#125;)server.listen(4000, () =&gt; &#123; console.log('The server is running at http://localhost:4000')&#125;) 上述代码经过两次跨域，值得注意的是浏览器向代理服务器发送请求，也遵循同源策略，最后在index.html文件打印出{&quot;title&quot;:&quot;fontend&quot;,&quot;password&quot;:&quot;123456&quot;} nginx反向代理实现原理类似于Node中间件代理，需要你搭建一个中转nginx服务器，用于转发请求。 使用nginx反向代理实现跨域，是最简单的跨域方式。只需要修改nginx的配置即可解决跨域问题，支持所有浏览器，支持session，不需要修改任何代码，并且不会影响服务器性能。 实现思路：通过nginx配置一个代理服务器（域名与domain1相同，端口不同）做跳板机，反向代理访问domain2接口，并且可以顺便修改cookie中domain信息，方便当前域cookie写入，实现跨域登录。 先下载nginx，然后将nginx目录下的nginx.conf修改如下: 1234567891011121314// proxy服务器server &#123; listen 80; server_name www.domain1.com; location / &#123; proxy_pass http://www.domain2.com:8080; #反向代理 proxy_cookie_domain www.domain2.com www.domain1.com; #修改cookie里域名 index index.html index.htm; # 当用webpack-dev-server等中间件代理接口访问nignx时，此时无浏览器参与，故没有同源限制，下面的跨域配置可不启用 add_header Access-Control-Allow-Origin http://www.domain1.com; #当前端只跨域不带cookie时，可为* add_header Access-Control-Allow-Credentials true; &#125;&#125; 最后通过命令行nginx -s reload启动nginx 1234567// index.htmlvar xhr = new XMLHttpRequest();// 前端开关：浏览器是否读写cookiexhr.withCredentials = true;// 访问nginx中的代理服务器xhr.open('get', 'http://www.domain1.com:81/?user=admin', true);xhr.send(); js 123456789101112131415// server.jsvar http = require('http');var server = http.createServer();var qs = require('querystring');server.on('request', function(req, res) &#123; var params = qs.parse(req.url.substring(2)); // 向前台写cookie res.writeHead(200, &#123; 'Set-Cookie': 'l=a123456;Path=/;Domain=www.domain2.com;HttpOnly' // HttpOnly:脚本无法读取 &#125;); res.write(JSON.stringify(params)); res.end();&#125;);server.listen('8080');console.log('Server is running at port 8080...'); window.name + iframewindow.name属性的独特之处：name值在不同的页面（甚至不同域名）加载后依旧存在，并且可以支持非常长的 name 值（2MB）。 其中a.html和b.html是同域的，都是http://localhost:3000;而c.html是http://localhost:4000 1234567891011121314151617// a.html(http://localhost:3000/b.html) &lt;iframe src="http://localhost:4000/c.html" frameborder="0" onload="load()" id="iframe"&gt;&lt;/iframe&gt; &lt;script&gt; let first = true // onload事件会触发2次，第1次加载跨域页，并留存数据于window.name function load() &#123; if(first)&#123; // 第1次onload(跨域页)成功后，切换到同域代理页面 let iframe = document.getElementById('iframe'); iframe.src = 'http://localhost:3000/b.html'; first = false; &#125;else&#123; // 第2次onload(同域b.html页)成功后，读取同域window.name中数据 console.log(iframe.contentWindow.name); &#125; &#125; &lt;/script&gt; b.html为中间代理页，与a.html同域，内容为空。1234// c.html(http://localhost:4000/c.html) &lt;script&gt; window.name = '我不爱你' &lt;/script&gt; 通过iframe的src属性由外域转向本地域，跨域数据即由iframe的window.name从外域传递到本地域。这个就巧妙地绕过了浏览器的跨域访问限制，但同时它又是安全操作。 location.hash + iframe实现原理： a.html欲与c.html跨域相互通信，通过中间页b.html来实现。 三个页面，不同域之间利用iframe的location.hash传值，相同域之间直接js访问来通信。 具体实现步骤：一开始a.html给c.html传一个hash值，然后c.html收到hash值后，再把hash值传递给b.html，最后b.html将结果放到a.html的hash值中。同样的，a.html和b.html是同域的，都是http://localhost:3000;而c.html是http://localhost:4000 1234567// a.html &lt;iframe src="http://localhost:4000/c.html#iloveyou"&gt;&lt;/iframe&gt; &lt;script&gt; window.onhashchange = function () &#123; //检测hash的变化 console.log(location.hash); &#125; &lt;/script&gt; 12345// b.html &lt;script&gt; window.parent.parent.location.hash = location.hash //b.html将结果放到a.html的hash值中，b.html可通过parent.parent访问a.html页面 &lt;/script&gt; 12345// c.htmlconsole.log(location.hash); let iframe = document.createElement('iframe'); iframe.src = 'http://localhost:3000/b.html#idontloveyou'; document.body.appendChild(iframe); document.domain + iframe该方式只能用于二级域名相同的情况下，比如 a.test.com 和 b.test.com 适用于该方式。 只需要给页面添加document.domain =&#39;test.com&#39; 表示二级域名都相同就可以实现跨域。 实现原理：两个页面都通过js强制设置document.domain为基础主域，就实现了同域。 我们看个例子：页面a.zf1.cn:3000/a.html获取页面b.zf1.cn:3000/b.html中a的值 1234567891011// a.html&lt;body&gt; helloa &lt;iframe src="http://b.zf1.cn:3000/b.html" frameborder="0" onload="load()" id="frame"&gt;&lt;/iframe&gt; &lt;script&gt; document.domain = 'zf1.cn' function load() &#123; console.log(frame.contentWindow.a); &#125; &lt;/script&gt;&lt;/body&gt; 12345678/ b.html&lt;body&gt; hellob &lt;script&gt; document.domain = 'zf1.cn' var a = 100; &lt;/script&gt;&lt;/body&gt; 总结 CORS支持所有类型的HTTP请求，是跨域HTTP请求的根本解决方案 JSONP只支持GET请求，JSONP的优势在于支持老式浏览器，以及可以向不支持CORS的网站请求数据。 不管是Node中间件代理还是nginx反向代理，主要是通过同源策略对服务器不加限制。 日常工作中，用得比较多的跨域方案是cors和nginx反向代理 参考http://www.ruanyifeng.com/blog/2016/04/cors.html https://developer.mozilla.org/zh-CN/docs/Web/API/Window/postMessage https://segmentfault.com/a/1190000011145364]]></content>
      <categories>
        <category>HTML</category>
      </categories>
      <tags>
        <tag>HTML</tag>
        <tag>跨域</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IOS中的Web开发]]></title>
    <url>%2F2019%2F03%2F25%2FIOS%E4%B8%AD%E7%9A%84Web%E5%BC%80%E5%8F%91%2F</url>
    <content type="text"><![CDATA[移动开发领域近年来已经逐渐告别了野蛮生长的时期，进入了相对成熟的时代。而一直以来 Native 和 Web 的争论从未停止，通过开发者孜孜不倦的努力，Web 的效率和 Native 的体验也一直在寻求着平衡。本文聚焦 iOS 开发和 Web 开发的交叉点，希望能通过简要的介绍，帮助开发者一窥 Hybrid 和大前端的构想。 IOS中web容器与加载1、IOS中的Web容器目前IOS系统为开发者提供三种方式来展示Web内容 UIWebViewUIWebView 从 iOS2 开始就作为 App 内展示 Web 内容的容器，但是长久以来一直遭受开发者的诟病；系统级的内存泄露、极高内存峰值、较差的稳定性、Touch Delay 以及 Javascript 的运行性能及通信限制等等。在 iOS12 以后已经标记为 Deprecated 不再维护。 WKWebView在 iOS 8 中，Apple 引入了新一代的 WebKit framework，同时提供了 WKWebView 用来替代传统的 UIWebView。它更加的稳定、拥有 60fps 滚动刷新率、丰富的手势、KVO、高效的 Web 和 Native 通信，默认进度条等等功能，而最重要的，是使用了和 safari 相同的 Nitro 引擎极大提升了 Javascript 的运行速度。WKWebView 独立的进程管理，也降低了内存占用及 Crash 对主 App 的影响。 SFSafariViewController在 iOS 9 中，Apple 引入了 SFSafariViewController。其特点就是在 App 内可以打开一个高度标准化的、和 Safari 一样界面和特性的页面。同时 SFSafariViewController 支持和 Safari 共享 Cookie 和表单数据等等。 Web容器选型对于 SFSafariViewController：由于其标准化程度之高，使之界面和交互逻辑无法和 App 统一，基于 App 的整体体验的考虑，一般都使用在相对独立的功能和模块中，最常见的就是在 App 内打开 App Store 或者广告、游戏推广的页面。 对于 UIWebView/WKWebView：如果说之前由于 NSURLProtocol 的问题，好多 App 都在继续使用 UIWebView，那么随着 App 放弃维护 UIWebView（iOS12），全部的 App 应该会陆续的切换到 WKWebView 中来。当然，最初 WKWebView 也为开发者们带来了一些难题，但是随着系统的升级与业务逻辑的适配也逐步的修复，后文会列举几个最为关注的技术点。 UIWebView/WKWebView 对主 App 内存的影响： 2、WebKit 框架与使用WebKit.frameworkWebKit 是一个开源的 Web 浏览器引擎。每当谈到 WebKit，开发者常常迷惑于它和 WebKit2、Safari、iOS 中的 framework、以及 Chromium 等浏览器的关系。 广义的 WebKit 其实就是指 WebCore，它主要包含了 HTML 和 CSS 的解析、布局和定位这类渲染 HTML 的功能逻辑。而狭义的 WebKit 就是在 WebCore 的基础上，不同平台封装 Javascript 引擎、网络层、GPU 相关的技术（WebGL、视频）、绘制渲染技术以及各个平台对应的接口，形成我们可以用的 WebView 或浏览器，也就是所谓的 WebKit Ports。 比如在 Safari 中 JS 的引擎使用 JavascriptCore，而 Chromium 中使用 V8；渲染方面 Safari 使用 CoreGraphics，而 Chromium 中使用 Skia；网络方面 Safari 使用 CFNetwork，而 Chromium 中使用 Chromium stack 等等。而 WebKit2 是相对于狭义上的 WebKit 架构而言，主要变化是在 API 层支持多进程，分离了 UI 和 Web 接口的进程，使之通过 IPC 来进行通讯。 对于 iOS 中的 WebKit.framework 就是在 WebCore、底层桥接、JSCore 引擎等核心模块的基础上，针对 iOS 平台的项目封装。它基于新的 WKWebView，提供了一系列浏览特性的设置，以及简单方便的加载回调。而具体类及使用，开发者可以查阅官方文档: https://developer.apple.com/documentation/webkit Web 容器使用流程与关键节点对于大部分日常使用来说，开发者需要关注的就是 WKWebView 的创建、配置、加载、以及系统回调的接收。 对于 Web 开发者，业务逻辑一般通过基于 Web 页面中 Dom 渲染的关键节点来处理。而对于 iOS 开发者，WKWebView 提供的的注册、加载和回调时机，没有明确的与 Web 加载的关键节点相关联。准确的理解和处理两个维度的加载顺序，选择合理的业务逻辑处理时机，才可以实现准确而高效的应用。 WKWebView 常见问题使用 WKWebView 带来的另外一个好处，就是我们可以通过源码理解部分加载逻辑，为 Crash 提供一些思路，或者使用一些私有方法处理复杂业务逻辑。 NSURLProtocol WKWebView 最为显著的改变，就是不支持 NSURLProtocol。为了兼容旧的业务逻辑，一部分 App 通过 WKBrowsingContextController 中的非公开方法实现了 NSURLProtocol。 12// WKBrowsingContextController + (void)registerSchemeForCustomProtocol:(NSString *)scheme WK_API_DEPRECATED_WITH_REPLACEMENT(&quot;WKURLSchemeHandler&quot;, macos(10.10, WK_MAC_TBA), ios(8.0, WK_IOS_TBA)); 在 iOS 11 中，系统增加了 setURLSchemeHandler 函数用来拦截自定义的 Scheme。但是不同于 UIWebView，新的函数只能拦截自定义的 Scheme(SchemeRegistry.cpp)，对使用最多的 HTTP/HTTPS 依然不能有效的拦截。 12345678//SchemeRegistry static const StringVectorFunction functions[] &#123; builtinSecureSchemes, // about;data... builtinSchemesWithUniqueOrigins, // javascript... builtinEmptyDocumentSchemes, builtinCanDisplayOnlyIfCanRequestSchemes, builtinCORSEnabledSchemes, //http;https &#125;; 白屏 通常 WKWebView 白屏的原因主要分两种，一种是由于 Web 的进程 Crash（多见于内部进程通信）；一种就是 WebView 渲染时的错误（Debug 一切正常只是没有对应的内容）。对于白屏的检测，前者在 iOS9 之后系统提供了对应 Crash 的回调函数，同时业界也有通过判断 URL/Title 是否为空的方式作为辅助；后者业界通过视图树对比，判断 SubView 是否包含 WKCompsitingView，以及通过随机点截图等方式作为白屏判断的依据。 其他 WKWebView 的系统级问题如 Cookie、POST 参数、异步 Javascript 等等一系列的问题，可以通过业务逻辑的调整重新适配。 由于 WebKit 源码等开放性，我们也可以利用私有方法来简化代码逻辑、实现复杂的产品需求。例如在 WKWebViewPrivate 中可以获得各种页面信息、直接取到 UserAgent、 在 WKBackForwardListPrivate 中可以清理掉全部的跳转历史、以及在 WKContentViewInteraction 中替换方法实现自定义的 MenuItem 等等。 12345678910@interface WKWebView (WKPrivate) @property (nonatomic, readonly) NSString *_userAgent WK_API_AVAILABLE(macosx(10.11), ios(9.0)); ... @interface WKBackForwardList (WKPrivate) - (void)_removeAllItems; ... @interface WKContentView (WKInteraction) - (BOOL)canPerformActionForWebView:(SEL)action withSender:(id)sender; 3、App 中的应用场景WKWebView 系统提供了四个用于加载渲染 Web 的函数。这四个函数从加载的类型上可以分为两类：加载 URL &amp; 加载 HTML\Data。所以基于此也延伸出两种不同的业务场景：加载 URL 的页面直出类和加载数据的模板渲染类，同时两种类型各自也有不同的优化重点及方向。 页面直出类12// 根据 URL 直接展示 Web 页面 - (nullable WKNavigation *)loadRequest:(NSURLRequest *)request; 通常各类 App 中的 Web 页面加载都是通过加载 URL 的方式，比如嵌入的运营活动页面、广告页面等等。 模板渲染类123// 根据模板 &amp; 数据渲染 Web 页面 - (nullable WKNavigation *)loadHTMLString:(NSString *)string baseURL:(nullable NSURL *)baseURL; ... 需要使用 WebView 展示，且交互逻辑较多的页面，最常见的就是资讯类 App 的内容展示页。 iOS 中 Web 与 Native 的通信单纯的使用 Web 容器加载页面已经不能满足复杂的功能，开发者希望数据可以在 Native 和 Web 之间通信传递来实现复杂的功能，而 Javascript 就是通信的媒介。对于有 WebView 的情况，虽然 WKWebView 提供了系统级的方法，但是大部分 App 仍然使用基于 URLScheme 的 WebViewBridge 用以兼容 UIWebView。而脱离了 WebView 容器，系统提供了 JavaScriptCore 的 framework，它也为之后蓬勃发展的跨平台和热修复技术提供了可能。 1. 基于 WebView 的通信基于 WebView 的通信主要有两个 途径，一个是通过系统或私有方法，获取 WebView 当中的 JSContext，使用系统封装的基于 JSCore 的函数通信。另一类就是通过创建自定义 Scheme 的 iframe Dom，客户端在回调中进行拦截实现。 UIWebView &amp; WKWebView 系统级在 UIWebView 时代没有提供系统级的函数进行 Web 与 Native 的交互，绝大部分 App 都是通过 WebViewJavascriptBridge（下节介绍）来进行的通信。但是由于 JavascriptCore 的存在，对于 UIWebView 来说只要有效的获取到内部的 JSContext，也可以达到目的。目前已知有效的几个私有方法获取 Context 的方法如下： 12345// 通过系统废弃函数获取 context - (void)webView:(WebView *)webView didCreateJavaScriptContext:(JSContext *)context forFrame:(WebFrame *)frame; // 通过 valueForKeyPath 获取 context self.jsContext = [_webView valueForKeyPath:@&quot;documentView.webView.mainFrame.javaScriptContext&quot;]; 在 WKWebView 中提供了系统级的 Web 和 Native 通讯机制，通过 Message Handler 的封装使开发效率有了很大的提升。同时系统封装了 JavaScript 对象和 Objective-C 对象的转换逻辑，也进降低了使用的门槛。 12345// js 端发送消息 window.webkit.messageHandlers.&#123;NAME&#125;.postMessage() //Native 在回调中接收 - (void)userContentController:(WKUserContentController *)userContentController didReceiveScriptMessage:(WKScriptMessage *)message; 拦截自定义 Scheme 请求 - WebViewJavascriptBridge由于私有方法的稳定性与审核风险，开发者不愿意使用上文提到的 UIWebView 获取 JSContext 的方式进行通信，所以通常都采用基于 iframe 和自定义 Scheme 的 JavascriptBridge 进行通信。虽然在之后的 WKWebView 提供了系统函数，但是大部分 App 都需要兼容 UIWebView 与 WKWebView，所以目前的使用范围仍然十分广泛。 在 Github 中类似的开源框架有很多，但是无外乎都是 Web 侧根据固定的格式创建包含通信信息的 Request，之后创建隐式 iFrame 节点请求；Native 侧在相应的 WebView 回调中解析 Request 的 Scheme，之后按照格式解析数据并处理。 而对于数据传递和回调处理的问题，在兼容两种 WebView、持续的更新的 WebViewJavascriptBridge 中，iFrame request 没有直接传递数据，而是 Web 和 Native 侧维护共同的参数或回调 Queue，Native 通过 Request 中 Scheme 的解析触发对 Queue 里数据的读取。 脱离 WebView 的通信 JavaScriptCoreJavascriptCoreJavascriptCore 一直作为 WebKit 中内置的 JS 引擎使用，在 iOS7 之后，Apple 对原有的 C/C++ 代码进行了 OC 的封装，成系统级的 framework 供开发者使用。作为一个引擎来讲，JavascriptCore 的词法、语法分析，以及多层次的 JIT 编译技术都是值得深入挖掘和学习的方向，由于篇幅的限制暂且不做深入的讨论。 JavascriptCore.framework虽然 JavascriptCore.framework 只暴露了较少的头文件和系统函数，但却提供了在 App 中脱离 WebView 执行 Javascript 的环境和能力。 JSVirtualMachine：提供了 JS 执行的底层资源及内存。虽然 Java 与 Javascript 没有一点关系，但是同样作为虚拟机，JSVM 和 JVM 做了一部分类似的事情。每个 JSVirtualMachine 独占线程，拥有独立的空间和管理，但是可以包含多个 JSContext。JSContext：提供了 JS 运行的上下文环境和接口。可以不准确的理解为，就是创建了一个 Javascript 中的 Window 对象。JSValue：提供了 OC 和 JS 间数据类型的封装和转换 Type Conversions。除了基本的数据类型，需要注意 OC 中的 Block 转换为 JS 中的 function，Class 转换为 Constructor 等等。 JSManagedValue：Javascript 使用 GC 机制管理内存，而 OC 采用引用计数的方式管理内存。所以在 JavascriptCore 使用过程中，难免会遇到循环引用以及提前释放的问题。JSManagedValue 解决了在两种环境中的内存管理问题。JSExport：提供了类、属性和实例方法的调用接口。内部实现是在 ProtoType &amp; Constructor 中实现对应的属性和方法。 使用 JavascriptCore 进行通信Native - Web: 通过 JavascriptCore，Native 可以直接在 Context 中执行 JS 语句，和 Web 侧进行通信和交互。 1JSValue *value = [self.jsContext evaluateScript:@&quot;document.cookie&quot;]; Web - Native: 对于 Web 侧向 Native 的通信，JavascriptCore 提供 两种 方式，注册 Block &amp; Export 协议。 1234567891011121314151617//Native self.jsContext[@&quot;addMethod&quot;] = ^ NSInteger(NSInteger a, NSInteger b) &#123; return a + b; &#125;; //JS console.log(addMethod(1, 2)); //3 //Native @protocol testJSExportProtocol &lt;JSExport&gt; @property (readonly) NSString *string; ... @interface OCClass : NSObject &lt;testJSExportProtocol&gt; //JS var OCClass = new OCClass(); console.log(OCClass.string); 对于 JavascriptCore 粗浅的理解，可以认为使用 Block 方法，内部是将 Block 保存到保存到一个 Web 环境中的全局的 Object 中，例如 window。而使用 JSExport 方法，则是在 Web 环境中 Object 的 prototype 中创建属性、实例方法；在 constructor 对象中创建类方法，从而实现 Web 中的调用。 App 中的应用场景对于基于 WebView 的通信，主要用于 App 向 H5 页面中注入的 Javascript Open Api，如提供 Native 的拍照、音视频、定位；以及 App 内的登录、分享等等功能。对于 JavaScriptCore，则催生了动态化、跨平台以及热修复等一系列技术的蓬勃发展。 跨平台与热修复近几年来国内外移动端各种方案如雨后春笋般涌现，“Write once, run anywhere”不再是开发者的向往。剥离跨平台技术在 Web 侧 DSL、virtualDom 等方面的优化，以及 Native 侧 Runtime 的应用与封装，对于两端通信的核心，依然是 JavascriptCore。 而不同于国外开发者对跨平台技术的积极探索，国内开发者也对热修复技术产生了极大的热情。同样作为 Native 和 Web 的交叉 - JavascriptCore，依然承担着整个技术结构中的通信任务。 1. 基于 Web 的热修复技术对于国内的 iOS 开发者来说，审核周期、敏感业务、支付分成以及 bug 修复都催生了热修复方向的不断探索。在苹果加强审核之前，几乎所有大型的 App 都把热修复当成了 iOS 开发的基础能力，最近在《移动开发还有救么》中也详细的介绍了相关黑科技的前世今生。在所有 iOS 热修复的方案中，基于 Javascript、同时也是影响最大的就是 JSPatch。 基于上文的分析，对于脱离 WebView 的 Native 和 Web 间的通信，我们只能使用 JavascriptCore。而在 JavascriptCore 中提供了两种方式用于通信，即 Context 注册 Block 的回调，以及 JSExport。对于热修复的场景来说，我们不可能把潜在需要修复的函数都一一使用协议进行注册，更不能对新增方法和删除方法等进行处理，所以在 Native 和 Web 通信这个维度，我们只能采用 Context 注册 Block 的方式。 确定了通信采用 Block 回调的方式后，热修复就面临着如何在 JS 中调用类以及类的方法问题。由于没有使用 JSExport 等方式，JS 是无法找到相应类等属性和方法，在 JSPathc 中，通过简单的字符串替换，将所有方法都替换成通用函数（__c），然后就可以将相关信息传递给 Native，进而使用 runtime 接口调用方法。 123456789101112// 替换全部方法调用 static NSString *_replaceStr = @&quot;.__c(\&quot;$1\&quot;)(&quot;; // 调用方法 __c: function(methodName) &#123; ... return function()&#123; ... var ret = instance ? _OC_callI(instance, selectorName, args, isSuper): _OC_callC(clsName, selectorName, args) return _formatOCToJS(ret) &#125; 当然对于 JSPatch 以及其他热修复的项目来说，Web 和 Native 通信只是整个框架中的一个技术点，更多的实现原理和细节由于篇幅的关系暂且不做介绍。 2. 基于 Web 的跨平台技术随着 Google 开源了基于 Dart 语言的 Flutter，跨平台的技术又进入了一个新的发展阶段。对于传统的跨平台技术来讲，各个公司以 JavascriptCore 作为通信桥梁，围绕着 DSL 的解析、方法表的注册、模块注册通信、参数传递的设计以及 OC Runtime 的运用等不同方向，封装成了一个又一个跨平台的项目。 而在其中，以 Javascript 作为前端 DSL 的跨平台技术方案里，FaceBook 的 react-native 以及阿里 (目前托管给了 Apache) 的 Weex 最为流行。在网络上两者的比较文章有很多，集中在学习成本、框架生态、代码侵入、性能以及包大小等, 各个业务可以根据自己的重点选择合理的技术结构。 而不管是 react-native 还是 Weex,Web 和 Native 的通信桥梁仍然是 JavascriptCore。 123456//weex 举例JSValue* (^callNativeBlock)(JSValue *, JSValue *, JSValue *) = ^JSValue*(JSValue *instance, JSValue *tasks, JSValue *callback)&#123; ... return [JSValue valueWithInt32:(int32_t)callNative(instanceId, tasksArray, callbackId) inContext:[JSContext currentContext]];&#125;;_jsContext[@&quot;callNative&quot;] = callNativeBlock; iOS 中 Web 相关优化策略随着 Web 技术的不断升级以及 App 动态性业务需求的增多，越来越多的 Web 页面加入到了 iOS App 当中。与之对应的，首屏展示速度——这个对于移动客户端 Web 的最重要体验优化，也成为了移动客户端中 Web 业务最重要的优化方向。 这一章节更为详细的设计与实现，请移步 iOS 新闻类 App 内容页技术探索 (https://dequan1331.github.io/hybrid-page-kit.html)。 1. 不同业务场景的优化策略对于单纯的 Web 页面来说，业界早已有了合理的优化方向以及成熟的优化方案，而对于移动客户端中的 Web 来说，开发者在进行单一的 Web 优化同时，还可以通过优化 Web 容器以及 Web 页面中数据加载方式等多个途径做出优化。 所以对于 iOS 开发中的优化来说，就是通过 Native 和 Web 两个维度的优化关键渲染路径，保证 WebView 优先渲染完毕。由此我们梳理了常规 Web 页面整体的加载顺序，从中找出关键渲染路径，继而逐个分析、优化。 2. Web 维度的优化通用 Web 优化对于 Web 的通用优化方案，一般来说在网络层面，可以通过 DNS 和 CDN 技术减少网络延迟、通过各种 HTTP 缓存技术减少网络请求次数、通过资源压缩和合并减少请求内容等。在渲染层面可以通过精简和优化业务代码、按需加载、防止阻塞、调整加载顺序优化等等。对于这个老生常谈的问题，业内已经有十分成熟和完整的总结，例如《Best Practices for Speeding Up Your Web Site》，已经有了很好的整理和总结。 其他脱离较为通用的优化，在对代码侵入宽容度较高的场景中，开发者对 Web 优化有着更为激进的做法。例如在 VasSonic 中，除了 Web 容器复用、数据模板分离、预拉取和通用的优化方式外，还通过自定义 VasSonic 标签将 HTML 页面进行划分，分段进行缓存控制，以达到更高的优化效果。 3. Native 维度的优化容器复用和预热WKWebView 虽然 JIT 大幅优化了 JS 的执行速度，但是单纯的加载渲染 HTML，WKWebView 比 UIWebView 慢了很多。根据渲染的不同阶段分别对耗时进行测试，同时对比 UIWebView，我们发现 WKWebView 在初始化及渲染开始前的耗时较多。 针对这种情况，业界主流的做法就是复用 &amp; 预热。预热即时在 App 启动时创建一个 WKWebView，使其内部部分逻辑预热已提升加载速度。而复用又分为两种，较为复杂的是处理边界条件已达到真正的复用，还有一种较为 Triky 的办法就是常驻一个空 WKWebView 在内存。 HybridPageKit 提供了易于集成的完整 WKWebView 重用机制实现, 开发者可以无需关注复用细节，无缝的体验更为高效的 WKWebView。 Native 并行资源请求 &amp; 离线包由于 Web 页面内请求流程不可控以及网络环境的影响，对于 Web 的加载来说，网络请求一直是优化的重点。开发者较为常用的做法是使用 Native 并行代理数据请求，替代 Web 内核的资源加载。在客户端初始化页面的同时，并行开始网络请求数据；当 Web 页面渲染时向 Native 获取其代理请求的数据。 而将并行加载和预加载做到极致的优化，就是离线包的使用。将常用的需要下载资源（HTML 模板、JS 文件、CSS 文件、占位图片）打包，App 选择合适的时机全部下载到本地，当 Web 页面渲染时向 Native 获取其数据。 通过离线包的使用，Web 页面可以并行（提前）加载页面资源，同时摆脱了网络的影响，提高了页面的加载速度和成功率。当然离线包作为资源动态更新的一个方式，合理的下载时机、增量更新、加密和校验等方面都是需要进行设计和思考的方向，后文会简单介绍。 复杂 Dom 节点 Native 化实现当并行请求资源，客户端代理数据请求的技术方案逐渐成熟时，由于 WKWebView 的限制，开发者不得不面对业务调整和适配。其中保留原有代理逻辑、采用 LocalServer 的方式最为普遍。但是由于 WKWebView 的进程间通信、LocalServer Socket 建立与连接、资源的重复编解码都影响了代理请求的效率。 所以对于一些资讯类 App，通常采用 Dom 节点占位、Native 渲染实现的方式进行优化，如图片、地图、音视频等模块。这样不但能减少通信和请求的建立、提供更加友好的交互、也能并行的进行 View 的渲染和处理，同时减少 Web 页面的业务逻辑。 HybridPageKit 中就提供封装好的功能框架，开发者可以简单的替换 Dom 节点为 NativeView。 按优先级划分业务逻辑从 App 的维度上看，一个 Web 页面从入口点击到渲染完成，或多或少都会有 Native 的业务逻辑并行执行。所以这个角度的优化关键渲染路径，就是优先保证 WebView 以及其他在首屏直接展示的 Native 模块优先渲染。所以承载 Web 页面的 Native 容器，可以根据业务逻辑的优先级，在保证 WebView 模块展示之后，选择合适的时机进行数据加载、视图渲染等。这样就能保证在 Native 的维度上，关键路径优先渲染。 4. 优化整体流程所以整体上对于客户端来说，我们可以从 Native 维度（容器和数据加载）以及 Web 维度两个方向提升加载速度，按照页面的加载流程，整体的优化方向如下： iOS 中 Web 相关延伸业务1. 模板引擎为了达到并行加载数据以及并行处理复杂的展示逻辑，对于非直出类型的 Web 页面，绝大部分 App 都采用数据和模板分离下发的方式。而这样的技术架构，导致在客户端内需要增加替换对应 DSL 的模板标签，形成最终的 HTML 的业务逻辑。简单的字符串替换逻辑不但低效，还无法做到合理的组件化管理，以及组件合理的与 Native 交互，而模板引擎相关技术会使这种逻辑和表现分离的业务场景实现的更加简洁和优雅。 基于模板引擎与数据分离，客户端可以根据数据并行创建子业务模块，同时在子业务模块中处理和 Native 交互的部分如图片裁剪适配、点击跳转等等，生成 HTML 代码片段。之后基于模板进行替换生成完整的页面。这样不但减少了大量的字符串替换逻辑，同时业务也得到了合理拆分。 模板引擎的本质就是字符串的解析和替换拼接。在 Web 端不同的使用场景有很多不同语法的引擎类型，而在客户端较为流行的，有使用较为复杂的 MGTemplateEngine，它类似于 Smarty，支持部分模板逻辑。也有基于 mustache，Logic-less 的 GRMustache 可供选择。 2. 资源动态更新和管理无论是离线包、本地注入的 JS、CSS 文件、以及本地化 Web 中的默认图片，目的都是通过提前下载，替换网络请求为本地读取来优化 Web 的加载体验和成功率。而对于这些资源的管理，开发者需要从下载与更新，以及 Web 中的访问这两个方面进行设计优化。 下载与更新下载与重试：对于资源或是离线包的下载，选择合适的时机、失败重载时机、失败重载次数都要根据业务灵活调整。通常为了增加成功率和及时更新，在冷启动、前后台切换、关键的操作节点，或者采用定时轮循的方式，都需要进行资源版本号或 MD5 的判断，用以触发下载逻辑。当然对于服务端来说，合理的灰度控制，也是保证业务稳定的重要途径。 签名校验：对于动态下载的资源，我们都需要将原文件的签名进行校验，防止在传输过程中被篡改。对于单项加密的办法就是双端对数据进行 MD5 的加密，之后客户端校验 MD5 是否符合预期；而双向加密可以采用 DES 等加密算法，客户端使用公钥对资源验证使用。 增量更新：为了减少资源和离线包的重复下载，业内大部分使用离线包的场景都采用了增量更新的方式。即客户端在触发请求资源时，带上本地已存在资源的标示，服务端根据标示和最新资源做对比，之后只提供新增或修改的 Patch 供客户端下载。 基于 LocalServer 的访问在完成资源的下载与更新后，如何将 Web 请求重定向到本地，大部分 App 都依赖于 NSURLProtocol。上文提到在 WKWebView 中虽然可以使用私有函数实现（或者 iOS11+ 提供系统函数），但是仍然有许多问题。 目前业界一部分 App，都采用了集成 LocalServer 的方式，接管部分 Web 请求，从而达到访问本地资源的目的。同时集成了 LocalServer，通过将本地资源封装成 Response，利用 HTTP 的缓存技术，进一步的优化了读取的时间和性能，实现层次化的缓存结构。而使用了本地资源的 HTTP 缓存，就需要考虑缓存的控制和过期时间。通常可以通过在 URL 上增加本地文件的修改时间、或本地文件的 MD5 来确保缓存的有效性。 GCDWebServer 浅析排除 Socket 类型，业界流行的 Objc 版针对 HTTP 开源的 WebServer，不外乎年久失修的 CocoaHTTPServer 以及 GCDWebServer。GCDWebServer 是一个基于 GCD 的轻量级服务器，简单的四个模块 - Server / Connection / Request / Reponse，以及通过维护 LIFO 的 Handler 队列传入业务逻辑生成响应。在排除了基于 RFC 的 Request/Response 协议设计之外，关键的代码和流程如下： 12345678910111213141516171819//GCDWebServer 端口绑定 bind(listeningSocket, address, length) listen(listeningSocket, (int)maxPendingConnections) //GCDWebServer 绑定 Socket 端口并接收数据源 dispatch_source_t source = dispatch_source_create(DISPATCH_SOURCE_TYPE_READ, listeningSocket, 0, dispatch_get_global_queue(_dispatchQueuePriority, 0)); //GCDWebServer 接收数据并创建 Connection dispatch_source_set_event_handler(source, ^&#123; ... GCDWebServerConnection* connection = [(GCDWebServerConnection*)[self-&gt;_connectionClass alloc] initWithServer:self localAddress:localAddress remoteAddress:remoteAddress socket:socket]; //GCDWebServerConnection 读取数据 dispatch_read(_socket, length, dispatch_get_global_queue(_server.dispatchQueuePriority, 0), ^(dispatch_data_t buffer, int error) &#123; //GCDWebServerConnection 处理 GCDWebServerMatchBlock 和 GCDWebServerAsyncProcessBlock self-&gt;_request = self-&gt;_handler.matchBlock(requestMethod, requestURL, requestHeaders, requestPath, requestQuery); ... _handler.asyncProcessBlock(request, [completion copy]); 在 LocalServer 的使用上，也要注意端口的选择 ports used by Apple，以及前后台切换时 suspendInBackground 的设置和业务处理。 3.Javascript Open Api随着 App 业务的不断发展，单纯的 Web 加载与渲染无法满足复杂的交互逻辑，如拍照、音视频、蓝牙、定位等，同时 App 内也需要统一的登录态，统一的分享逻辑以及支付逻辑等。所以针对第三方的 Web 页面，Native 需要注册相应的 Javascript 接口供 Web 使用。 对于 Api 需要提供的能力、接口设计和文档规范，不同的业务逻辑和团队代码风格会有不同的定义，微信 JS-SDK 说明文档 就是一个很好的例子。而脱离 Javascript Open Api 对外的接口设计和封装，在内部的实现上也有一些通用的关键因素，这里简单列举几个： 注入方式和时机对于 Javascript 文件的注入，最简单的就是将 JS 文件打包到项目中，使用 WKWebView 提供的系统函数进行注入。这种方式无需网络加载，可以合理的选择注入时机，但是无法动态的进行修改和调整。而对于这部分业务需求需要经常调整的 App 来说，也可以把文件存储到 CDN，通过模板替换或者和 Web 合作者约定，在 Web 的 HTML 中通过 URL 的方式进行加载，这种的方式虽然动态化程度较高，但是需要合作方的配合，同时对于 JS Api 也不能做到拆分的注入。 针对上面的两种方式的优点不足，一个较为合理的方式是 Javascript 文件采用本地注入的方式，同时建立资源的动态更新系统（上文）。这样一方面支持了动态更新，同时也无需合作方的配合，对于不同的业务场景也可以拆分不同的 Api 进行注入，保证安全。 安全控制对于 Javascript Open Api 设计实现的另一个重要方面，就是安全性的控制。由于完整的 Api 需要支持 Native 登录、Cookies 等较为敏感的信息获取，同时也支持一些对 UI 和体验影响较多的功能如页面跳转、分享等，所以 App 需要一套权限分级的逻辑控制 Web 相关的接口调用，保证体验和安全。 常规的做法就是对 Javascript Open Api 建立分级的管理，不同权限的 Web 页面只能调用各自权限内的接口。客户端通过 Domain 进行分级，同时支持动态拉取权限 Domain 白名单，灵活的配置 Web 页面的权限。在此基础上 App 内部也可以通过业务逻辑的划分，在 Native 层面使用不同的容器加载页面，而容器根据业务逻辑的不同，注入不同的 JS 文件进行 Api 权限控制。 参考https://github.com/dequan1331/HybridPageKit]]></content>
      <categories>
        <category>Ios</category>
      </categories>
      <tags>
        <tag>Ios</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android Jetpack架构组件介绍]]></title>
    <url>%2F2019%2F03%2F24%2FAndroid-Jetpack%E6%9E%B6%E6%9E%84%E7%BB%84%E4%BB%B6%E4%BB%8B%E7%BB%8D%2F</url>
    <content type="text"><![CDATA[前言Google 为了帮助 Android 开发者更快更好地开发 App，推出了一系列组件，这些组件被打包成了一个整体，称作Android Jetpack，它包含的组件如下图所示： 老的 support 包被整合进了 Jetpack，例如上图 Foundation 模块的 AppCompat，整合进去之后，包名做了一下修改，全部以 androidx 开头。Android Studio 提供的迁移工具（Refactor &gt; Migrate to AndroidX）可以将源码中的旧包名替换成新的，但是如果 Maven 依赖的产物还未迁移到 AndroidX的话，还需要配置一个工具—— Jetifier，只需要在 build.gradle 中加上两行配置即可： 12android.useAndroidX=trueandroid.enableJetifier=true Jetfier 会在编译阶段直接修改依赖产物的字节码，简单粗暴。 架构大图Jetpack 不属于 Android Framework，不是 Android 开发的必需品，它只是应用层开发的一种辅助手段，帮我们解决了一些常见问题，比如版本兼容、API 易用性、生命周期管理等。其中 Architecture 部分的组件（Android Architecture Components，以下简称 AAC）组合起来形成了一套完整的架构解决方案，在没有更好的方案被发明出来之前，我们姑且把 AAC 当做 Android 架构领域的最佳实践，它的出现一定程度上避免了很多不必要的轮子。 官方给出的架构指导非常明确地表达出了每个架构组件的位置： 这张图背后隐含了三大设计思想： 关注点分离（SOC / Separation Of Concerns） 数据驱动UI（Reactive） 唯一真相源（SSOC / Single Source Of Truth） SOC 具体到工程实践中就是分层合理，单层的职责越明确，对上下游的依赖越清晰就意味着它的结构更稳定，也更可测（testable）。一个 App 从全局来看，可以划分为三部分：首先是 UI Controller 层，包含 Activity 和 Fragment；其次是 ViewModel 层，既可以做 MVVM 的 VM、MVP 的 P，也可以做 UI 的数据适配，这一层可以实现数据驱动 UI；最后是 Repository 层，它作为 SSOC，是一个 Facade 模式，对上层屏蔽了数据的来源，可以来自 local，也是来自 remote，数据持久化策略向上透明。 一张架构蓝图，三大设计原则，接下来深入细节，看看组件之间如何配合才能实现这个架构。 Lifecycle与 React/Vue 或者 iOS 相比，Android 的生命周期都比较复杂，如果要监听生命周期，一般情况下只能覆写 Activity / Fragment 的回调方法（onCreate、onResume、onPause、onDestroy 等），样板代码少不了，可维护性也变差。 如果要对生命周期进行简化，可以抽象成一个图，点表示状态，线表示事件： Lifecycle 负责处理这些点（states）和线（events），Activity / Fragment 是 LifecycleOwner，监听者则是 LifecycleObserver，一个非常清晰的观察者模式。 123456789101112class MyObserver : LifecycleObserver &#123; @OnLifecycleEvent(Lifecycle.Event.ON_RESUME) fun connectListener() &#123; ... &#125; @OnLifecycleEvent(Lifecycle.Event.ON_PAUSE) fun disconnectListener() &#123; ... &#125;&#125; 如果我们的组件需要强绑定声明周期，那么只需要借助 Lifecycle 去监听生命周期的状态和事件即可，再也不用覆写各种回调方法了。下面将要讲到的 LiveData 和 ViewModel 都是 Lifecycle-Aware Components，它们都用到了 Lifecycle。 Android 生命周期管理不当带来的最大问题就是内存泄露，举一个我们经常遇到的场景：一个异步任务（比如网络请求）持有了 UI 元素的引用，只要任务没有执行完，所有与这个 UI 元素有强引用关系的元素都没法被 GC，如果这样的场景多发生几次，很可能会引起 OOM。 为了异步对象引用的问题，最早我们使用 AsyncTask，任务执行在 worker thread，执行结果在主线程上发起回调。AsyncTask 的致命缺点是不支持流式数据（stream），而且回调嵌套太深（callback hell），与软件质量衡量指标之一的 maintainable 背道而驰，不好用自然就会慢慢被淘汰。 后来我们开始使用 RxJava，响应式编程，声明式写法，再借助 retrolambda 这种 backport，即使当年 Android 只支持到 JDK7，我们依然可以利用各种 operator 写出非常简洁的代码，“filter map 我闭~着眼”。RxJava 不但完美解决了线程调度的问题，还为我们提供了 OO 之外的抽象——作用在流上的 lambda，基于函数的抽象。但是，即便完美如斯，生命周期的问题依然无法回避，因为 Java 天生的局限性，一个 lambda 无论伪造地再像高阶函数，它本质上还是一个匿名内部类，这个匿名内部类依然持有对 outer class 实例的引用。于是我们必须通过 CompositeDisposable 来管理订阅关系，发起异步操作时记录订阅，离开页面时取消订阅，仍然需要覆写 onDestory 或者 onPause 。 如果我们以 Repository 层为界把架构蓝图分为上下两部分的话，上面的部分是数据展示，下面的部分是数据获取，数据获取部分因为要请求 Remote 数据，必然会依赖到线程调度，而数据展示必然运行在 UI 线程，与生命周期强相关，这个时候就需要 LiveData 登场了。 LiveDataLiveData 也是一个观察者模型，但是它是一个与 Lifecycle 绑定了的 Subject，也就是说，只有当 UI 组件处于 ACTIVE 状态时，它的 Observer 才能收到消息，否则会自动切断订阅关系，不用再像 RxJava 那样通过 CompositeDisposable 来手动处理。 LiveData 的数据类似 EventBus 的 sticky event，不会被消费掉，只要有数据，它的 observer 就会收到通知。如果我们要把 LiveData 用作事件总线，还需要做一些定制，Github 上搜 SingleLiveEvent 可以找到源码实现。 我们没法直接修改 LiveData 的 value，因为它是不可变的（immutable），可变（mutable）版本是 MutableLiveData，通过调用 setValue（主线程）或 postValue（非主线程）可以修改它的 value。如果我们对外暴露一个 LiveData，但是不希望外部可以改变它的值，可以用如下技巧实现： 12private val _waveCode = MutableLiveData&lt;String&gt;()val waveCode: LiveData&lt;String&gt; = _waveCode 内部用 MutableLiveData ，可以修改值，对外暴露成 LiveData 类型，只能获取值，不能修改值 LiveData 有一个实现了中介者模式的子类 —— MediatorLiveData，它可以把多个 LiveData 整合成一个，只要任何一个 LiveData 有数据变化，它的观察者就会收到消息： 123456val liveData1 = ...val liveData2 = ...val liveDataMerger = MediatorLiveData&lt;&gt;();liveDataMerger.addSource(liveData1) &#123; value -&gt; liveDataMerger.setValue(value))liveDataMerger.addSource(liveData2) &#123; value -&gt; liveDataMerger.setValue(value)) 综上，我们汇总一下 LiveData 的使用场景： LiveData - immutable 版本 MutableLiveData - mutable 版本 MediatorLiveData - 可汇总多个数据源 SingleLiveEvent - 事件总线 LiveData 只存储最新的数据，虽然用法类似 RxJava2 的 Flowable，但是它不支持背压（backpressure），所以不是一个流（stream），利用 LiveDataReactiveStreams 我们可以实现 Flowable 和 LiveData 的互换。 如果把异步获取到的数据封装成 Flowable，通过 toLiveData 方法转换成 LiveData，既利用了 RxJava 的线程模型，还消除了 Flowable 与 UI Controller 生命周期的耦合关系，借助 Data Binding 再把 LiveData 绑定到 xml UI 元素上，数据驱动 UI，妥妥的响应式。于是一幅如下模样的数据流向图就被勾勒了出来： 图中右上角的 Local Data 是 AAC 提供的另一个强大武器 —— ORM 框架 Room。 Room数据库作为数据持久层，其重要性不言而喻，当设备处于离线状态时，数据库可用于缓存数据；当多个 App 需要共享数据时，数据库可以作为数据源，但是基于原生 API 徒手写 CRUD 实在是痛苦，虽然 Github 上出现了不少 ORM 框架，但是它们的易用性也不敢让人恭维，直到 Room 出来之后，Android 程序员终于可以像 mybatis 那样轻松地操纵数据库了。 Room 是 SQLite 之上的应用抽象层，而 SQLite 是一个位于 Android Framework 层的内存型数据库。虽然 Realm 也是一个优秀的数据库，但是它并没有内置于 Android 系统，所会增大 apk 的体积，使用 Room 则没有这方面烦恼。 Room 的结构抽象得非常简单，数据对象（表名 + 字段）用 @Entity 注解来定义，数据访问用 @Dao 来注解，db 本身则用 @Database 来定义，如果要支持复杂类型，可以定义 @TypeConverters，然后在编译阶段，apt 会根据这些注解生成代码。Room 与 App 其他部分的交互如下图所示： Entity 是一个数据实体，表示一条记录，它的用法如下： 12345678@Entity(tableName = "actors")data class Actor( @PrimaryKey @ColumnInfo(name = "id") val actorId: String, val name: String, val birthday: Date?, val pictureUrl: String) Actor 是一个用 @Entity 注解的 data class，它会生成一个名字是 actors 的表，注意到有一个字段是 @Date? ，但是 SQLite 本身不支持这种复杂类型（complex type），所以我们还需要写一个可以转换成基础类型的转换器： 1234567class Converters &#123; @TypeConverter fun timestampToDate(value: Long?) = value?.let &#123; Date(it) &#125; @TypeConverter fun dateToTimestamp(date: Date?) = date?.time&#125; 转换器通过 @TypeConverters 可作用于 class、field、method、parameter，分别代表不同的作用域。比如作用在 @Database 类的上，那么它的作用域就是 db 中出现的所有 @Dao 和 @Entity。 12345@Database(entities = [Actor::class], version = 1, exportSchema = false)@TypeConverters(Converters::class)abstract class AppDatabase : RoomDatabase() &#123; abstract fun actorDao(): ActorDao&#125; @Query 中的 SQL 语句可以直接引用方法参数，而且它的返回值可以是 LiveData 类型，也支持 Flowable 类型，也就是说，Room 原生支持响应式，这是对数据驱动最有利的支持，也是 Room 区别于其他 ORM 框架的显著特征。 至此，我们可以确定，无论数据来自 Remote 还是来自本地 DB，架构蓝图中的 Repository 对 ViewModel 提供的数据可以永远是 LiveData 类型，接下来我们看一下 ViewModel 的妙用。 ViewModelViewModel 是一个多面手，因为它的生命周期比较长，可以跨越因为配置变动（configuration changed，比如屏幕翻转）引起的 Activity 重建，因此 ViewModel 不能持有对 Activity / Fragment 的引用。 如果 ViewModel 中要用到 context 怎么办呢？没关系，框架提供了一个 ViewModel 的子类 AndroidViewModel ，它在构造时需要传入 Application 实例。 既然 ViewModel 与 UI Controller 无关，当然可以用作 MVP 的 Presenter 层提供 LiveData 给 View 层，因为 LiveData 绑定了 Lifecycle，所以不存在内存泄露的问题。除此之外，ViewModel 也可以用做 MVVM 模式的 VM 层，利用 Data Binding 直接把 ViewModel 的 LiveData 属性绑定到 xml 元素上，xml 中声明式的写法避免了很多样板代码，数据驱动 UI 的最后一步，我们只需要关注数据的变化即可，UI 的状态会自动发生变化。 ViewModel 配合 Data Binding 的用法与 React 非常相似，ViewModel 实例相当于 state，xml 文件就好比 render 函数，只要 state 数据发生变化，render 就会重新渲染 UI，但是 data binding 还有更强大的一点，它支持双向绑定。举个例子，UI 需要展示一个评论框，允许展示评论，也允许用户修改，那么我们可以直接把 EditText 双向绑定到一个 LiveData 之上，只要用户有输入，我们就可以收到通知，完全不需要通过 Kotlin/Java 来操控 UI： 12&lt;TextInputEditText android:text="@=&#123;viewModel.commentText&#125;" /&gt; 注意，如果要在 xml 中使用 LiveData，需要把 lifecycle owner 赋给 binding： 123val binding: MainBinding = DataBindingUtil.setContentView(this, R.layout.main)// Specify the current activity as the lifecycle owner.binding.setLifecycleOwner(this) 因为 ViewModel 拿到的数据是 Repository 给的，可能不适用于 UI 元素，所以 ViewModel 还承担了数据适配的工作，有时候我们需要汇总 repository 的多个返回值一次性给到 UI，那么就可以使用 LiveData 的“操作符” Transformations.switchMap，用法可以认为等同于 Rx 的 flatMap；如果只想对 LiveData 的 value 做一些映射，可以使用 Transformations.map，目前 Transformations 只有这两个操作符，因为不管 Kotlin 还是 Java8，都提供了很多声明式的操作符，对流的支持都比较友好，而 LiveData本身不是一个流，所以这两个操作符足矣。 除了数据适配之外，ViewModel 还有一个强大的用法 —— Fragment 之间共享数据，这样 ViewModel 又扮演了 FLUX 模式中的 store 这一角色，是多个页面（fragment）之间唯一的数据出口。 ViewModel 的用法也非常简单，通过 ViewModelProviders.of 可以获取 ViewModel 实例： 12val viewModel = ViewModelProviders.of(requireActivity(), factory) .get(ActorViewModel::class.java) 一通操作猛如虎之后，UI controller 层变得薄如蝉翼，它只做了一件事情，把数据从左手（ViewModel）倒给了右手（使用了 Data Binding 的 xml）。 如果把 ViewModel 作为 SSOC（唯一真相源），多个 Fragment 之间共享数据，再利用 SingleLiveEvent 做总线，一个 Activity 配多个 Fragment 的写法就避免了 Activity 之间通过 Intent 传递数据的繁琐。但是 Fragment 的堆栈管理一直是一个让人头疼的问题，AAC 的 Navigation 不但完美解决了这个问题，而且还提供可视化的路由，只需拖拽一下就能生成类型安全的跳转逻辑。 NavigationNavigation 用一个图（graph）来表示页面间的路由关系，图的节点（node）表示页面，边（edge）表示跳转关系。例如下图 8 个页面的跳转关系，一目了然： 页面与页面之间的连线叫 action，它可以配置进离场动画（Animations），也可以配置出栈行为（Pop Behavior），还支持 Single Top 的启动选项（Launch Options）。进离场动画和启动选项很好理解，出栈行为是一个比较强大的功能，action 箭头所指的方向表示目标页面入栈，箭头的反方向则表示目标页面出栈，而出栈的行为在 Navigation 编辑器中完全可控，我们可以指定要出栈到哪个页面，甚至可以指定目标页面是否也需要出栈： 针对页面节点，还可以定义它要接收的参数（arguments），支持默认值，从此 Fragment 之间的参数传递变得非常直观，非常安全。 看一下具体用法，首先在跳转发起页面，通过 apt 生成的跳转函数传入参数： 123val actorId = getSelectedActorId()val direction = ActorListFragmentDirections.showDetail(actorId)findNavController().navigate(direction) 然后利用目标页面生成的 *Args 获取参数： 1然后利用目标页面生成的 *Args 获取参数： 这里的 navArgs 是一个扩展函数，利用了 Kotlin 的 ReadWriteProperty。 几行代码就搞定了页面之间的跳转，而且还是可视化！从没有想过 Android 的页面跳转竟会变得如何简单，但是 Navigation 的方案并不是原创，iOS 的 Storyboard 很早就支持拖拽生成路由。当年 Android 推出 ConstraintLayout 之时，我们都认为是参考了 Storyboard 的页面拖拽，现在再配上 Navigation，从页面到跳转，一个完整的拖拽链路就形成了。平台虽然有差异化，但是使用场景一致的前提下，解决方案也就殊途同归了。 了解完了与生命周期有关的组件，接下来我们来看细节。 PagingUI 没有办法一次性展示所有的数据，端上的系统资源（电量、内存）也有限制，不可能把所有数据都加载到内存中；而且大批量请求数据不但浪费带宽，在某些网络情况（弱网、慢网）下还会导致请求失败，所以分页是很多情景下的刚需。Github 上有各式各样的解决方案，这一次，Google 直接推出了官方的分页组件——Paging。 Paging 将分页逻辑拆解为三部分： 数据源 DataSource 数据块 PagedList 数据展示 PagedListAdapter DataSource 的数据来源于后端服务或者本地数据库，并且用三个子类来表示三种分页模式： PageKeyedDataSource - 单页数据以 page key 为标识，例如当前页的 Response 中包含了下一页的 url，这个 url 就是 page key。 ItemKeyedDataSource - 单页数据以 item key 为标识，比如下一页的请求要带当前页最后一个 item 的 id，这个 itemId 就是 item key。 PositionalDataSource - 单页数据以位置为标识，这种模式比较常见，Room 只支持这一种，因为数据库查询以 OFFSET 和 LIMIT 做分页。 PageKeyedDataSource 和 ItemKeyedDataSource 适用于内存型数据，比如直接从后端获取后需要展示的数据。PositionalDataSource 适用于本地 Room 数据或者使用 Room 做缓存的 Cache 数据。 数据流向的关系图如下所示： LivePagedListBuilder 利用 DataSource.Factory 和 PageList.Config 创建 LiveData，UI Controller 拿到数据之后交给 PagedListAdapter 展示到 RecyclerView。 上图表达了数据的流向，如果从 UI 层往回看，页面展示的数据存储在 PagedList 中，PagedList 只是 DataSource 的数据块（chunk），当 PagedList 需要更多数据时，DataSource 就会给更多，当 DataSource 一无所有时便会触发 BoundaryCallback 获取更多数据，直到数据全部展示完毕。 LivePagedListBuilder 会将 PagedList 包装成 LiveData&lt;PagedList&gt; 给到下游，它在整个数据交互链路中的位置如下图所示： Repository 拿到 Dao 的 DataSource.Factory 之后，调用它的 toLiveData 方法并传入 PagedList.Config，然后生成一个分页的 LiveData 交给 ViewModel 层。 Paging 加上生命周期相关的架构组件解决了数据存储、数据流转和数据展示的问题。除此之外，AAC 还包括一个强大的异步任务执行器 WorkManager，它解决了任务执行的 可靠性，无论 App 退出还是设备重启，交给 WorkerManager 的任务都会被执行。 WorkManagerWorkManager 虽然解决了任务执行可靠性的问题，但是它无法精确控制任务的执行时间，因为 WorkManager 要根据 OS 资源来选择执行任务。Android 自身提供了很多方案来解决后台任务执行的问题，可以根据下图的决策路径选择不同的组件： WorkManager 整体上可分为四部分：任务类型、任务构建、任务监控和任务控制。 一、任务类型WorkManager 提供了一次性任务和周期性任务两种任务类型： OneTimeWorkRequest —— 一次性任务 PeriodicTimeWorkRequest —— 周期性任务 二、任务构建一是执行条件，二是执行顺序。 Constraints —— 通过 Constraints.Builder构建任务执行的条件（网络类型、电量、设备空间等） WorkContinuation —— 可以指定任务的执行顺序，例如可以按照 PERT 图的顺序执行任务： 三、任务监控通过回调来获知任务的当前状态： 四、任务控制包括加入队列，取消任务，其中 UniqueWork 提供了多种加入队列的策略（REPLACE、KEEP、APPEND）： cancelWorkById(UUID) —— 通过 ID 取消单个任务 cancelAllWorkByTag(String) —— 通过 Tag 取消所有任务 cancelUniqueWork(String) —— 通过名字取消唯一任务 除此之外，WorkerManager 还提供了四种不同线程模型的 Worker： Worker —— 基于默认后台线程 CoroutineWorker —— 基于 Kotlin 的协程 RxWorker —— 基于 RxJava2 ListenableWorker —— 基于回调的异步 总结Google 官方架构组件 AAC 为我们提供了太多通用问题的解决方案，使用场景包括数据持久化、异步任务调度、生命周期管理，UI 分页、UI 导航，当然还有强大的 MVVM 框架 Data Binding，这些架构组件不但使代码变得清晰易读，而且独立于 Android SDK 向下兼容，AAC 使我们更加聚焦产品，专注于解决问题，而不是花太多的时间重复造轮子。 资料https://developer.android.google.cn/jetpack/androidx/migrate https://developer.android.google.cn/jetpack/ https://developer.android.google.cn/jetpack/docs/guide https://proandroiddev.com/advanced-data-binding-binding-to-livedata-one-and-two-way-binding-dae1cd68530f]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mysql优化小技巧]]></title>
    <url>%2F2019%2F03%2F24%2FMysql%E4%BC%98%E5%8C%96%E5%B0%8F%E6%8A%80%E5%B7%A7%2F</url>
    <content type="text"><![CDATA[程序嵌入SQL语句优化小技巧 1、比较运算符能用’=’就不用’&lt;&gt;’‘=’增加了索引的使用几率 2、明知只有一条查询结果，那请使用’LIMIT 1’‘LIMIT 1’可以避免全表扫描，找到对应结果就不会再继续扫描了 3、为列选择合适的数据类型能用TINYINT就不用SMALLLINT,能用SMALLINT就不用INT，内存消耗越小越好 4、将大的DELETE，UPDATE或者INSERT查询变成多个小查询为了达到更好的性能以及更好的数据控制，可以将它们变成多个小查询 5、如果结果集允许重复的话，使用UNION ALL代替UNION因为UNION ALL不去重复，效率高于UNION 6、为获得相同结果集的多次执行，请保持SQL语句前后一致目的是为了充分利用查询缓冲，比如根据地域或者产品id查询产品价格，第一次使用了1SELECT price FROM order WHERE id = 123456 and region = 'BEIJING'; 那么第二次同样的查询，请保持以上语句的一致性，比如不要将where语句里面的id和region位置调换顺序。 7、避免使用’SELECT *’如果不查询表中所有的列，尽量避免使用SELECT *，因为这样会进行全表扫描，不能有效利用索引，增大了数据库服务器的负担，以及它与应用程序客户端之间的网络IO开销。 8、WHERE子句里面的列尽量被索引只是’尽量’，并不是说所有的列。因地制宜，根据实际情况进行调整，索引太多也会降低性能。 9、JOIN子句里面的列尽量被索引同样只是’尽量’ 10、ORDER BY的列尽量被索引性能会更好 11、使用LIMIT实现分页逻辑提高性能，减少不必要数据库和应用的网络传输 12、使用EXPLAIN关键字去查看执行计划EXPLAIN可以检查索引使用情况以及扫描的行。 moreSQL调优方法还有很多种，同样的查询结果可以有很多种查询方式，最好的方法就是测试！]]></content>
      <categories>
        <category>DBA</category>
      </categories>
      <tags>
        <tag>Mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS入门]]></title>
    <url>%2F2019%2F03%2F19%2FCSS%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[CSS入门学习Tool: Visual Studio Code 文中元素=标签 外链样式与内链样式外链1&lt;link rel="stylesheet" type="text/css" href="style/main.css"&gt; 内链123&lt;style type="text/css"&gt; ...&lt;/style&gt; 块元素与内联元素块元素概念：独占一行的元素，标签代表有div,p，h1~h6等等 div没有任何语义的标签，而在H5中新增了一些语义标签，具体请看另一片文章关于HTML5的新特性块元素主要作为页面的布局，一般情况块元素用来包含内联元素。p标签不可以包含其他任何块元素 实例证明:1234567891011121314151617&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;meta http-equiv="X-UA-Compatible" content="IE=edge"&gt; &lt;title&gt;Page Title&lt;/title&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1"&gt; &lt;link rel="stylesheet" type="text/css" media="screen" href="main.css"&gt; &lt;script src="main.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;p&gt; 哈哈哈 &lt;div&gt;哈哈&lt;/div&gt; &lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 浏览器上查看内容可以正常显示，但是检查浏览器元素的显示则解析成了 内联元素概念：只占自身内容大小的元素，标签代表有span,a等 a标签可以包含任何内联和块元素，但是除了它本身 实例证明:12345678910111213141516&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;meta http-equiv="X-UA-Compatible" content="IE=edge"&gt; &lt;title&gt;Page Title&lt;/title&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1"&gt; &lt;link rel="stylesheet" type="text/css" media="screen" href="main.css"&gt; &lt;script src="main.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;a href="#"&gt; &lt;a href="#"&gt;&lt;/a&gt; &lt;/a&gt;&lt;/body&gt;&lt;/html&gt; 检查浏览器元素的显示则解析成了 标签间的关系标签之间的关系： 父标签：直接包含子标签的标签 子标签：直接被父标签包含的标签 祖先标签：直接或间接包含后代标签的标签，父标签也是祖先标签 后代标签：直接或间接被祖先标签包含的标签，子标签也是后代标签 兄弟标签：拥有相同父标签的标签 选择器标签选择器12345678910111213141516171819&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style type="text/css"&gt; div &#123; width: 200px; height: 200px; color: red; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div&gt;我是一个div&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; ID选择器12345678910111213141516171819&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style type="text/css"&gt; #d1 &#123; width: 200px; height: 200px; color: red; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="d1"&gt;我是一个div&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 类选择器12345678910111213141516171819&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style type="text/css"&gt; .c1 &#123; width: 200px; height: 200px; color: red; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="c1"&gt;我是一个div&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 选择器分组（并集选择器）语法：选择器1，选择器2，选择器3{} 12345678910111213141516171819&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style type="text/css"&gt; .c1,p,span&#123; color: red; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="c1"&gt;我是一个div&lt;/div&gt; &lt;p&gt;我是一个段落&lt;/p&gt; &lt;span&gt;我是一个span&lt;/span&gt;&lt;/body&gt;&lt;/html&gt; 通配选择器语法：*{} 1234567891011121314151617181920&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style type="text/css"&gt; * &#123; padding: 0; margin: 0; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="c1"&gt;我是一个div&lt;/div&gt; &lt;p&gt;我是一个段落&lt;/p&gt; &lt;span&gt;我是一个span&lt;/span&gt;&lt;/body&gt;&lt;/html&gt; 这个一般用于适配每个浏览器的默认值。 复合选择器（交集选择器)语法：选择器1选择器2{} 后代选择器选中指定标签的指定后代标签 语法：祖先标签 后代标签 {} 1234567891011121314151617181920&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style type="text/css"&gt; #d1 p&#123; color: red; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="d1"&gt; &lt;p&gt;我是一个在div里的段落&lt;/p&gt; &lt;/div&gt; &lt;p&gt;我是一个段落&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 子代选择器选中父标签的指定子标签 语法：父标签 &gt; 子标签 {} 123456789101112131415161718192021&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style type="text/css"&gt; div &gt; p &gt; span&#123; color: red; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="d1"&gt; &lt;p&gt;我是一个在div里的段落&lt;span&gt;我是span&lt;/span&gt;&lt;/p&gt; &lt;span&gt;我也是span&lt;/span&gt; &lt;/div&gt; &lt;p&gt;我是一个段落&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 伪类选择器伪类：专门用来表示标签的一种特殊状态 hover和active可以被其他标签所使用，不仅只是用于a标签vistited伪类由于涉及到用户隐私问题，所以在该标签内仅仅只能设置color属性，其他设置也无效。也可能还有存在版本问题，IE6可以设置，其余基本测试失败。 1234567891011121314151617181920212223242526&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style type="text/css"&gt; a:link &#123; color: red; &#125; a:visited &#123; color: blue; &#125; a:hover &#123; color: yellow; &#125; a:active &#123; color: orange; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;a href="http://www.baidu.com"&gt;我是超链接&lt;/a&gt;&lt;/body&gt;&lt;/html&gt; 伪元素（伪标签）选择器表示元素中的一些特许位置 12345678910111213141516171819202122&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style type="text/css"&gt; p::first-letter &#123; color: red; &#125; p::first-line &#123; color: yellow; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;p&gt; 我是一个很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长的文字 &lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 属性选择器根据元素中的属性或者属性值来选指定元素。 语法： 标签[属性名]{} 有这个属性的 标签[属性名=”属性值”]{} 以属性为属性值的 标签^[属性名=”属性值”]{} 以属性的属性值为开头的 标签$[属性名=”属性值”]{} 以属性的属性值为结尾的 标签[属性名=”属性值”]{} 以属性的属性值为包含的 我是一个段落，title就是其中一个属性。 title就是一个属性 1234567891011121314151617181920212223&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style type="text/css"&gt; span[class] &#123; color: red; &#125; p[title="content"] &#123; color: orange; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;span class='hh'&gt;我是一个段落&lt;/span&gt; &lt;p title="content"&gt; 我是一个很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长的文字 &lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 结构伪类选择器:first-child {} 选中父元素中第一个子元素:last-child {} 选中父元素中最后一个子元素:nth-child(n) {} 选中父元素中正数第n个子元素:nth-last-child(n) {} 选中父元素中倒数第n个子元素:first-of-type {} 选中第一个元素:last-of-type {} 选中最后一个元素:nth-child(n) {} 选中第n个元素 1234567891011121314151617181920&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style type="text/css"&gt; p:first-child &#123; color: red; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;p&gt;哈哈&lt;/p&gt; &lt;p&gt;哈哈&lt;/p&gt; &lt;p&gt;哈哈&lt;/p&gt; &lt;p&gt;哈哈&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 兄弟元素选择器选中一个元素后的指定兄弟元素。语法：兄弟元素前 + 兄弟元素后 {} 12345678910111213141516171819202122&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style type="text/css"&gt; p + span &#123; color: red; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;p&gt;哈哈&lt;/p&gt; &lt;p&gt;哈哈&lt;/p&gt; &lt;span&gt;我是兄弟&lt;/span&gt; &lt;p&gt;哈哈&lt;/p&gt; &lt;p&gt;哈哈&lt;/p&gt; &lt;span&gt;我是最后一个span&lt;/span&gt;&lt;/body&gt;&lt;/html&gt; 否定伪类选择器可以从已经选中的元素中剔除某些元素 语法：选择器:not(选择器){} 12345678910111213141516171819202122&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style type="text/css"&gt; p:not(.c) &#123; color: red; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;p&gt;我是p&lt;/p&gt; &lt;p&gt;我是p&lt;/p&gt; &lt;p class="c"&gt;我是p&lt;/p&gt; &lt;p&gt;我是p&lt;/p&gt; &lt;p&gt;我是p&lt;/p&gt; &lt;p&gt;我是p&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 样式的继承祖先的元素会被他的后代所继承。可以利用继承的特性将一些基本的样式继承给祖先元素。但并不是所有样式都会被后代元素所继承。例如一些背景相关的样式，都不会被继承。 选择器的优先级使用不同选择器时，选中了同一个元素并设置了相同的样式，则优先级高的优先显示。 优先级规则(数值为参考值)： 内联样式 优先级 1000 ID选择器 优先级 100 类和伪类 优先级 10 元素选择器 优先级 1 通配选择器 优先级 0 继承样式 无优先级 当选择器有多种选择器时，先将优先级相加再进行比对选择器的优先级不会超过它的最大数量级(虽然很少这样写)如果选择器的优先级相同，谁在代码的位置靠后就用谁。并集选择器的优先级单独计算，并集每个选择器都是独立的。 特殊情况：在样式后添加一个!important，则该样式会获得最高优先级，甚至超过内联样式。(尽量避免使用，多人开发时比较麻烦) 伪类顺序关于a的伪类有四个,:link,:visited,hover,:active，这四个伪类优先级是一样的。 但是特殊情况:hover与:active这两种情况是相同的，都是会同时触发。由于优先级相等，所以看谁在代码后就使用谁。所以写伪类的顺序一般都是有规则的，最好习惯写为:link-&gt;:visited-&gt;:hover-&gt;:active 盒模型CSS 框模型 (Box Model) 规定了元素框处理元素内容、内边距、边框 和 外边距 的方式。 盒模型属性 一个盒子分成这么几个部分 内容部分 内边距 边框 外边距 他们都有各自的简写方式。盒子大小由内容区、内边距、边框共同决定。 内容区css中定义width与height定义的只是内容区的大小 边框元素的边框 (border) 是围绕元素内容和内边距的一条或多条线。CSS border 属性允许你规定元素边框的样式、宽度和颜色。 为元素设定边框必须设置三个属性:width,color,style。但是大部分浏览器都会有边框的默认值。 边框样式：border-style边框的宽度：border-width边框的颜色：border-color 12345678910111213141516171819202122&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;&lt;/title&gt; &lt;style type="text/css"&gt; .box &#123; width: 200px; height: 200px; border-width: 2px; border-color: yellow; border-style: solid; /*简写*/ border: 2px green solid; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="box"&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 内边距元素的内边距在边框和内容区之间。控制该区域最简单的属性是 padding 属性。CSS padding 属性定义元素边框与元素内容之间的空白区域。 padding属性接受长度值或者百分比值，但不允许使用负值。 h1 元素的各边都有 10 像素的内边距h1 {padding: 10px;} 也可以根据上、右、下、左顺序分别赋值h1 {padding: 10px 0.25em 2ex 20%;} 单边属性 padding-top padding-right padding-bottom padding-left 当宽度为auto（默认值）此时指定的内边距不会影响盒子的可见宽度，而是自动修复宽度而适应内边距。 外边距围绕在元素边框的空白区域是外边距。设置外边距会在元素外创建额外的“空白”。设置外边距的最简单的方法就是使用 margin 属性，这个属性接受任何长度单位、百分数值甚至负值。 margin 属性接受任何长度单位，可以是像素、英寸、毫米或 em。margin 可以设置为 auto。但是允许设置为负值。 auto值一般设置水平方向，可以用来设置居中。 用法基本和padding类似。 由于页面元素都是靠左上来进行布局，则设置左，上外边距时会影响自身盒子的位置，相反，设置右，下外边距时会影响其他盒子的位置。 外边距合并外边距合并指的是，当两个垂直外边距相遇时，它们将形成一个外边距。合并后的外边距的高度等于两个发生合并的外边距的高度中的较大者。 两种情况： 第一种：两边为兄弟相邻的元素时 123456789101112131415161718192021222324252627&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;&lt;/title&gt; &lt;style type="text/css"&gt; .box1 &#123; height: 200px; width: 200px; background-color: yellow; margin-bottom: 100px; &#125; .box2 &#123; height: 200px; width: 200px; background-color: green; margin-top: 200px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="box1"&gt;&lt;/div&gt; &lt;div class="box2"&gt;&lt;/div&gt; &lt;!-- 两盒盒子的margin仅仅只有200px，而不是300px，仅取决于最大的那个margin而不是相加的值 --&gt;&lt;/body&gt;&lt;/html&gt; 第二种：两边为父子关系的元素并某个边与边重叠时 1234567891011121314151617181920212223242526&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;&lt;/title&gt; &lt;style type="text/css"&gt; .box2 &#123; width: 200px; height: 100px; background-color: yellow; margin-top: 100px; &#125; .box &#123; width: 200px; height: 300px; background-color: green; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="box"&gt; &lt;div class="box2"&gt;&lt;/div&gt; &lt;!-- 结果会发现box2不是相对于box移动了100px，而是box往下移动了100px，原因是因为box和box2处于父子关系，它们的上边框进行了重叠导致的--&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 解决方式 1、使用padding，但是会影响盒子原来内容大小2、添加一个空的table标签3、使用:before伪类，添加一个display=table属性和属性值，原理与第二点相似，但是不会添加无意义的文档标签。 内联元素的盒模型内联元素无法设置width和height，其余基本和块元素的盒模型相似。 三步走：内容区、padding、margin、border display中的block、inline、inline-block、nonedisplay属性规定元素应该生成的框(盒模型)的类型。 说明 这个属性用于定义建立布局时元素生成的显示框类型。对于 HTML 等文档类型，如果使用 display 不谨慎会很危险，因为可能违反 HTML 中已经定义的显示层次结构。对于 XML，由于 XML 没有内置的这种层次结构，所有 display 是绝对必要的。 主要使用的值： 值 描述 none 此元素不会被显示 block 此元素将显示为块级元素，此元素前后会带有换行符 inline 默认。此元素会被显示为内联元素，元素前后没有换行符 inline-block 行内块元素（CSS2.1新增） 更多的值请参考链接 将一个div设置为内联元素：1234567891011121314151617181920&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;&lt;/title&gt; &lt;style type="text/css"&gt; .box &#123; width: 100px; height: 100px; background-color: yellow; display: inline; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="box"&gt;a&lt;/div&gt; &lt;!-- 会发现div的设置的宽度和高度设置无效，div已经变为内联元素 --&gt;&lt;/body&gt;&lt;/html&gt; visibility中的hidden、visiblevisibility 属性规定元素是否可见，可以被继承。 值 描述 visible 默认值，元素是可见的 hidden 元素是不可见的 collapse 当在表格元素中使用时，此值可删除一行或一列，但是它不会影响表格的布局。被行或列占据的空间会留给其他内容使用。如果此值被用在其他的元素上，会呈现为 “hidden”。 inherit 规定应该从父元素继承 visibility 属性的值。 使 h2 元素不可见： 1234h2 &#123; visibility:hidden; &#125; overflow解决溢出内容显示,overflow 属性规定当内容溢出元素框时发生的事情。 值 描述 visible 默认值。内容不会被修剪，会呈现在元素框之外。 hidden 内容会被修剪，并且其余内容是不可见的。 scroll 内容会被修剪，但是浏览器会显示滚动条以便查看其余的内容。 auto 如果内容被修剪，则浏览器会显示滚动条以便查看其余的内容。 inherit 规定应该从父元素继承 overflow 属性的值。 在一个狭小的div以滚动条的方式显示一段文本123456789101112131415161718192021&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;&lt;/title&gt; &lt;style type="text/css"&gt; .box &#123; width: 200px; height: 200px; overflow: auto; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="box"&gt; &lt;p&gt;上面这个操作有一些缺陷，不能序列化函数、undefined、循环引用等，详见传送门，但是也能应付一些日常情况了。事实上，在 Props 是引用类型时，单独修改对象、数组的某个属性或下标，Vue 并不会抛出错误。当然，前提是你要非常清楚自己在做什么，并写好注释，防止你的小伙伴们疑惑。有的同学可能知道，在组件上绑定的属性，如果没有在组件内部用 Props 声明，会默认绑定到组件的根元素上去。还是之前的栗子：。&lt;/p&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 文档流文档流出在网页最底层，它表示的是一个网页中的位置，我们所创建的元素默认都处于文档流中。原文是normal flow，至于为何翻译成文档流见仁见智。指语言文本从左到右，从上到下显示。但是浮动、绝对定位、固定定位这些都会导致脱离文档流。 浮动float 属性定义元素在哪个方向浮动。以往这个属性总应用于图像，使文本围绕在图像周围，不过在 CSS 中，任何元素都可以浮动。浮动元素会生成一个块级框，而不论它本身是何种元素。 如果浮动非替换元素，则要指定一个明确的宽度；否则，它们会尽可能地窄。 值 描述 left 元素向左浮动 right 元素向右浮动。 none 默认值。元素不浮动，并会显示在其在文本中出现的位置。 inherit 规定应该从父元素继承 float 属性的值。 设置浮动会脱离文档流，元素会尽量向父元素或者遇到其他元素的左上或者右上靠。如果浮动元素上边是一个块元素，则浮动元素不会浮动超过这个块元素。 浮动的元素不会盖住文字，会自动环绕在浮动元素周围。当块元素设置float脱离文档流后，宽和高则默认是变成被内容撑开。内联元素使用float脱离文档流后，会变成块元素。 清除浮动clear 属性规定元素的哪一侧不允许其他浮动元素。 clear 属性定义了元素的哪边上不允许出现浮动元素。在 CSS1 和 CSS2 中，这是通过自动为清除元素（即设置了 clear 属性的元素）增加上外边距实现的。在 CSS2.1 中，会在元素上外边距之上增加清除空间，而外边距本身并不改变。不论哪一种改变，最终结果都一样，如果声明为左边或右边清除，会使元素的上外边框边界刚好在该边上浮动元素的下外边距边界之下。 值 描述 left 在左侧不允许浮动元素。 right 在右侧不允许浮动元素。 both 在左右两侧均不允许浮动元素。 none 默认值。允许浮动元素出现在两侧。 inherit 规定应该从父元素继承 clear 属性的值。 both是清除影响对当前元素影响最大的元素对兄弟元素有效，父子是无效的。清除浮动clean属性，清除其他浮动元素对当前元素的影响 实例： 1234567891011121314151617181920212223242526272829&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;&lt;/title&gt; &lt;style type="text/css"&gt; .box1 &#123; width: 100px; height: 100px; background-color: yellow; float: right; &#125; .box2 &#123; width: 200px; height: 200px; background-color: blue; clear: right; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="box1"&gt;&lt;/div&gt; &lt;div class="box2"&gt;&lt;/div&gt; &lt;!-- 如果box2不设置clear，则box2的位置将被顶到box1的高度上，2⃣而设置了clear后，box2还在原来的位置 --&gt;&lt;/body&gt;&lt;/html&gt; 高度塌陷问题原因：在文档流中，父元素高度默认是由子元素的高度撑起来的，但是设置浮动后，子元素脱离了文档流，则导致了父元素的高度塌陷。 1234567891011121314151617181920212223242526272829&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;&lt;/title&gt; &lt;style type="text/css"&gt; .parent &#123; border: 2px red solid; &#125; .sun &#123; height: 200px; width: 100px; background-color: yellow; float: right; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="parent"&gt; &lt;div class="sun"&gt; &lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 解决方式一BFC:Block Formatting （IE6以下并不支持）Context，W3C标准中，页面中都有一个隐含的属性。默认是关闭的，当打开的时候，会出现以下特性： 父元素的垂直外边距不会与子元素重叠 开启BFC的元素不会被浮动元素所覆盖 开启BFC的元素可以包含浮动的子元素 如何开启BFC（无法直接开启） 设置元素浮动 开启元素绝对定位 设置元素的display的值为inline-block 设置元素的overflow的值为非visible的值（推荐hidden）【该方式最简单的方式，副作用最小】 兼容IE6 则可以使用相似于BFC的，成为hasLayout，开启方式则设置zoom:1即可。但是该方式仅支持IE8以下。如需完全兼容和其他浏览器，则设置两者同时设置。或者指定元素宽度。 解决方式二利用清除浮动，直接在高度塌陷的父元素的最后，添加一个空白的div，由于该元素没有浮动，所以它是可以撑开父元素的高度的，对其进行清除浮动，消除了上一个元素的浮动影响，即可撑起父元素的高度，且该方案兼容性比方案一更高，影响度最小。但是添加了一个毫无意义的div标签，可读性变差了。 1234567891011121314151617181920212223242526272829303132&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;&lt;/title&gt; &lt;style type="text/css"&gt; .parent &#123; border: 2px red solid; &#125; .sun &#123; height: 200px; width: 100px; background-color: yellow; float: right; &#125; .clearfix &#123; clear: both; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="parent"&gt; &lt;div class="sun"&gt;&lt;/div&gt; &lt;div class="clearfix"&gt;&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 解决方式三利用:after伪类选择器。 :after 选择器在被选元素的内容后面插入内容。请使用 content 属性来指定要插入的内容。 通过alter伪类向元素添加一个空白的块元素，然后对其清除元素。和方式二的原理相同，但是该方式可读性更高。不会在html中添加毫无意义的空白标签。 12345678910111213141516171819202122232425262728293031323334353637&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;&lt;/title&gt; &lt;style type="text/css"&gt; .parent &#123; border: 2px red solid; &#125; .sun &#123; height: 200px; width: 100px; background-color: yellow; float: right; &#125; /*.clearfix &#123; clear: both; &#125;*/ .clearfix:after &#123; content: ""; clear: both; display: block; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="parent clearfix"&gt; &lt;div class="sun"&gt;&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; display的值可以为block，也可以为table。 定位定位指的是将指定的元素摆放在页面中指定的位置，通过定位可以任意的摆放元素。 这个属性定义建立元素布局所用的定位机制。任何元素都可以定位，不过绝对或固定元素会生成一个块级框，而不论该元素本身是什么类型。相对定位元素会相对于它在正常流中的默认位置偏移。默认值static。元素的位置通过 “left”, “top”, “right” 以及 “bottom” 属性进行规定。 值 描述 absolute 生成绝对定位的元素，相对于 static 定位以外的第一个父元素进行定位。 fixed 生成绝对定位的元素，相对于浏览器窗口进行定位。 relative 生成相对定位的元素，相对于其正常位置进行定位。 static 默认值。没有定位，元素出现在正常的流中（忽略 top, bottom, left, right 或者 z-index 声明）。 inherit 规定应该从父元素继承 position 属性的值。 相对定位相对定位设置了，但不设置偏移量则也没有效果相对定位是相对于元素在文档流原来的位置进行定位相对定位不会脱离文档流相对定位会使得元素提升一个层级相对定位不会改变元素的性质，块元素依然是块元素。内联依然也依然是内联。 123456789101112131415161718192021222324252627282930313233&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;&lt;/title&gt; &lt;style type="text/css"&gt; .box1 &#123; width: 200px; height: 200px; background-color: yellow; &#125; .box2 &#123; width: 200px; height: 200px; background-color: green; position: relative; left: 100px; top: 100px; &#125; .box3 &#123; width: 200px; height: 200px; background-color: blue; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="box1"&gt;&lt;/div&gt; &lt;div class="box2"&gt;&lt;/div&gt; &lt;!-- 相对于原来box2的位置进行偏移向右100像素，向下100像素 --&gt; &lt;div class="box3"&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 绝对定位开启绝对定位会使元素脱离文档流绝对定位是相当于离它最近的开启了定位的祖先元素进行定位的如果所有的祖先元素都没有开启定位，则相对于浏览器窗口进行定位绝对定位会使得元素提升一个层级并改变元素的性质 如果祖先元素没有任何一个开启了定位，则是相对于浏览器窗口进行定位 12345678910111213141516171819202122232425262728293031323334353637383940&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;&lt;/title&gt; &lt;style type="text/css"&gt; .box1 &#123; width: 200px; height: 200px; background-color: yellow; &#125; .box2 &#123; width: 200px; height: 200px; background-color: green; &#125; .box3 &#123; width: 200px; height: 200px; background-color: blue; &#125; .box4 &#123; width: 100px; height: 100px; background-color: black; position: absolute; left: 0; top: 0; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="box1"&gt;&lt;/div&gt; &lt;div class="box2"&gt; &lt;div class="box4"&gt;&lt;/div&gt; &lt;!-- 祖先元素都没有开启定位，则box4的原点位置则是浏览器左上角 --&gt; &lt;/div&gt; &lt;div class="box3"&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 开启box2元素的定位，则box4原点的位置发生改变 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;&lt;/title&gt; &lt;style type="text/css"&gt; .box1 &#123; width: 200px; height: 200px; background-color: yellow; &#125; .box2 &#123; width: 200px; height: 200px; background-color: green; position: relative; &#125; .box3 &#123; width: 200px; height: 200px; background-color: blue; &#125; .box4 &#123; width: 100px; height: 100px; background-color: black; position: absolute; left: 0; top: 0; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="box1"&gt;&lt;/div&gt; &lt;div class="box2"&gt; &lt;div class="box4"&gt;&lt;/div&gt; &lt;!-- 最近的祖先元素box2开启了定位，则原点位置发生了改变，为box2块元素的左上角 --&gt; &lt;/div&gt; &lt;div class="box3"&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 一般情况自元素开启绝对定位，则父元素会开启相对定位 固定定位固定定位也是绝对定位的一种，大部分特点和绝对定位一样。但是它永远都相对于浏览器窗口进行定位，不管父元素到底有没有开启定位。而且只会固定在浏览器窗口的位置，不会因为其他因素（滚动条等）而改变元素位置。 1234567891011121314151617181920212223&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;&lt;/title&gt; &lt;style type="text/css"&gt; body &#123; height: 5000px; &#125; .box &#123; height: 500px; width: 80px; position: fixed; background-color: yellow; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="box"&gt;&lt;/div&gt; &lt;!-- 固定定位该元素不会因为浏览器页面滚动而发生位置的改变 --&gt; &lt;p&gt;看看我有没有滚动啊啊啊啊啊啊啊啊啊啊啊&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 应用可以用于底部的返回，导航漂浮菜单 元素层级如果定位元素处于相同层级，则后面的元素会盖住前面的元素（结构上） 也可以通过z-index来修改元素层级，但是没有开启定位的元素不起作用。 父元素的层级就算比子元素高，但是也不会盖住子元素。 1234567891011121314151617181920&lt;html&gt;&lt;head&gt;&lt;style type="text/css"&gt;img.x&#123;position:absolute;left:0px;top:0px;z-index:-1&#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;这是一个标题&lt;/h1&gt;&lt;img class="x" src="/i/eg_mouse.jpg" /&gt; &lt;p&gt;默认的 z-index 是 0。Z-index -1 拥有更低的优先级。&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; opacityopacity 属性设置元素的不透明级别。值为0-1区间。0表示完全透明，1是完全不透明。 在IE8以及以下不支持，需要支持则使用如下属性代替，filter滤镜，值为alpha(opacity=50),区间0-100,相当于opacity=0.5 123456789101112131415161718192021&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;style&gt; body &#123;background-color:yellow;&#125;div&#123;background-color:red;opacity:0.5;filter:Alpha(opacity=50); /* IE8 以及更早的浏览器 */&#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div&gt;本元素的不透明度是 0.5。请注意，文本和背景色都受到不透明级别的影响。&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 背景background 简写属性在一个声明中设置所有的背景属性。 可以设置如下属性： background-color 规定要使用的背景颜色。 background-position 规定背景图像的位置。 background-size 规定背景图片的尺寸。 background-repeat 规定如何重复背景图像。 background-origin 规定背景图片的定位区域。 background-clip 规定背景的绘制区域。 background-attachment 规定背景图像是否固定或者随着页面的其余部分滚动。 background-image 规定要使用的背景图像。 简写属性：没有顺序，也没有规定有多少个值。background: #00FF00 url(bgimage.gif) no-repeat fixed top; IE8 以及更早的浏览器不支持一个元素多个背景图像。IE7 以及更早的浏览器不支持 “inherit”。IE8 需要 !DOCTYPE。IE9 支持 “inherit”。 IE6不支持PNG24在IE6中对图片格式为PNG24的支持度不高，解决方式 将png转为png-8格式即可，但是清晰度会有一点损失。 使用JS第三方库ie6_png 按钮背景闪烁有一个按钮，按钮的状态分别设置了三个背景，上代码 1234567891011121314151617181920212223&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;&lt;/title&gt; &lt;style type="text/css"&gt; .btn &#123; display: block; width: 93px; height: 29px; background: url('img/link.png'); &#125; .btn:hover &#123; background: url('img/hover.png'); &#125; .btn:active &#123; background: url('img/active.png'); &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;a class="btn"&gt;&lt;/a&gt;&lt;/body&gt;&lt;/html&gt; 造成原因：浏览器外部资源不是同时加载，而是资源被使用才会去加载资源，而上述的例子中，link.png被加载了，但是hover和active下状态没有马上触发，所以没有加载该资源图片，当状态被触发的时候该状态的图片才会加载，但是加载图片并不是立刻能够完成的，所以在加载的过程中有一段时间，背景图片无法显示，造成了背景闪烁。为了解决将图片整合成一张图片，利用background-position来分别显示各自的位置，这种图片又称精灵图/雪碧图。 解决方法:123456789101112131415161718192021222324252627&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;&lt;/title&gt; &lt;style type="text/css"&gt; .btn &#123; display: block; width: 93px; height: 29px; background: url('img/btn.png'); &#125; .btn:hover &#123; background: url('img/btn.png'); background-position: 93px 0; &#125; .btn:active &#123; background: url('img/btn.png'); background-position: 186px 0; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;a class="btn"&gt;&lt;/a&gt;&lt;/body&gt;&lt;/html&gt; CSS精灵图/雪碧图CSS Sprite(CSS 精灵), 也称作 雪碧图。 将导航背景图片，按钮背景图片等有规则的合并成一张背景图，即将多张图片合为一张整图，然后用background-position”来实现背景图片的定位技术。 优势 通过图片整合来减少对服务器的请求次数，从而提高 页面的加载速度 通过整合图片来减小图片的体积 图片整合原则： 边切图边整合 定位时避免使用bottom,right等，用具体的数值，为了避免当你的宽度或高度上扩展sprites图时出现位置的错误 将小图标预留足够的空间，因为使用这些图标元素通常会有大量的内容而且可能需要扩展的间距，以至于其它的图片可能会意外出现在本区域内。一般的情况下，会将这些小图标整合到文件的最右侧 单张整合好的sprite图片在100KB以内 按分类整合图片 为了方便计算尺寸，一般情况会将sprites图的坐标计算成整数倍 表格简单用法不介绍了。table标签，tr行标签，td单元格标签，th表头标签。 去除table与td的距离通过border-spacing属性设置这个距离。 表格边框合并通过border-collapse设置为collapse即可，一旦设置border-spacing自动失效。 长表格有一些情况下，表格是非常长的，则这时候需要将表格分为三个部分表头，表主体，表底部。则html提供了三个标签thead,tbody,tfoot来分别表示进行区分。作用就是区分表格的不同部分。如果表格没有写tbody标签，则浏览器会默认添加一个tbody。 CSS Hack有一些特殊情况，，有一些代码只需要运行在特定的浏览器（IE6等），则可以使用CSS Hack来解决，这段代码只在某些浏览器中识别，而其他浏览器等不会识别。 以下列举的只是一小部分，像火狐等浏览器都有自己的HACK，但是相对于一般用于IE更广法。 不到万不得已的情况尽量不要使用 条件Hack用于选择IE浏览器及IE的不同版本if条件Hack是HTML级别的（包含但不仅是CSS的Hack，可以选择任何HTML代码块） 仅对IE10以下有效，其余浏览器解析为html注释。 判断IE123&lt;!--[if IE]&gt; ...&lt;![endif]--&gt; 判断IE6123&lt;!--[if IE 6]&gt; ...&lt;![endif]--&gt; 判断IE9以下（但不包括IE9）123&lt;!--[if lt IE 9]&gt; ...&lt;![endif]--&gt; lt为小于，lte为小于等于，gt为大于，gte为大于等于，!为选择指定版本外的所有IE版本(非) 属性Hack选择不同的浏览器及版本尽可能减少对CSS Hack的使用。Hack有风险，使用需谨慎通常如未作特别说明，本文档所有的代码和示例的默认运行环境都为标准模式。一些CSS Hack由于浏览器存在交叉认识，所以需要通过层层覆盖的方式来实现对不同浏览器进行Hack的。如下面这个例子： 123456789101112_：选择IE6及以下。连接线（中划线）（-）亦可使用，为了避免与某些带中划线的属性混淆，所以使用下划线（_）更为合适。*：选择IE7及以下。诸如：（+）与（#）之类的均可使用，不过业界对（*）的认知度更高\9：选择IE6+\0：选择IE8+和Opera[;property:value;];：选择webkit核心浏览器（Chrome,Safari）。IE7及以下也能识别。中括号内外的3个分号必须保留，第一个分号前可以是任意规则或任意多个规则[;color:#f00;]; 与 [color:#f00;color:#f00;]; 与 [margin:0;padding:0;color:#f00;]; 是等价的。生效的始终是中括号内的最后一条规则，所以通常选用第一种写法最为简洁 案例代码：123456789101112131415161718192021&lt;!DOCTYPE html&gt;&lt;html lang="zh-cn"&gt;&lt;head&gt;&lt;meta charset="utf-8" /&gt;&lt;title&gt;属性级Hack_CSS参考手册_web前端开发参考手册系列&lt;/title&gt;&lt;style&gt;h1&#123;margin:10px 0;font-size:16px;&#125;.test&#123; color:#c30; /* For Firefox */ [;color:#ddd;]; /* For webkit(Chrome and Safari) */ color:#090\0; /* For Opera */ color:#00f\9; /* For IE8+ */ *color:#f00; /* For IE7 */ _color:#ff0; /* For IE6 */&#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div class="test"&gt;在不同浏览器下看看我的颜色吧&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 选择符Hack选择不同的浏览器及版本尽可能减少对CSS Hack的使用。Hack有风险，使用需谨慎通常如未作特别说明，本文档所有的代码和示例的默认运行环境都为标准模式。一些CSS Hack由于浏览器存在交叉认识，所以需要通过层层覆盖的方式来实现对不同浏览器进行Hack的。 用得比较少 1234* html .test&#123;color:#090;&#125; /* For IE6 and earlier */* + html .test&#123;color:#ff0;&#125; /* For IE7 */.test:lang(zh-cn)&#123;color:#f00;&#125; /* For IE8+ and not IE */.test:nth-child(1)&#123;color:#0ff;&#125; /* For IE9+ and not IE */ 参考链接http://www.w3school.com.cn/css]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mac关闭/开启独立显卡]]></title>
    <url>%2F2019%2F03%2F19%2FMac%E5%85%B3%E9%97%AD-%E5%BC%80%E5%90%AF%E7%8B%AC%E7%AB%8B%E6%98%BE%E5%8D%A1%2F</url>
    <content type="text"><![CDATA[本人使用的是2018款15寸的Mbp，每次用迅雷播放器观看总是自动帮我切换到独立显卡，功耗和发热实在是太严重了，所以想单独仅使用集成显卡。 普通的界面中只找到了自动切换模式在设置-节能选项卡中可以找到。 而想单独使用，则终端使用命令123456#强制使用核显(集成显卡)$ sudo pmset -a GPUSwitch 0#强制使用独立显卡$ sudo pmset -a GPUSwitch 1#自动切换$ sudo pmset -a GPUSwitch 2 自由选择切换即可。 或者使用一个gfxCardStatus软件也可实现，但未经尝试。命令更方便。]]></content>
      <categories>
        <category>程序人生</category>
      </categories>
      <tags>
        <tag>Mac</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP预定义变量]]></title>
    <url>%2F2019%2F03%2F19%2FPHP%E9%A2%84%E5%AE%9A%E4%B9%89%E5%8F%98%E9%87%8F%2F</url>
    <content type="text"><![CDATA[PHP预定义变量对于全部脚本而言，PHP 提供了大量的预定义变量。这些变量将所有的外部变量表示成内建环境变量，并且将错误信息表示成返回头。 超全局变量 — 超全局变量是在全部作用域中始终可用的内置变量 $GLOBALS — 引用全局作用域中可用的全部变量 $_SERVER — 服务器和执行环境信息 $_GET — HTTP GET 变量 $_POST — HTTP POST 变量 $_FILES — HTTP 文件上传变量 $_REQUEST — HTTP Request 变量 $_SESSION — Session 变量 $_ENV — 环境变量 $_COOKIE — HTTP Cookies $php_errormsg — 前一个错误信息 $HTTP_RAW_POST_DATA — 原生POST数据 $http_response_header — HTTP 响应头 $argc — 传递给脚本的参数数目 $argv — 传递给脚本的参数数组 参考资料 https://secure.php.net/manual/zh/reserved.variables.php]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mac缺少freetype解决方案]]></title>
    <url>%2F2019%2F03%2F19%2FMac%E7%BC%BA%E5%B0%91freetype%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%2F</url>
    <content type="text"><![CDATA[环境Mac OS X 10.14.3 问题最近在使用thinkphp的验证码模块时，出现了一个异常Call to undefined function think\captcha\imagettftext()没有imagettftext()这个函数，原因是因为php缺少gd库中的freetype模块导致的。 知道了原因后，查询了网上大致的方法，大概这么几种 重新编译PHP 用brew重新安装新的PHP https://php-osx.liip.ch 一句话脚本 在尝试了很多遍后，都没有成功。有一篇文章讲到了这些方案比较过时，在Macos10.14版本下更改了安全策略，新增了Rootless机制，具体请看我博客中另一篇文章关于Rootless的介绍。 解决方案一（便携）使用第三方集成环境例如MAMP,MAMP PRO,XAMPP等 方案二（推荐）首先关闭Rootless关闭步骤1231、重启 Mac 并按住 Command+R，进入恢复模式2、打开终端 Terminal3、输入csrutil disable 开启步骤 1231、重启 Mac 并按住 Command+R，进入恢复模式2、打开终端 Terminal3、输入csrutil enable 重新brew安装php这里我试过关闭rootless后使用一句话脚本也没有办法安装成功。也试过一些网上的方案例如1$ brew install php56 --with-apche --with-freetype 但是运行出现Error: invalid option: --with-apche此错误，寻思没有解决办法。 成功的方案 1$ brew install php@7.1 --build-from-source 记住添加--build-from-source参数 php 版本可自行通过brew search php来查看需要安装所需，运行后出现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697==&gt; Installing dependencies for php@7.1: pkg-config==&gt; Installing php@7.1 dependency: pkg-config==&gt; Downloading https://homebrew.bintray.com/bottles/pkg-config-0.29.2.mojave.bo######################################################################## 100.0%==&gt; Pouring pkg-config-0.29.2.mojave.bottle.tar.gz🍺 /usr/local/Cellar/pkg-config/0.29.2: 11 files, 627.2KB==&gt; Installing php@7.1==&gt; Downloading https://php.net/get/php-7.1.26.tar.xz/from/this/mirror==&gt; Downloading from https://secure.php.net/distributions/php-7.1.26.tar.xz # # # # -=O=- ==&gt; Patchingpatching file acinclude.m4Hunk #1 succeeded at 444 (offset 3 lines).Hunk #2 succeeded at 459 (offset 3 lines).Hunk #3 succeeded at 494 (offset 3 lines).Hunk #4 succeeded at 506 (offset 3 lines).Hunk #5 succeeded at 2507 (offset 88 lines).==&gt; ./buildconf --force==&gt; ./configure --prefix=/usr/local/Cellar/php@7.1/7.1.26 --localstatedir=/usr/l==&gt; make==&gt; make install==&gt; /usr/local/Cellar/php@7.1/7.1.26/bin/pear config-set php_ini /usr/local/etc/==&gt; /usr/local/Cellar/php@7.1/7.1.26/bin/pear config-set php_dir /usr/local/shar==&gt; /usr/local/Cellar/php@7.1/7.1.26/bin/pear config-set doc_dir /usr/local/shar==&gt; /usr/local/Cellar/php@7.1/7.1.26/bin/pear config-set ext_dir /usr/local/lib/==&gt; /usr/local/Cellar/php@7.1/7.1.26/bin/pear config-set bin_dir /usr/local/opt/==&gt; /usr/local/Cellar/php@7.1/7.1.26/bin/pear config-set data_dir /usr/local/sha==&gt; /usr/local/Cellar/php@7.1/7.1.26/bin/pear config-set cfg_dir /usr/local/shar==&gt; /usr/local/Cellar/php@7.1/7.1.26/bin/pear config-set www_dir /usr/local/shar==&gt; /usr/local/Cellar/php@7.1/7.1.26/bin/pear config-set man_dir /usr/local/shar==&gt; /usr/local/Cellar/php@7.1/7.1.26/bin/pear config-set test_dir /usr/local/sha==&gt; /usr/local/Cellar/php@7.1/7.1.26/bin/pear config-set php_bin /usr/local/opt/==&gt; /usr/local/Cellar/php@7.1/7.1.26/bin/pear update-channels==&gt; CaveatsTo enable PHP in Apache add the following to httpd.conf and restart Apache: LoadModule php7_module /usr/local/opt/php@7.1/lib/httpd/modules/libphp7.so &lt;FilesMatch \.php$&gt; SetHandler application/x-httpd-php &lt;/FilesMatch&gt;Finally, check DirectoryIndex includes index.php DirectoryIndex index.php index.htmlThe php.ini and php-fpm.ini file can be found in: /usr/local/etc/php/7.1/php@7.1 is keg-only, which means it was not symlinked into /usr/local,because this is an alternate version of another formula.If you need to have php@7.1 first in your PATH run: echo 'export PATH="/usr/local/opt/php@7.1/bin:$PATH"' &gt;&gt; ~/.bash_profile echo 'export PATH="/usr/local/opt/php@7.1/sbin:$PATH"' &gt;&gt; ~/.bash_profileFor compilers to find php@7.1 you may need to set: export LDFLAGS="-L/usr/local/opt/php@7.1/lib" export CPPFLAGS="-I/usr/local/opt/php@7.1/include"To have launchd start php@7.1 now and restart at login: brew services start php@7.1Or, if you don't want/need a background service you can just run: php-fpm==&gt; Summary🍺 /usr/local/Cellar/php@7.1/7.1.26: 508 files, 63MB, built in 5 minutes 46 seconds==&gt; Caveats==&gt; php@7.1To enable PHP in Apache add the following to httpd.conf and restart Apache: LoadModule php7_module /usr/local/opt/php@7.1/lib/httpd/modules/libphp7.so &lt;FilesMatch \.php$&gt; SetHandler application/x-httpd-php &lt;/FilesMatch&gt;Finally, check DirectoryIndex includes index.php DirectoryIndex index.php index.htmlThe php.ini and php-fpm.ini file can be found in: /usr/local/etc/php/7.1/php@7.1 is keg-only, which means it was not symlinked into /usr/local,because this is an alternate version of another formula.If you need to have php@7.1 first in your PATH run: echo 'export PATH="/usr/local/opt/php@7.1/bin:$PATH"' &gt;&gt; ~/.bash_profile echo 'export PATH="/usr/local/opt/php@7.1/sbin:$PATH"' &gt;&gt; ~/.bash_profileFor compilers to find php@7.1 you may need to set: export LDFLAGS="-L/usr/local/opt/php@7.1/lib" export CPPFLAGS="-I/usr/local/opt/php@7.1/include"To have launchd start php@7.1 now and restart at login: brew services start php@7.1Or, if you don't want/need a background service you can just run: php-fpm 主要查看后面的提示信息并配置环境12$ echo 'export PATH="/usr/local/opt/php@7.1/bin:$PATH"' &gt;&gt; ~/.bash_profile$ echo 'export PATH="/usr/local/opt/php@7.1/sbin:$PATH"' &gt;&gt; ~/.bash_profile 然后source ~/.bash_profire 再次重新运行thinkphp中的验证码模块，实验成功 参考资料https://blog.csdn.net/leiflyy/article/details/53016769 https://blog.csdn.net/liaobangxiang/article/details/79460290 https://github.com/EricLi404/notes/issues/1 https://stackoverflow.com/questions/50259893/home-brew-php-7-2-5-install-with-curl https://hackycy.github.io/2019/03/19/Mac-OS-X-10-11-Rootless-介绍]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>环境搭建</tag>
        <tag>Mac</tag>
        <tag>Homebrew</tag>
        <tag>PHP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mac OS X 10.11+ Rootless 介绍]]></title>
    <url>%2F2019%2F03%2F19%2FMac-OS-X-10-11-Rootless-%E4%BB%8B%E7%BB%8D%2F</url>
    <content type="text"><![CDATA[RootlessMac OS X 10.11+ (El Capitan) 以后，引入了 Rootless 安全机制，该机制限制了 root 用户的权限，有部分操作即使是 root 也无法执行。在搭建php环境时遇到了这个，所以记录了下来。 该机制的详细介绍，请参考：Wikipedia: System Integrity ProtectionApple: System Integrity Protection Guide 主要限制有：以下目录无法修改：/System, /bin, /sbin, 或者 /usr (/usr/local 除外)，以及内置 App 和系统工具 Utilities。具体的限制名单在 /System/Library/Sandbox/rootless.conf 文件中有定义，该文件行首的 * 表示该行记录不在限制之列无法追踪调试系统进程无法加载未经验证的内核扩展 可能引起的问题和解决方案 修改受限制的文件或文件夹 123sudo cp -f FILE /usr/bin/# 报错： cp: /usr/bin/FILE: Operation not permitted 执行部分命令受挫 123456sudo gem install posix-spawn -v '0.3.11'# 报错：Building native extensions. This could take a while...ERROR: While executing gem ... (Errno::EPERM) Operation not permitted - /usr/bin/posix-spawn-benchmark 关闭/开启Rootless如果遇到的问题难以解决，也可以关闭 rootless 功能，彻底解决引起的权限问题，但是关闭 rootless 将会严重降低系统安全性，必须尽快重新开启。 关闭1、重启 Mac 并按住 Command+R，进入恢复模式2、打开终端 Terminal3、输入csrutil disable 开启1、重启 Mac 并按住 Command+R，进入恢复模式2、打开终端 Terminal3、输入csrutil enable]]></content>
      <categories>
        <category>程序人生</category>
      </categories>
      <tags>
        <tag>Mac</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo博客Next主题不蒜子失效解决]]></title>
    <url>%2F2019%2F03%2F17%2Fhexo%E5%8D%9A%E5%AE%A2Next%E4%B8%BB%E9%A2%98%E4%B8%8D%E8%92%9C%E5%AD%90%E5%A4%B1%E6%95%88%E8%A7%A3%E5%86%B3%2F</url>
    <content type="text"><![CDATA[2018年底发现不蒜子开始失效，但是没有管，现在看了官网 原因官网解释：因七牛强制过期『dn-lbstatics.qbox.me』域名，与客服沟通无果，只能更换域名到『busuanzi.ibruce.info』！ 解决方案直接根据提示替换即可 替换路径themes/next/layout/_third-party/analytics/busuanzi-counter.swig，打开文件 找到&lt;script async src=&quot;https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js&quot;&gt;&lt;/script&gt;替换&lt;script async src=&quot;//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js&quot;&gt;&lt;/script&gt;]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP之魔术常量]]></title>
    <url>%2F2019%2F03%2F14%2FPHP%E4%B9%8B%E9%AD%94%E6%9C%AF%E5%B8%B8%E9%87%8F%2F</url>
    <content type="text"><![CDATA[魔术常量PHP 向它运行的任何脚本提供了大量的预定义常量。不过很多常量都是由不同的扩展库定义的，只有在加载了这些扩展库时才会出现，或者动态加载后，或者在编译时已经包括进去了。 有八个魔术常量它们的值随着它们在代码中的位置改变而改变。例如 __LINE__的值就依赖于它在脚本中所处的行来决定。这些特殊的常量不区分大小写，如下： 几个php的魔术常量 名称 说明 LINE 文件中的当前行号 FILE 文件的完整路径和文件名。如果用在被包含文件中，则返回被包含的文件名。自PHP4.0.2起，FILE总是包含一个绝对路径（如果是符号连接，则是解析后的绝对路径），而在此之前的版本有时会包含一个相对路径。 DIR 文件所在的目录。如果用在被包含的文件中，则返回被包含的文件所在的目录，它等价于dirname(_FILE)。除非是根目录，否则目录名不包括末尾的斜杠。（PHP5.3.0中新增）。 FUNCTION 函数名称（PHP 4.3.0 新加）。自 PHP 5 起本常量返回该函数被定义时的名字（区分大小写）。在 PHP 4 中该值总是小写字母的。 CLASS 类的名称（PHP 4.3.0 新加）。自 PHP 5 起本常量返回该类被定义时的名字（区分大小写）。在 PHP 4 中该值总是小写字母的。类名包括其被声明的作用区域（例如 Foo\Bar）。注意自 PHP 5.4 起 CLASS 对 trait 也起作用。当用在 trait 方法中时，CLASS 是调用 trait 方法的类的名字。 TRAIT Trait 的名字（PHP 5.4.0 新加）。自 PHP 5.4 起此常量返回 trait 被定义时的名字（区分大小写）。Trait 名包括其被声明的作用区域（例如 Foo\Bar）。 METHOD 类的方法名（PHP 5.0.0 新加）。返回该方法被定义时的名字（区分大小写）。 NAMESPACE 当前命名空间的名称（区分大小写）。此常量是在编译时定义的（PHP 5.3.0 新增）。 参考资料https://secure.php.net/manual/zh/language.constants.predefined.php]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Js高级-面向对象]]></title>
    <url>%2F2019%2F03%2F11%2FJs%E9%AB%98%E7%BA%A7-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%2F</url>
    <content type="text"><![CDATA[JS基本介绍 JS的用途：Javascript可以实现浏览器端、服务器端(nodejs)。。。 浏览器端JS由以下三个部分组成： ECMAScript：基础语法(数据类型、运算符、函数。。。) BOM(浏览器对象模型)：window、location、history、navigator。。。 DOM(文档对象模型)：div、p、span。。。 ECMAScript又名es，有以下重大版本： 旧时代： es1.0。。。es3.1 新时代： es5 es6(es2015) es7(es2016)、es8(es2017) Js基本数据类型和复杂数据类型一句总结，使用排除法，除掉基本数据类型都是复杂数据类型即字符串、数字、布尔值、null、undefined其余都是对象类型。复杂数据类型例如Date、Array等。 对象的基本使用12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;script type="text/javascript"&gt; //创建对象 var person = &#123; name : "张三", age : 18, say : function()&#123; console.log('i am from china'); &#125; &#125;; //获取属性 console.log(person.name); console.log(person.age); person.say(); //设置属性 person.address = "中国广东广州"; console.log(person.address); //清除属性 delete person.address; delete person.adc //无意义,但是也不会报错 console.log(person.address); //delete只能删除对象的属性,而不能删除变量 //清空对象 person=&#123;&#125;; //将person变为null person = null; //两者意义不一样 &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 输出123张三18i am from china 对象是键值对的集合：对象是由属性和方法构成的 (ps：也有说法为：对象里面皆属性，认为方法也是一个属性) name是属性 age是属性 say是方法 获取属性的方式.语法 person.age获取age属性 person.say获取到一个方法 []语法 person[&quot;name&quot;]等价于person.age person[&quot;say&quot;]等价于person.say 2种方式的差异： .语法更方便，但是坑比较多(有局限性)，比如： .后面不能使用js中的关键字、保留字(class、this、function。。。) .后面不能使用数字123var obj=&#123;&#125;;obj.this=5; //语法错误obj.0=10; //语法错误 []使用更广泛 o1[变量name] [“class”]、[“this”]都可以随意使用 obj[&quot;this&quot;]=10 [0]、[1]、[2]也可以使用 obj[3]=50 = obj[&quot;3&quot;]=50 思考：为什么obj[3]=obj[“3”] 甚至还可以这样用：[“[object Array]”] jquery里面就有这样的实现 也可以这样用：[“{abc}”] 给对象添加了{abc}属性 设置属性 student[&quot;gender&quot;]=&quot;男&quot; 等价于： student.gender=&quot;男&quot; 含义：如果student对象中没有gender属性，就添加一个gender属性，值为”男” 如果student对象中有gender属性，就修改gender属性的值为”男” 案例1：student.isFemale=true 案例2：student[&quot;children&quot;]=[1,2,5] 案例3：123student.toShanghai=function()&#123; console.log("正在去往上海的路上") &#125; 删除属性 delete student[“gender”] delete student.gender 构造函数概念12345678&lt;script type="text/javascript"&gt; function Person(name, age)&#123; this.name = name; this.age = age; &#125; var person = new Person('张三', 40); console.log(person);&lt;/script&gt; person就是根据【Person构造函数】创建出来的对象 任何函数都可以当成构造函数 例如function CreateFunc(){ } 只要把一个函数通过new的方式来进行调用，我们就把这一次函数的调用方式称之为：构造函数的调用 new CreateFunc(); 此时CreateFunc就是一个构造函数 CreateFunc(); 此时的CreateFunc并不是构造函数 关于new Object()，new Object()等同于对象字面量{} 构造函数的执行过程var person = new Person() 创建一个对象，称之为这个Person构造函数的实例，p1 创建一个内部对象，this，将this指向该实例 执行函数内部的代码，其中，操作this的部分就是操作了该实例 返回值 如果函数没有返回值，没有return语句，那么就会返回构造函数的实例p1 如果函数返回了一个基本数据类型的值，那么就会返回本次构造函数的实例p1 如果函数返回了一个复杂数据类型的值，那么本次函数的返回值就是该值。 12345678910111213141516171819function fn()&#123; &#125;var f1=new fn(); //f1就是fn的实例function fn2()&#123; return "abc";&#125;var f2=new fn2(); //f2是fn2构造函数的实例function fn3()&#123; return [1,3,5]; //数组是一个对象类型的值， //所以数组是一个复杂数据类型的值 //--&gt;本次构造函数的真正返回值就是该数组 //--&gt;不再是fn3构造函数的实例&#125;var f3=new fn3(); //f3还是fn3的实例吗？错//f3值为[1,3,5] JS中的继承JS中的继承和其他语言不太一样。JS中的继承是你可以通过某种方式让某个对象访问到其他对象中的属性、方法，那么这种方式就可以称之为继承。而并不是简单的所谓的Xxx extends Parent 为什么要使用继承 有些对象会有方法(动作、行为)，而这些方法都是函数，如果把这些方法和函数都放在构造函数中声明就会导致内存的浪费12345678function Person()&#123; this.say=function()&#123; console.log("你好") &#125;&#125;var p1=new Person();var p2=new Person();console.log(p1.say === p2.say); //false 继承的方式原型链继承原型链继承第一种方式123Person.prototype.say = function()&#123; console.log('hello'); &#125; 当然这样写没有问题，但是方法一旦过多，代码的冗余将会非常的多。 原型链继承第二种方式123456789Person.prototype = &#123; constructor:Person, say:function()&#123; console.log('hello'); &#125;, run:function()&#123; console.log('running'); &#125; &#125; 注意：1、一般情况下，应该先改变原型对象，再创建对象。2、对于新原型，一般会添加一个constructor属性，从而不破坏原来的原型对象结构。 拷贝继承（也称混入继承：mixin）场景：有时候想使用某个对象中的属性，但是又不想直接破坏它，于是就可以创建这个对象的拷贝类似于jQuery中的$.extend，编写Jquery插件的必经之路 来看一个例子12345678910111213var o1 = &#123; age : 1 &#125; var o2 = o1; o2.age = 18; console.log(o1.age); //结果输出18 //1、修改了o2对象的age属性 //2、由于o2对象跟o1对象是同一个对象 //3、所以此时o1对象的age属性也被修改了 这里涉及到一个知识点深拷贝和浅拷贝， 深拷贝只是拷贝一层属性，没有内部对象 深拷贝其实是利用了递归的原理，将对象的若干层属性拷贝出来。 上述例子中只是一个浅拷贝。 那么什么场景下适合使用拷贝继承12345678910var o3 = &#123; gender : '男', grade : '初三', name : '张三'&#125;var o4 = &#123; gender : '男', grade : '初三', name : '李四'&#125; 实现11234567891011var o3 = &#123; gender : '男', grade : '初三', name : '张三' &#125; var cp = &#123;&#125;; cp.gender = o3.gender; cp.grade = o3.gender; cp.name = o3.name; console.log(cp); //&#123;gender: "男", grade: "男", name: "张三"&#125; 这样的方式可以说在开发中就是写死的，毫无重用性。 实现21234567891011121314var o3 = &#123; gender : '男', grade : '初三', name : '张三' &#125;function extend(target,source)&#123; for(key in source) &#123; target[key] = source[key]; &#125; return target; &#125; var target = &#123;&#125;; extend(target, o3); console.log(target); //&#123;gender: "男", grade: "初三", name: "张三"&#125; 如果很多时候需要用到拷贝继承，无疑封装成一个函数来进行复用是很好的。 在es6中也有了对象扩展运算符，仿佛就是为了拷贝继承而生的:123456789var o3 = &#123; gender : '男', grade : '初三', name : '张三' &#125; var target = &#123; ...o3 &#125;; console.log(target);//&#123;gender: "男", grade: "初三", name: "张三"&#125; var target2 = &#123; ...o3, age:20 &#125;; console.log(target2);//&#123;gender: "男", grade: "初三", name: "张三", age: 20&#125; 可以说简单到令人发指的操作，当然也会存在兼容问题啦，这里不涉及es6，单纯扯一下。 原型式继承（道格拉斯在蝴蝶书中提出的） 使用场景 可以创建一个纯洁的对象，对象中什么属性都没有 创建一个继承自某个父对象的字对象 12345678910111213//创建空对象var o1 = Object.create(null);console.log(o1); //&#123;&#125;console.log(o1.__proto__) //undefined//继承父对象var parent = &#123; age : 50, name : "爸爸"&#125;var s1 = Object.create(parent);console.log(s1); //&#123;&#125;console.log(s1.__proto__); //&#123;age: 50, name: "爸爸"&#125; 可以看得出一些区别，所谓的纯洁对象，真的很纯。这个使用也很方便。 借用构造函数继承场景：适用于2种构造函数之间有相似的逻辑的情况。原理：函数的call、apply调用方式（函数的调用方式在另一篇文章） 场景举例：1234567891011121314function Animal(name,age,gender)&#123; this.name=name; this.age=age; this.gender=gender;&#125;function Person(name,age,gender,say)&#123; this.name=name; this.age=age; this.gender=gender; this.say=function()&#123; &#125;&#125; 局限性：Animal（父类的构造函数）的构造函数必须完全适用于Person（子类的构造函数） 借用构造函数实现1234567891011121314151617181920function Animal(name,age)&#123; this.name=name; this.age=age;&#125;function Person(name,age,say)&#123; // this.name=name; // this.age=age; // this.gender=gender; Animal.apply(this, [name, age]); //等同与下面语句 //Animal.call(this, name, age); this.say=function()&#123; &#125;&#125;console.log(new Person('张三', 18, function()&#123; console.log('say');&#125;)) //&#123;name: "张三", age: 18, say: ƒ&#125; and so on还有寄生继承，寄生组合继承，这里举例出以上几条常用的，其余这里就不再一一细数了。 原型链概念：JS中的对象可能会有父对象，父对象中可能还会有父对象，就是祖宗十九代了。根本：继承 - 属性：对象中几乎都会有一个`__proto`的一个属性，指向他的父对象 - 意义，可以访问到父对象中的相关属性和方法 根对象：Object.prototype 123456function Animal()&#123;&#125;var cat = new Animal();console.log(cat.__proto__); //等同于 Animal.prototypeconsole.log(cat.__proto__.__proto__);//等同于 Object.prototype 变量作用域概念：就是一个变量可以使用的范围。 最外层作用域：全局作用域 通过函数创建出一个独立的作用域，其中函数还可以嵌套，所以作用域也可以嵌套。 作用域链 由于作用域是相对于变量而言的，而如果存在多级作用域，这个变量又来自于哪里？这个问题就需要好好地探究一下了，我们把这个变量的查找过程称之为变量的作用域链 作用域链的意义：查找变量（确定变量来自于哪里，变量是否可以访问） 简单来说，作用域链可以用以下几句话来概括：(或者说：确定一个变量来自于哪个作用域) 查看当前作用域，如果当前作用域声明了这个变量，就确定结果 查找当前作用域的上级作用域，也就是当前函数的上级函数，看看上级函数中有没有声明 再查找上级函数的上级函数，直到全局作用域为止 如果全局作用域中也没有，我们就认为这个变量未声明(xxx is not defined) 例子1：1234567891011121314var age = 10; //全局变量 (function log()&#123; console.log(age); //可访问 var name = "zhangsan"; console.log(name); //可访问 &#125;)(); console.log(name); //不能访问 console.log(age); //可访问 例子2：12345678910var gender = "男";var f = (function()&#123; console.log(gender); //可以访问 return function() &#123; console.log(gender); //可以访问 &#125; var age = 10;&#125;)();f(); 闭包一个经典的例子1234567891011function fn()&#123; var a = 1; return function()&#123; a++; console.log(a); &#125; &#125; var f = fn(); f(); //2 f(); //3 f(); //4 可以看出a的输出并没有一直输出3，而是2、3、4，而产生的原因是因为fn函数执行完毕后，匿名函数的引用导致没有释放a变量，而作用域中保留了最新的a变量的值，闭包问题就产生了。 闭包不仅仅只是说要返回一个函数，还可以是一个对象 闭包的应用 模块化 防止变量被破坏 举例：模块化的应用参考Vue.js中的源码 防止变量被破坏，运用场景 举例：KTV中的最低消费，最低消费的数值不能够暴露出去让别人随便修改，这样会脏了数据，返回一个对象暴露方法来进行业务操作，而不是进行直接操作。1234567891011121314151617181920212223242526272829303132333435363738394041&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;script type="text/javascript"&gt; //场景举例 function KTV()&#123; //最低消费1000 var leastPrice = 1000; var sale = 0; return &#123; //消费 pay:function(pr)&#123; sale += pr; &#125;, //结账 settlement:function()&#123; if(sale&lt;leastPrice)&#123; console.log("您未达到最低消费，请继续消费"); &#125; else &#123; console.log("欢迎下次光临"); &#125; &#125; &#125; &#125; var p1 = KTV(); p1.pay(100); p1.settlement(); //您未达到最低消费，请继续消费 p1.pay(1000); p1.settlement(); //欢迎下次光临 &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 但是如果需要进行修改最低消费，场景：老板的朋友进行消费，需要修改12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;script type="text/javascript"&gt; //场景举例 function KTV()&#123; //最低消费1000 var leastPrice = 1000; var sale = 0; return &#123; //消费 pay:function(pr)&#123; sale += pr; &#125;, //结账 settlement:function()&#123; if(sale&lt;leastPrice)&#123; console.log("您未达到最低消费，请继续消费"); &#125; else &#123; console.log("欢迎下次光临"); &#125; &#125;, //传入工号，和修改最低消费值 edit:function(id,lp)&#123; if(id == 888)&#123; leastPrice = lp; &#125;else&#123; console.log("你不是管理员，无法修改"); &#125; &#125; &#125; &#125; var p1 = KTV(); p1.pay(100); p1.settlement(); //您未达到最低消费，请继续消费 p1.edit(100, 200); //你不是管理员，无法修改 p1.edit(888, 100); //欢迎下次光临 p1.settlement(); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 闭包的运用防止变量被破坏，暴露出方法来间接修改数值，防止出现脏数据。闭包中也有作用域链的相关运用。相辅相成吧。]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mysql命令行导入/出数据库]]></title>
    <url>%2F2019%2F03%2F11%2FMysql%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%AF%BC%E5%85%A5-%E5%87%BA%E6%95%B0%E6%8D%AE%E5%BA%93%2F</url>
    <content type="text"><![CDATA[通常开发都会使用Navicat或者PhpMyAdmin来进行数据库管理，即使方便，但是用于部署时就需要知道原生的一些命令。 mysqldump导出数据库1mysqldump -u 数据库用户名 -p 数据库名称 &gt; 导出数据库名称.sql 如：mysqldump -u root -p 1111 &gt; 1111_bak.sql，回车后输入密码导出到当前目录。 mysql导入数据库1mysql -u 数据库用户名 -p 导入数据库名称 &lt; 导入数据库源文件名称.sql 如：mysql -u root -p 1111 &lt; 1111_bak.sql，回车后输入密码从当前目录导入。]]></content>
      <categories>
        <category>DBA</category>
      </categories>
      <tags>
        <tag>Mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android无法获取本地服务器(Localhost)解决方案]]></title>
    <url>%2F2019%2F03%2F10%2FAndroid%E6%97%A0%E6%B3%95%E8%8E%B7%E5%8F%96%E6%9C%AC%E5%9C%B0%E6%9C%8D%E5%8A%A1%E5%99%A8-Localhost-%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%2F</url>
    <content type="text"><![CDATA[在Android开发中通过localhost或127.0.0.1访问本地服务器时，会报java.net.ConnectException: localhost/127.0.0.1:8083 -Connection refused异常。* 为什么会报这个异常呢？因为Android模拟器本身把自己当做了localhost或127.0.0.1，而此时我们又通过localhost或127.0.0.1访问本地服务器，所以会抛出异常了。 解决方案： 使用10.0.2.2来代替localhost和127.0.0.1即可]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mac显示隐藏文件/文件夹]]></title>
    <url>%2F2019%2F03%2F08%2FMac%E6%98%BE%E7%A4%BA%E9%9A%90%E8%97%8F%E6%96%87%E4%BB%B6-%E6%96%87%E4%BB%B6%E5%A4%B9%2F</url>
    <content type="text"><![CDATA[Mac下一些隐藏文件夹是没有办法可见的，终端下也不会进行显示，例如用户文件下下的.m2 终端执行命令设置隐藏文件可见1$ defaults write com.apple.finder AppleShowAllFiles TRUE 设置隐藏文件不可见1$ defaults write com.apple.finder AppleShowAllFiles FALSE 重启Finder生效1$ killall Finder]]></content>
      <categories>
        <category>程序人生</category>
      </categories>
      <tags>
        <tag>Mac</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS3新特性]]></title>
    <url>%2F2019%2F03%2F07%2FCSS3%E6%96%B0%E7%89%B9%E6%80%A7%2F</url>
    <content type="text"><![CDATA[CSS3【控制样式，网页布局】CSS3中新特性样式篇 背景123456789101112131415161718background-origin： 规定背景图片的定位区域。 ☞ padding-box 背景图像相对内边距定位（默认值） ☞ border-box 背景图像相对边框定位【以边框左上角为参照进行位置设置】 ☞ content-box 背景图像相对内容区域定位【以内容区域左上角为参照进行位置设置】 备注： 1. 默认盒子的背景图片是在盒子的内边距左上角对齐设置。background-clip： 规定背景的绘制区域。 ☞ border-box 背景被裁切到边框盒子位置 【将背景图片在整个容器中显示】 ☞ padding-box 背景被裁切到内边距区域【将背景图片在内边距区域（包含内容区域）显示】 ☞ content-box 背景被裁切到内容区域【将背景图片在内容区域显示】background-size： 规定背景图片的尺寸。 ☞ cover ☞ contain 边框1234567891011121314151617box-shadow： 盒子阴影border-radius： 边框圆角border-image: 边框图片 /* 设置边框图片 */ border-image-source: url("2.png"); /* 边框图片裁切 : 不需要带单位*/ border-image-slice: 20; /* 设置边框图片的平铺方式 */ /* border-image-repeat: stretch; */ border-image-repeat: round; /* border-image-repeat: repeat; */ border-image-width: 20px; 文本1☞text-shadow： 设置文本阴影 CSS3新特性之选择器篇123456789101112131415161718192021222324252627☞ 属性选择器： [属性名=值] &#123;&#125; [属性名] &#123;&#125; 匹配对应的属性即可 [属性名^=值] &#123;&#125; 以值开头 [属性名*=值] &#123;&#125; 包含 [属性名$=值] &#123;&#125; 以值结束 ☞ 结构伪类选择器： :first-child &#123;&#125; 选中父元素中第一个子元素 :last-child &#123;&#125; 选中父元素中最后一个子元素 :nth-child(n) &#123;&#125; 选中父元素中正数第n个子元素 :nth-last-child(n) &#123;&#125; 选中父元素中倒数第n个子元素 备注； n 的取值大于等于0 n 可以设置预定义的值 odd[选中奇数位置的元素] even【选中偶数位置的元素】 n 可以是一个表达式： an+b的格式☞ 其他选择器： :target 被锚链接指向的时候会触发该选择器 ::selection 当被鼠标选中的时候的样式 ::first-line 选中第一行 ::first-letter 选中第一个字符 CSS3新特性之颜色渐变12345678910111213141516171819202122232425☞ 线性渐变： 1. 开始颜色和结束颜色 2. 渐变的方向 3. 渐变的范围 background-image: linear-gradient( to right, red, blue ); 备注： 表示方向： 1. to + right | top | bottom | left 2. 通过角度表示一个方向 0deg [从下向上渐变] 90deg【从左向右】☞ 径向渐变： /* 径向渐变 */ background-image: radial-gradient( 100px at center, red, blue ); 2D转换1234567891011121314151617181920☞ 位移 transform: translate(100px,100px); 备注： 位移是相对元素自身的位置发生位置改变☞ 旋转 transform: rotate(60deg); 备注： 取值为角度☞ 缩放 transform: scale(0.5,1); 备注： 取值为倍数关系，缩小大于0小于1，放大设置大于1 ☞ 倾斜 transform: skew(30deg,30deg); 备注： 第一个值代表沿着x轴方向倾斜 第二个值代表沿着y轴方向倾斜 3D转换12345678910111213☞ 位移 transform: translateX() translateY() translateZ()☞ 旋转 transform: rotateX(60deg) rotateY(60deg) rotateZ(60deg);☞ 缩放 transform: scaleX(0.5) scaleY(1) scaleZ(1);☞ 倾斜 transform: skewX(30deg) skewY();☞ transform-style: preserve-3d; 将平面图形转换为立体图形 CSS3新特性之动画篇过渡1234567891011121314151617https://www.cnblogs.com/afighter/p/5731293.html补间动画 /* 设置哪些属性要参与到过渡动画效果中： all */ transition-property: all; /* 设置过渡执行时间 */ transition-duration: 1s; /* 设置过渡延时执行时间 */ transition-delay: 1s; /* 设置过渡的速度类型 */ transition-timing-function: linear; 动画12345678910111213141516171819 /* 1定义动画集 */ @keyframes rotate &#123; /* 定义开始状态 0%*/ from &#123; transform: rotateZ(0deg); &#125; /* 结束状态 100%*/ to &#123; transform: rotateZ(360deg); &#125; &#125;注意： 1. 如果设置动画集使用的是百分比，那么记住百分比是相对整个动画执行时间的。 CSS3新特性之网页布局篇伸缩布局或者弹性布局【响应式布局】12345678910111213141516171819202122232425262728293031323334353637383940414243☞ 设置父元素为伸缩盒子【直接父元素】 display： flex 为什么在伸缩盒子中，子元素会在一行上显示？ 1. 子元素是按照伸缩盒子中主轴方向显示 2. 只有伸缩盒子才有主轴和侧轴 3. 主轴： 默认水平从左向右显示 4。 侧轴： 始终要垂直于主轴☞ 设置伸缩盒子主轴方向（flex-direction） flex-direction: row; 【默认值】 flex-direction: row-reverse; flex-direction: column; flex-direction: column-reverse;☞ 设置元素在主轴的对齐方式( justify-content) /* 设置子元素在主轴方向的对齐方式 */ justify-content: flex-start; justify-content: flex-end; justify-content: center; justify-content: space-between; justify-content: space-around;☞ 设置元素在侧轴的对齐方式 （align-items） align-items: flex-start; align-items: flex-end; align-items: center; /* 默认值 */ align-items: stretch;☞ 设置元素是否换行显示（flex-wrap） 1. 在伸缩盒子中所有的元素默认都会在一行上显示 2. 如果希望换行： flex-wrap: wrap | nowrap;☞ 设置元素换行后的对齐方式（ align-content） align-content: flex-start; align-content: flex-end; align-content: center; align-content: space-around; align-content: space-between; /* 换行后的默认值 */ align-content: stretch;]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IOS中JSON序列化与反序列化]]></title>
    <url>%2F2019%2F03%2F06%2FIOS%E4%B8%ADJSON%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8E%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%2F</url>
    <content type="text"><![CDATA[序列化与反序列化序列化： 将数据结构或对象转换成二进制串的过程。反序列化：将在序列化过程中所生成的二进制串转换成数据结构或者对象的过程。 NSJSONSerializationjson-&gt;oc一段服务器的json数据 12345&#123; "data":"hello", "code":200, "msg":"success"&#125; 二进制数据转json,方法123456789/* * 第一个参数：json的二进制数据 * 第二个参数： * NSJSONReadingMutableContainers = (1UL &lt;&lt; 0),得到OC对象是可变的 * NSJSONReadingMutableLeaves = (1UL &lt;&lt; 1), 字典和数组中的字符串都是可变的，iOS7以后出现很多问题，一般不会用到 * NSJSONReadingAllowFragments = (1UL &lt;&lt; 2) 既不是字典也不是数组，则必须使用该枚举值 如果返回数据为@“\&quot;hahahahaha\&quot;” * 第三个参数：错误信息 */ NSDictionary *dic = [NSJSONSerialization JSONObjectWithData:data options:kNilOptions error:nil]; 举例 12345678910111213141516171819202122NSURL *url = [NSURL URLWithString:@&quot;http://127.0.0.1:8000/hello/name&quot;]; NSURLRequest *request = [NSURLRequest requestWithURL:url]; [NSURLConnection sendAsynchronousRequest:request queue:[NSOperationQueue mainQueue] completionHandler:^(NSURLResponse * _Nullable response, NSData * _Nullable data, NSError * _Nullable connectionError) &#123; if (connectionError) &#123; NSLog(@&quot;%@&quot;, connectionError); return; &#125; NSHTTPURLResponse *res = (NSHTTPURLResponse *) response; if (res.statusCode == 200) &#123; //开始解析json NSError *error = nil; id json = [NSJSONSerialization JSONObjectWithData:data options:NSJSONReadingMutableContainers error:&amp;error]; if (error) &#123; NSLog(@&quot;%@&quot;, error); return; &#125; NSLog(@&quot;%@&quot;, json); &#125;else&#123; NSLog(@&quot;服务器错误&quot;); &#125; &#125;]; 输出结果123452019-03-06 17:44:34.480939+0800 JsonDemo[5349:107008] &#123; code = 200; data = hello; msg = success;&#125; oc-&gt;json举例1234567891011121314151617181920212223242526/* 注意：并不是所有的OC对象都可以转化为json 例如字符串 * 顶层必须是NSArray或者NSDictionnary * 所有的元素必须是 NSString, NSNumber, NSArray, NSDictionary, or NSNull * 字典中所有的key必须是NSStrings类型的 * NSNumbers 不能是无穷大 */ // 1、提供转化的OC字典 NSDictionary *dic = @&#123; @&quot;code&quot;:@200, @&quot;data&quot;:[NSNull null], @&quot;msg&quot;:@&quot;oh my json&quot; &#125;; // 2、判断OC对象是否可以转换为json对象 BOOL isVaild = [NSJSONSerialization isValidJSONObject:dic]; if (isVaild) &#123; /* * 第一个参数：需要序列化的数据 * 第二个参数：如果添加就输出排版美观效果 如果不添加按照默认输出 * NSJSONWritingPrettyPrinted = (1UL &lt;&lt; 0) */ NSData *data = [NSJSONSerialization dataWithJSONObject:dic options:NSJSONWritingPrettyPrinted error:nil]; NSLog(@&quot;%@&quot;,[[NSString alloc] initWithData:data encoding:NSUTF8StringEncoding]); &#125;else&#123; NSLog(@&quot;该对象无法转换&quot;); &#125; 控制台输出123452019-03-06 17:57:27.734633+0800 JsonDemo[6202:131086] &#123; &quot;msg&quot; : &quot;oh my json&quot;, &quot;data&quot; : null, &quot;code&quot; : 200&#125; MJExtension安装CocoaPods1pod &apos;MJExtension&apos; 手动导入github链接 使用字典转模型模型USER123456789@interface User : NSObject@property(copy, nonatomic)NSString *name;@property(copy, nonatomic)NSString *zhiye;@property(copy, nonatomic)NSString *money;@end 1234567NSDictionary *dict = @&#123; @&quot;name&quot;:@&quot;ycy&quot;, @&quot;zhiye&quot;:@&quot;程序员&quot;, @&quot;money&quot;:@&quot;-4000&quot; &#125;; User *user = [User mj_objectWithKeyValues:dict]; NSLog(@&quot;%@&quot;,user.name); JSONString转模型123456789/ 1.Define a JSONStringNSString *jsonString = @&quot;&#123;\&quot;name\&quot;:\&quot;Jack\&quot;, \&quot;icon\&quot;:\&quot;lufy.png\&quot;, \&quot;age\&quot;:20&#125;&quot;;// 2.JSONString -&gt; UserUser *user = [User mj_objectWithKeyValues:jsonString];// 3.Print user&apos;s propertiesNSLog(@&quot;name=%@, icon=%@, age=%d&quot;, user.name, user.icon, user.age);// name=Jack, icon=lufy.png, age=20 more查看官方文档即可链接]]></content>
      <categories>
        <category>Ios</category>
      </categories>
      <tags>
        <tag>Ios</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IOS9以上中的ATS问题]]></title>
    <url>%2F2019%2F03%2F06%2FIOS9%E4%BB%A5%E4%B8%8A%E4%B8%AD%E7%9A%84ATS%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[WWDC 15 提出的 ATS (App Transport Security) 是 Apple 在推进网络通讯安全的一个重要方式。在 iOS 9 和 OS X 10.11 中，默认情况下非 HTTPS 的网络访问是被禁止的。 作为参考，这里将有效的 NSAppTransportSecurity 字典结构 123456789101112131415NSAppTransportSecurity : Dictionary &#123; NSAllowsArbitraryLoads : Boolean NSAllowsArbitraryLoadsForMedia : Boolean NSAllowsArbitraryLoadsInWebContent : Boolean NSAllowsLocalNetworking : Boolean NSExceptionDomains : Dictionary &#123; &lt;domain-name-string&gt; : Dictionary &#123; NSIncludesSubdomains : Boolean NSExceptionAllowsInsecureHTTPLoads : Boolean NSExceptionMinimumTLSVersion : String NSExceptionRequiresForwardSecrecy : Boolean // Default value is YES NSRequiresCertificateTransparency : Boolean &#125; &#125;&#125; ATS设定的参照表格 如果网站内没有启用https，如何关闭，在info.plist文件中加入source code下12345&lt;key&gt;NSAppTransportSecurity&lt;/key&gt;&lt;dict&gt; &lt;key&gt;NSAllowsArbitraryLoads&lt;/key&gt; &lt;true/&gt;&lt;/dict&gt; plist下添加NSAppTransportSecurity字典-&gt;并添加键值对NSAllowsArbitraryLoads=YES来禁用ATS 参照链接https://onevcat.com/2016/06/ios-10-ats/ https://stackoverflow.com/questions/31254725/transport-security-has-blocked-a-cleartext-http]]></content>
      <categories>
        <category>Ios</category>
      </categories>
      <tags>
        <tag>Ios</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IOS模拟器截图/录制屏幕]]></title>
    <url>%2F2019%2F03%2F06%2FIOS%E6%A8%A1%E6%8B%9F%E5%99%A8%E6%88%AA%E5%9B%BE-%E5%BD%95%E5%88%B6%E5%B1%8F%E5%B9%95%2F</url>
    <content type="text"><![CDATA[截图 iOS 的模拟器截图，按 Command + S或者通过 File 菜单都可以完成。 录制屏幕终端下运行该命令， 1xcrun simctl io booted recordVideo &lt;filename&gt;.&lt;extension&gt; 运行命令后没有报错则已经开始录制屏幕了，如果想要停止则直接Ctrl + C 停止结束命令即可。默认视频会保存在终端的当前目录下，当然你也可以指定当前目录。 xcrun unable to find simctl解决方法如果出现命令无法执行并报出这个错误xcrun: error: unable to find utility &quot;simctl&quot;, not a developer tool or in PATH 修改一下打开Xcode &gt; Preferences &gt; Locations 更改一下 Command Line Tools选项就可以了,如图]]></content>
      <categories>
        <category>Ios</category>
      </categories>
      <tags>
        <tag>Ios</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android P/9.0 http网络请求异常问题]]></title>
    <url>%2F2019%2F03%2F06%2FAndroid-P-9-0-http%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82%E5%BC%82%E5%B8%B8%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[使用Android P系统时，app使用http请求出现异常。 异常原因 Google表示，为保证用户数据和设备的安全，针对下一代 Android 系统(Android P)的应用程序，将要求默认使用加密连接，这意味着 Android P 将禁止 App使用所有未加密的连接，因此运行 Android P系统的安卓设备无论是接收或者发送流量，未来都不能明码传输，需要使用下一代(Transport LayerSecurity)传输层安全协议，而 Android Nougat 和 Oreo 则不受影响。 因此在Android P中使用HttpUrlConnection时会报出次异常 1W/System.err: java.io.IOException: Cleartext HTTP traffic to **** not permitted 而使用OKHttp时，同样也会报出异常 1java.net.UnknownServiceException: CLEARTEXT communication ** not permitted by network security policy 在Android P系统的设备上，如果应用使用的是非加密的明文流量的http网络请求，则会导致该应用无法进行网络请求，https则不会受影响，同样地，如果应用嵌套了webview，webview也只能使用https请求。有人认为 Android P 上所有的 App 都需要使用 TLS 加密会降低上网体验，事实上这是一种误解，至于 App 对于少数旧服务器的连接如果非要使用明码传输，开发者需要更改 App 的网络安全配置以允许此类连接。 解决方案APP内所有请求更改为Https将targetSdkVersion改为27以下开启/允许http请求在res下新增一个xml目录，然后创建一个名为：network_security_config.xml 文件（名字自定） ，内容如下，大概意思就是允许开启http请求 1234567&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;network-security-config&gt; &lt;base-config cleartextTrafficPermitted="true" /&gt;&lt;/network-security-config&gt; 然后在AndroidManifest.xml文件中的Application标签下增加一行属性 12345678&lt;application ... android:networkSecurityConfig="@xml/network_security_config" ...&gt; ...&lt;/application&gt; 参考链接https://www.jianshu.com/p/57047a84e559 https://android-developers.googleblog.com/2018/04/protecting-users-with-tls-by-default-in.html https://android-developers.googleblog.com/2018/04/dns-over-tls-support-in-android-p.html]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Html5新特性]]></title>
    <url>%2F2019%2F03%2F04%2FHtml5%E6%96%B0%E7%89%B9%E6%80%A7%2F</url>
    <content type="text"><![CDATA[01-HTML5基础了解HTML5 12345678910111213141516☞HTML5属于上一代HTML的新迭代语言，设计HTML5最主要的目的是为了在移动设备上支持多媒体！！！ 例如： video 标签和 audio 及 canvas 标记☞ 新特性： 1. 取消了过时的显示效果标记 &lt;font&gt;&lt;/font&gt; 和 &lt;center&gt;&lt;/center&gt; ... 2. 新表单元素引入 3. 新语义标签的引入 4. canvas标签（图形设计） 5. 本地数据库（本地存储） 6. 一些API☞ 好处： 1. 跨平台 例如：比如你开发了一款HTML5的游戏，你可以很轻易地移植到UC的开放平台、Opera的游戏中心、Facebook应用平台，甚至可以通过封装的技术发放到App Store或Google Play上，所以它的跨平台性非常强大，这也是大多数人对HTML5有兴趣的主要原因。☞ 缺点： 1. pc端浏览器支持不是特别友好，造成用户体验不佳 新语义标签网页布局结构标签及兼容处理12345678&lt;header&gt;&lt;/header&gt;&lt;footer&gt;&lt;/footer&gt;&lt;article&gt;&lt;/article&gt;&lt;aside&gt;&lt;/aside&gt;&lt;nav&gt;&lt;/nav&gt;&lt;section&gt;&lt;/section&gt;....http://www.w3school.com.cn/html/html5_semantic_elements.asp 多媒体标签及属性介绍12345678910111213141516☞ &lt;video&gt;&lt;/video&gt; 视频 属性：controls 显示控制栏 属性：autoplay 自动播放 属性：loop 设置循环播放☞ &lt;audio&gt;&lt;/audio&gt; 音频 属性：controls 显示控制栏 属性：autoplay 自动播放 属性：loop 设置循环播放☞ video标签支持的格式 http://www.w3school.com.cn/html5/html_5_video.asp☞ 多媒体标签在网页中的兼容效果方式 &lt;video&gt; &lt;source src="code/多媒体标签/trailer.mp4"&gt; &lt;source src="trailer.ogg"&gt; &lt;source src="trailer.WebM"&gt; &lt;/video&gt; 新表单元素及属性智能表单控件1234567891011 &lt;input type="email"&gt; email: 输入合法的邮箱地址 url： 输入合法的网址 number： 只能输入数字 range： 滑块 color： 拾色器 date： 显示日期 month： 显示月份 week ： 显示第几周 time： 显示时间 表单属性12345678910111213141516171819202122232425262728 ◆form属性： autocomplete=on | off 自动完成 novalidate=true | false 是否关闭校验 ◆ input属性： *autofocus ： 自动获取焦点 form： list： &lt;input type="text" list="abc"/&gt; &lt;datalist id="abc"&gt; &lt;option value="123"&gt;12312&lt;/option&gt; &lt;option value="123"&gt;12312&lt;/option&gt; &lt;option value="123"&gt;12312&lt;/option&gt; &lt;option value="123"&gt;12312&lt;/option&gt; &lt;/datalist&gt; multiple： 实现多选效果 *placeholder ： 占位符 （提示信息） *required： 必填项作业： ◆自己解决required自定义提示信息 ◆预习和复习留下的疑问： ◆ 如何修改表单控件中的默认提示信息 1. 表单验证触发oninvalid事件 2. 通过setCustomValidity方法设置修改内容 HTMl5中的API获取页面元素及类名操作和自定义属性123456789101112131415161718192021222324252627282930313233343536☞ document.querySelector("选择器")； 备注： 选择器： 可以是css中的任意一种选择器 通过该选择器只能选中第一个元素。☞ document.querySelectorAll("选择器"); 备注： 与document.querySelector区别： querySelectorAll 可以选中所有符合选择器规则的元素，返回的是一个列表。querySelector返回的只是单独的一个元素 ☞ Dom.classList.add("类名"): 给当前dom元素添加类样式☞ Dom.classList.remove("类名"); 给当前dom元素移除类样式☞ classList.contains("类名"); 检测是否包含类样式☞ classList.toggle("active"); 切换类样式（有就删除，没有就添加）☞ 自定义属性 （小案例分析体验自定义属性） data-自定义属性名 备注： 在标签中，以data-自定义名称 1. 获取自定义属性 Dom.dataset 返回的是一个对象 Dom.dataset.属性名 或者 Dom.dataset[属性名] 注意： 属性名是不包含data- 2. 设置自定义属性 Dom.dataset.自定义属性名=值 或者 Dom.dataset[自定义属性名]=值； 文件读取123456789101112131415 ☞ FileReader FileReader 接口有3个用来读取文件方法返回结果在result中 readAsBinaryString ---将文件读取为二进制编码 readAsText ---将文件读取为文本 readAsDataURL ---将文件读取为DataURL☞ FileReader 提供的事件模型 onabort 中断时触发 onerror 出错时触发 onload 文件读取成功完成时触发 onloadend 读取完成触发，无论成功或失败 onloadstart 读取开始时触发 onprogress 读取中☞ 分析读取图片小案例 获取网络状态123456☞ 获取当前网络状态 window.navigator.onLine 返回一个布尔值☞ 网络状态事件 1. window.ononline 2. window.onoffline 获取地理定位12345678910☞ 获取一次当前位置 window.navigator.geolocation.getCurrentPosition(success,error); 1. coords.latitude 维度 2. coords.longitude 经度☞ 实时获取当前位置 window.navigator.geolocation.watchPosition(success,error);☞ 分析地理定位小案例 本地存储12345678910111213141516171819202122☞发展： 随着互联网的快速发展，基于网页的应用越来越普遍，同时也变的越来越复杂，为了满足各种各样的需求，会经常性在本地存储大量的数据，传统方式我们以document.cookie来进行存储的，但是由于其存储大小只有4k左右，并且解析也相当的复杂，给开发带来诸多不便，HTML5规范则提出解决方案，使用sessionStorage和localStorage存储数据。 ☞ localStorage： 1. 永久生效 2. 多窗口共享 3. 容量大约为20M ◆window.localStorage.setItem(key,value) 设置存储内容 ◆window.localStorage.getItem(key) 获取内容 ◆window.localStorage.removeItem(key) 删除内容 ◆window.localStorage.clear() 清空内容 ☞ sessionStorage： 1. 生命周期为关闭当前浏览器窗口 2. 可以在同一个窗口下访问 3. 数据大小为5M左右 ◆window.sessionStorage.setItem(key,value) ◆window.sessionStorage.getItem(key) ◆window.sessionStorage.removeItem(key) ◆window.sessionStorage.clear() 操作多媒体1234http://www.w3school.com.cn/html5/html5_ref_audio_video_dom.asp作业： 完成一个在线音乐播放器或者视频播放器 Canvas画布绘图工具12345☞ 介绍canvas画布☞ 设置画布大小： 使用属性方式设置☞ 解决画布重绘问题 1. 设置一次描边 2. 开启新的图层 绘图方法123456789101112131415161718192021ctx.moveTo(x,y) 落笔ctx.lineTo(x,y) 连线ctx.stroke() 描边ctx.beginPath()； 开启新的图层演示： strokeStyle="值"线宽： linewidth="值" 备注：不需要带单位线连接方式： lineJoin: round | bevel | miter (默认)线帽（线两端的结束方式）： lineCap: butt(默认值) | round | square 闭合路径： ctx.closePath()--绘制一条直线演示代码--作业： 1. 从200,100的位置绘制宽为200高为150的矩形 2. 准备一个600*400的画布，三等分这个画布，分别绘制正方形。直角三角形，梯形 渐变方案1234567891011121314151617181920212223242526272829☞ 线性渐变 var grd=ctx.createLinearGradient(x0,y0,x1,y1); x0--&gt;渐变开始的x坐标 y0--&gt;渐变开始的y坐标 x1--&gt;渐变结束的x坐标 y1--&gt;渐变结束的y坐标 grd.addColorStop(0,&quot;black&quot;); 设置渐变的开始颜色 grd.addColorStop(0.1,&quot;yellow&quot;); 设置渐变的中间颜色 grd.addColorStop(1,&quot;red&quot;); 设置渐变的结束颜色 ctx.strokeStyle=grd; ctx.stroke(); 备注： addColorStop(offse,color); 中渐变的开始位置和结束位置介于0-1之间，0代表开始，1代表结束。中间可以设置任何小数 ☞ 径向渐变 ctx.createradialGradient(x0,y0,r0,x1,y1,r1); (x0,y0)：渐变的开始圆的 x,y 坐标 r0：开始圆的半径 (x1,y1)：渐变的结束圆的 x,y 坐标 r1：结束圆的半径 填充效果12ctx.fill(); 设置填充效果ctx.fillstyle=&quot;值&quot;; 设置填充颜色 非零环绕原则1☞ 绘制一个如下图形 1234567☞ 非零环绕原则： 1. 任意找一点，越简单越好 2. 以点为圆心，绘制一条射线，越简单越好（相交的边越少越好） 3. 以射线为半径顺时针旋转，相交的边同向记为+1，反方向记为-1，如果相加的区域等于0，则不填充。 4. 非零区域填充 ☞ 非零环绕原则案例： 绘制虚线12345678910111213141516171819202122原理： 设置虚线其实就是设置实线与空白部分直接的距离,利用数组描述其中的关系 例如： [10,10] 实线部分10px 空白部分10px 例如： [10,5] 实线部分10px 空白部分5px 例如： [10,5,20] 实线部分10px 空白5px 实线20px 空白部分10px 实线5px 空白20px....绘制： ctx.setLineDash(数组); ctx.stroke(); 例如： ctx.moveTo(100, 100); ctx.lineTo(300, 100); ctx.setLineDash([2,4]); ctx.stroke();注意： 如果要将虚线改为实线，只要将数组改为空数组即可。 绘制动画效果123456789☞ 绘制一个描边矩形： content.strokeRect(x,y,width,height) ☞ 绘制一个填充矩形： content.fillRect(x,y,width,height) ☞ 清除： content.clearRect(x,y,width,height) ☞ 实现动画效果： 1. 先清屏 2. 绘制图形 3. 处理变量 绘制文本123456789101112131415161718192021222324☞ 绘制填充文本 content.fillText(文本的内容,x,y)☞ 绘制镂空文本 content.strokeText(); ☞ 设置文字大小： content.font=&quot;20px 微软雅黑&quot; 备注： 该属性设置文字大小，必须按照cssfont属性的方式设置 ☞ 文字水平对齐方式【文字在圆心点位置的对齐方式】 content.textalign=&quot;left | right | center&quot;☞文字垂直对齐方式 content.textBaseline=&quot;top | middle | bottom | alphabetic(默认)&quot;☞文字阴影效果 ctx.shadowColor=&quot;red&quot;; 设置文字阴影的颜色 ctx.ShadowOffsetX=值; 设置文字阴影的水平偏移量 ctx.shadowOffsetY=值; 设置文字阴影的垂直偏移量 ctx.shadowBlur=值; 设置文字阴影的模糊度 绘制图片12345678910111213141516171819☞ //将图片绘制到画布的指定位置 content.drawImage(图片对象,x,y);☞ //将图片绘制到指定区域大小的位置 x,y指的是矩形区域的位置，width和height指的是矩形区域的大小 content.drawImage(图片对象,x,y,width,height); ☞ //将图片的指定区域绘制到指定矩形区域内 content.drawImage(图片对象,sx,sy,swidth,sheight,dx,dy,dwidth,dheight); sx,sy 指的是要从图片哪块区域开始绘制，swidth，sheight 是值 截取图片区域的大小 dx,dy 是指矩形区域的位置，dwidth,dheight是值矩形区域的大小 ☞ 解决图片绘制到某一个区域的按原比例缩放绘制： 绘制宽：绘制高==原始宽：原始高 绘制圆弧123456789101112131415161718192021222324252627282930313233343536373839404142434445464748☞ content.arc(x,y,radius,startradian,endradian[,direct]); x,y 圆心的坐标 radius 半径 startradian 开始弧度 endradian 结束弧度 direct 方向（默认顺时针 false） true 代表逆时针 ☞ 0度角在哪？ 以圆心为中心向右为0角 顺时针为正，逆时针为负 ☞ 备注： 角度 和 弧度的关系： 角度:弧度= 180:pi 特殊值 0度 = 0弧度 30度 = π/6 (180度的六分之一) 45度 = π/4 60度 = π/3 90度 = π/2 180度 = π 360度 = 2π ☞ 绘制圆上任意点： 公式： x=ox+r*cos( 弧度 ) y=oy+r*sin( 弧度 ) ox: 圆心的横坐标 oy: 圆心的纵坐标 r： 圆的半径 平移【坐标系圆点的平移】12345678910111213ctx.translate(x,y); 特点： 通过该方法可以将原点的位置进行重新设置。 注意： 1. translate(x,y) 中不能设置一个值 2. 与moveTo(x,y) 的区别： moveTo(x,y) 指的是将画笔的落笔点的位置改变，而坐标系中的原点位置并没有发生改变 translate(x,y) 是将坐标系中的原点位置发生改变 旋转【坐标系旋转】1ctx.rotate(弧度) 伸缩123456ctx.scale(x,y) 备注： 沿着x轴和y轴缩放 x,y 为倍数 例如： 0.5 1]]></content>
      <categories>
        <category>HTML</category>
      </categories>
      <tags>
        <tag>HTML</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IOS之自动布局AutoLayout]]></title>
    <url>%2F2019%2F03%2F04%2FIOS%E4%B9%8B%E8%87%AA%E5%8A%A8%E5%B8%83%E5%B1%80AutoLayout%2F</url>
    <content type="text"><![CDATA[AutoLayout自动布局介绍UI布局对于iOS开发者来说并不陌生，在iOS6之前，大家都是通过UI控件的Frame属性和Autoresizing Mask来进行UI布局的。AutoLayout则是苹果公司在iOS6推出的一种基于约束的，描述性的布局系统。自从AutoLayout问世以来，逐步得到了iOS开发者们的青睐，尤其是iPhone6机型尺寸的出现。 AutoLayout占据UI布局的主要领导位置依赖于它的特殊性： 基于约束：和以往定义frame的位置和尺寸不同，AutoLayout的位置确定是以所谓相对位置的约束来定义的，比如x坐标为superView的中心，y坐标为屏幕底部上方10像素等 描述性： 约束的定义和各个view的关系使用接近自然语言或者可视化语言（稍后会提到）的方法来进行描述 布局系统：即字面意思，用来负责界面的各个元素的位置。 AutoLayout使用原理创建约束IOS6中新加入了一个类，NSLayoutConstraint,它的约束满足一个公式 1item1.attribute = multiplier ⨉ item2.attribute + constant 相应公式的代码为12345678//view_1(红色)top 距离self.view的topNSLayoutConstraint *view_1TopToSuperViewTop = [NSLayoutConstraint constraintWithItem:view_1 attribute:NSLayoutAttributeTop relatedBy:NSLayoutRelationEqual toItem:self.view attribute:NSLayoutAttributeTop multiplier:1 constant:30]; 这里对应的约束是“view_1的顶部（y）＝ self.view的顶部(y)*1 + 30”。 添加约束在创建约束后，需要将其添加到作用的view上。UIView添加约束的实例方法 12- (void)addConstraint:(NSLayoutConstraint *)constraint NS_AVAILABLE_IOS(6_0);- (void)addConstraints:(NSArray&lt;__kindof NSLayoutConstraint *&gt; *)constraints NS_AVAILABLE_IOS(6_0); UIView中的一个属性translatesAutoresizingMaskIntoConstraints 1234//如果你定义的view想用autolayout，就将translatesAutoresizingMaskIntoConstraints = NO//如果你使用的不是autolayout，就将translatesAutoresizingMaskIntoConstraints = YES 约束的属性 当然，如何添加也有相应的规则。 对其他的view没有任何关系时，添加到自己的view上比如说添加一个按钮的宽和高的约束，对其他的view没有任何关系，则将约束添加到自己身上。 为按钮添加一个宽和高为两百的约束1234567891011121314151617181920#import &quot;ViewController.h&quot;@interface ViewController ()@property (strong, nonatomic) IBOutlet UIButton *btn1;@end@implementation ViewController- (void)viewDidLoad &#123; [super viewDidLoad]; // Do any additional setup after loading the view, typically from a nib. NSLayoutConstraint *c1 = [NSLayoutConstraint constraintWithItem:self.btn1 attribute:NSLayoutAttributeWidth relatedBy:NSLayoutRelationEqual toItem:nil attribute:NSLayoutAttributeWidth multiplier:1 constant:200]; NSLayoutConstraint *c2 = [NSLayoutConstraint constraintWithItem:self.btn1 attribute:NSLayoutAttributeHeight relatedBy:NSLayoutRelationEqual toItem:nil attribute:NSLayoutAttributeHeight multiplier:1 constant:200]; self.btn1.translatesAutoresizingMaskIntoConstraints = NO; [self.btn1 addConstraint:c1]; [self.btn1 addConstraint:c2];&#125;@end 对于两个同层级view之间的约束关系，则添加到他们的父View上例如3.1与3.2为同层级view，约束关系则添加到父view2.1上。 添加了一个蓝色view的上边线与绿色view的下边线对其的约束，两个view为同级约束，则添加到了父view上。 对于两个不同层级的view之间的约束关系，则添加到他们最近的共同的父view上。例如3.3与3.5为同层级view，约束关系则添加到父view1上。 但是相对于这种情况应该用的很少。 刷新约束可以通过setNeedsUpdateConstraints和layoutIfNeeded两个方法来刷新约束，使得UIView重新布局。 Masonry框架最后说明一下，在Masonry中能够添加autolayout约束有三个函数： 123456789- (NSArray *)mas_makeConstraints:(void(^)(MASConstraintMaker *make))block;- (NSArray *)mas_updateConstraints:(void(^)(MASConstraintMaker *make))block;- (NSArray *)mas_remakeConstraints:(void(^)(MASConstraintMaker *make))block;/*mas_makeConstraints 只负责新增约束 Autolayout不能同时存在两条针对于同一对象的约束 否则会报错 mas_updateConstraints 针对上面的情况 会更新在block中出现的约束 不会导致出现两个相同约束的情况mas_remakeConstraints 则会清除之前的所有约束 仅保留最新的约束三种函数善加利用 就可以应对各种情况了*/ 常用属性 123456//乘以- (MASConstraint * (^)(CGFloat multiplier))multipliedBy;//除以- (MASConstraint * (^)(CGFloat divider))dividedBy;//优先级- (MASConstraint * (^)(MASLayoutPriority priority))priority;]]></content>
      <categories>
        <category>Ios</category>
      </categories>
      <tags>
        <tag>Ios</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTML5语义性标签兼容解决]]></title>
    <url>%2F2019%2F03%2F02%2FHTML5%E8%AF%AD%E4%B9%89%E6%80%A7%E6%A0%87%E7%AD%BE%E5%85%BC%E5%AE%B9%E8%A7%A3%E5%86%B3%2F</url>
    <content type="text"><![CDATA[前言现在大部分的浏览器都能够很好的支持H5，但还是不免得有一些浏览器是不能够支持HTML5的新特性及其一些新标签，特别是在IE8以下的浏览器。 兼容办法第一种通过document.createElement(&quot;nav&quot;);的办法来逐个创建标签元素，但是通过其办法还需要定义好其元素的CSS样式。 第二种使用js插件，这里使用的是html5shiv，BootCDN有提供,链接 1&lt;script src="https://cdn.bootcss.com/html5shiv/r29/html5.js"&gt;&lt;/script&gt; 终极解决办法单纯使用第二种的时候，有一些浏览器本身就能够支持，所以在代码中进行判断是否需要该js使用条件Hack 1234&lt;!-- 终极解决方案 --&gt; &lt;!--[if lte IE 8]&gt; &lt;script src="https://cdn.bootcss.com/html5shiv/r29/html5.js"&gt;&lt;/script&gt; &lt;![endif]--&gt; 是否需要兼容可以看业务是否需要，也可以提示用户进行更换浏览器，毕竟IE是个坑爹的浏览器。]]></content>
      <categories>
        <category>HTML</category>
      </categories>
      <tags>
        <tag>HTML</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Objective-C之深、浅拷贝]]></title>
    <url>%2F2019%2F03%2F01%2FObjective-C%E4%B9%8B%E6%B7%B1%E3%80%81%E6%B5%85%E6%8B%B7%E8%B4%9D%2F</url>
    <content type="text"><![CDATA[什么是深拷贝和浅拷贝 深拷贝就是对一个对象的拷贝，浅拷贝是对一个对象地址的拷贝。 copy，mutablecopy 原则：copy方法返回的是一个不可变对象，不可变即该对象不能执行增删操作，这也是MutableArray不能用copy修饰的原因。mutablecopy方法返回的是一个可变对象。 大多数NSString、Block都需要copy]]></content>
      <categories>
        <category>Ios</category>
      </categories>
      <tags>
        <tag>Ios</tag>
        <tag>Objective-C</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Objective-C之Block]]></title>
    <url>%2F2019%2F03%2F01%2FObjective-C%E4%B9%8BBlock%2F</url>
    <content type="text"><![CDATA[关于Block在iOS4.0之后，block横空出世，它本身封装了一段代码并将这段代码当做变量，通过block()的方式进行回调。 block的代码是内联的，效率高于函数调用block对于外部变量默认是只读属性block被Objective-C看成是对象处理 对于block的底层实现在网上已经有很多资料了，其源码更是可以在opensource.apple.com上下载，因此，本文更着重于对于block的基本应用 Block特性MRC环境 认识Block一个简单的block，实现两个数之和1234int(^sum)(int a, int b) = ^(int a, int b)&#123; return a + b; &#125;;NSLog(@&quot;%d&quot;,sum(3,5)); 代码左边是一个block的生命，int为block的返回值类型，^符号后面为block的名称，后面括号里面为参数列表，该block的参数列表有两个，两个都是int类型参数。右边为block的定义。用网上一张图来更好的认识到block。 Block访问外部基本类型数据 静态变量 和 全局变量 在加和不加 block 都会直接引用变量地址。也就意味着 可以修改变量的值。在没有加block 参数的情况下。 基本类型常量时，看一段代码 1234567891011int main(int argc, const char * argv[]) &#123; @autoreleasepool &#123; // insert code here... CGPoint p = CGPointMake(10, 10); void(^bt)(void) = ^()&#123; NSLog(@&quot;%f , %f&quot;, p.x, p.y); &#125;; bt(); &#125; return 0;&#125; 输出122019-03-01 11:35:15.244937+0800 BlockDemo[866:40789] 10.000000 , 10.000000Program ended with exit code: 0 可以看到block可以直接访问到外部的局部变量。但是block内使用外部的变量相当于拷贝了一份外部变量来使用，并不能直接修改外部变量的值，例如 编译器直接进行报错，但是如果想直接修改外部的局部变量的值，那就需要在外部的局部变量前面加上__block的声明。 Block访问外部常量变量NSString *a = @&quot;hello&quot;; a 为常量变量，@“hello”为常量。）—–不加block类型 block 会引用常量的地址（浅拷贝）。加block类型 block会去引用常量变量（如：a变量，a = @”abc”.可以任意修改a 指向的内容。）的地址。 block 会拷贝变量内容到自己的栈内存上，以便执行时可以调用。 但并不是对str 内容做了深拷贝，重新申请内存。 因为str 是栈内存上的变量，指向 一个常量区的@“hello”. 编译器做的优化是 当block 去拷贝str 指向内容时发现是个常量， 所以会去引用 @“hello” 的指针，没必要再取申请一块内存。 Block访问外部对象变量如（MyClass class、Block block）。 这里block 也是”类“对象（类似对象，其包含isa指针,clang 反编译可以查看。因为它不像从NSObject 继承下来的对象都支持 retain、copy、release）。* Block的copy、retain、release操作不同于NSObjec的copy、retain、release操作： Block_copy与copy等效，Block_release与release等效； Block_copy与copy等效，Block_release与release等效； 对Block不管是retain、copy、release都不会改变引用计数retainCount，retainCount始终是1； NSGlobalBlock：retain、copy、release操作都无效； NSStackBlock：retain、release操作无效，必须注意的是，NSStackBlock在函数返回后，Block内存将被回收。即使retain也没用。容易犯的错误是[[mutableAarry addObject:stackBlock]，在函数出栈后，从mutableAarry中取到的stackBlock已经被回收，变成了野指针。正确的做法是先将stackBlock copy到堆上，然后加入数组：[mutableAarry addObject:[[stackBlock copy] autorelease]]。支持copy，copy之后生成新的NSMallocBlock类型对象 NSMallocBlock支持retain、release，虽然retainCount始终是1，但内存管理器中仍然会增加、减少计数。copy之后不会生成新的对象，只是增加了一次引用，类似retain； 尽量不要对Block使用retain操作 Block循环引用最简单也最常出现的,block导致循环引用的现象,就是在block中执行了self.xxx,比如 这个问题大家的见的多了,也都知道怎么解决,声明一个用__weak修饰的self替换block中的self就可以解决问题了,不过下面这个方法也能够解决循环引用的问题 总结Block的特性也赋予了它许多的灵活性，但是也会出现很多的一些内存泄漏，不易调试的问题，还要多多深入探究。]]></content>
      <categories>
        <category>Ios</category>
      </categories>
      <tags>
        <tag>Ios</tag>
        <tag>Objective-C</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IOS基础 - WKWebView使用]]></title>
    <url>%2F2019%2F02%2F28%2FIOS%E5%9F%BA%E7%A1%80-WKWebView%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[WKWebView对比UIWebView的优势 1.WKWebView的内存开销要比UIWebView小很多2.拥有高达60FPS滚动刷新率及内置手势3.支持了更多的HTML5特性4.html页面和WKWebView交互更方便5.Safari相同的JavaScript引擎6.提供常用的属性，如加载网页进度的属性estimatedProgress 基本使用倒入库 引入头文件#import &lt;WebKit/WebKit.h&gt; 初始化123456789101112131415161718192021222324@interface MainViewController () &lt;WKNavigationDelegate&gt;@property(strong, nonatomic) WKWebView *webview;@end@implementation MainViewController- (void)viewDidLoad &#123; [super viewDidLoad]; // Do any additional setup after loading the view. WKWebView *wv = [[WKWebView alloc] init]; wv.navigationDelegate = self; [self.view addSubview:wv]; [wv mas_makeConstraints:^(MASConstraintMaker *make) &#123; make.top.equalTo(wv.superview.mas_top).with.offset(0); make.left.equalTo(wv.superview.mas_left).with.offset(0); make.right.equalTo(wv.superview.mas_right).with.offset(0); make.bottom.equalTo(wv.superview.mas_bottom).with.offset(0); &#125;]; self.webview = wv; //加载网页 [self.webview loadRequest:[NSURLRequest requestWithURL:[NSURL URLWithString:@&quot;https://www.baidu.com&quot;]]];&#125; 关于WKWebView的代理WKNavigationDelegate12345678910111213141516171819202122#pragma mark - WKNavigationDelegate// 页面开始加载时调用- (void)webView:(WKWebView *)webView didStartProvisionalNavigation:(WKNavigation *)navigation;// 当内容开始到达时调用- (void)webView:(WKWebView *)webView didCommitNavigation:(WKNavigation *)navigation;// 页面加载完成之后调用- (void)webView:(WKWebView *)webView didFinishNavigation:(WKNavigation *)navigation;// 页面加载失败时调用- (void)webView:(WKWebView *)webView didFailProvisionalNavigation:(WKNavigation *)navigation withError:(NSError *)error;//收到服务器重定向请求后调用- (void)webView:(WKWebView *)webView didReceiveServerRedirectForProvisionalNavigation:(WKNavigation *)navigation;// 在收到响应开始加载后，决定是否跳转- (void)webView:(WKWebView *)webView decidePolicyForNavigationResponse:(WKNavigationResponse *)navigationResponse decisionHandler:(void (^)(WKNavigationResponsePolicy))decisionHandler;// 在请求开始加载之前调用，决定是否跳转- (void)webView:(WKWebView *)webView decidePolicyForNavigationAction:(WKNavigationAction *)navigationAction decisionHandler:(void (^)(WKNavigationActionPolicy))decisionHandler; WKUIDelegate12345678910- (nullable WKWebView *)webView:(WKWebView *)webView createWebViewWithConfiguration:(WKWebViewConfiguration *)configuration forNavigationAction:(WKNavigationAction *)navigationAction windowFeatures:(WKWindowFeatures *)windowFeatures;// 在js中调用alert函数时，会调用该方法。- (void)webView:(WKWebView *)webView runJavaScriptAlertPanelWithMessage:(NSString *)message initiatedByFrame:(WKFrameInfo *)frame completionHandler:(void (^)(void))completionHandler;// 在js中调用confirm函数时，会调用该方法- (void)webView:(WKWebView *)webView runJavaScriptConfirmPanelWithMessage:(NSString *)message initiatedByFrame:(WKFrameInfo *)frame completionHandler:(void (^)(BOOL result))completionHandler;// 在js中调用prompt函数时，会调用该方法- (void)webView:(WKWebView *)webView runJavaScriptTextInputPanelWithPrompt:(NSString *)prompt defaultText:(nullable NSString *)defaultText initiatedByFrame:(WKFrameInfo *)frame completionHandler:(void (^)(NSString * __nullable result))completionHandler;]]></content>
      <categories>
        <category>Ios</category>
      </categories>
      <tags>
        <tag>Ios</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IDEA技巧]]></title>
    <url>%2F2019%2F02%2F28%2FIDEA%E6%8A%80%E5%B7%A7%2F</url>
    <content type="text"><![CDATA[IDEA技巧WebStorm 通用技巧 几乎在所有面板包括弹出窗口里，都能直接键入名字进行快速跳转。例如 在查找结果中增量查找 在 Outline 窗口中快速跳转 在 Project、Recent File 中快速跳转 常用快捷键(Mac)：导航： 打开文件：Shift + ⌘ + O (被我改成了和 Chrome 相同的 ⌘ + O) 文件名前面或后面加上/可打开目录 打开符号：Alt + ⌘ + O 搜索任意：双击 Shift 跳转到声明：⌘ + Alt + B 跳转到实现：⌘ + B 搜索所有引用：我定义的是 Shift + F12 弹出文件结构列表(Outline)：⌘ + F12 弹出最近关闭的文件列表(Recent File)：⌘ + E 之后直接键入文件名可快速跳转到最近关闭的文件，找不到的话按回车则在项目中查找。 跳转到下一查找结果：Alt + ⌘ + Down 文件内代码替换 Ctrl + R 弹出外部资源菜单：(在 Tab 标签上) ⌘ + Click 添加书签：F3，浏览书签：⌘ + F3 跳转到代码块开头：Alt + ⌘ + [ 在左右（花）括号之间跳转：Ctrl + M 视图： 跳转回编辑面板: Esc 切换下一个代码标签：Ctrl + Tab 或 Shift + ⌘ + ] 切换上一个代码标签：Shift + ⌘ + [ 最大化/还原编辑面板：双击标签栏 显示所有视图边栏：显示双击并按住 ⌘ 关闭当前显示查找结果标签页：Ctrl + Shift + F4 编辑： 插入代码片段(Code Snippet)：⌘ + J 重构：Ctrl + T 重命名（变量等）：Shift + F6 重构预览时，从搜索结果中排除：Delete 格式化代码：Alt + ⌘ + L 缩进对齐：Ctrl + Alt + I 弹出 Intention Actions: Alt + Enter 同时选中下一个相同代码块：Ctrl + G 同时选中所有相同代码块：Ctrl + ⌘ + G 一些 Unix 终端快捷键：Ctrl + A/E/K 单纯粘贴（不自动缩进也不格式化代码）：Shift + Alt + ⌘ + V 行注释：⌘ + / 块注释：Alt + ⌘ + / 行操作： 复制(选中)行：⌘ + D 上移(选中)行：Shift + Alt + Up 上移(选中)语句：Shift + ⌘ + Up 在上面插入新行：Alt + ⌘ + Enter 在下面插入新行： Shift + Enter 删除行：⌘ + Delete 显示： 显示方法参数说明：⌘ + P 显示光标处的代码文档：F1 快速查看定义：Alt + Space 高亮当前文件中所有选中字段：Shift + ⌘ + F7 (然后⌘ + G跳转下一个) 扩大选中的代码块：Alt + Up（可以用来选词，按越多次选中的代码块范围越大） 折叠/展开代码块：⌘ + -/= 光标向上/向下移动同时滚动视图(Move Up)：我定义的是 Shift + ⌘ + I/K 其它： 激活搜索框 “Match Case”: Alt + C 激活搜索框 “Words”: Alt + R 重复最近的搜索：焦点在输入框时按 Down 新建草稿文件: ⌘ + Shift + N 调整 Layout 以突出编码区域，更适合宽屏： [Preferences] Appearance &amp; Behavior &gt; Appearance：勾选 Widescreen … layout [Menu] View: 把 Toolbar, Tool Buttons, Status Bar, Navigation bar 全关掉 允许解析 module 等 node 全局变量： [Preferences] Languages &amp; Frameworks &gt; JavaScript &gt; Libraries: 勾选 Node.js Globals 隐藏代码折叠的箭头： [Preferences] Editor &gt; Code Folding: 取消 Show code folding outline 从项目中排除第三方文件，优化代码搜索结果： [Preferences] Project &gt; Directories: 选中不需要的文件夹，点上面的 Excluded，例如这样设置：也可以在 [Project] 面板上的文件夹点击右键，选择 Mark Directory As &gt; Excluded 不在 [Project] 显示已排除的第三方文件： [Project] 点击 “Scope按钮”，选择 Project Files 按文件类型排序： [Project] 点击齿轮下拉菜单，选中 Sort by Type 和 Folders Always on Top 在 [Project] 中定位到当前编辑的脚本： 点击图中的小图标 去掉 spell checking： [Preference] Editor &gt; Inspections: 把 spelling 项的复选去掉 设置缩进和代码格式化操作： [Preference] Editor &gt; General &gt; Smart Keys: 按需设置 屏蔽对象定义时最后多写一个逗号引起的报错： [Preference] Editor &gt; Inspections &gt; JavaScript &gt; General: 取消 Last comma in object literal 减少 jshint 报错 在项目的 .idea/jsLinters/ 目录下添加 jshint.xml Postfix Completion [Preferences] Editor &gt; General &gt; Postfix Completion：启用你喜欢的选项 开启 ES6 支持 [Preferences] Languages &amp; Frameworks &gt; JavaScript：选择 ECMAScript 6（需要重启 WebStorm 才能生效） 自动识别当前文件的缩进类型 [Preferences] Editor &gt; Code Style：选择 Detect and use existing file indents for editing 滚动条快速滚动到选中位置 系统设置中选中该项 WebStrom 作为 merge 工具/Applications/WebStorm.app/Contents/MacOS/webstorm merge $(cd $(dirname &quot;$LOCAL&quot;) &amp;&amp; pwd)/$(basename &quot;$LOCAL&quot;) $(cd $(dirname &quot;$REMOTE&quot;) &amp;&amp; pwd)/$(basename &quot;$REMOTE&quot;) $(cd $(dirname &quot;$BASE&quot;) &amp;&amp; pwd)/$(basename &quot;$BASE&quot;) $(cd $(dirname &quot;$MERGED&quot;) &amp;&amp; pwd)/$(basename &quot;$MERGED&quot;) WebStrom 作为 diff 工具/Applications/WebStorm.app/Contents/MacOS/webstorm diff $(cd $(dirname &quot;$LOCAL&quot;) &amp;&amp; pwd)/$(basename &quot;$LOCAL&quot;) $(cd $(dirname &quot;$REMOTE&quot;) &amp;&amp; pwd)/$(basename &quot;$REMOTE&quot;)]]></content>
      <categories>
        <category>程序人生</category>
      </categories>
      <tags>
        <tag>IDEA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[解决AndroidStudio导入项目在 Building gradle project info 一直卡住]]></title>
    <url>%2F2019%2F02%2F28%2F%E8%A7%A3%E5%86%B3AndroidStudio%E5%AF%BC%E5%85%A5%E9%A1%B9%E7%9B%AE%E5%9C%A8-Building-gradle-project-info-%E4%B8%80%E7%9B%B4%E5%8D%A1%E4%BD%8F%2F</url>
    <content type="text"><![CDATA[Android studio一个小小的痛点 解决AndroidStudio导入项目在 Building gradle project info 一直卡住Android Studio导入项目的时候，一直卡在Building gradle project info这一步，主要原因还是因为被墙的结果。gradle官网虽然可以访问，但是速度连蜗牛都赶不上… 三种解决办法离线包下载导入方式 查看所需gradle版本：打开C:\Users\用户名.gradle\wrapper\dists\gradle-x.xx-all\xxxxxxxxxxxx，如果里面的gradle-xx-all.zip不完整（如0KB），则说明下载不成功，需要下载离线包放置到该目录下。 下载地址：https://services.gradle.org/distributions/ 修改gradle-wrapper.properties方式 1、随便找一个你之前能够运行的AS项目 2、打开项目的/gradle/wrapper/gradle-wrapper.properties文件 3、复制最后一行distributionUrl这一整行的内容，例如：distributionUrl=https\://services.gradle.org/distributions/gradle-2.8-all.zip，替换到你要导入的项目里的gradle-wrapper.properties文件中。 4、重启Android Studio，重新导入项目就可以了~~ 翻墙翻开中国伟大的墙就可以了。本人一直用的蓝灯。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Android Studio</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mac安装Mysql教程]]></title>
    <url>%2F2019%2F02%2F25%2FMac%E5%AE%89%E8%A3%85Mysql%E6%95%99%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[环境 MacOS10以上 下载Mysql这里以Mysql5.7为例 官网为了方便开发，推荐直接选择dmg文件下载安装 安装Mysql直接双击即可，傻瓜式操作。 注意，安装成功后会弹出一个对话框，你直接忽略了可以看通知面板，这个就是Mysql的初始密码如图 启动Mysql安装完毕后系统偏好设置会多出一个选项 点击进去 安装之后，默认MySQL的状态是stopped，关闭的，需要点击“Start MySQL Server”按钮来启动它，启动之后，状态会变成running。下方还有一个复选框按钮，可以设置是否在系统启动的时候自动启动MySQL，默认是勾选的，建议取消，节省开机时间。 终端连接Mysql1vim ~/.bash_profile 添加export PATH=${PATH}:/usr/local/mysql/bin即可 登陆Mysql1mysql -uroot -p 输入刚开始安装对话框中提示的初始密码，登陆成功后请修改密码，否则无法执行其他命令。 1ALTER USER 'root'@'localhost' IDENTIFIED BY 'newpassword';]]></content>
      <categories>
        <category>DBA</category>
      </categories>
      <tags>
        <tag>Mysql</tag>
        <tag>环境搭建</tag>
        <tag>Mac</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mac使用HomeBrew安装Composer]]></title>
    <url>%2F2019%2F02%2F25%2FMac%E4%BD%BF%E7%94%A8HomeBrew%E5%AE%89%E8%A3%85Composer%2F</url>
    <content type="text"><![CDATA[环境 MacOS10以上 安装HomeBrewhomebrew官网 链接 1/usr/bin/ruby -e "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)" 回车安装即可 安装Composer1brew install composer 安装完毕后composer可能不是最新版本，也可以升级 1composer self-update 修改Packagist 镜像修改 composer 的全局配置文件 打开命令行窗口（windows用户）或控制台（Linux、Mac 用户）并执行如下命令：1composer config -g repo.packagist composer https://packagist.phpcomposer.com 使用composer举例我要引用phalcon的开发工具包。在项目文件夹下新建文件composer.json，并添加如下代码 12345&#123; &quot;require&quot;: &#123; &quot;phalcon/devtools&quot;: &quot;dev-master&quot; &#125;&#125; 运行 1composer update 项目文件夹下就会有vendor文件夹，依赖文件都在这下面啦。使用时直接包含autoload.php就可以了 1require 'vendor/autoload.php'; 更多命令可以直接查看官方文档http://docs.phpcomposer.com/03-cli.html 参考链接： https://www.jianshu.com/p/2b96cc9f593e https://pkg.phpcomposer.com/ https://getcomposer.org/]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>环境搭建</tag>
        <tag>Mac</tag>
        <tag>Composer</tag>
        <tag>Homebrew</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mac使用HomeBrew安装Maven]]></title>
    <url>%2F2019%2F02%2F20%2FMac%E4%BD%BF%E7%94%A8HomeBrew%E5%AE%89%E8%A3%85Maven%2F</url>
    <content type="text"><![CDATA[环境 MacOS10以上 jdk1.6或以上 安装HomeBrewhomebrew官网 链接 1/usr/bin/ruby -e "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)" 回车安装即可 安装Maven12345678$ brew search maven==&gt; Formulaemaven ✔ maven-shell maven@3.3maven-completion maven@3.2 maven@3.5==&gt; Caskshomebrew/cask-fonts/font-maven-pro$ brew install maven 验证maven是否安装成功1mvn -v 配置Maven仓库setting.xml路径为/usr/local/Cellar/maven/3.5.0/libexec/conf/settings.xml修改即可。 可将settings.xml直接拷贝到.m2文件夹下，进行配置。 ~~如果没有.m2文件夹时,运行命令1$ mvn help:system 然后打开当前用户的目录，可以在其中找到.m2文件夹~~]]></content>
      <categories>
        <category>Maven</category>
      </categories>
      <tags>
        <tag>环境搭建</tag>
        <tag>Mac</tag>
        <tag>Homebrew</tag>
        <tag>Maven</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CocoaPods简单安装和使用]]></title>
    <url>%2F2019%2F01%2F18%2FCocoaPods%E7%AE%80%E5%8D%95%E5%AE%89%E8%A3%85%E5%92%8C%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[什么是CocoaPodsCocoaPods是专门为iOS工程提供对第三方库的依赖的管理工具，通过CocoaPods，我们可以更方便地管理每个第三方库的版本，而且不需要我们做太多的配置。直观、集中和自动化地管理我们项目的第三方库。 安装CocoaPods更新gem1sudo gem update --system 更换镜像删除自带镜像1gem sources --remove https://rubygems.org/ 更换1gem sources -a https://gems.ruby-china.com/ 查看1gem sources -l 如图显示即为替换镜像成功 安装1sudo gem install cocoapods 配置1pod setup 到这里CocoaPods就已经安装完毕了。 使用CocoaPods查找第三方库比如说要查找某个库，直接在终端输入 1pod search QMUIKit 完成后他会自动进入一个新的页面显示搜索结果，上下滑动查看更多，要退出的话按wq就可以了。以后再搜索就不需要建索引了。 引入第三方库到项目中这里演示第三方库为QMUIKit 打开xcode新建一个项目，打开终端，进入项目路径中。 输入1pod init 将自动生成一个Podfile文件，也可以自己生成，命令生成有默认模板 vim编写,添加qmuikit 安装第三方库1pod install 查看项目目录变化 在访达中 原本使用xcodeproj打开项目，但是现在要改变成xcworkspace打开项目了。 这样就可以正常使用该库啦。但是有时候没有只能提示时候，需要更改Build Settings中的User header search paths添加$(SRCROOT)并选择recursive 增加第三方继续编写Podfile文件添加第三方库然后在执行pod install就可以了 更新第三方第三方库们都有人在维护升级，我们需要隔断时间就要更新下我们工程中第三方库的版本。只需要终端输入命令pod update就可以了。如果遇到pod install或者pod update慢的问题，原因在于当执行以上两个命令的时候会升级CocoaPods的spec仓库，加一个参数可以省略这一步，然后速度就会提升不少。加参数的命令如下： 12pod install --verbose --no-repo-updatepod update --verbose --no-repo-update 删除第三方当我们需要去掉某个第三方库时，只需要在Podfile删除该引入该库的语句，然后执行pod update或者pod install就可以了。 升级CocoaPods升级CocoaPods版本的命令和安装CocoaPods的命令一样，都是1sudo gem install cocoapods 卸载CocoaPods卸载CocoaPods的命令是1sudo gem uninstall cocoapods CocoaPods Mac AppCocoaPods桌面应用版下载地址：https://cocoapods.org/app 参考 https://juejin.im/entry/5c067eb56fb9a04a0a5ef583?utm_source=gold_browser_extension https://guides.cocoapods.org/syntax/podfile.html#podfile]]></content>
      <categories>
        <category>Ios</category>
      </categories>
      <tags>
        <tag>Ios</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Tomcat基本使用]]></title>
    <url>%2F2018%2F11%2F21%2FTomcat%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[下载安装到apache官网。www.apache.org http://jakarta.apache.org(产品的主页) 安装版：window （exe、msi） linux（rmp）压缩版：window（rar，zip） linux（tar，tar.gz） 学习时候使用 运行和关闭tomcat启动软件a）找到%tomcat%/bin/startup.bat ，双击这个文件b）弹出窗口，显示信息（不要关闭次窗口）c）打开浏览器，输出以下地址 http://localhost:8080d）看到一只猫画面，证明软件启动成功！ 关闭软件a）找到%tomcat%/bin/shutdown.bat，双击这个文件即可！b）打开浏览器，输出以下地址。看到“无法连接”（最好先清空浏览器缓存） Tomcat目录结构bin存放常用tomcat命令 conf存放server配置文件 lib自带jar包 logs存放日志 temp存放临时文件 webapps存放共享资源目录 work工作空间 Tomcat常见问题一闪而过配置好JDK环境即可，即JAVA_HOME,PATH，CLASSPATH环境变量即可。 端口占用的错误原因： tomcat启动所需的端口被其他软件占用了！解决办法：a）关闭其他软件程序，释放所需端口b）修改tomcat软件所需端口找到并修改%tomcat%/conf/server.xml文件 123&lt;Connector port="8081" protocol="HTTP/1.1" connectionTimeout="20000" redirectPort="8443" /&gt; CATALINA环境变量问题原因： tomcat软件启动后，除了查找JAVA_HOME后，还会再查找一个叫CATALINA_HOME变量，这个变量的作用是设置tomcat的根目录。解决办法：建议不要设置CATALINA_HOME变量。检查如果有的话，清除掉！！！]]></content>
      <categories>
        <category>Tomcat</category>
      </categories>
      <tags>
        <tag>环境搭建</tag>
        <tag>Tomcat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[单例模式-JAVA实现]]></title>
    <url>%2F2018%2F11%2F20%2F%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F-JAVA%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[单例模式什么是单例？就是保证在一个jvm当中只能由一个实例。（区分不是在多个jvm当中。） 单例模式有七种写法。 本文只提出两种，一种懒汉式和饿汉式。 懒汉式123456789101112131415161718192021222324252627public class Single &#123; public static void main(String[] args) &#123; System.out.println(Singleton.getInstance()); System.out.println(Singleton.getInstance()); System.out.println(Singleton.getInstance()); System.out.println(Singleton.getInstance()); &#125;&#125;class Singleton &#123; private static Singleton mSingleton; private Singleton()&#123;&#125; public static Singleton getInstance() &#123; if (mSingleton == null) &#123; synchronized (Singleton.class) &#123; //加锁，线程不安全，故加上 mSingleton = new Singleton(); &#125; &#125; return mSingleton; &#125;&#125; 1234cn.net.sweetlover.patern.Singleton@1540e19dcn.net.sweetlover.patern.Singleton@1540e19dcn.net.sweetlover.patern.Singleton@1540e19dcn.net.sweetlover.patern.Singleton@1540e19d 被需要时才进行初始化，且只有同一个实例，但会发生线程不安全。 饿汉式12345678910111213141516171819202122public class Single &#123; public static void main(String[] args) &#123; System.out.println(Singleton.getInstance()); System.out.println(Singleton.getInstance()); System.out.println(Singleton.getInstance()); System.out.println(Singleton.getInstance()); &#125;&#125;class Singleton &#123; private final static Singleton mSingleton = new Singleton(); private Singleton()&#123;&#125; public static Singleton getInstance() &#123; return mSingleton; &#125;&#125; 1234cn.net.sweetlover.patern.Singleton@1540e19dcn.net.sweetlover.patern.Singleton@1540e19dcn.net.sweetlover.patern.Singleton@1540e19dcn.net.sweetlover.patern.Singleton@1540e19d 这两者的区分：懒汉式不是线程安全的，且效率比饿汉式要低（因为加了同步），但是节约内存。但饿汉式是天生线程安全的，因为当class被加载的时候就已经被初始化了。]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>JAVA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[kafka简单入门(概念)]]></title>
    <url>%2F2018%2F11%2F05%2Fkafka%E7%AE%80%E5%8D%95%E5%85%A5%E9%97%A8-%E6%A6%82%E5%BF%B5%2F</url>
    <content type="text"><![CDATA[kafka简介Kafka是目前主流的流处理平台，同时作为消息队列家族的一员，其高吞吐性作为很多场景下的主流选择。 什么是Kafka LinkedIn开发 2011年初开源，加入Apache基金会 2012年从Apache Incubator毕业 Apache顶级开源 Apache Kafka是一个分布式流媒体平台。这到底是什么意思呢？ 流媒体平台有三个关键功能： 发布和订阅记录流，类似于消息队列或者企业消息传递系统。 以容错的持久方式存储记录流。 记录发生时处理流。 Kafka通常用于两大类应用： 构建可在系统或应用程序之间可靠获取数据的实时流数据管道 构建转换或响应数据流的实时流应用程序 Kafka概念Producer消息和数据的生产者，向Kafka的一个topic发布消息的进程/代码/服务。 Consumer消息和数据的消费者，订阅数据（topic）并且处理其发布的消息的进程/代码/服务。 Consumer Group对于同一个topic，会广播给不同的group，一个group中，只有 一个consumer 可以消费该消息。 Broker物理概念，Kafka集群中每个kafka节点。 Topic逻辑概念，Kafka消息的类别，对数据进行区分、隔离。 Partition物理概念，Kafka下数据存储的基本单元。一个Topic数据，会被分散存储到多个Partition，每个Partition是 有序的 。 每一个Topic被切分为多个Partitions 消费者数目少于或者等于Partition的数目 Broker Group中的每一个Broker保存Topic的一个或多个Partitions Consumer Group的仅有一个Consumer读取Topic的一个或者多个Partitions，并且是唯一的Consumer Replication一个partition的多个副本。同一个Partition可能有多个Replica，多个Replica之间数据是一样的，相当于备份一样。 当集群中有Broker挂掉的情况，系统可以主动的使Replicas提供服务 系统默认设置每一个Topic的Replication系数为1，可以在创建Topic单独设置 特点 基本单位是Topic的Partition 所有的读和写都从Leader进，Followers只是作为备份 Follower必须能够及时复制Leader的数据 增加容错性和可扩展性。 Replication Leader一个Partition的多个Replica上，需要一个Leader负责该Partition上的Producer和Consumer交互。且有且只有一个。 ReplicaManager负责管理当前Broker所有分区的副本的信息，处理KafkaController发起的一些请求，副本状态的切换、添加/读取消息等。]]></content>
      <categories>
        <category>消息队列</category>
      </categories>
      <tags>
        <tag>kafka</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android点击两次返回退出应用]]></title>
    <url>%2F2018%2F10%2F30%2FAndroid%E7%82%B9%E5%87%BB%E4%B8%A4%E6%AC%A1%E8%BF%94%E5%9B%9E%E9%80%80%E5%87%BA%E5%BA%94%E7%94%A8%2F</url>
    <content type="text"><![CDATA[在一些app中，一般都是主页面都会有一个连续点击两次返回键就能够退出，也是防止返回键误触导致直接退出了应用。示例没有复杂的activity管理，点击两次后直接finish就完成了。 思路直接判断用户两次按键的时间差是否在一个预期值之内，是则退出，否则应该出现一些提示来提醒用户。 12345678910111213141516171819202122232425262728293031public class MainActivity extends BaseActivity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); &#125; //记录用户首次点击返回键的时间 private long mExitFirstTime = 0; //双击间隔 private long mExitIntervalMs = 2000; @Override public boolean onKeyUp(int keyCode, KeyEvent event) &#123; switch (keyCode)&#123; case KeyEvent.KEYCODE_BACK: long secondTime = System.currentTimeMillis(); if(secondTime - mExitFirstTime &gt; mExitIntervalMs)&#123; mExitFirstTime = secondTime; Toast.makeText(MainActivity.this, R.string.exit_tip, Toast.LENGTH_SHORT) .show(); return true; //消费掉该事件 &#125;else&#123; finish(); &#125; break; &#125; return super.onKeyUp(keyCode, event); &#125;&#125; 重写onKeyDown()和onBackPressed()方法都能捕获Back的点击事件，]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[正则表达式]]></title>
    <url>%2F2018%2F09%2F28%2F%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[参考链接: https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Regular_Expressions 特殊字符 字符 含义 \ 匹配规则将依照下列规则：在非特殊字符之前的反斜杠表示下一个字符是特殊的，不能从字面上解释。例如，没有前面’\’的’b’通常匹配小写’b’，无论它们出现在哪里。如果加了’\’,这个字符变成了特殊意义的字符，意思是匹配一个字符边界。反斜杠也可以将其后的特殊字符，转义为字面量。例如，模式 /a/ 代表会匹配0个或者多个a。相反，模式 /a\/ 将 ‘‘ 的特殊性移除，从而可以匹配像 “a“ 这样的字符串。 ^ 匹配输入的开始，如果多行标志被设置为true，那么也匹配换行符后紧跟的位置。例如, /^A/ 并不匹配 “an A” 中的 ‘A’，但是会匹配 “An E”中的 ‘A’。当 ‘^’ 作为第一个字符出现在一个字符集合模式时，它将会有不同的含义。 $ 匹配输入的结束。如果多行标志被设置为true，那么也匹配换行符前的位置。例如， /t$/ 并不会匹配 “eater” 中的 ‘t’,但是会匹配 “eat” 中的 ‘t’。 * 匹配前一个表达式0次或者多次。等价于{0,}。例如，/bo*/ 会匹配”A ghost boooooed”中的 ‘booooo’ 和 “A bird warbled” 中的 ‘b’，但是在”A goat grunted” 中将不会匹配任何东西。 + 匹配前面一个表达式1次或者多次。等价于{1,}。例如，/a+/匹配了在”candy”中的’a’，和在”caaaaaaandy”中所有的’a’。 ? 匹配前面一个表达式0次或者1次。等价于{0,1}。例如，/e?le?/ 匹配”angel”中的’el’，和”angel”中的’el’，和”angle”中的’le’以及”oslo”中的’l’。如果紧跟在任何量词*、+、?或者{}的后面，将会使变量变为非贪婪的（匹配尽量少的字符），和缺省使用的贪婪模式（匹配尽可能多的字符）正好相反。例如，对”123abc”应用 /\d+/ 将会返回’123’，如果使用/\d+?/，则只会匹配到’1’。还可以运用先行断言。 . (小数点)匹配除换行符之外的任何单个字符。例如，/.n/将会匹配”nay, an apple is on the tree”中的’an’和’on’，但是不会匹配’nay’。 (x) 匹配’x’并且记住匹配项，就像下面的例子展示的那样。括号被称为捕获括号。模式 /(foo) (var) \1 \2/中的’(foo)’和’(bar)’匹配并记住字符串”foo bar foo bar”中的前两个单词，模式中的\1 和 \2 匹配字符串的后两个单词。注意\1、\2、\n是用在正则表达式的匹配环节。 (?:x) 匹配’x’但是不记住匹配项。这种叫做非捕获括号，使得你能够定义为正则表达式运算符一起使用的子表达式。来看表达式/(?:foo){1,2}/。如果表达式是/foo{1,2}/，{1,2}将只对’foo’的最后一个字符’o’生效。如果使用非捕获括号，则{1,2}会匹配整个’foo’单词。 x(?=y) 匹配’x’仅仅当’x’后面跟着’y’，这种叫做正向肯定查找。例如，/Jack(?=Spart)/会匹配到’Jack’仅仅当他后面跟着’Spart’。/Jack(?=Spart&#124;Frost)/匹配’Jack’仅仅当它后面跟着’Spart’或者是’Frost’。但是’Spart’和’Frost’都不是匹配结果的一部分。 x(?!y) 匹配’x’仅仅当’x’后面不跟着’y’，这个叫做正向否定查找。例如，/\d+(?!.)/匹配一个数字仅仅当这个数字后面没有跟小数点的时候。 x&#124;y 匹配’x’或者’y’。例如，/green&#124;red/匹配”green apple”中的’green’和”red apple”中的’red’ {n} n是一个正整数，匹配了前面一个字符刚好发生n次。 比如，/a{2}/不会匹配”candy”中的’a’，但是会匹配”caandy”中的所有a，以及”caaandy”中的前两个a。 {n,m} n,m都是整数。匹配前面的字符至少n次，最多m次。如果n和m的值为0，这个值被忽略。例如，/a{1,3}/ 并不匹配”cndy”中的任意字符，匹配”candy”中的’a’，匹配”caandy”中的前两个’a’，也匹配”caaaaaaaandy”中的前三个a。 [xyz] 一个字符集合。匹配方括号中的任意字符，包括转义字符。你可以使用破折号( - )来指定一个字符范围。对于( . )和星号( * )这样的特许符号在一个字符集中没有特殊的意义/他们不必进行转义，不过转义也是起作用的。例如，[abcd]和[a-d]是一样的。他们都匹配”brisket”中的’b’，也都匹配”city”中的’c’。/[a-z.]+/和/[\w.]+/都匹配”test.i.ng”中的所有字符。 [^xyz] 反向字符集。也就是说，它匹配任何没有包含在反括号中的字符。你可以使得破折号( - )来指定一个字符范围。任何普通字符在这里都是起作用的。例如，[^abc]和[^a-c]是一样的。他们匹配”brisker”中的’r’，也匹配”chop”中的’h’。 [\b] 匹配一个退格（U+0008）。不要和\b混淆了。 \b 匹配一个词的边界。一个词的边界就是一个词不被另外一个“字”字符跟随的位置或者没有其他“字”字符在其前面的位置。注意，一个匹配的词的边界并不包含在匹配的内容中。换句话说，一个匹配的词的边界的内容的长度为0.（不要和[\b]混淆了）。例如，/\bm/匹配”moon”中的”m”，/oo\b/并不匹配”oo”，因为’oo’被一个字符’n’紧跟着。/oon\b/匹配”moon”中的’oon’，因为’oon’是这个字符串的结束部分，这样他没有被一个字符紧跟着。/\w\b\w/将不能匹配任何字符串，因为在一个单词中间的字符永远不可能同时满足没有字符跟随和有字符跟随的两种跟随情况。 \B 匹配一个非单词边界。他匹配一个前后字符都是相同类型的位置：都是字符或者都不是字符。一个字符串的开始和结尾都被认为不是字符或者空字符串。例如，/\B../匹配”noonday”中的’oo’，而/y\B../则会匹配”possibly yestarday”中的’yes’。 \cX 当X是处于A到Z之间的字符的时候。匹配字符串中的一个控制符。例如，/\cM/匹配字符串中的”control-M”(U+000D)。 \d 匹配一个数字，相当于[0-9]。例如，/\d/或者/[0-9]/匹配”B2 is the bigjj”中的’2’。 \D 匹配一个非数字字符。相当于[^0-9]。例如，/\D/或者/[^0-9]/匹配”B2 is a jj”中的B。 \f 匹配一个换页符(U+000C)。 \n 匹配一个换行符(U+000A)。 \r 匹配一个回车符(U+000D)。 \s 匹配一个空白字符，包括空格、制表符、换页符和换行符。等价于[\f\n\r\t\v\u00a0\u1680\u1680\u180e\u2000-\u200a\u2028\u2029\u202f\u205f\u3000\ufeff]。例如，/\s\w*/匹配”foo bar.”中的’bar’。 \S 匹配一个非空白字符。等价于[^\f\n\r\t\v\u00a0\u1680\u1680\u180e\u2000-\u200a\u2028\u2029\u202f\u205f\u3000\ufeff]。例如，/\S\w*/匹配”foo bar.”中的’foo’。 \t 匹配一个水平制表符(U+0009)。 \v 匹配一个垂直制表符(U+000B)。 \w 匹配一个单字字符(字母、数字或者下划线)。等价于[A-Za-Z0-9_]。例如，/\w/匹配”apple”中的’a’，”$5.28”中的’5’和”3D”中的’3’。 \W 匹配一个非单字字符。等价于[^A-Za-z0-9_]。例如，/\W/或者/[^A-Za-z0-9_]/匹配”50%”中的’%’。 \n 在正则表达式中，它返回最后的第n个子捕获匹配的子字符串(捕获的数目以左括号计数)。比如/apple(,)\sorange\1/匹配”apple, orange, cherry, peach.”中的’apple, orange’。 \0 匹配NULL(U+0000)字符，不要在这后面跟其它小数，因为0&lt;digits&gt;是一个八进制转义序列。 \xhh 与代码hh匹配字符(两个十六进制数字)。 \uhhhh 与代码hhhh匹配字符(四个十六进制数字)。 \u{hhhh} (仅当设置了u标志时)使用Unicode值hhhh匹配字符(十六进制数字)。 常用正则表达式校验数字的表达式 数字：^[0-9]*$ n位的数字：^\d{n}$ 至少n位的数字：^\d{n,}$ m-n位的数字：^\d{m,n}$ 零和非零开头的数字：^(0|[1-9][0-9]*)$ 非零开头的最多带两位小数的数字：^([1-9][0-9]*)+(.[0-9]{1,2})?$ 带1-2位小数的正数或负数：^(-)?\d+(.\d{1,2})$ 正数、负数、和小数：^(-|+)?\d+(.\d+)?$ 有两位小数的正实数：^[0-9]+(.[0-9]{2})?$ 有1~3位小数的正实数：^[0-9]+(.[0-9]{1,3})?$ 非零的正整数：^[1-9]\d$ 或 ^([1-9][0-9]){1,3}$ 或 ^+?[1-9][0-9]*$ 非零的负整数：^-[1-9][]0-9”$ 或 ^-[1-9]\d$ 非负整数：^\d+$ 或 ^[1-9]\d*|0$ 非正整数：^-[1-9]\d*|0$ 或 ^((-\d+)|(0+))$ 非负浮点数：^\d+(.\d+)?$ 或 ^[1-9]\d.\d|0.\d[1-9]\d|0?.0+|0$ 非正浮点数：^((-\d+(.\d+)?)|(0+(.0+)?))$ 或 ^(-([1-9]\d.\d|0.\d[1-9]\d))|0?.0+|0$ 正浮点数：^[1-9]\d.\d|0.\d[1-9]\d$ 或 ^(([0-9]+.[0-9][1-9][0-9])|([0-9][1-9][0-9].[0-9]+)|([0-9][1-9][0-9]))$ 负浮点数：^-([1-9]\d.\d|0.\d[1-9]\d)$ 或 ^(-(([0-9]+.[0-9][1-9][0-9])|([0-9][1-9][0-9].[0-9]+)|([0-9][1-9][0-9])))$ 浮点数：^(-?\d+)(.\d+)?$ 或 ^-?([1-9]\d.\d|0.\d[1-9]\d|0?.0+|0)$ 校验字符的表达式 汉字：^[\u4e00-\u9fa5]{0,}$ 英文和数字：^[A-Za-z0-9]+$ 或 ^[A-Za-z0-9]{4,40}$ 长度为3-20的所有字符：^.{3,20}$ 由26个英文字母组成的字符串：^[A-Za-z]+$ 由26个大写英文字母组成的字符串：^[A-Z]+$ 由26个小写英文字母组成的字符串：^[a-z]+$ 由数字和26个英文字母组成的字符串：^[A-Za-z0-9]+$ 由数字、26个英文字母或者下划线组成的字符串：^\w+$ 或 ^\w{3,20}$ 中文、英文、数字包括下划线：^[\u4E00-\u9FA5A-Za-z0-9_]+$ 中文、英文、数字但不包括下划线等符号：^[\u4E00-\u9FA5A-Za-z0-9]+$ 或 ^[\u4E00-\u9FA5A-Za-z0-9]{2,20}$ 可以输入含有^%&amp;’,;=?$\”等字符：[^%&amp;’,;=?$\x22]+ 禁止输入含有~的字符：[^~\x22]+ 特殊需求表达式 Email地址：^\w+([-+.]\w+)@\w+([-.]\w+).\w+([-.]\w+)*$ 域名：[a-zA-Z0-9][-a-zA-Z0-9]{0,62}(/.[a-zA-Z0-9][-a-zA-Z0-9]{0,62})+/.? InternetURL：[a-zA-z]+://[^\s] 或 ^http://([\w-]+.)+[\w-]+(/[\w-./?%&amp;=])?$ 手机号码：^(13[0-9]|14[5|7]|15[0|1|2|3|5|6|7|8|9]|18[0|1|2|3|5|6|7|8|9])\d{8}$ 电话号码(“XXX-XXXXXXX”、”XXXX-XXXXXXXX”、”XXX-XXXXXXX”、”XXX-XXXXXXXX”、”XXXXXXX”和”XXXXXXXX)：^((\d{3,4}-)|\d{3.4}-)?\d{7,8}$ 国内电话号码(0511-4405222、021-87888822)：\d{3}-\d{8}|\d{4}-\d{7} 电话号码正则表达式（支持手机号码，3-4位区号，7-8位直播号码，1－4位分机号）: ((\d{11})|^((\d{7,8})|(\d{4}|\d{3})-(\d{7,8})|(\d{4}|\d{3})-(\d{7,8})-(\d{4}|\d{3}|\d{2}|\d{1})|(\d{7,8})-(\d{4}|\d{3}|\d{2}|\d{1}))$) 身份证号(15位、18位数字)，最后一位是校验位，可能为数字或字符X：(^\d{15}$)|(^\d{18}$)|(^\d{17}(\d|X|x)$) 帐号是否合法(字母开头，允许5-16字节，允许字母数字下划线)：^[a-zA-Z][a-zA-Z0-9_]{4,15}$ 密码(以字母开头，长度在6~18之间，只能包含字母、数字和下划线)：^[a-zA-Z]\w{5,17}$ 强密码(必须包含大小写字母和数字的组合，不能使用特殊字符，长度在 8-10 之间)：^(?=.\d)(?=.[a-z])(?=.*[A-Z])[a-zA-Z0-9]{8,10}$ 强密码(必须包含大小写字母和数字的组合，可以使用特殊字符，长度在8-10之间)：^(?=.\d)(?=.[a-z])(?=.*[A-Z]).{8,10}$ 日期格式：^\d{4}-\d{1,2}-\d{1,2} 一年的12个月(01～09和1～12)：^(0?[1-9]|1[0-2])$ 一个月的31天(01～09和1～31)：^((0?[1-9])|((1|2)[0-9])|30|31)$ xml文件：^([a-zA-Z]+-?)+[a-zA-Z0-9]+\.[x|X][m|M][l|L]$ 中文字符的正则表达式：[\u4e00-\u9fa5] 双字节字符：[^\x00-\xff] (包括汉字在内，可以用来计算字符串的长度(一个双字节字符长度计2，ASCII字符计1)) 空白行的正则表达式：\n\s*\r (可以用来删除空白行) HTML标记的正则表达式：&lt;(\S?)[^&gt;]&gt;.?|&lt;.? /&gt; ( 首尾空白字符的正则表达式：^\s|\s$或(^\s)|(\s$) (可以用来删除行首行尾的空白字符(包括空格、制表符、换页符等等)，非常有用的表达式) 腾讯QQ号：[1-9][0-9]{4,} (腾讯QQ号从10000开始) 中国邮政编码：[1-9]\d{5}(?!\d) (中国邮政编码为6位数字) IP地址：((?:(?:25[0-5]|2[0-4]\d|[01]?\d?\d)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d?\d)) 钱的输入格式 有四种钱的表示形式我们可以接受:”10000.00” 和 “10,000.00”, 和没有 “分” 的 “10000” 和 “10,000”：^[1-9][0-9]*$ 这表示任意一个不以0开头的数字,但是,这也意味着一个字符”0”不通过,所以我们采用下面的形式：^(0|[1-9][0-9]*)$ 一个0或者一个不以0开头的数字.我们还可以允许开头有一个负号：^(0|-?[1-9][0-9]*)$ 这表示一个0或者一个可能为负的开头不为0的数字.让用户以0开头好了.把负号的也去掉,因为钱总不能是负的吧。下面我们要加的是说明可能的小数部分：^[0-9]+(.[0-9]+)?$ 必须说明的是,小数点后面至少应该有1位数,所以”10.”是不通过的,但是 “10” 和 “10.2” 是通过的：^[0-9]+(.[0-9]{2})?$ 这样我们规定小数点后面必须有两位,如果你认为太苛刻了,可以这样：^[0-9]+(.[0-9]{1,2})?$ 这样就允许用户只写一位小数.下面我们该考虑数字中的逗号了,我们可以这样：^[0-9]{1,3}(,[0-9]{3})*(.[0-9]{1,2})?$ 1到3个数字,后面跟着任意个 逗号+3个数字,逗号成为可选,而不是必须：^([0-9]+|[0-9]{1,3}(,[0-9]{3})*)(.[0-9]{1,2})?$ “+”可以用”*”替代如果你觉得空字符串也可以接受的话(奇怪,为什么?)最后,别忘了在用函数时去掉去掉那个反斜杠,一般的错误都在这里]]></content>
      <categories>
        <category>程序人生</category>
      </categories>
      <tags>
        <tag>正则表达式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Go并发之channel]]></title>
    <url>%2F2018%2F09%2F25%2FGo%E5%B9%B6%E5%8F%91%E4%B9%8Bchannel%2F</url>
    <content type="text"><![CDATA[channel是什么channel是Go中一个非常重要的特性，在Go并发之goroutine里有介绍了CSP模型，CSP 是 Communicating Sequential Process 的简称，中文可以叫做通信顺序进程，是一种并发编程模型。Go实现了CSP部分的理论，goroutine对应CSP中并发执行的实体，channel也就对应着CSP中的channel。 channel操作符操作符 &lt;- 1234567ch := make(chan int)//读x &lt;- chan//写chan &lt;- 10 channel创建必须使用make创建channel 12bufChan := make(chan int, 10) //1、带缓冲channelnoBufChan := make(chan string) //2、无缓冲channel 和map类似，channel也是一个对应make创建的底层数据结构的引用，当我们复制一个channel或者用于函数参数传递时，只是拷贝了一个channel的引用，channel的零值为nil。 以方式1创建的channel是带缓冲的，方式2即为无缓冲的。 示例代码1：12345678910111213141516package mainimport "fmt"func main() &#123; channel := make(chan int) //创建一个int类型的channel //匿名函数 go func() &#123; channel &lt;- 10 fmt.Println("chan &lt;-") //子协程 &#125;() &lt;- channel //没有数据前阻塞 fmt.Println("&lt;- chan")&#125; 运行结果： 再来看一下下面这个例子 12345678910111213141516package mainimport "fmt"func main() &#123; var channel chan int go func() &#123; channel &lt;- 10 fmt.Println("chan &lt;-") &#125;() &lt;- channel fmt.Println("&lt;- chan")&#125; 运行结果： 为什么会deadlock，因为channel并没有创建。 不带缓冲channel一个基于无缓存的channel的发送操作将导致发送者goroutine阻塞，直到另一个goroutine在相同的channel上执行接收操作，当发送的值通过channel成功传输之后，两个goroutine可以继续执行后面的语句。反之，如果接受操作先发生，那么接收者goroutine也将阻塞，直到有另一个goroutine在相同的channel上执行发送操作。 基于无缓存channel的发送和接收操作将导致两个goroutine做一次同步操作。因为这个原因，无缓存channel有时候也被成为同步channel。当通过一个无缓存channel发送数据时，接收者收到数据发生在唤醒发送者goroutine之前。 channel接受和发送数据都是阻塞的，除非另一端已经准备好，这样使得goroutine同步变得更加的简单，不用显式的lock。 谓阻塞就是读取，会被阻塞，直到有数据接收。其次，任何发送将会被阻塞，直到数据被读出。 无缓冲的channel是多个goroutine之间同步很棒的工具。 示例代码：12345678910111213141516171819202122package mainimport "fmt"func sum(a []int, ch chan int)&#123; total := 0 fmt.Println(a) for _,v := range a &#123; total += v &#125; ch&lt;- total&#125;func main() &#123; ch := make(chan int) a := []int&#123;1,2,3,4,5,6&#125; go sum(a[:3], ch) go sum(a[3:], ch) x := &lt;-ch y := &lt;-ch fmt.Println(x, y)&#125; 运行结果： 结果有两种，这只是其中一种。 带缓冲的channel在Go中也允许指定channel的缓冲大小 1ch := make(chan type, value) 当 value = 0 时，channel就是无缓冲的channel，当 value &gt; 0 时， channel有缓冲、是非阻塞的，直到写满value个元素后才阻塞写入。 示例代码：123456789101112package mainimport "fmt"func main() &#123; ch := make(chan int, 2) //缓冲大小为2 ch&lt;- 10 ch&lt;- 20 fmt.Println(&lt;-ch) fmt.Println(&lt;-ch)&#125; 运行结果： 如果代码中将缓存区域设置为1，则会出现deadlock错误。fatal error: all goroutines are asleep - deadlock! 单向channel默认情况下是双向的，即可读可写，读代表receive，写代表send。 通常情况我们会将一个通道作为函数参数传递过去，但是默认是双向的，我只想让该参数只能进行读或者写，那就用到了单向channel。 123var ch1 chan int //默认双向var ch2 chan&lt;- int //单向，只读var ch3 &lt;-chan int //单项，只写 双向channel可以隐式转换为单向channel，反之则不行。 关闭channel关闭channel只需要close函数即可，可以使用多返回值的方式 v,ok := &lt;-ch方式来判断channel是否被关闭。 示例代码：1234567891011121314151617181920package mainimport "fmt"func foreach(arr []int, b chan bool)&#123; for i,v := range arr &#123; fmt.Printf("i=%d, v=%d \n", i, v) &#125; b&lt;- true close(b)&#125;func main() &#123; arr := []int&#123;12,4,6,7,9,2&#125; ch := make(chan bool, 10) go foreach(arr, ch) if v, ok := &lt;-ch; !ok &#123; fmt.Println(v) &#125;&#125; 当一个channel被关闭后，再向该channel发送数据将导致panic异常。 其实你并不需要关闭每一个channel。只要当需要告诉接收者goroutine，所有的数据已经全部发送时才需要关闭channel。不管一个channel是否被关闭，当它没有被引用时将会被Go语言的垃圾自动回收器回收。（不要将关闭一个打开文件的操作和关闭一个channel操作混淆。对于每个打开的文件，都需要在不使用的使用调用对应的Close方法来关闭文件。）试图重复关闭一个channel将导致panic异常，试图关闭一个nil值的channel也将导致panic异常。关闭一个channels还会触发一个广播机制 Range遍历channel可以通过range，像操作slice或者map一样操作缓存类型的channel 使用range实现斐波那契数列 示例代码：1234567891011121314151617181920package mainimport "fmt"func fibonacci(n int, f chan int)&#123; x, y := 1, 1 for i:=0; i&lt;n; i++ &#123; f &lt;- x x, y = y, x+y &#125; close(f)&#125;func main() &#123; ch := make(chan int, 10) go fibonacci(cap(ch), ch) for v := range ch &#123; fmt.Printf("%d ", v) &#125;&#125; SelectGo提供了一个关键字select，通过select可以监听channel上的数据流动。 语法和恶switch非常相似，每个条件由case来描述。但是select有很多限制，其中一条就是每个case语句里必须是一个IO操作。 大致结构12345678selct &#123; case &lt;-ch: //如果读数据，则执行 case ch&lt;- 1: //如果写数据，则执行 default: //默认处理流程，但是一般情况select不用该条件，因为无意义&#125; 在一个select语句中，Go会按顺序从头到尾评估每一条发送和接收的语句。 但是其中任意一语句都可以，是任意都可以(即没有被堵塞)，那么就从那么可以执行的语句中任意选择来使用。 如果没有任意一条语句可以执行，那么可能有两种情况。 如果给出了default语句，则会执行default语句，同时程序的执行会从select语句后的语句中恢复。 如果没有default语句，那么select语句将被阻塞，直到有一个通信可以进行下去。 使用select实现斐波那契数列示例代码：12345678910111213141516171819202122232425262728293031323334package mainimport "fmt"func fibonacci(n chan int, b chan bool) &#123; x, y := 1, 1 for &#123; select &#123; case n&lt;- x: x, y = y, x+y case &lt;-b: fmt.Println("end") return &#125; &#125;&#125;//使用select实现斐波那契func main() &#123; n := make(chan int, 10) b := make(chan bool) go func() &#123; for i := 0; i &lt; cap(n); i++ &#123; fmt.Println(&lt;-n) &#125; b&lt;- true &#125;() fibonacci(n, b)&#125; 运行结果：]]></content>
      <categories>
        <category>Golang</category>
      </categories>
      <tags>
        <tag>Golang基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Go并发之goroutine]]></title>
    <url>%2F2018%2F09%2F24%2FGo%E5%B9%B6%E5%8F%91%E4%B9%8Bgoroutine%2F</url>
    <content type="text"><![CDATA[Go语言并发优势作为云计算时代的C语言之称的Go语言，第一是因为Go语言设计简单，第二21实际最重要的就是并发程序设计，而Go在语言层面上就支持了并发。在此同时，并发程序的内存管理有时候是非常复杂的，而Go自身也提供了自动垃圾回收机制。 Go语言为并发编程而内置的上层API是基于CSP模型，这里引用了知乎原文链接,CSP(Communicating Sequential Process)模型和Actor模型是两门非常复古且外形接近的并发模型。但CSP与Actor有以下几点比较大的区别： CSP并不Focus发送消息的实体/Task，而是关注发送消息时消息所使用的载体，即channel。 在Actor的设计中，Actor与信箱是耦合的，而在CSP中channel是作为first-class独立存在的。 另外一点在于，Actor中有明确的send/receive的关系，而channel中并不区分这样的关系，执行块可以任意选择发送或者取出消息。 另外默认情况下的channel是无缓存的,对channel的send动作是同步阻塞的，直到另外一个持有该channel引用的执行块取出消息(channel为空)，反之，receive动作亦然。藉此，我们可以得到一个基本确定的事实，by default时，实际的receive操作只会在send之后才被发生。而Actor中，由于send这个动作是异步的，因此Actor的receive会按照信箱接受到消息的顺序来进行处理。当然，除此以外，channel还有种Buffered Channel的模式，在默认情况的基础上，你可以确定channel内的消息数量，当channel中消息数量不满足于初始化时Buffer数目时，send动作不会被阻塞，写入操作会立即完成(因此Buffered Channel在很大程度上与Actor非常接近)，直到Buffer数目已满，则send动作开始阻塞。 这也意味着显示锁都是可以避免的，因为Go语言通过安全的通道发送和接受以实现同步，也简化了并发程序的编写。 而一般情况下，桌面计算机跑十几二十个线程就有点负载了，而同样的一台计算机，却可以轻松跑起成百上千甚至万个goroutine进行资源竞争。 goroutine是什么goroutine是Go并行设计的设置核心，它其实就是协程，但是它比线程更小，十几个goroutine可能体现在底层就是五六个线程，Go语言内部帮你实现了这些goroutine之间的内存共享。执行goroutine只需极少的栈内存，当然会根据相应的数据伸缩。也正是如此，可以同时运行成千上万个并发任务。goroutine比thread更易用、更高效、更轻便。 goroutine的创建只需要函数调用前加一个 go 关键字，就可以创建并发执行单元。无需了解其他细节，调度器会自动安排到合适的系统线程上执行。 像java语言一样，go也有其main函数，有着其main thread。在go语言中，main函数既在一个单独的goroutine中运行，也可以成为main goroutine。新的goroutine用go语句来创建。 示例代码1：12345678910111213package mainimport ( "fmt" "time")func main() &#123; for &#123; //死循环 fmt.Println("this is main goroutine") time.Sleep(time.Second) &#125;&#125; 运行结果： 手动退出，这是一个主协程，那么再看下面一个代码示例代码2：1234567891011121314151617181920212223package mainimport ( "fmt" "time")func newTask()&#123; for &#123; fmt.Println("this is a new Task") time.Sleep(time.Second) &#125;&#125;func main() &#123; for &#123; fmt.Println("this is main goroutine") time.Sleep(time.Second) &#125; newTask()&#125; 运行结果： 毫无疑问示例2与示例1中运行结果没有区别，而如何让他们同时执行呢 示例代码3：12345678910111213141516171819202122232425package mainimport ( "fmt" "time")func newTask()&#123; for &#123; fmt.Println("this is a new Task") time.Sleep(time.Second) &#125;&#125;func main() &#123; go newTask() //新建一个协程 //需要将代码放置前面，如果放置后面，死循环同样没办法执行这条语句 for &#123; fmt.Println("this is main goroutine") time.Sleep(time.Second) &#125;&#125; 运行结果： 一个新的协程只需要一个关键字go就已经完成了。 main goroutine先退出我们再看一个奇怪的现象 示例代码4：12345678910111213141516171819package mainimport ( "fmt" "time")func newTask()&#123; for &#123; fmt.Println("this is a new Task") time.Sleep(time.Second) &#125;&#125;func main() &#123; go newTask()&#125; 运行结果： 为什么结果什么都没有，我们明明已经开了一个新的协程来进行执行newTask函数，这就是go中main函数执行的太快了，也就是main goroutine已经执行完了，所有的goroutine都会直接打断，程序退出。 为了防止main goroutine过快的结束，123456789101112131415161718192021package mainimport ( "fmt" "time")func newTask()&#123; for &#123; fmt.Println("this is a new Task") time.Sleep(time.Second) &#125;&#125;func main() &#123; go newTask() time.Sleep(5 * time.Second)&#125; 运行结果： 让main goroutine睡了5秒，而newTask也刚好执行了5次，也解释了当main goroutine结束时，所有的goroutine都会直接打断，程序退出。]]></content>
      <categories>
        <category>Golang</category>
      </categories>
      <tags>
        <tag>Golang基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Go环境搭建]]></title>
    <url>%2F2018%2F09%2F22%2FGo%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[Go语言优势GO语言（Golang）是云计算时代的C语言。它不仅有着更高的生产效率，也对多处理器系统应用程序的编程进行了优化，语言层面支持并发，内置runtime，支持GC，并且语法简单易学，并不像java有着那么复杂的语法。 Go可以做什么 服务器编程 分布式系统 网络编程 内存数据库 云平台 and so on 环境搭建教程基于win10，linux等系统请参考其他文章官网，自行下载msi文件，傻瓜式安装，安装路径不要出现中文避免出差错。需要翻墙，没有可以选择Golang中文网测试安装：打开终端输入12$ go versiongo version go1.11 windows/amd64 即可完成安装 环境配置打开终端输入123456789101112131415161718192021222324252627$ go envset GOARCH=amd64set GOBIN=set GOCACHE=C:\Users\Administrator\AppData\Local\go-buildset GOEXE=.exeset GOFLAGS=set GOHOSTARCH=amd64set GOHOSTOS=windowsset GOOS=windowsset GOPATH=E:\Goset GOPROXY=set GORACE=set GOROOT=G:\Golangset GOTMPDIR=set GOTOOLDIR=G:\Golang\pkg\tool\windows_amd64set GCCGO=gccgoset CC=gccset CXX=g++set CGO_ENABLED=1set GOMOD=set CGO_CFLAGS=-g -O2set CGO_CPPFLAGS=set CGO_CXXFLAGS=-g -O2set CGO_FFLAGS=-g -O2set CGO_LDFLAGS=-g -O2set PKG_CONFIG=pkg-configset GOGCCFLAGS=-m64 -mthreads -fno-caret-diagnostics -Qunused-arguments -fmessage-length=0 -fdebug-prefix-map=C:\Users\ADMINI~1\AppData\Local\Temp\go-build669911038=/tmp/go-build -gno-record-gcc-switches msi包基本会把环境配置完成，但要配置GOPATH目录，不要用默认配置的计算机(右键)-属性-高级系统设置-环境变量在 用户变量 下添加 GOPATH 值为你想要的路径即可。在配置目录下创建三个文件夹，分别是 src目录 此目录是自己在GoPath目录下手动创建的，用于放源代码文件。 pkg目录 此目录是在src的源文件目录下对.go文件通过go install之后自动生成的，放编译后的包文件。 bin目录 此目录是在src的源文件目录下对 .go文件通过go build和go install之后自动生成的，.go文件要调用pkg下的包文件。 环境基本搭建完成。再次输入1$ go env 发现修改了即可。]]></content>
      <categories>
        <category>Golang</category>
      </categories>
      <tags>
        <tag>环境搭建</tag>
        <tag>Golang基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Maven配置]]></title>
    <url>%2F2018%2F09%2F22%2FMaven%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[Maven基础环境搭建 环境 window10 jdk1.6或以上 下载Maven官网 直接选择 apache-maven-3.5.4-bin.zip格式下载解压即可 配置环境变量MAVEN_HOME我的解压存放的目录是 G:\Maven ，下面目录自行替换 计算机(右键)-属性-高级系统设置-环境变量 新建系统变量 MAVEN_HOME 变量值： G:\Maven 编辑系统变量 Path 添加变量值： G:\Maven\bin 检测是否安装成功git-bash或者命令提示符下，输入123456$ mvn --versionApache Maven 3.5.4 (1edded0938998edf8bf061f1ceb3cfdeccf443fe; 2018-06-18T02:33:14+08:00)Maven home: G:\MavenJava version: 1.8.0_131, vendor: Oracle Corporation, runtime: G:\Java\jreDefault locale: zh_CN, platform encoding: GBKOS name: "windows 10", version: "10.0", arch: "amd64", family: "windows" 出现类似即可。 Maven配置修改本地仓库地址Maven缺省的本地仓库路径 用户目录/.m2/repository 打开maven安装目录下的conf目录中的 settings.xml 文件 搜索 localRepository取消注释，修改成想要存放的路径保存即可，如图所示 IDEA配置 Eclipse配置]]></content>
      <categories>
        <category>Maven</category>
      </categories>
      <tags>
        <tag>环境搭建</tag>
        <tag>Maven</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[架构参考]]></title>
    <url>%2F2018%2F09%2F22%2F%E6%9E%B6%E6%9E%84%E5%8F%82%E8%80%83%2F</url>
    <content type="text"><![CDATA[架构参考，原文来自(https://blog.52itstyle.com/architecture.html) 技术选型网关：Nginx、Kong、Zuul缓存：Redis、MemCached、OsCache、EhCache搜索：ElasticSearch、Solr熔断：Hystrix 负载均衡：DNS、F5、LVS、Nginx、OpenResty、HAproxy注册中心：Eureka、Zookeeper、Redis、Etcd、Consul认证鉴权：JWT消费队列：RabbitMQ、ZeroMQ、Redis、ActiveMQ、Kafka 日志收集：ELK、Redis系统监控：GPE、PinPoint、Zipkin文件系统：OSS、NFS、FastDFS、MogileFSRPC框架： Dubbo、Motan、Thrift、grpc 构建工具：Maven、Gradle集成部署：Docker、Jenkins、Git、Maven 数据库：MySql、Redis、MongoDB、PostgreSQL、Memcache、HBase网络：专用网络VPC、弹性公网IP、CDN数据库中间件：DRDS （阿里云）、Mycat、360 Atlas、Cobar (不维护了)分布式框架：Dubbo、Motan、Spring-Could 架构必备负载均衡（负载均衡算法）反向代理服务隔离服务限流服务降级（自动优雅降级）失效转移超时重试（代理超时、容器超时、前端超时、中间件超时、数据库超时、NoSql超时）回滚机制（上线回滚、数据库版本回滚、事务回滚） 高并发应用缓存HTTP缓存多级缓存分布式缓存连接池异步并发 分布式事务二阶段提交(强一致)三阶段提交(强一致)消息中间件(最终一致性)，推荐阿里的RocketMQ 队列任务队列消息队列请求队列 扩容单体垂直扩容单体水平扩容应用拆分数据库拆分数据库分库分表数据异构分布式任务 网络安全SQL注入XSS攻击CSRF攻击拒绝服务（DoS，Denial of Service）攻击]]></content>
      <categories>
        <category>架构之路</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[开源协议介绍]]></title>
    <url>%2F2018%2F09%2F22%2F%E5%BC%80%E6%BA%90%E5%8D%8F%E8%AE%AE%E4%BB%8B%E7%BB%8D%2F</url>
    <content type="text"><![CDATA[一些开源协议的介绍，考古。分别是MIT,Apache,LGPL,GPL,BSD,MPL 现今存在的开源协议很多，而经过Open Source Initiative组织通过批准的开源协议目前有58种（http://www.opensource.org/licenses /alphabetical）。 Apache Licene 2.0Apache Licence是著名的非盈利开源组织Apache采用的协议。该协议和BSD类似，同样鼓励代码共享和尊重原作者的著作权，同样允许代码修改，再发布（作为开源或商业软件）。需要满足的条件也和BSD类似： 需要给代码的用户一份Apache Licence 如果你修改了代码，需要在被修改的文件中说明。 在延伸的代码中（修改和有源代码衍生的代码中）需要带有原来代码中的协议，商标，专利声明和其他原来作者规定需要包含的说明。 如果再发布的产品中包含一个Notice文件，则在Notice文件中需要带有Apache Licence。你可以在Notice中增加自己的许可，但不可以表现为对Apache Licence构成更改。 Apache Licence也是对商业应用友好的许可。使用者也可以在需要的时候修改代码来满足需要并作为开源或商业产品发布/销售。 12345678910111213Apache Licence是著名的非盈利开源组织Apache采用的协议。该协议和BSD类似，同样鼓励代码共享和尊重原作者的著作权，同样允许代码修改，再发布（作为开源或商业软件）。需要满足的条件也和BSD类似： （1）需要给代码的用户一份Apache Licence （2）如果你修改了代码，需要再被修改的文件中说明。 （3）在延伸的代码中（修改和有源代码衍生的代码中）需要带有原来代码中的协议，商标，专利声明和其他原来作者规定需要包含的说明。 （4）如果再发布的产品中包含一个Notice文件，则在Notice文件中需要带有Apache Licence。你可以在Notice中增加自己的许可，但不可以表现为对Apache Licence构成更改。 Apache Licence也是对商业应用友好的许可。使用者也可以在需要的时候修改代码来满足需要并作为开源或商业产品发布/销售。 Apache Licence 2.0版本授予了用户大量的权利。这些权利可以应用于拷贝权，也可以用于专利权。因为很多许可协议只能适用于拷贝权，不适用于专利权，所以这个灵活性就成了让想有专利的开发者们选择许可协议时的一个显著参考因素。 下面是关于Apache许可协议所允许的事项的详细说明： （1）权利永恒。一旦被授权，权利永久不失。 （2）权利无疆界。在一个国家里被授权，形同于在所有国家被授权。例如，你在美国，但许可权最初在印度被授予，你同样可以使用这个被授权的程序。 （3）授权无需付费和支付酬劳。你既不需要在使用之前支付任何的费用，也无需在每次使用时支付任何的费用，或者其它类似情况。 （4）权利不排他。使用这种许可协议下的软件时，不妨碍你使用其它软件。 （5）权利不可变更。 权利一旦授予，不可剥夺。也就是说，你在使用这个软件的过程中，你无需担心这种情况：当你开发出了令人羡慕的基于这种授权软件的衍生产品时，有人突然跳出来对你说，“抱歉，你将不再被允许使用这个程序。”（在这个协议里有个条款声明：如果你控告别人在这个许可协议下的产品有侵犯专利的行为，那你的授权将会自动终止，但这只是适用于有专利权的作品。只要你不搞有专利作品的诉讼，你永远无需担心这种问题。） 英文原文：http://www.apache.org/licenses/LICENSE-2.0.html MPL (Mozilla Public License)MPL是The Mozilla Public License的简写，是1998年初Netscape的 Mozilla小组为其开源软件项目设计的软件许可证。MPL许可证出现的最重要原因就是，Netscape公司认为GPL许可证没有很好地平衡开发者对 源代码的需求和他们利用源代码获得的利益。同著名的GPL许可证和BSD许可证相比，MPL在许多权利与义务的约定方面与它们相同（因为都是符合OSIA 认定的开源软件许可证）。但是，相比而言MPL还有以下几个显著的不同之处: MPL虽然要求对于经MPL许可证发布的源代码的修改也要以MPL许可证的方式再许可出来，以保证其他人可以在MPL的条款下共享源代码。但是，在MPL 许可证中对“发布”的定义是“以源代码方式发布的文件”，这就意味着MPL允许一个企业在自己已有的源代码库上加一个接口，除了接口程序的源代码以MPL 许可证的形式对外许可外，源代码库中的源代码就可以不用MPL许可证的方式强制对外许可。这些，就为借鉴别人的源代码用做自己商业软件开发的行为留了一个 豁口。 MPL许可证第三条第7款中允许被许可人将经过MPL许可证获得的源代码同自己其他类型的代码混合得到自己的软件程序。 对软件专利的态度，MPL许可证不像GPL许可证那样明确表示反对软件专利，但是却明确要求源代码的提供者不能提供已经受专利保护的源代码（除非他本人是 专利权人，并书面向公众免费许可这些源代码），也不能在将这些源代码以开放源代码许可证形式许可后再去申请与这些源代码有关的专利。 对源代码的定义而在MPL（1.1版本）许可证中，对源代码的定义是:“源代码指的是对作品进行修改最优先择 取的形式，它包括:所有模块的所有源程序，加上有关的接口的定义，加上控制可执行作品的安装和编译的‘原本’（原文为‘Script’），或者不是与初始 源代码显著不同的源代码就是被源代码贡献者选择的从公共领域可以得到的程序代码。” MPL许可证第3条有专门的一款是关于对源代码修改进行描述的规定，就是要求所有再发布者都得有一个专门的文件就对源代码程序修改的时间和修改的方式有描述。 英文原文：http://www.mozilla.org/MPL/MPL-1.1.html BSDBSD开源协议是一个给于使用者很大自由的协议。基本上使用者可以”为所欲为”,可以自由的使用，修改源代码，也可以将修改后的代码作为开源或者专有软件再发布。 但”为所欲为”的前提当你发布使用了BSD协议的代码，或则以BSD协议代码为基础做二次开发自己的产品时，需要满足三个条件： 如果再发布的产品中包含源代码，则在源代码中必须带有原来代码中的BSD协议。 如果再发布的只是二进制类库/软件，则需要在类库/软件的文档和版权声明中包含原来代码中的BSD协议。 不可以用开源代码的作者/机构名字和原来产品的名字做市场推广。 BSD 代码鼓励代码共享，但需要尊重代码作者的著作权。BSD由于允许使用者修改和重新发布代码，也允许使用或在BSD代码上开发商业软件发布和销售，因此是对 商业集成很友好的协议。而很多的公司企业在选用开源产品的时候都首选BSD协议，因为可以完全控制这些第三方的代码，在必要的时候可以修改或者二次开发。 123456BSD开源协议是一个给于使用者很大自由的协议。基本上使用者可以”为所欲为”,可以自由的使用，修改源代码，也可以将修改后的代码作为开源或者专有软件再发布。但”为所欲为”的前提当你发布使用了BSD协议的代码，或则以BSD协议代码为基础做二次开发自己的产品时，需要满足三个条件： （1）如果再发布的产品中包含源代码，则在源代码中必须带有原来代码中的BSD协议。 （2）如果再发布的只是二进制类库/软件，则需要在类库/软件的文档和版权声明中包含原来代码中的BSD协议。 （3）不可以用开源代码的作者/机构名字和原来产品的名字做市场推广。 BSD代码鼓励代码共享，但需要尊重代码作者的著作权。BSD由于允许使用者修改和重新发布代码，也允许使用或在BSD代码上开发商业软件发布和销售，因此是对商业集成很友好的协议。 而很多的公司企业在选用开源产品的时候都首选BSD协议，因为可以完全控制这些第三方的代码，在必要的时候可以修改或者二次开发。 新BSD协议（“3条款许可协议”）无任何限制的允许你以任何目的二次分发这种软件，唯一的要求是必须保留拷贝权的声明和协议里的软件权利放弃条款。这种协议还有一个限制，未经许可不得使用这个作品的所有曾经捐助者的署名。 新BSD协议和简化BSD协议的最主要的区别是后者删除了署名条款。 GPL（GNU General Public License）我们很熟悉的Linux就是采用了GPL。GPL协议和BSD, Apache Licence等鼓励代码重用的许可很不一样。GPL的出发点是代码的开源/免费使用和引用/修改/衍生代码的开源/免费使用，但不允许修改后和衍生的代 码做为闭源的商业软件发布和销售。这也就是为什么我们能用免费的各种linux，包括商业公司的linux和linux上各种各样的由个人，组织，以及商 业软件公司开发的免费软件了。 GPL协议的主要内容是只要在一个软件中使用(”使用”指类库引用，修改后的代码或者衍生代码)GPL 协议的产品，则该软件产品必须也采用GPL协议，既必须也是开源和免费。这就是所谓的”传染性”。GPL协议的产品作为一个单独的产品使用没有任何问题， 还可以享受免费的优势。 由于GPL严格要求使用了GPL类库的软件产品必须使用GPL协议，对于使用GPL协议的开源代码，商业软件或者对代码有保密要求的部门就不适合集成/采用作为类库和二次开发的基础。 其它细节如再发布的时候需要伴随GPL协议等和BSD/Apache等类似。 GPL V2 、 V3GPL同其它的自由软件许可证一样，许可社会公众享有：运行、复制软件的自由，发行传播软件的自由，获得软件源码的自由，改进软件并将自己作出的改进版本向社会发行传播的自由。GPL还规定：只要这种修改文本在整体上或者其某个部分来源于遵循GPL的程序，该修改文本的 整体就必须按照GPL流通，不仅该修改文本的源码必须向社会公开，而且对于这种修改文本的流通不准许附加修改者自己作出的限制。因此，一项遵循GPL流通 的程序不能同非自由的软件合并。GPL所表达的这种流通规则称为copyleft，表示与copyright(版权)的概念“相左”。 GPL协议最主要的几个原则： 确保软件自始至终都以开放源代码形式发布，保护开发成果不被窃取用作商业发售。任何一套软 件，只要其中使用了受 GPL 协议保护的第三方软件的源程序，并向非开发人员发布时，软件本身也就自动成为受 GPL 保护并且约束的实体。也就是说，此时它必须开放源代码。 GPL 大致就是一个左侧版权（Copyleft，或译为“反版权”、“版权属左”、“版权所无”、“版责”等）的体现。你可以去掉所有原作的版权 信息，只要你保持开源，并且随源代码、二进制版附上 GPL 的许可证就行，让后人可以很明确地得知此软件的授权信息。GPL 精髓就是，只要使软件在完整开源 的情况下，尽可能使使用者得到自由发挥的空间，使软件得到更快更好的发展。 无论软件以何种形式发布，都必须同时附上源代码。例如在 Web 上提供下载，就必须在二进制版本（如果有的话）下载的同一个页面，清楚地提供源代码下载的链接。如果以光盘形式发布，就必须同时附上源文件的光盘。 开发或维护遵循 GPL 协议开发的软件的公司或个人，可以对使用者收取一定的服务费用。但还是一句老话——必须无偿提供软件的完整源代码，不得将源代码与服务做捆绑或任何变相捆绑销售。 LGPL（GNU Lesser General Public License）LGPL是GPL的一个为主要为类库使用设计的开源协议。和GPL要求任何使用/修改/衍生之GPL类库的的软件必须采用GPL协议不同。 LGPL 允许商业软件通过类库引用(link)方式使用LGPL类库而不需要开源商业软件的代码。这使得采用LGPL协议的开源代码可以被商业软件作为类库引用并 发布和销售。 但是如果修改LGPL协议的代码或者衍生，则所有修改的代码，涉及修改部分的额外代码和衍生的代码都必须采用LGPL协议。因此LGPL协议的开源 代码很适合作为第三方类库被商业软件引用，但不适合希望以LGPL协议代码为基础，通过修改和衍生的方式做二次开发的商业软件采用。 GPL/LGPL都保障原作者的知识产权，避免有人利用开源代码复制并开发类似的产品 MITMIT是和BSD一样宽范的许可协议,作者只想保留版权,而无任何其他了限制.也就是说,你必须在你的发行版里包含原许可协议的声明,无论你是以二进制发布的还是以源代码发布的。 相关资料 http://www.open-open.com/solution/view/1319814738108 http://www.open-open.com/solution/view/1405088577732 http://www.open-open.com/solution/view/1319816219625]]></content>
      <categories>
        <category>程序人生</category>
      </categories>
      <tags>
        <tag>开源协议</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Go fmt包的格式化输出]]></title>
    <url>%2F2018%2F09%2F14%2FGo-fmt%E5%8C%85%E7%9A%84%E6%A0%BC%E5%BC%8F%E5%8C%96%E8%BE%93%E5%87%BA%2F</url>
    <content type="text"><![CDATA[golang 的fmt 包实现了格式化I/O函数，类似于C的 printf 和 scanf 普通占位符 占位符 说明 %v 相应值的默认格式，基本万能 %+v 打印结构体时，会添加字段名 %#v 响应值的Go语法表示 %T 响应值的类型的Go语法表示 %% 字面上的百分号，并非值的占位符 布尔占位符 占位符 说明 %t true 或者 false 整数占位符 占位符 说明 %b 二进制表示 %c 相应unicode码所表示的字符 %d 十进制表示 %o 八进制表示 %q 单引号围绕的字符字面值，由Go语法安全的转义，如Printf(%q, 0x4E2E)输出’中’ %x 十六进制表示，字母形式为小写a-f %X 十六进制表示，字母形式为A-F %U unicode格式，U+1234 等同于 U+%04X 浮点数和复数的组成部分（实部和虚部） 占位符 说明 %b 无小数部分的，指数为二的幂的科学记数法 %e 科学记数法 %E 科学计数法 %f 有小数点而无指数 %g 根据情况选择%e 或者 %f 以产生更紧凑的输出 %G 根据情况选择%E 或者 %f 以产生更紧凑的输出 字符串和字节切片 占位符 说明 %s 输出字符串表示（字符串类型或[]byte类型） %q 双引号围绕的字符串，由Go语法安全地转义 %x 十六进制，小写字母，每字节两个字符 %X 十六进制，大写字母，每字节两个字符 指针 占位符 说明 %p 十六进制表示，前缀0x 其他 占位符 说明 + 总打印数值的正负号；对于%q（%+q）保证只输出ASCII编码的字符。 - 在右侧而非左侧填充空格（左对齐该区域） # 备用格式：为八进制添加前导 0（%#o） ‘ ‘ (空格)为数值中省略的正负号留出空白（% d） 0 填充前导的0而非空格；对于数字，这会将填充移到正负号之后 golang没有 ‘%u’ 点位符，若整数为无符号类型，默认就会被打印成无符号的。 宽度与精度的控制格式以Unicode码点为单位。宽度为该数值占用区域的最小宽度；精度为小数点之后的位数。操作数的类型为int时，宽度与精度都可用字符 ‘*’ 表示。 对于 %g/%G 而言，精度为所有数字的总数，例如：123.45，%.4g 会打印123.5，（而 %6.2f 会打印123.45）。 %e 和 %f 的默认精度为6 对大多数的数值类型而言，宽度为输出的最小字符数，如果必要的话会为已格式化的形式填充空格。 而以字符串类型，精度为输出的最大字符数，如果必要的话会直接截断。]]></content>
      <categories>
        <category>Golang</category>
      </categories>
      <tags>
        <tag>Golang基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Go标准命令]]></title>
    <url>%2F2018%2F09%2F14%2FGo%E6%A0%87%E5%87%86%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[Go命令Go语言自带有一套完整的命令操作工具，你可以通过在命令行中执行go来查看它们： 图1.3 Go命令显示详细的信息 这些命令对于我们平时编写的代码非常有用，接下来就让我们了解一些常用的命令。 go build 这个命令主要用于编译代码。在包的编译过程中，若有必要，会同时编译与之相关联的包。 如果是普通包，就像我们在1.2节中编写的mymath包那样，当你执行go build之后，它不会产生任何文件。如果你需要在$GOPATH/pkg下生成相应的文件，那就得执行go install。 如果是main包，当你执行go build之后，它就会在当前目录下生成一个可执行文件。如果你需要在$GOPATH/bin下生成相应的文件，需要执行go install，或者使用go build -o 路径/a.exe。 如果某个项目文件夹下有多个文件，而你只想编译某个文件，就可在go build之后加上文件名，例如go build a.go；go build命令默认会编译当前目录下的所有go文件。 你也可以指定编译输出的文件名。例如1.2节中的mathapp应用，我们可以指定go build -o astaxie.exe，默认情况是你的package名(非main包)，或者是第一个源文件的文件名(main包)。 （注：实际上，package名在Go语言规范中指代码中“package”后使用的名称，此名称可以与文件夹名不同。默认生成的可执行文件名是文件夹名。） go build会忽略目录下以“_”或“.”开头的go文件。 如果你的源代码针对不同的操作系统需要不同的处理，那么你可以根据不同的操作系统后缀来命名文件。例如有一个读取数组的程序，它对于不同的操作系统可能有如下几个源文件： array_linux.goarray_darwin.goarray_windows.goarray_freebsd.go go build的时候会选择性地编译以系统名结尾的文件（Linux、Darwin、Windows、Freebsd）。例如Linux系统下面编译只会选择array_linux.go文件，其它系统命名后缀文件全部忽略。 参数的介绍 -o 指定输出的文件名，可以带上路径，例如 go build -o a/b/c -i 安装相应的包，编译+go install -a 更新全部已经是最新的包的，但是对标准包不适用 -n 把需要执行的编译命令打印出来，但是不执行，这样就可以很容易的知道底层是如何运行的 -p n 指定可以并行可运行的编译数目，默认是CPU数目 -race 开启编译的时候自动检测数据竞争的情况，目前只支持64位的机器 -v 打印出来我们正在编译的包名 -work 打印出来编译时候的临时文件夹名称，并且如果已经存在的话就不要删除 -x 打印出来执行的命令，其实就是和-n的结果类似，只是这个会执行 -ccflags &#39;arg list&#39; 传递参数给5c, 6c, 8c 调用 -compiler name 指定相应的编译器，gccgo还是gc -gccgoflags &#39;arg list&#39; 传递参数给gccgo编译连接调用 -gcflags &#39;arg list&#39; 传递参数给5g, 6g, 8g 调用 -installsuffix suffix 为了和默认的安装包区别开来，采用这个前缀来重新安装那些依赖的包，-race的时候默认已经是-installsuffix race,大家可以通过-n命令来验证 -ldflags &#39;flag list&#39; 传递参数给5l, 6l, 8l 调用 -tags &#39;tag list&#39; 设置在编译的时候可以适配的那些tag，详细的tag限制参考里面的 Build Constraints go clean 这个命令是用来移除当前源码包和关联源码包里面编译生成的文件。这些文件包括 _obj/ 旧的object目录，由Makefiles遗留 _test/ 旧的test目录，由Makefiles遗留 _testmain.go 旧的gotest文件，由Makefiles遗留 test.out 旧的test记录，由Makefiles遗留 build.out 旧的test记录，由Makefiles遗留 *.[568ao] object文件，由Makefiles遗留 DIR(.exe) 由go build产生 DIR.test(.exe) 由go test -c产生 MAINFILE(.exe) 由go build MAINFILE.go产生 *.so 由 SWIG 产生 我一般都是利用这个命令清除编译文件，然后github递交源码，在本机测试的时候这些编译文件都是和系统相关的，但是对于源码管理来说没必要。 $ go clean -i -n cd /Users/astaxie/develop/gopath/src/mathapp rm -f mathapp mathapp.exe mathapp.test mathapp.test.exe app app.exe rm -f /Users/astaxie/develop/gopath/bin/mathapp 参数介绍 -i 清除关联的安装的包和可运行文件，也就是通过go install安装的文件 -n 把需要执行的清除命令打印出来，但是不执行，这样就可以很容易的知道底层是如何运行的 -r 循环的清除在import中引入的包 -x 打印出来执行的详细命令，其实就是-n打印的执行版本 go fmt 有过C/C++经验的读者会知道,一些人经常为代码采取K&amp;R风格还是ANSI风格而争论不休。在go中，代码则有标准的风格。由于之前已经有的一些习惯或其它的原因我们常将代码写成ANSI风格或者其它更合适自己的格式，这将为人们在阅读别人的代码时添加不必要的负担，所以go强制了代码格式（比如左大括号必须放在行尾），不按照此格式的代码将不能编译通过，为了减少浪费在排版上的时间，go工具集中提供了一个go fmt命令 它可以帮你格式化你写好的代码文件，使你写代码的时候不需要关心格式，你只需要在写完之后执行go fmt &lt;文件名&gt;.go，你的代码就被修改成了标准格式，但是我平常很少用到这个命令，因为开发工具里面一般都带了保存时候自动格式化功能，这个功能其实在底层就是调用了go fmt。接下来的一节我将讲述两个工具，这两个工具都自带了保存文件时自动化go fmt功能。 使用go fmt命令，其实是调用了gofmt，而且需要参数-w，否则格式化结果不会写入文件。gofmt -w -l src，可以格式化整个项目。 所以go fmt是gofmt的上层一个包装的命令，我们想要更多的个性化的格式化可以参考 gofmt gofmt的参数介绍 -l 显示那些需要格式化的文件 -w 把改写后的内容直接写入到文件中，而不是作为结果打印到标准输出。 -r 添加形如“a[b:len(a)] -&gt; a[b:]”的重写规则，方便我们做批量替换 -s 简化文件中的代码 -d 显示格式化前后的diff而不是写入文件，默认是false -e 打印所有的语法错误到标准输出。如果不使用此标记，则只会打印不同行的前10个错误。 -cpuprofile 支持调试模式，写入相应的cpufile到指定的文件 go get 这个命令是用来动态获取远程代码包的，目前支持的有BitBucket、GitHub、Google Code和Launchpad。这个命令在内部实际上分成了两步操作：第一步是下载源码包，第二步是执行go install。下载源码包的go工具会自动根据不同的域名调用不同的源码工具，对应关系如下： BitBucket (Mercurial Git) GitHub (Git) Google Code Project Hosting (Git, Mercurial, Subversion) Launchpad (Bazaar) 所以为了go get 能正常工作，你必须确保安装了合适的源码管理工具，并同时把这些命令加入你的PATH中。其实go get支持自定义域名的功能，具体参见go help remote。 参数介绍： -d 只下载不安装 -f 只有在你包含了-u参数的时候才有效，不让-u去验证import中的每一个都已经获取了，这对于本地fork的包特别有用 -fix 在获取源码之后先运行fix，然后再去做其他的事情 -t 同时也下载需要为运行测试所需要的包 -u 强制使用网络去更新包和它的依赖包 -v 显示执行的命令 go install 这个命令在内部实际上分成了两步操作：第一步是生成结果文件(可执行文件或者.a包)，第二步会把编译好的结果移到$GOPATH/pkg或者$GOPATH/bin。 参数支持go build的编译参数。大家只要记住一个参数-v就好了，这个随时随地的可以查看底层的执行信息。 go test 执行这个命令，会自动读取源码目录下面名为*_test.go的文件，生成并运行测试用的可执行文件。输出的信息类似 ok archive/tar 0.011s FAIL archive/zip 0.022s ok compress/gzip 0.033s ... 默认的情况下，不需要任何的参数，它会自动把你源码包下面所有test文件测试完毕，当然你也可以带上参数，详情请参考go help testflag 这里我介绍几个我们常用的参数： -bench regexp 执行相应的benchmarks，例如 -bench=. -cover 开启测试覆盖率 -run regexp 只运行regexp匹配的函数，例如 -run=Array 那么就执行包含有Array开头的函数 -v 显示测试的详细命令 go toolgo tool下面下载聚集了很多命令，这里我们只介绍两个，fix和vet go tool fix . 用来修复以前老版本的代码到新版本，例如go1之前老版本的代码转化到go1,例如API的变化 go tool vet directory|files 用来分析当前目录的代码是否都是正确的代码,例如是不是调用fmt.Printf里面的参数不正确，例如函数里面提前return了然后出现了无用代码之类的。 go generate这个命令是从Go1.4开始才设计的，用于在编译前自动化生成某类代码。go generate和go build是完全不一样的命令，通过分析源码中特殊的注释，然后执行相应的命令。这些命令都是很明确的，没有任何的依赖在里面。而且大家在用这个之前心里面一定要有一个理念，这个go generate是给你用的，不是给使用你这个包的人用的，是方便你来生成一些代码的。 这里我们来举一个简单的例子，例如我们经常会使用yacc来生成代码，那么我们常用这样的命令： go tool yacc -o gopher.go -p parser gopher.y -o 指定了输出的文件名， -p指定了package的名称，这是一个单独的命令，如果我们想让go generate来触发这个命令，那么就可以在当然目录的任意一个xxx.go文件里面的任意位置增加一行如下的注释： //go:generate go tool yacc -o gopher.go -p parser gopher.y 这里我们注意了，//go:generate是没有任何空格的，这其实就是一个固定的格式，在扫描源码文件的时候就是根据这个来判断的。 所以我们可以通过如下的命令来生成，编译，测试。如果gopher.y文件有修改，那么就重新执行go generate重新生成文件就好。 $ go generate $ go build $ go test godoc在Go1.2版本之前还支持go doc命令，但是之后全部移到了godoc这个命令下，需要这样安装go get golang.org/x/tools/cmd/godoc 很多人说go不需要任何的第三方文档，例如chm手册之类的（其实我已经做了一个了，chm手册），因为它内部就有一个很强大的文档工具。 如何查看相应package的文档呢？ 例如builtin包，那么执行godoc builtin 如果是http包，那么执行godoc net/http 查看某一个包里面的函数，那么执行godoc fmt Printf 也可以查看相应的代码，执行godoc -src fmt Printf 通过命令在命令行执行 godoc -http=:端口号 比如godoc -http=:8080。然后在浏览器中打开127.0.0.1:8080，你将会看到一个golang.org的本地copy版本，通过它你可以查询pkg文档等其它内容。如果你设置了GOPATH，在pkg分类下，不但会列出标准包的文档，还会列出你本地GOPATH中所有项目的相关文档，这对于经常被墙的用户来说是一个不错的选择。 其它命令 go还提供了其它很多的工具，例如下面的这些工具 go version 查看go当前的版本 go env 查看当前go的环境变量 go list 列出当前全部安装的package go run 编译并运行Go程序 以上这些工具还有很多参数没有一一介绍，用户可以使用go help 命令获取更详细的帮助信息。]]></content>
      <categories>
        <category>Golang</category>
      </categories>
      <tags>
        <tag>Golang基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL错误集]]></title>
    <url>%2F2018%2F09%2F13%2FMySQL%E9%94%99%E8%AF%AF%E9%9B%86%2F</url>
    <content type="text"><![CDATA[MYSQL错误集记录 ERROR 1215-Cannot add foreign key constraint先看俩个表结构 对reader表进行添加外键约束book表12mysql&gt; ALTER TABLE reader ADD CONSTRAINT fk_book_reader FOREIGN key -&gt; reader(book_id) REFERENCES book(book_id); 报错：1215-Cannot add foreign key constraint问题分析： 主外键更多的是某表的主键与子表的某个列进行关联，要求是具备相同的数据类型和属性 要求：具备相同的数据类型和约束发现：unsigned，数字的字符长度不一致。修改reader表book_id列属性1mysql&gt; ALTER TABLE reader MODIFY book_id INT UNSIGNED; 再次进行添加外键约束，问题解决。 ERROR 1075 (42000): Incorrect table definition; there can be only one auto column and it must be defined as a key引发原因，建表语句：12345mysql&gt; create table if not exists user( -&gt; id int unsigned auto_increment, -&gt; uuid varchar(30) not null, -&gt; primary key (uuid,id) -&gt; ) engine=InnoDB default charset=utf8; 解决方法：当有一个自增键和另外一个字段需要作为主键时，一定要在定义primary key中先定义自增键，否则报错。12345mysql&gt; create table if not exists user( -&gt; id int unsigned auto_increment, -&gt; uuid varchar(30) not null, -&gt; primary key (id,uuid) -&gt; ) engine=InnoDB default charset=utf8;]]></content>
      <categories>
        <category>DBA</category>
      </categories>
      <tags>
        <tag>Mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Centos7搭建FTP服务器]]></title>
    <url>%2F2018%2F09%2F11%2FCentos7%E6%90%AD%E5%BB%BAFTP%E6%9C%8D%E5%8A%A1%E5%99%A8%2F</url>
    <content type="text"><![CDATA[之前部署阿里云服务器需要上传一些文件，所以搭建了FTP服务器，便记录一下。 环境 Centos7 安装VSFTPD1$ yum install vsftpd -y 配置VSFTPDvsftpd的配置文件是 /etc/vsftpd/vsftpd.conf ，直接用vim打开编辑即可。使用vim编辑器打开vsftpd配置文件：1$ vim /etc/vsftpd/vsftpd.conf 关键修改 anonymous_enable=YES 是否允许匿名用户登陆FTP。 为了安全起见关闭这个功能（将等号后的YES改成NO即可）。 dirmessage_enable=YES 切换目录时，显示目录下.message文件中的内容 默认是开启的 local_umask=022 FTP上本地的文件权限，默认是077，不过vsftpd安装后的配置文件里默认是022. 没有什么特殊情况不用修改。 xferlog_enable=YES 启用上传和下载的日志功能，默认开启。 ftpd_banner=XXXX FTP的欢迎信息。 data_connection_timeout=120 数据连接超时时间。 启动VSFTPD开机启动12$ systemctl enable vsftpd.service$ systemctl start vsftpd.service 创建FTP用户修改完vsftpd的配置文件之后我们还是不能使用vsftpd，因为我们还没有设置ftp的用户。添加一个名为ftpuser的用户，用户文件夹位置为：/home/ftpdir，且禁止此用户登陆服务器：12$ useradd -d /home/ftpdir -s /sbin/nologin ftpuser$ passwd ftpuser 这时候系统会要求您输入新的密码并且重复一遍。顺便一提在SSH中，密码一般不会回显，所以初学者可能会觉得输进去没反应，其实是已经输进去了。调整文件夹权限123$ chmod 777 /home/ftpdir$ cd /home$ ls -l 调整防火墙我这里用的是传统的管理方式在CentOS 7或RHEL 7或Fedora中防火墙由firewalld来管理，需要还原12$ systemctl stop firewalld $ systemctl mask firewalld 并且安装iptables-services：1$ yum install iptables-services -y 设置开机启动：12$ systemctl enable iptables$ systemctl start iptables 开放端口 主动模式 使用Vim编辑器打开iptables配置文件：1$ vim /etc/sysconfig/iptables 添加1-A INPUT -m state --state NEW -m tcp -p tcp --dport 21 -j ACCEPT 重启服务1$ systemctlrestart iptables.service 被动模式(未测试) 如果ftp处于被动模式下，除了需要修改iptables的配置文件以外，还需要修改vsftpd的配置文件。首先是修改vsftpd的配置文件：使用Vim编辑器打开vsftpd配置文件：1$ vim /etc/vsftpd/vsftpd.conf 现在配置文件中找到 “connect_from_port_20=YES” 并将它修改为 “connect_from_port_20=NO” ，关闭掉vsftpd的主动模式。 然后在配置文件的末尾追加： 使vsftpd运行在被动模式 pasv_enable=YES 被动模式最小端口号30000 pasv_min_port=30000 被动模式最大端口号31000 pasv_max_port=31000 保存配置文件并退出。然后重启vsftpd服务：1$ systemctl restart vsftpd.service 然后再使用Vim编辑器打开iptables配置文件：1$ vim /etc/sysconfig/iptables 添加这两句话：（“#”开头的是注释，可以不添加）1234#开放ftp协议21端口，允许接受来自21端口的新建TCP连接-A INPUT -p tcp -m state --state NEW -m tcp --dport 21 -j ACCEPT#开放30000-31000号端口，允许接受来自此端口号段的新建TCP连接 **-A INPUT -p tcp --dport 30000:31000 -j ACCEPT 保存并退出，然后重启iptables服务：1$ systemctl restart iptables.service]]></content>
      <categories>
        <category>服务器运维</category>
      </categories>
      <tags>
        <tag>Centos7</tag>
        <tag>FTP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[电脑小技巧]]></title>
    <url>%2F2018%2F09%2F10%2F%E7%94%B5%E8%84%91%E5%B0%8F%E6%8A%80%E5%B7%A7%2F</url>
    <content type="text"><![CDATA[日常电脑使用小技巧 不用截图工具截取整个网页打开浏览器(测试chrome可用)并调出控制台，快捷键 f12 然后选择快捷键 ctrl + shift + p 调出,如图(我也忘记叫什么了)输入capt，出现一下选择，选择如图即可截取整张网页，并自动下载至浏览器默认下载目录测试图太长就不放了，可以自行测试，应该浏览器都通用(国外)]]></content>
      <categories>
        <category>程序人生</category>
      </categories>
      <tags>
        <tag>chrome</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL入门]]></title>
    <url>%2F2018%2F09%2F10%2FMySQL%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[MySql入门教程,Sql语句复习 环境 centos7 virtualbox MySQL 5.7 教程 SQL语言分类 DQL(数据查询语言) 数据查询语言DQL基本结构是由SELECT子句，FROM子句，WHERE DML(数据操纵语言) 数据操纵语言DML主要有三种形式：插入：INSERT，更新：UPDATE，删除：DELETE DDL(数据定义语言) 数据定义语言DDL用来创建数据库中的各种对象—–表、视图、索引、同义词、聚簇等 DCL(数据控制语言) 数据控制语言DCL用来授予或回收访问数据库的某种特权，并控制数据库操纵事务发生的时间及效果，对数据库实行监视 Centos下Mysq显示方式设置 使用more 1mysql&gt; pager more 使用less 1mysql&gt; pager less less模式下按下键盘q退出 还原 1mysql&gt; nopager 使用\G按行垂直显示结果如果一行很长，需要这行显示的话，看起结果来就非常的难受。在SQL语句或者命令后使用\G而不是分号结尾，可以将每一行的值垂直输出。这个可能也是大家对于MySQL最熟悉的区别于其他数据库工具的一个特性了。 1234mysql&gt; use mysql;Database changedmysql&gt; select * from user\G MySQL用户设置如果你需要添加 MySQL 用户，你只需要在 mysql 数据库中的 user 表添加新用户即可。 以下为添加用户的的实例，用户名为guest，密码为guest123，并授权用户可进行 SELECT, INSERT 和 UPDATE操作权限：1234567891011121314151617181920mysql&gt; use mysql;Database changedmysql&gt; INSERT INTO user (host, user, password, select_priv, insert_priv, update_priv) VALUES ('localhost', 'guest', PASSWORD('guest123'), 'Y', 'Y', 'Y');Query OK, 1 row affected (0.20 sec)mysql&gt; FLUSH PRIVILEGES;Query OK, 1 row affected (0.01 sec)mysql&gt; SELECT host, user, password FROM user WHERE user = 'guest';+-----------+---------+------------------+| host | user | password |+-----------+---------+------------------+| localhost | guest | 6f8c114b58f2ce9e |+-----------+---------+------------------+1 row in set (0.00 sec) 注意：在 MySQL5.7 中 user 表的 password 已换成了authentication_string。 error 这种方式出现过mysql插入用户的时候，突然出现了 Field ‘ssl_cipher’ doesn’t have a default value 的错误，现已解决，步骤如下：在mysql的user表中增加连接用户帐号：这里不要直接使用INSERT语句添加user记录，使用INSERT可能出现：ERROR 1364 (HY000): Field ‘ssl_cipher’ doesn’t have a default value错误。 你可以在创建用户时，为用户指定权限，在对应的权限列中，在插入语句中设置为 ‘Y’ 即可，用户权限列表如下： Select_priv Insert_priv Update_priv Delete_priv Create_priv Drop_priv Reload_priv Shutdown_priv Process_priv File_priv Grant_priv References_priv Index_priv Alter_priv 另外一种添加用户的方法为通过SQL的 GRANT 命令，以下命令会添加用户 zara ，密码为 zara123 。123mysql&gt;GRANT SELECT ON *.* TO 'zara'@'localhost' IDENTIFIED BY 'zara123' -&gt;WITH GRANT OPTION;Query OK 为数据库TUTORIALS添加用户 zara ，密码为 zara1231234mysql&gt; GRANT SELECT,INSERT,UPDATE,DELETE,CREATE,DROP -&gt; ON TUTORIALS.* -&gt; TO 'zara'@'localhost' -&gt; IDENTIFIED BY 'zara123'; 管理数据库命令USE (dbname);选择要操作的数据库，之后所执行的mysql命令都是针对该数据库1mysql&gt; use mysql; SHOW DATABASES;列出Mysql数据库管理系统的数据库列表1mysql&gt; SHOW DATABASES; SHOW TABLES;显示指定数据库的所有表，使用该命令前需要使用 use 命令来选择要操作的数据库。1mysql&gt; SHOW TABLES; SHOW COLUMNS FROM (tablename):显示数据表的属性，属性类型，主键信息 ，是否为 NULL，默认值等其他信息。 SHOW INDEX FROM (tablename):显示数据表的详细索引信息，包括PRIMARY KEY（主键）。1mysql&gt; SHOW INDEX FROM user; SHOW TABLE STATUS LIKE [FROM db_name] [LIKE ‘pattern’] \G:该命令将输出Mysql数据库管理系统的性能及统计信息。 1mysql&gt; SHOW TABLE STATUS FROM mysql; 创建数据库登陆 MySQL 服务后，使用 create 命令创建数据库，语法如下:1CREATE DATABASE booklib; 删除数据库如果使用普通用户可能需要权限来进行删除数据库，登陆root账户，拥有最高权限，删除数据库需要谨慎，一旦删除，数据将会消失。语法如下1DROP DATABASE (dbname); MySQL数据类型 数字类型 整数: tinyint、smallint、mediumint、int、bigint 浮点数: float、double、real、decimal 日期和时间: date、time、datetime、timestamp、year 字符串类型 字符串: char、varchar 文本: tinytext、text、mediumtext、longtext 二进制(可用来存储图片、音乐等): tinyblob、blob、mediumblob、longblob 字符串类型 类型 单位 最大 特性 CHAR 字符 最大为255字符 存储定长，容易造成空间的浪费 VARCHAR 字符 可以超过255个字符 存储变长，节省存储空间 TEXT 字节 总大小为65535字节，约为64KB - TEXT在MySQL内部大多存储格式为溢出页，效率不如CHAR Mysql默认为utf-8，那么在英文模式下1个字符=1个字节，在中文模式下1个字符=3个字节。 数字类型整形 type Storage Minumun Value Maximum Value (Bytes) (Signed/Unsigned) (Signed/Unsigned) TINYINT 1 -128 127 0 255 SMALLINT 2 -32768 32767 0 65535 MEDIUMINT 3 -8388608 8388607 0 16777215 INT 4 -2147483648 2147483647 0 4294967295 BIGINT 8 -9223372036854775808 9223372036854775807 0 18446744073709551615 浮点型 属性 存储空间 精度 精确性 说明 FLOAT(M, D) 4 bytes 单精度 非精确 单精度浮点型，m总个数，d小数位 DOUBLE(M, D) 8 bytes 双精度 比Float精度高 双精度浮点型，m总个数，d小数位 FLOAT容易造成精度丢失 定点数DECIMAL 高精度的数据类型，常用来存储交易相关的数据 DECIMAL(M,N).M代表总精度，N代表小数点右侧的位数（标度） 1 &lt; M &lt; 254, 0 &lt; N &lt; 60; 存储空间变长 时间类型 类型 字节 例 精确性 DATE 三字节 2015-05-01 精确到年月日 TIME 三字节 11:12:00 精确到时分秒 DATETIME 八字节 2015-05-01 11::12:00 精确到年月日时分秒 TIMESTAMP 2015-05-01 11::12:00 精确到年月日时分秒 MySQL在5.6.4版本之后，TIMESTAMP和DATETIME支持到微秒。 TIMESTAMP会根据系统时区进行转换，DATETIME则不会 存储范围的区别 TIMESTAMP存储范围：1970-01-01 00::00:01 to 2038-01-19 03:14:07 DATETIME的存储范围：1000-01-01 00:00:00 to 9999-12-31 23:59:59 一般使用TIMESTAMP国际化 如存时间戳使用数字类型BIGINT 创建数据表创建MYSQL数据以下信息 表名 表字段名 定义表每个字段 语法1CREATE TABLE (tablename) (column name column type, ...) 例子：创建一个书本表，书本有编号,名字，出版社，作者名称，价格，出版日期12345678mysql&gt; CREATE TABLE IF NOT EXISTS book( &gt; book_id INT UNSIGNED AUTO_INCREMENT, &gt; book_name VARCHAR(50) NOT NULL, &gt; author VARCHAR(10) NOT NULL, &gt; pub VARCHAR(100), &gt; pub_date DATE, &gt; PRIMARY KEY (book_id) &gt; ) ENGINE=InnoDB DEFAULT CHARSET=utf8; 解析： 如果不想字段为NULL，可以设置字段为NOT NULL，但是一旦字段该数值为null，则会报错。 AUTO_INCREMENT定义列为自增的属性，一般用于主键，数值会自动加1。 PRIMARY KEY关键字用于定义列为主键。 您可以使用多列来定义主键，列间以逗号分隔。 ENGINE 设置存储引擎，CHARSET 设置编码。 删除数据表MySQL删除数据表，语法1DROP TABLE (tablename); 示例:1mysql&gt; DROP TABLE book; 插入数据使用 INSERT INTO 语句来插入数据,语法123INSERT INTO table_name ( field1, field2,...fieldN ) VALUES ( value1, value2,...valueN ); 如果数据是字符型，必须使用单引号或者双引号，如：”value”。 示例:12mysql&gt; INSERT INTO book(book_name, author, pub, pub_date) -&gt; VALUES('Android Coder', 'bitch', 'english', NOW()) 一次插入多行语句1234mysql&gt; INSERT INTO book(book_name, author, pub, pub_date) -&gt; VALUES -&gt; ('python', 'pp', 'english', DATE('2010-08-10')), -&gt; ('kotlin', 'kk', 'amearica', DATE('2013-07-10')); 查询数据使用SQL SELECT 查询数据,语法1234SELECT column_name,column_nameFROM table_name[WHERE Clause][LIMIT N][ OFFSET M] 查询语句中你可以使用一个或者多个表，表之间使用逗号(,)分割，并使用WHERE语句来设定查询条件。 SELECT 命令可以读取一条或者多条记录。 你可以使用星号（*）来代替其他字段，SELECT语句会返回表的所有字段数据 你可以使用 WHERE 语句来包含任何条件。 你可以使用 LIMIT 属性来设定返回的记录数。 你可以通过OFFSET指定SELECT语句开始查询的数据偏移量。默认情况下偏移量为0。 1mysql&gt; SELECT * FROM book; WHERE 字句我们知道从 MySQL 表中使用 SQL SELECT 语句来读取数据。如需有条件地从表中选取数据，可将 WHERE 子句添加到 SELECT 语句中。语法12SELECT field1, field2,...fieldN FROM table_name1, table_name2...[WHERE condition1 [AND [OR]] condition2..... 查询语句中你可以使用一个或者多个表，表之间使用逗号, 分割，并使用WHERE语句来设定查询条件。 你可以在 WHERE 子句中指定任何条件。 你可以使用 AND 或者 OR 指定一个或多个条件。 WHERE 子句也可以运用于 SQL 的 DELETE 或者 UPDATE 命令。 WHERE 子句类似于程序语言中的 if 条件，根据 MySQL 表中的字段值来读取指定的数据。 操作符 描述 实例 = 等号，检测两边值是否相等，相等返回true A = B 返回true &lt;&gt;, != 不等于，检测两边值是否相等，相等返回false A != B 返回false &gt; 大于，检测左边值是否大于右边值，大于则返回true A &gt; B 返回true &lt; 小于，检测左边值是否小于右边值，小于则返回true A &lt; B 返回true &gt;= 大于等于，检测左边值是否大于等于右边值，同上 A &gt;= B 返回true &lt;= 大于等于，检测左边值是否大于等于右边值，同上 A &lt;= B 返回true 如果我们想在 MySQL 数据表中读取指定的数据，WHERE 子句是非常有用的。使用主键来作为 WHERE 子句的条件查询是非常快速的。如果给定的条件在表中没有任何匹配的记录，那么查询不会返回任何数据。 1mysql&gt; SELECT * FROM book WHERE author='bitch' UPDATE 查询使用SQL UPDATE语句修改或更新数据库中数据 语法12UPDATE table_name SET field1=new-value1, field2=new-value2[WHERE Clause] 你可以同时更新一个或多个字段。 你可以在 WHERE 子句中指定任何条件。 你可以在一个单独表中同时更新数据。 1mysql&gt; UPDATE book SET author = 'jack' WHERE book_id = 4; DELETE 删除SQL 的 DELETE FROM 命令来删除 MySQL 数据表中的记录。语法1DELETE FROM table_name [WHERE Clause] 如果没有指定 WHERE 子句，MySQL 表中的所有记录将被删除。 你可以在 WHERE 子句中指定任何条件 您可以在单个表中一次性删除记录。 请谨慎 1mysql&gt; DELETE FROM book WHERE book_name = 'TEST'; LIKE 子句MySQL 中使用 SQL SELECT 命令来读取数据， 同时我们可以在 SELECT 语句中使用 WHERE 子句来获取指定的记录。WHERE 子句中可以使用等号 = 来设定获取数据的条件，如 “runoob_author = ‘RUNOOB.COM’”。但是有时候我们需要获取 runoob_author 字段含有 “COM” 字符的所有记录，这时我们就需要在 WHERE 子句中使用 SQL LIKE 子句。SQL LIKE 子句中使用百分号 %字符来表示任意字符，类似于UNIX或正则表达式中的星号 *。如果没有使用百分号 %, LIKE 子句与等号 = 的效果是一样的。 语法123SELECT field1, field2,...fieldN FROM table_nameWHERE field1 LIKE condition1 [AND [OR]] filed2 = 'somevalue' 你可以在 WHERE 子句中指定任何条件。 你可以在 WHERE 子句中使用LIKE子句。 你可以使用LIKE子句代替等号 =。 LIKE 通常与 % 一同使用，类似于一个元字符的搜索。 你可以使用 AND 或者 OR 指定一个或多个条件。 你可以在 DELETE 或 UPDATE 命令中使用 WHERE…LIKE 子句来指定条件。 like 匹配/模糊匹配，会与 % 和 _ 结合使用。‘%a’ //以a结尾的数据‘a%’ //以a开头的数据‘%a%’ //含有a的数据‘_a_’ //三位且中间字母是a的‘a’ //两位且结尾字母是a的‘a‘ //两位且开头字母是a的 1mysql&gt; SELECT * FROM book WHERE pub LIKE 'a%'; UNION 操作符MySQL UNION 操作符用于连接两个以上的 SELECT 语句的结果组合到一个结果集合中。多个 SELECT 语句会删除重复的数据。 语法1234567SELECT expression1, expression2, ... expression_nFROM tables[WHERE conditions]UNION [ALL | DISTINCT]SELECT expression1, expression2, ... expression_nFROM tables[WHERE conditions]; expression1, expression2, … expression_n: 要检索的列。 tables: 要检索的数据表。 WHERE conditions: 可选， 检索条件。 DISTINCT: 可选，删除结果集中重复的数据。默认情况下 UNION 操作符已经删除了重复数据，所以 DISTINCT 修饰符对结果没啥影响。 ALL: 可选，返回所有结果集，包含重复数据。 案例 排序读取的数据进行排序，我们就可以使用 MySQL 的 ORDER BY 子句来设定你想按哪个字段哪种方式来进行排序，再返回搜索结果。 语法12SELECT field1, field2,...fieldN table_name1, table_name2...ORDER BY field1, [field2...] [ASC [DESC]] 你可以使用任何字段来作为排序的条件，从而返回排序后的查询结果。 你可以设定多个字段来排序。 你可以使用 ASC 或 DESC 关键字来设置查询结果是按升序或降序排列。 默认情况下，它是按升序排列。 你可以添加 WHERE…LIKE 子句来设置条件。 1mysql&gt; SELECT * FROM book ORDER BY pub_date ASC; 分组GROUP BY 语句根据一个或多个列对结果集进行分组。在分组的列上我们可以使用 COUNT, SUM, AVG,等函数。 语法1234SELECT column_name, function(column_name)FROM table_nameWHERE column_name operator valueGROUP BY column_name; 1mysql&gt; SELECT COUNT(*), book_name FROM book GROUP BY book_name; 注意 group by 语句用法有一个注意点，在 select 语句中，所查询的字段除了聚合函数（SUM ,AVG,COUNT…)以外 必须只能是分组的字段，举例：1SELECT book_id,book_name,count(*) FROM book GROUP BY book_name; 以上会报错,纠正1SELECT book_id,book_name,count(*) FROM book GROUP BY book_id,book_name; 分组后的条件使用 HAVING 来限定，WHERE 是对原始数据进行条件限制。几个关键字的使用顺序为 where 、group by 、having、order by 连接使用 MySQL 的 JOIN 在两个或多个表中查询数据。你可以在 SELECT, UPDATE 和 DELETE 语句中使用 Mysql 的 JOIN 来联合多表查询。JOIN 按照功能大致分为如下三类： INNER JOIN（内连接,或等值连接）：获取两个表中字段匹配关系的记录。 LEFT JOIN（左连接）：获取左表所有记录，即使右表没有对应匹配的记录。 RIGHT JOIN（右连接）： 与 LEFT JOIN 相反，用于获取右表所有记录，即使左表没有对应匹配的记录。 实例 NULL 值处理我们已经知道 MySQL 使用 SQL SELECT 命令及 WHERE 子句来读取数据表中的数据,但是当提供的查询条件字段为 NULL 时，该命令可能就无法正常工作。为了处理这种情况，MySQL提供了三大运算符: IS NULL: 当列的值是 NULL,此运算符返回 true。 IS NOT NULL: 当列的值不为 NULL, 运算符返回 true。 &lt;=&gt;: 比较操作符（不同于=运算符），当比较的的两个值为 NULL 时返回 true。 关于 NULL 的条件比较运算是比较特殊的。你不能使用 = NULL 或 != NULL 在列中查找 NULL 值 。在 MySQL 中，NULL 值与任何其它值的比较（即使是 NULL）永远返回 false，即 NULL = NULL 返回false 。MySQL 中处理 NULL 使用 IS NULL 和 IS NOT NULL 运算符。 实例:表中有一行有NULL值的数据，如果使用1mysql&gt; SELECT * FROM book WHERE pub = NULL; 会出现判断NULL， =和！=是不起作用的12mysql&gt; SELECT * FROM book WHERE author IS NULL;mysql&gt; SELECT * FROM book WHERE author IS NOT NULL; 正则表达式案例 事务MySQL 事务主要用于处理操作量大，复杂度高的数据。比如说，在人员管理系统中，你删除一个人员，你即需要删除人员的基本资料，也要删除和该人员相关的信息，如信箱，文章等等，这样，这些数据库操作语句就构成一个事务！ 在 MySQL 中只有使用了 Innodb 数据库引擎的数据库或表才支持事务。 事务处理可以用来维护数据库的完整性，保证成批的 SQL 语句要么全部执行，要么全部不执行。 事务用来管理 insert,update,delete 语句 一般来说，事务是必须满足4个条件（ACID）：：原子性（Atomicity，或称不可分割性）、一致性（Consistency）、隔离性（Isolation，又称独立性）、持久性（Durability）。 原子性：一个事务（transaction）中的所有操作，要么全部完成，要么全部不完成，不会结束在中间某个环节。事务在执行过程中发生错误，会被回滚（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。 一致性：在事务开始之前和事务结束以后，数据库的完整性没有被破坏。这表示写入的资料必须完全符合所有的预设规则，这包含资料的精确度、串联性以及后续数据库可以自发性地完成预定的工作。 隔离性：数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。事务隔离分为不同级别，包括读未提交（Read uncommitted）、读提交（read committed）、可重复读（repeatable read）和串行化（Serializable）。 持久性：事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。 在 MySQL 命令行的默认设置下，事务都是自动提交的，即执行 SQL 语句后就会马上执行COMMIT 操作。因此要显式地开启一个事务务须使用命令 BEGIN 或 STARTTRANSACTION，或者执行命令 SET AUTOCOMMIT=0，用来禁止使用当前会话的自动提交。 事务控制语句： BEGIN或START TRANSACTION；显式地开启一个事务； COMMIT；也可以使用COMMIT WORK，不过二者是等价的。COMMIT会提交事务，并使已对数据库进行的所有修改成为永久性的； ROLLBACK；有可以使用ROLLBACK WORK，不过二者是等价的。回滚会结束用户的事务，并撤销正在进行的所有未提交的修改； SAVEPOINT identifier；SAVEPOINT允许在事务中创建一个保存点，一个事务中可以有多个SAVEPOINT； RELEASE SAVEPOINT identifier；删除一个事务的保存点，当没有指定的保存点时，执行该语句会抛出一个异常； ROLLBACK TO identifier；把事务回滚到标记点； SET TRANSACTION；用来设置事务的隔离级别。InnoDB存储引擎提供事务的隔离级别有READ UNCOMMITTED、READ COMMITTED、REPEATABLE READ和SERIALIZABLE。 案例 ALTER命令当我们需要修改数据表名或者修改数据表字段时，就需要使用到MySQL ALTER命令。 ALTER TABLE：添加，修改，删除表的列，约束等表的定义。 查看列：desc 表名; 修改表名：alter table t_book rename to bbb; 添加列：alter table 表名 add column 列名 varchar(30); 删除列：alter table 表名 drop column 列名; 修改列名MySQL： alter table bbb change nnnnn hh int; 修改列属性：alter table t_book modify name varchar(22); sp_rename：SQLServer 内置的存储过程，用与修改表的定义。 案例 约束MySQL 查看约束，添加约束，删除约束 添加列，修改列，删除列 查看表的字段信息：desc 表名; 查看表的所有信息：show create table 表名; 添加主键约束：alter table 表名 add constraint 主键 （形如：PK_表名） primary key 表名(主键字段); 添加外键约束：alter table 从表 add constraint 外键（形如：FK_从表_主表） foreign key 从表(外键字段) references 主表(主键字段); 删除主键约束：alter table 表名 drop primary key; 删除外键约束：alter table 表名 drop foreign key 外键（区分大小写）; 修改表名：alter table t_book rename to bbb; 添加列：alter table 表名 add column 列名 varchar(30); 删除列：alter table 表名 drop column 列名; 修改列名： alter table bbb change nnnnn hh int; 修改列属性：alter table t_book modify name varchar(22); 12mysql&gt; desc book;mysql&gt; desc reader; 添加book_id列到reader表，并添加外键约束(book表中的book_id)12mysql&gt; ALTER TABLE reader ADD book_id INT UNSIGNED;mysql&gt; desc reader; 12mysql&gt; ALTER TABLE reader ADD CONSTRAINT fk_book_reader FOREIGN key -&gt; reader(book_id) REFERENCES book(book_id); 出现1215详情见另一篇文章[MySQL错误集] 索引MySQL索引的建立对于MySQL的高效运行是很重要的，索引可以大大提高MySQL的检索速度。打个比方，如果合理的设计且使用索引的MySQL是一辆兰博基尼的话，那么没有设计和使用索引的MySQL就是一个人力三轮车。索引分单列索引和组合索引。单列索引，即一个索引只包含单个列，一个表可以有多个单列索引，但这不是组合索引。组合索引，即一个索引包含多个列。创建索引时，你需要确保该索引是应用在 SQL 查询语句的条件(一般作为 WHERE 子句的条件)。实际上，索引也是一张表，该表保存了主键与索引字段，并指向实体表的记录。上面都在说使用索引的好处，但过多的使用索引将会造成滥用。因此索引也会有它的缺点：虽然索引大大提高了查询速度，同时却会降低更新表的速度，如对表进行INSERT、UPDATE和DELETE。因为更新表时，MySQL不仅要保存数据，还要保存一下索引文件。建立索引会占用磁盘空间的索引文件。 显示索引1mysql&gt; SHOW INDEX FROM table_name\G 普通索引创建索引这是最基本的索引，它没有任何限制。它有以下几种创建方式：1CREATE INDEX indexName ON mytable(cname(length)); 如果是CHAR，VARCHAR类型，length可以小于字段实际长度；如果是BLOB和TEXT类型，必须指定 length。 修改表结构(添加索引)1ALTER table tableName ADD INDEX indexName(columnName) 创建表的时候直接指定12345CREATE TABLE mytable( ID INT NOT NULL, username VARCHAR(16) NOT NULL, INDEX [indexName] (username(length)) ); 删除索引的语法1DROP INDEX [indexName] ON mytable; 为book表中book_name建立基本的索引1mysql&gt; CREATE INDEX INDEX_BOOKNAME ON book(book_name(50)); 唯一索引它与前面的普通索引类似，不同的就是：索引列的值必须唯一，但允许有空值。如果是组合索引，则列值的组合必须唯一。它有以下几种创建方式： 创建索引1CREATE UNIQUE INDEX indexName ON mytable(username(length)) 修改表结构1ALTER table mytable ADD UNIQUE [indexName] (username(length)) 创建表的时候直接指定12345CREATE TABLE mytable( ID INT NOT NULL, username VARCHAR(16) NOT NULL, UNIQUE [indexName] (username(length)) ); 使用ALTER 命令添加和删除索引有四种方式来添加数据表的索引： ALTER TABLE tbl_name ADD PRIMARY KEY (column_list): 该语句添加一个主键，这意味着索引值必须是唯一的，且不能为NULL。 ALTER TABLE tbl_name ADD UNIQUE index_name (column_list): 这条语句创建索引的值必须是唯一的（除了NULL外，NULL可能会出现多次）。 ALTER TABLE tbl_name ADD INDEX index_name (column_list): 添加普通索引，索引值可出现多次。 ALTER TABLE tbl_name ADD FULLTEXT index_name (column_list):该语句指定了索引为 FULLTEXT ，用于全文索引。 例子：1mysql&gt; ALTER TABLE reader ADD INDEX (reader_name); 你还可以在 ALTER 命令中使用 DROP 子句来删除索引。尝试以下实例删除索引:1mysql&gt; ALTER TABLE reader DROP INDEX (reader_name); 使用 ALTER 命令添加和删除主键 主键只能作用于一个列上，添加主键索引时，你需要确保该主键默认不为空（NOT NULL）。实例如下：12mysql&gt; ALTER TABLE testalter_tbl MODIFY i INT NOT NULL;mysql&gt; ALTER TABLE testalter_tbl ADD PRIMARY KEY (i); 你也可以使用 ALTER 命令删除主键：1mysql&gt; ALTER TABLE testalter_tbl DROP PRIMARY KEY; 删除主键时只需指定PRIMARY KEY，但在删除索引时，你必须知道索引名。 临时表MySQL 临时表在我们需要保存一些临时数据时是非常有用的。临时表只在当前连接可见，当关闭连接时，Mysql会自动删除表并释放所有空间。临时表在MySQL 3.23版本中添加，如果你的MySQL版本低于 3.23版本就无法使用MySQL的临时表。不过现在一般很少有再使用这么低版本的MySQL数据库服务了。MySQL临时表只在当前连接可见，如果你使用PHP脚本来创建MySQL临时表，那每当PHP脚本执行完成后，该临时表也会自动销毁。如果你使用了其他MySQL客户端程序连接MySQL数据库服务器来创建临时表，那么只有在关闭客户端程序时才会销毁临时表，当然你也可以手动销毁。 语法和建表差不多，只不过 TABLE 关键字改成 TEMPORARY TABLE 即可。 删除和普通删除表语法没区别。 复制表使用 SHOW CREATE TABLE 命令获取创建数据表(CREATE TABLE) 语句，该语句包含了原数据表的结构，索引等。1mysql&gt; SHOW CREATE TABLE book\G 复制表的内容，你就可以使用 INSERT INTO … SELECT 语句来实现案例 note:来给大家区分下mysql复制表的两种方式。第一、只复制表结构到新表create table 新表 select from 旧表 where 1=2或者create table 新表 like 旧表第二、复制表结构及数据到新表create table新表 select from 旧表 序列使用MySQL 序列是一组整数：1, 2, 3, …，由于一张数据表只能有一个字段自增主键， 如果你想实现其他字段也实现自动增加，就可以使用MySQL序列来实现。 前面也有用到过的 AUTO_INCREMENT 来定义列既可以实现序列 重置序列如果你删除了数据表中的多条记录，并希望对剩下数据的AUTO_INCREMENT列进行重新排列，那么你可以通过删除自增的列，然后重新添加来实现。 不过该操作要非常小心，如果在删除的同时又有新记录添加，有可能会出现数据混乱。操作如下所示：1234mysql&gt; ALTER TABLE insect DROP id;mysql&gt; ALTER TABLE insect -&gt; ADD id INT UNSIGNED NOT NULL AUTO_INCREMENT FIRST, -&gt; ADD PRIMARY KEY (id); 序列的开始值创建表时12345678mysql&gt; CREATE TABLE insect -&gt; ( -&gt; id INT UNSIGNED NOT NULL AUTO_INCREMENT, -&gt; PRIMARY KEY (id), -&gt; name VARCHAR(30) NOT NULL, -&gt; date DATE NOT NULL, -&gt; origin VARCHAR(30) NOT NULL)engine=innodb auto_increment=100 charset=utf8; ALTER修改1mysql&gt; ALTER TABLE t AUTO_INCREMENT = 100; 处理重复数据防止表中出现重复数据你可以在MySQL数据表中设置指定的字段为 PRIMARY KEY（主键） 或者 UNIQUE（唯一） 索引来保证数据的唯一性。 统计重复数据以下我们将统计表中 first_name 和 last_name的重复记录数：1234mysql&gt; SELECT COUNT(*) as repetitions, last_name, first_name -&gt; FROM person_tbl -&gt; GROUP BY last_name, first_name -&gt; HAVING repetitions &gt; 1; 以上查询语句将返回 person_tbl 表中重复的记录数。 一般情况下，查询重复的值，请执行以下操作： 确定哪一列包含的值可能会重复。 在列选择列表使用COUNT(*)列出的那些列。 在GROUP BY子句中列出的列。 HAVING子句设置重复数大于1。 过滤重复数据如果你需要读取不重复的数据可以在 SELECT 语句中使用 DISTINCT 关键字来过滤重复数据。你也可以使用 GROUP BY 来读取数据表中不重复的数据： 导出数据更多 导出 SQL 格式的数据12$ mysqldump -u root -p (dbName) (tableName) &gt; dump.txtpassword ****** 表名可不加，不加则导出整个数据库实例:1$ mysqldump -u root -p booklib &gt; /tmp/booklib.txt 导入数据更多 source命令导入先登录进数据库1234mysql&gt; create database booklib; # 创建数据库mysql&gt; use booklib; # 使用已创建的数据库 mysql&gt; set names utf8; # 设置编码mysql&gt; source /tmp/booklib.sql # 导入备份数据库]]></content>
      <categories>
        <category>DBA</category>
      </categories>
      <tags>
        <tag>Mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Centos7安装Mysql5.7]]></title>
    <url>%2F2018%2F09%2F07%2FCentos7%E5%AE%89%E8%A3%85Mysql5-7%2F</url>
    <content type="text"><![CDATA[环境 centos7 virtualbox 安装centos7需要检查是否已经安装了Mariadb在安装MySQL之前要检查当前环境中是否已经装了Mariadb，如果存在则需要卸载，否则可能导致MySQL安装失败1$ rpm -qa | grep mariadb 如果输出maraidb等的信息则需要进行卸载，如图需要进行强制卸载1$ rpm -e --nodeps mariadb-libs-5.5.56-2.el7.x86_64 Yum Repo官方指导点击链接查看最新的Yum Repository123// 设置rpm$ rpm -Uvh https://dev.mysql.com/get/mysql80-community-release-el7-1.noarch.rpm$ yum repolist all | grep mysql 如图需要安装5.7版本，则需要选择发布系列,编辑/etc/yum.repos.d/mysql-community.repo 文件来选择系列 。这是文件中发布系列的子存储库的典型条目：123456[mysql80-community]name=MySQL 8.0 Community Serverbaseurl=http://repo.mysql.com/yum/mysql-8.0-community/el/6/$basearch/enabled=1gpgcheck=1gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-mysql 找到要配置的子存储库的条目，然后编辑该enabled选项。指定 enabled=0禁用子存储库，或 enabled=1启用子存储库。例如，要安装MySQL 5.7，请确保您拥有enabled=0MySQL 8.0的上述子存储库条目，并且具有 enabled=15.7系列的条目：1234567# Enable to use MySQL 5.7[mysql57-community]name=MySQL 5.7 Community Serverbaseurl=http://repo.mysql.com/yum/mysql-5.7-community/el/6/$basearch/enabled=1gpgcheck=1gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-mysql 您应该只在任何时候为一个发布系列启用子存储库。当启用多个版本系列的子存储库时，Yum将使用最新的系列。 通过运行以下命令并检查其输出来验证是否已启用和禁用了正确的子存储库（对于启用dnf的系统，请使用dnf替换 命令中的 yum）：1$ yum repolist enabled | grep mysql 安装mysql1$ yum install -y mysql-community-server 二进制编译安装后续补上 CMake方式安装后续补上 启动使用以下命令启动MySQL服务器：1$ systemctl start mysqld.service 检查MySQL服务器的状态1$ systemctl status mysqld.service MySQL服务器初始化（从MySQL5.7开始）：在服务器初始启动时，如果服务器的数据目录为空，则会发生以下情况： 服务器已初始化。 在数据目录中生成SSL证书和密钥文件。 该validate_password插件安装并启用。 将‘root‘@’localhost’ 创建一个超级用户帐户。设置超级用户的密码并将其存储在错误日志文件中。要显示它，请使用以下命令：1$ grep 'temporary password' /var/log/mysqld.log 通过上面命令获取生成的临时密码登录并为超级用户帐户设置自定义密码，尽快更改root密码：1$ mysql -uroot -p 修改root本地登录密码1$ ALTER USER 'root'@'localhost' IDENTIFIED BY 'MyNewPass4!'; 注意MySQL的 validate_password 插件默认安装。这将要求密码包含至少一个大写字母，一个小写字母，一个数字和一个特殊字符，并且密码总长度至少为8个字符。 实例]]></content>
      <categories>
        <category>DBA</category>
      </categories>
      <tags>
        <tag>Mysql</tag>
        <tag>Centos7</tag>
        <tag>环境搭建</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo + github 搭建个人博客]]></title>
    <url>%2F2018%2F09%2F07%2Fhexo-github-%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[我的历史上第一篇教程，Hexo+github搭建个人博客。虽然网上有很多，但是想从这一篇开始我的写作之路。 一些前戏搭建此博客时，百度了很多资料，但是上手还是从官方资料开始上手这是官方链接HexoNext主题图标库 开始使用前提Hexo博客的前提需要在本地先安装nodejs与git推荐一下使用淘宝NPM，本人是windows环境下搭建，建议用git-bash NodeJs Git以上的安装就不写在文章里了，不会可自行百度 部署 安装Hexo 1$ npm install -g hexo-cli 搭建安装Hexo完成后，请执行以下命令，hexo会在指定文件夹中创建文件1234$ cd e:/ $ hexo init &lt;folder&gt;$ cd &lt;folder&gt;$ npm install 新建完成后会生成hexo所需要的一些文件_config.yml网站的一些主要配置信息都在这文件下进行配置详细参数可点击链接进行查看config Hexo命令init1$ hexo init [folder] 新建一个网站。如果没有设置 folder ，Hexo 默认在目前的文件夹建立网站 new1$ hexo new [post|draft|page] &lt;title&gt; 新建一篇文章。如果没有设置 layout 的话，默认使用 _config.yml 中的 default_layout 参数代替。如果标题包含空格的话，请使用引号括起来。 generate1$ hexo g 生成静态文件。 server1$ hexo s 启动服务器。默认情况下，访问网址为： http://localhost:4000/。 deploy1$ hexo d 部署网站。 clean1$ hexo clean 清除缓存文件 (db.json) 和已生成的静态文件 (public)。 Hexo美化主题安装这里安装的是比较热门的Next主题里面也有中文文档，安装说明都很详细，具体安装不在本教程说明,但是具体说明主题中的 _config.yml 文件和站点中的 _config.yml 文件配置是有区别之分的，请详细查看清楚具体是配置哪个配置文件。 启用主题修改站点配置文件 _config.yml 1234# Extensions## Plugins: https://hexo.io/plugins/## Themes: https://hexo.io/themes/theme: next 主题设定选择 Scheme Scheme 是 NexT 提供的一种特性，借助于 Scheme，NexT 为你提供多种不同的外观。同时，几乎所有的配置都可以 在 Scheme 之间共用。目前 NexT 支持三种 Scheme，他们是： Muse - 默认 Scheme，这是 NexT 最初的版本，黑白主调，大量留白 Mist - Muse 的紧凑版本，整洁有序的单栏外观 Pisces - 双栏 Scheme，小家碧玉似的清新 Gemini - 左侧网站信息及目录，块+片段结构布局Scheme 的切换通过更改 主题配置文件，搜索 scheme 关键字。 你会看到有四行 scheme 的配置，将你需用启用的 scheme 前面注释 # 去除即可。 动态背景 目前NexT主题最新的是V6.0版本，这个版本中可以有4种动态背景： Canvas-nest three_waves canvas_lines canvas_sphere在 _config.yml 文件中即可配置，但是需要下载配置栗子 点击出现桃心效果浏览器输入：http://7u2ss1.com1.z0.glb.clouddn.com/love.js 拷贝所有代码，在/themes/next/source/js/src里面新建love.js，然后在\themes\next\layout_layout.swig文件末尾添加以下代码： 12&lt;!-- 页面点击小红心 --&gt; &lt;script type="text/javascript" src="/js/src/love.js"&gt;&lt;/script&gt; 设置网站图标默认的网站图标是一个N，当然是需要制定一个图了，在网上找到图后，将其放在 /themes/next/source/images 里面,找到主题配置文件中的favicon关键字，进行替换,如图 实现统计功能 实现效果图 具体实现方法在博客根目录下,git-bash1$ npm install hexo-wordcount --save 然后在主题的配置文件中，配置如下：123# Post wordcount display settings# Dependencies: https://github.com/willin/hexo-wordcountword_count: true 修改主题 swig 布局 为了能在文章信息处显示字数，我们需要修改 themes/next/layout/_macro/post.swig ，在 class 为 post-meta 的 div 中的添加如下内容：12345678910&#123;% if theme.word_count %&#125; &lt;span class=&quot;post-letters-count&quot;&gt; &amp;nbsp; | &amp;nbsp; &lt;i class=&quot;fa fa-align-right&quot;&gt;&lt;/i&gt; &lt;span&gt;字数统计:&#123;&#123; wordcount(post.content) &#125;&#125;字&lt;/span&gt; &amp;nbsp; | &amp;nbsp; &lt;i class=&quot;fa fa-align-left&quot;&gt;&lt;/i&gt; &lt;span&gt;阅读时长:&#123;&#123; min2read(post.content) &#125;&#125;分&lt;/span&gt; &lt;/span&gt;&#123;% endif %&#125; 修改文章内链接文本样式修改文件 themes\next\source\css_common\components\post\post.styl ，在末尾添加如下css样式，：1234567891011// 文章内链接文本样式.post-body p a&#123; color: #0593d3; border-bottom: none; border-bottom: 1px solid #0593d3; &amp;:hover &#123; color: #fc6423; border-bottom: none; border-bottom: 1px solid #fc6423; &#125;&#125; 其中选择 .post-body 是为了不影响标题，选择 p 是为了不影响首页“阅读全文”的显示样式,颜色可以自己定义。 添加背景在 theme/next/source/css/_custom 文件夹下打开 custom.styl 文件，往里面添加以下代码：1234567body&#123; background:url(图片链接); background-size:cover; background-repeat:no-repeat; background-attachment:fixed; background-position:center; &#125; 本地图片将图片放至主题目录下 source\images 修改文章底部的那个带#号的标签 具体实现方法 修改模板 /themes/next/layout/_macro/post.swig ，搜索 rel=”tag”&gt;# ，将 # 换成 在网站底部加上访问量 具体实现方法 打开 \themes\next\layout_partials\footer.swig 文件,在 copyright 前加上画红线这句话：1&lt;script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"&gt;&lt;/script&gt; 然后再合适的位置添加显示统计的代码，如图：1234567&lt;div class="powered-by"&gt; &lt;i class="fa fa-user-md"&gt;&lt;/i&gt; &lt;span id="busuanzi_container_site_uv"&gt; 本站访客数:&lt;span id="busuanzi_value_site_uv"&gt;&lt;/span&gt; &lt;/span&gt; &amp;nbsp|&amp;nbsp&lt;/div&gt; 在这里有两中不同计算方式的统计代码： pv的方式，单个用户连续点击n篇文章，记录n次访问量 123&lt;span id="busuanzi_container_site_pv"&gt; 本站总访问量&lt;span id="busuanzi_value_site_pv"&gt;&lt;/span&gt;次&lt;/span&gt; uv的方式，单个用户连续点击n篇文章，只记录1次访客数 123&lt;span id="busuanzi_container_site_uv"&gt; 本站总访问量&lt;span id="busuanzi_value_site_uv"&gt;&lt;/span&gt;次&lt;/span&gt; 文章加密访问打开 themes\next\layout_partials\head 文件,在以下位置插入这样一段代码：1234567891011121314&lt;script&gt; (function () &#123; if ('&#123;&#123; page.password &#125;&#125;') &#123; if (prompt('请输入文章密码') !== '&#123;&#123; page.password &#125;&#125;') &#123; alert('密码错误！'); if (history.length === 1) &#123; location.replace("http://xxxxxxx.xxx"); // 这里替换成你的首页 &#125; else &#123; history.back(); &#125; &#125; &#125; &#125;)();&lt;/script&gt; 然后在文章上写成类似这样：就ok啦，不过很容易被破解掉噢 当然还有另一种方式 guide1guide2按照指引就可以啦~ 部署首先需要进行创建您个人的github账户 创建公钥打开git-bash,执行 1ssh-keygen -t rsa -C "your_email@youremail.com" 直接按三次回车，可不用输入密码，然后打开C盘查找Users/当前用户目录(Administrator),找到.ssh文件夹，打开文件夹下的id_rsa.pub文件，可用记事本文件打开将里面文字全部复制 打开github个人主页 (https://github.com/settings/ssh) ,点击 Add SSH Key 按钮，粘贴进去保存即可 安装 hexo-deployer-git。 1$ npm install hexo-deployer-git --save 创建github仓库仓库名中填写&lt;github的用户名&gt;.github.io 修改 _config.yml 文件12345deploy: type: git repo: &lt;repository url&gt; branch: [branch] message: [message] repository url使用ssh url即可，message不填也可branch用master分支即可 执行1$ hexo d 或者1$ hexo g -d 进入博客的github所在仓库，进入仓库设置,查看GitHub Pages即可完成部署 基本操作这里只提到一些编写过程中遇到的问题 markdown语法 插入图片这里涉及到资源文件夹 绝对路径当Hexo项目中只用到少量图片时，可以将图片统一放在 source/images 文件夹中，通过markdown语法访问它们。1![](/images/image.jpg) 相对路径图片除了可以放在统一的 source/images 文件夹中，还可以放在文章自己的目录中。文章的目录可以通过配置 config.yml 来生成。1post_asset_folder: true 把 _config.yml 中配置post_asset_folder设置为true后，通过命令hexo new &lt;文章名字&gt;，hexo就会在文章的目录下建立一个和文章同名的文件夹，然后把图片资源放进该文件夹下，即可通过1234567891011121314![](images/image.jpg)``` 记住和第一点绝对路径有区别，别在路径前面加/，否则会出错## 文档格式假设我们的文章名为 “hello hexo markdwon”，在命令行键入以下命令即可：``` markdown---title: hello hexo markdowndate: 2016-11-16 18:11:25tags:--- 这些内容是干嘛的呢？事实上，他们就是用于设置 MarkDown 文档在被解析为静态网页文件时的相关配置，这些配置参数一般位于文件中最上方以 — 分隔的区域。 其中，title 的值是当前文档名，也是将来在网页中显示的文章标题。 date 值是我们新建文档时的当地时区时间。 tags 值是文档的标签，我们可以随意赋值为文档贴标签。其用法如下：12345678---title: hello hexo markdowndate: 2016-11-16 18:11:25tags:- hello- hexo- markdown--- 文章分类categories 是用来给文章分类的，它跟 tags 不同的是其具有顺序性和层次性。 categories 的用法同 tags 一样，只不过斗个 categories 值是分先后顺序的。12categories:- hexo 文章摘要有的时候，主题模板配置的不够好的话，Hexo 最终生成的静态站点是不会自动生成文章摘要的。 所以，为了保险起见，我们也自己手动设置文章摘要，这样也方便避免自动生成的摘要不优雅的情况。 设置文章摘要，我们只需在想显示为摘要的内容之后添 即可。像下面这样：1234567891011---title: hello hexo markdowndate: 2016-11-16 18:11:25tags:- hello- hexo- markdown---我是短小精悍的文章摘要(๑•̀ㅂ•́)و✧&lt;!-- more --&gt;紧接着文章摘要的正文内容 这样， 之前、文档配置参数之后中的内容便会被渲染为站点中的文章摘要。 注意！文章摘要在文章详情页是正文中最前面的内容。]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F09%2F07%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment Warn使用win10记事本编辑会出现乱码问题.]]></content>
  </entry>
</search>
