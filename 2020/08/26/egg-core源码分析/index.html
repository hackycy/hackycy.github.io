<!DOCTYPE html>












  


<html class="theme-next mist use-motion" lang="zh-CN">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">





  
  
    
    
  <script src="/lib/pace/pace.min.js?v=1.0.2"></script>
  <link href="/lib/pace/pace-theme-flash.min.css?v=1.0.2" rel="stylesheet">







<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
    
  
  <link href="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.css" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=6.4.1" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=6.4.1">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.ico?v=6.4.1">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon.ico?v=6.4.1">


  <link rel="mask-icon" href="/images/logo.svg?v=6.4.1" color="#222">









<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '6.4.1',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":true,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




<script type="text/javascript">
    (function () {
        if ('') {
            if (prompt('请输入访问密码') !== '') {
                alert('密码错误！');
                if (history.length === 1) {
                    location.replace("https://hackycy.github.io");
                } else {
                    history.back();
                }
            }
        }
    })();
</script>

  <meta name="description" content="前言最近在翻查egg-cool-router源码查看如何使用装饰器来注册egg路由，看到了一些很牛逼的操作，想知道为什么就查了一下关于源码讲解的文章，解惑了所以摘抄了下来。">
<meta name="keywords" content="NodeJS,Egg">
<meta property="og:type" content="article">
<meta property="og:title" content="egg-core源码分析">
<meta property="og:url" content="http://hackycy.github.io/2020/08/26/egg-core源码分析/index.html">
<meta property="og:site_name" content="思忆技术">
<meta property="og:description" content="前言最近在翻查egg-cool-router源码查看如何使用装饰器来注册egg路由，看到了一些很牛逼的操作，想知道为什么就查了一下关于源码讲解的文章，解惑了所以摘抄了下来。">
<meta property="og:locale" content="zh-CN">
<meta property="og:updated_time" content="2021-01-06T10:23:26.721Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="egg-core源码分析">
<meta name="twitter:description" content="前言最近在翻查egg-cool-router源码查看如何使用装饰器来注册egg路由，看到了一些很牛逼的操作，想知道为什么就查了一下关于源码讲解的文章，解惑了所以摘抄了下来。">



  <link rel="alternate" href="/atom.xml" title="思忆技术" type="application/atom+xml">




  <link rel="canonical" href="http://hackycy.github.io/2020/08/26/egg-core源码分析/">



<script type="text/javascript" id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>egg-core源码分析 | 思忆技术</title>
  






  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?8a525e92400d0ab6fc5484cce235a326";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




  <noscript>
  <style type="text/css">
    .use-motion .motion-element,
    .use-motion .brand,
    .use-motion .menu-item,
    .sidebar-inner,
    .use-motion .post-block,
    .use-motion .pagination,
    .use-motion .comments,
    .use-motion .post-header,
    .use-motion .post-body,
    .use-motion .collection-title { opacity: initial; }

    .use-motion .logo,
    .use-motion .site-title,
    .use-motion .site-subtitle {
      opacity: initial;
      top: initial;
    }

    .use-motion {
      .logo-line-before i { left: initial; }
      .logo-line-after i { right: initial; }
    }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">思忆技术</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
      
        <h1 class="site-subtitle" itemprop="description">思忆，分享技术</h1>
      
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">
    <a href="/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-home"></i> <br>首页</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-about">
    <a href="/about/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-user"></i> <br>关于</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">
    <a href="/tags/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>标签<span class="badge">65</span></a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-categories">
    <a href="/categories/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-th"></i> <br>分类<span class="badge">27</span></a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">
    <a href="/archives/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>归档<span class="badge">141</span></a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-schedule">
    <a href="/schedule/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-calendar"></i> <br>日程表</a>
  </li>

      
      
    </ul>
  

  
    

  

  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  
    <div class="reading-progress-bar"></div>
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://hackycy.github.io/2020/08/26/egg-core源码分析/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="hackycy">
      <meta itemprop="description" content="“被窝是天堂开设在人间的分店。”">
      <meta itemprop="image" content="https://tvax3.sinaimg.cn/crop.0.0.1006.1006.180/006oXysjly8g5r75wnp14j30ry0rydi1.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="思忆技术">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">egg-core源码分析
              
            
          </h2>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2020-08-26 11:17:20" itemprop="dateCreated datePublished" datetime="2020-08-26T11:17:20+00:00">2020-08-26</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2021-01-06 10:23:26" itemprop="dateModified" datetime="2021-01-06T10:23:26+00:00">2021-01-06</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/NodeJS/" itemprop="url" rel="index"><span itemprop="name">NodeJS</span></a></span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2020/08/26/egg-core源码分析/#comments" itemprop="discussionUrl">
                
                  <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2020/08/26/egg-core源码分析/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

          
            <span class="post-letters-count">
                &nbsp; | &nbsp;
              <i class="fa fa-align-right"></i>
              <span>字数统计:8.4k字</span>
                &nbsp; | &nbsp;
              <i class="fa fa-align-left"></i>
              <span>阅读时长:36分</span>
            </span>
          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>最近在翻查<a href="https://www.npmjs.com/package/egg-cool-router" target="_blank" rel="noopener">egg-cool-router</a>源码查看如何使用装饰器来注册egg路由，看到了一些很牛逼的操作，想知道为什么就查了一下关于源码讲解的文章，解惑了所以摘抄了下来。</p>
<a id="more"></a>
<h1 id="egg-core是什么"><a href="#egg-core是什么" class="headerlink" title="egg-core是什么"></a>egg-core是什么</h1><h2 id="应用、框架、插件之间的关系"><a href="#应用、框架、插件之间的关系" class="headerlink" title="应用、框架、插件之间的关系"></a>应用、框架、插件之间的关系</h2><p>在学习egg-core是什么之前，我们先了解一下关于Egg框架中应用，框架，插件这三个概念及其之间的关系：</p>
<ul>
<li>一个应用必须指定一个框架才能运行起来，根据需要我们可以给一个应用配置多个不同的插件</li>
<li>插件只完成特定独立的功能，实现即插即拔的效果</li>
<li>框架是一个启动器，必须有它才能运行起来。框架还是一个封装器，它可以在已有框架的基础上进行封装，框架也可以配置插件，其中Egg，EggCore都是框架</li>
<li>在框架的基础上还可以扩展出新的框架，也就是说框架是可以无限级继承的，有点像类的继承</li>
<li>框架/应用/插件的关于service/controler/config/middleware的目录结构配置基本相同，称之为加载单元（loadUnit），包括后面源码分析中的getLoadUnits都是为了获取这个结构</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"># 加载单元的目录结构如下图，其中插件和框架没有controller和router.js</span><br><span class="line"># 这个目录结构很重要，后面所有的load方法都是针对这个目录结构进行的</span><br><span class="line">        loadUnit</span><br><span class="line">        ├── package.json</span><br><span class="line">        ├── app</span><br><span class="line">        │   ├── extend</span><br><span class="line">        │   |   ├── helper.js</span><br><span class="line">        │   |   ├── request.js</span><br><span class="line">        │   |   ├── response.js</span><br><span class="line">        │   |   ├── context.js</span><br><span class="line">        │   |   ├── application.js</span><br><span class="line">        │   |   └── agent.js</span><br><span class="line">        │   ├── service</span><br><span class="line">        |   ├── controller</span><br><span class="line">        │   ├── middleware</span><br><span class="line">        │   └── router.js</span><br><span class="line">        └── config</span><br><span class="line">            ├── config.default.js</span><br><span class="line">            ├── config.prod.js</span><br><span class="line">            ├── config.test.js</span><br><span class="line">            ├── config.local.js</span><br><span class="line">            └── config.unittest.js</span><br></pre></td></tr></table></figure>
<h2 id="eggCore的主要工作"><a href="#eggCore的主要工作" class="headerlink" title="eggCore的主要工作"></a>eggCore的主要工作</h2><p>egg.js的大部分核心代码实现都在<a href="https://github.com/eggjs/egg-core" target="_blank" rel="noopener">egg-core库</a>中，egg-core主要export四个对象:</p>
<ul>
<li>EggCore类：继承于Koa，做一些初始化工作，EggCore中最主要的一个属性是loader，也就是egg-core的导出的第二个类EggLoader的实例</li>
<li>EggLoader类：整个框架目录结构（controller，service，middleware，extend，route.js）的加载和初始化工作都在该类中实现的，主要提供了几个load函数(loadPlugin,loadConfig,loadMiddleware,loadService,loadController,loadRouter等)，这些函数会根据指定目录结构下文件输出形式不同进行适配，最终挂载输出内容。</li>
<li>BaseContextClass类：这个类主要是为了我们在使用框架开发时，在controller和service作为基类使用，只有继承了该类，我们才可以通过this.ctx获取到当前请求的上下文对象</li>
<li>utils对象：几个主要的函数，包括转换成中间件函数middleware，根据不同类型文件获取文件导出内容函数loadFile等</li>
</ul>
<p>所以egg-core做的主要事情就是根据loadUnit的目录结构规范，将目录结构中的config，controller，service，middleware，plugin，router等文件load到app或者context上，开发人员只要按照这套约定规范，就可以很方便进行开发，以下是EggCore的exports对象源码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//egg-core源码 -&gt; index文件导出的数据结构</span></span><br><span class="line"><span class="keyword">const</span> EggCore = <span class="built_in">require</span>(<span class="string">'./lib/egg'</span>);</span><br><span class="line"><span class="keyword">const</span> EggLoader = <span class="built_in">require</span>(<span class="string">'./lib/loader/egg_loader'</span>);</span><br><span class="line"><span class="keyword">const</span> BaseContextClass = <span class="built_in">require</span>(<span class="string">'./lib/utils/base_context_class'</span>);</span><br><span class="line"><span class="keyword">const</span> utils = <span class="built_in">require</span>(<span class="string">'./lib/utils'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  EggCore,</span><br><span class="line">  EggLoader,</span><br><span class="line">  BaseContextClass,</span><br><span class="line">  utils,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="EggLoader的具体实现源码学习"><a href="#EggLoader的具体实现源码学习" class="headerlink" title="EggLoader的具体实现源码学习"></a>EggLoader的具体实现源码学习</h3><h4 id="EggCore类源码学习"><a href="#EggCore类源码学习" class="headerlink" title="EggCore类源码学习"></a>EggCore类源码学习</h4><p>EggCore类是算是上文提到的框架范畴，它从Koa类继承而来，并做了一些初始化工作，其中有三个主要属性是：</p>
<ul>
<li>loader：这个对象是EggLoader的实例，定义了多个load函数，用于对loadUnit目录下的文件进行加载，后面后专门讲这个类的是实现</li>
<li>router：是EggRouter类的实例，从<a href="https://github.com/alexmingoia/koa-router" target="_blank" rel="noopener">koa-router</a>继承而来，用于egg框架的路由管理和分发，这个类的实现在后面的loadRouter函数会有说明</li>
<li>lifecycle：这个属性用于app的生命周期管理，由于和整个文件加载逻辑关系不大，所以这里不作说明</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//egg-core源码 -&gt; EggCore类的部分实现</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> KoaApplication = <span class="built_in">require</span>(<span class="string">'koa'</span>);</span><br><span class="line"><span class="keyword">const</span> EGG_LOADER = <span class="built_in">Symbol</span>.for(<span class="string">'egg#loader'</span>);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EggCore</span> <span class="keyword">extends</span> <span class="title">KoaApplication</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(options = &#123;&#125;) &#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        <span class="keyword">const</span> Loader = <span class="keyword">this</span>[EGG_LOADER];</span><br><span class="line">        <span class="comment">//初始化loader对象</span></span><br><span class="line">        <span class="keyword">this</span>.loader = <span class="keyword">new</span> Loader(&#123;</span><br><span class="line">            baseDir: options.baseDir,          <span class="comment">//项目启动的根目录</span></span><br><span class="line">            app: <span class="keyword">this</span>,                         <span class="comment">//EggCore实例本身</span></span><br><span class="line">            plugins: options.plugins,          <span class="comment">//自定义插件配置信息，设置插件配置信息有多种方式，后面我们会讲</span></span><br><span class="line">            logger: <span class="keyword">this</span>.console,             </span><br><span class="line">            serverScope: options.serverScope, </span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">get</span> [EGG_LOADER]() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">require</span>(<span class="string">'./loader/egg_loader'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//router对象</span></span><br><span class="line">    <span class="keyword">get</span> router() &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>[ROUTER]) &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">this</span>[ROUTER];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">const</span> router = <span class="keyword">this</span>[ROUTER] = <span class="keyword">new</span> Router(&#123; <span class="attr">sensitive</span>: <span class="literal">true</span> &#125;, <span class="keyword">this</span>);</span><br><span class="line">        <span class="comment">// register router middleware</span></span><br><span class="line">        <span class="keyword">this</span>.beforeStart(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">this</span>.use(router.middleware());</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> router;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//生命周期对象初始化</span></span><br><span class="line">    <span class="keyword">this</span>.lifecycle = <span class="keyword">new</span> Lifecycle(&#123;</span><br><span class="line">        baseDir: options.baseDir,</span><br><span class="line">        app: <span class="keyword">this</span>,</span><br><span class="line">        logger: <span class="keyword">this</span>.console,</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="EggLoader类源码学习"><a href="#EggLoader类源码学习" class="headerlink" title="EggLoader类源码学习"></a>EggLoader类源码学习</h4><p>如果说eggCore是egg框架的精华所在，那么eggLoader可以说是eggCore的精华所在，下面我们主要从EggLoader的实现细节开始学习eggCore这个库：</p>
<p>EggLoader首先对app中的一些基本信息（pkg/eggPaths/serverEnv/appInfo/serverScope/baseDir等）进行整理，并且定义一些基础共用函数(getEggPaths/getTypeFiles/getLoadUnits/loadFile)，所有的这些基础准备都是为了后面介绍的几个load函数作准备，我们下面看一下其基础部分的实现：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//egg-core源码 -&gt; EggLoader中基本属性和基本函数的实现</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EggLoader</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(options) &#123;</span><br><span class="line">        <span class="keyword">this</span>.options = options;</span><br><span class="line">        <span class="keyword">this</span>.app = <span class="keyword">this</span>.options.app;</span><br><span class="line">        <span class="comment">//pkg是根目录的package.json输出对象</span></span><br><span class="line">        <span class="keyword">this</span>.pkg = utility.readJSONSync(path.join(<span class="keyword">this</span>.options.baseDir, <span class="string">'package.json'</span>));</span><br><span class="line">        <span class="comment">//eggPaths是所有框架目录的集合体，虽然我们上面提到一个应用只有一个框架，但是框架可以在框架的基础上实现多级继承，所以是多个eggPath</span></span><br><span class="line">        <span class="comment">//在实现框架类的时候，必须指定属性Symbol.for('egg#eggPath')，这样才能找到框架的目录结构</span></span><br><span class="line">        <span class="comment">//下面有关于getEggPaths函数的实现分析</span></span><br><span class="line">        <span class="keyword">this</span>.eggPaths = <span class="keyword">this</span>.getEggPaths();</span><br><span class="line">        <span class="keyword">this</span>.serverEnv = <span class="keyword">this</span>.getServerEnv();</span><br><span class="line">        <span class="comment">//获取app的一些基本配置信息(name,baseDir,env,scope,pkg等)</span></span><br><span class="line">        <span class="keyword">this</span>.appInfo = <span class="keyword">this</span>.getAppInfo();</span><br><span class="line">        <span class="keyword">this</span>.serverScope = options.serverScope !== <span class="literal">undefined</span></span><br><span class="line">            ? options.serverScope</span><br><span class="line">            : <span class="keyword">this</span>.getServerScope();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//递归获取继承链上所有eggPath</span></span><br><span class="line">    getEggPaths() &#123;</span><br><span class="line">        <span class="keyword">const</span> EggCore = <span class="built_in">require</span>(<span class="string">'../egg'</span>);</span><br><span class="line">        <span class="keyword">const</span> eggPaths = [];</span><br><span class="line">        <span class="keyword">let</span> proto = <span class="keyword">this</span>.app;</span><br><span class="line">        <span class="comment">//循环递归的获取原型链上的框架Symbol.for('egg#eggPath')属性</span></span><br><span class="line">        <span class="keyword">while</span> (proto) &#123;</span><br><span class="line">            proto = <span class="built_in">Object</span>.getPrototypeOf(proto);</span><br><span class="line">            <span class="comment">//直到proto属性等于EggCore本身，说明到了最上层的框架类，停止循环</span></span><br><span class="line">            <span class="keyword">if</span> (proto === <span class="built_in">Object</span>.prototype || proto === EggCore.prototype) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">const</span> eggPath = proto[<span class="built_in">Symbol</span>.for(<span class="string">'egg#eggPath'</span>)];</span><br><span class="line">            <span class="keyword">const</span> realpath = fs.realpathSync(eggPath);</span><br><span class="line">            <span class="keyword">if</span> (!eggPaths.includes(realpath)) &#123;</span><br><span class="line">                eggPaths.unshift(realpath);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> eggPaths;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//函数输入：config或者plugin；函数输出：当前环境下的所有配置文件</span></span><br><span class="line">    <span class="comment">//该函数会根据serverScope，serverEnv的配置信息，返回当前环境对应filename的所有配置文件</span></span><br><span class="line">    <span class="comment">//比如我们的serverEnv=prod，serverScope=online，那么返回的config配置文件是['config.default', 'config.prod', 'config.online_prod']</span></span><br><span class="line">    <span class="comment">//这几个文件加载顺序非常重要，因为最终获取到的config信息会进行深度的覆盖，后面的文件信息会覆盖前面的文件信息</span></span><br><span class="line">    getTypeFiles(filename) &#123;</span><br><span class="line">        <span class="keyword">const</span> files = [ <span class="string">`<span class="subst">$&#123;filename&#125;</span>.default`</span> ];</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.serverScope) files.push(<span class="string">`<span class="subst">$&#123;filename&#125;</span>.<span class="subst">$&#123;<span class="keyword">this</span>.serverScope&#125;</span>`</span>);</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.serverEnv === <span class="string">'default'</span>) <span class="keyword">return</span> files;</span><br><span class="line"></span><br><span class="line">        files.push(<span class="string">`<span class="subst">$&#123;filename&#125;</span>.<span class="subst">$&#123;<span class="keyword">this</span>.serverEnv&#125;</span>`</span>);</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.serverScope) files.push(<span class="string">`<span class="subst">$&#123;filename&#125;</span>.<span class="subst">$&#123;<span class="keyword">this</span>.serverScope&#125;</span>_<span class="subst">$&#123;<span class="keyword">this</span>.serverEnv&#125;</span>`</span>);</span><br><span class="line">        <span class="keyword">return</span> files;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//获取框架、应用、插件的loadUnits目录集合，上文有关于loadUnits的说明</span></span><br><span class="line">    <span class="comment">//这个函数在下文中介绍的loadSerivce,loadMiddleware,loadConfig,loadExtend中都会用到，因为plugin，framework，app中都会有关系这些信息的配置</span></span><br><span class="line">    getLoadUnits() &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.dirs) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.dirs;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">const</span> dirs = <span class="keyword">this</span>.dirs = [];</span><br><span class="line">        <span class="comment">//插件目录，关于orderPlugins会在后面的loadPlugin函数中讲到</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.orderPlugins) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">const</span> plugin <span class="keyword">of</span> <span class="keyword">this</span>.orderPlugins) &#123;</span><br><span class="line">                dirs.push(&#123;</span><br><span class="line">                    path: plugin.path,</span><br><span class="line">                    type: <span class="string">'plugin'</span>,</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//框架目录</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> eggPath <span class="keyword">of</span> <span class="keyword">this</span>.eggPaths) &#123;</span><br><span class="line">            dirs.push(&#123;</span><br><span class="line">                path: eggPath,</span><br><span class="line">                type: <span class="string">'framework'</span>,</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//应用目录</span></span><br><span class="line">        dirs.push(&#123;</span><br><span class="line">            path: <span class="keyword">this</span>.options.baseDir,</span><br><span class="line">            type: <span class="string">'app'</span>,</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> dirs;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这个函数用于读取某个LoadUnit下的文件具体内容，包括js文件，json文件及其它普通文件</span></span><br><span class="line">    loadFile(filepath, ...inject) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!filepath || !fs.existsSync(filepath)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (inject.length === <span class="number">0</span>) inject = [ <span class="keyword">this</span>.app ];</span><br><span class="line">        <span class="keyword">let</span> ret = <span class="keyword">this</span>.requireFile(filepath);</span><br><span class="line">        <span class="comment">//这里要注意，如果某个js文件导出的是一个函数，且不是一个Class，那么Egg认为这个函数的格式是：app =&gt; &#123;&#125;,输入是EggCore实例，输出是真正需要的信息</span></span><br><span class="line">        <span class="keyword">if</span> (is<span class="function">.<span class="keyword">function</span>(<span class="params">ret</span>) &amp;&amp; !<span class="title">is</span>.<span class="title">class</span>(<span class="params">ret</span>)) </span>&#123;</span><br><span class="line">            ret = ret(...inject);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="各种loader函数的实现源码分析"><a href="#各种loader函数的实现源码分析" class="headerlink" title="各种loader函数的实现源码分析"></a>各种loader函数的实现源码分析</h3><p>上文中只是介绍了EggLoader中的一些基本属性和函数，那么如何将LoadUnits中的不同类型的文件分别加载进来呢，egg-core中每一种类型（service/controller等）的文件加载都在一个独立的文件里实现。比如我们加载controller文件可以通过’./mixin/controller’目录下的loadController完成，加载service文件可以通过’./mixin/service’下的loadService函数完成，然后将这些方法挂载EggLoader的原型上，这样就可以直接在EggLoader的实例上使用</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//egg-core源码 -&gt; 混入不同目录文件的加载方法到EggLoader的原型上</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> loaders = [</span><br><span class="line">  <span class="built_in">require</span>(<span class="string">'./mixin/plugin'</span>),            <span class="comment">//loadPlugin方法</span></span><br><span class="line">  <span class="built_in">require</span>(<span class="string">'./mixin/config'</span>),            <span class="comment">//loadConfig方法</span></span><br><span class="line">  <span class="built_in">require</span>(<span class="string">'./mixin/extend'</span>),            <span class="comment">//loadExtend方法</span></span><br><span class="line">  <span class="built_in">require</span>(<span class="string">'./mixin/custom'</span>),            <span class="comment">//loadCustomApp和loadCustomAgent方法</span></span><br><span class="line">  <span class="built_in">require</span>(<span class="string">'./mixin/service'</span>),           <span class="comment">//loadService方法</span></span><br><span class="line">  <span class="built_in">require</span>(<span class="string">'./mixin/middleware'</span>),        <span class="comment">//loadMiddleware方法</span></span><br><span class="line">  <span class="built_in">require</span>(<span class="string">'./mixin/controller'</span>),        <span class="comment">//loadController方法</span></span><br><span class="line">  <span class="built_in">require</span>(<span class="string">'./mixin/router'</span>),            <span class="comment">//loadRouter方法</span></span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> loader <span class="keyword">of</span> loaders) &#123;</span><br><span class="line">  <span class="built_in">Object</span>.assign(EggLoader.prototype, loader);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们按照上述loaders中定义的元素顺序，对各个load函数的源码实现进行一一分析：</p>
<h4 id="loadPlugin函数"><a href="#loadPlugin函数" class="headerlink" title="loadPlugin函数"></a>loadPlugin函数</h4><p>插件是一个迷你的应用，没有包含router.js和controller文件夹，我们上文也提到，应用和框架里都可以包含插件，而且还可以通过环境变量和初始化参数传入，关于插件初始化的几个参数：</p>
<ul>
<li>enable： 是否开启插件</li>
<li>env： 选择插件在哪些环境运行</li>
<li>path： 插件的所在路径</li>
<li>package： 和path只能设置其中一个，根据package名称去node_modules里查询plugin，后面源码里有详细说明</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//egg-core源码 -&gt; loadPlugin函数部分源码</span></span><br><span class="line"></span><br><span class="line">loadPlugin() &#123;</span><br><span class="line">    <span class="comment">//加载应用目录下的plugins</span></span><br><span class="line">    <span class="comment">//readPluginConfigs这个函数会先调用我们上文提到的getTypeFiles获取到app目录下所有的plugin文件名，然后按照文件顺序进行加载并合并，并规范plugin的数据结构</span></span><br><span class="line">    <span class="keyword">const</span> appPlugins = <span class="keyword">this</span>.readPluginConfigs(path.join(<span class="keyword">this</span>.options.baseDir, <span class="string">'config/plugin.default'</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//加载框架目录下的plugins</span></span><br><span class="line">    <span class="keyword">const</span> eggPluginConfigPaths = <span class="keyword">this</span>.eggPaths.map(<span class="function"><span class="params">eggPath</span> =&gt;</span> path.join(eggPath, <span class="string">'config/plugin.default'</span>));</span><br><span class="line">    <span class="keyword">const</span> eggPlugins = <span class="keyword">this</span>.readPluginConfigs(eggPluginConfigPaths);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//可以通过环境变量EGG_PLUGINS对配置plugins，从环境变量加载plugins</span></span><br><span class="line">    <span class="keyword">let</span> customPlugins;</span><br><span class="line">    <span class="keyword">if</span> (process.env.EGG_PLUGINS) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        customPlugins = <span class="built_in">JSON</span>.parse(process.env.EGG_PLUGINS);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">        debug(<span class="string">'parse EGG_PLUGINS failed, %s'</span>, e);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//从启动参数options里加载plugins</span></span><br><span class="line">    <span class="comment">//启动参数的plugins和环境变量的plugins都是自定义的plugins，可以对默认的应用和框架plugin进行覆盖</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.options.plugins) &#123;</span><br><span class="line">      customPlugins = <span class="built_in">Object</span>.assign(&#123;&#125;, customPlugins, <span class="keyword">this</span>.options.plugins);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.allPlugins = &#123;&#125;;</span><br><span class="line">    <span class="keyword">this</span>.appPlugins = appPlugins;</span><br><span class="line">    <span class="keyword">this</span>.customPlugins = customPlugins;</span><br><span class="line">    <span class="keyword">this</span>.eggPlugins = eggPlugins;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//按照顺序对plugin进行合并及覆盖</span></span><br><span class="line">    <span class="comment">//_extendPlugins在合并的过程中，对相同name的plugin中的属性进行覆盖，有一个特殊处理的地方，如果某个属性的值是空数组，那么不会覆盖前者</span></span><br><span class="line">    <span class="keyword">this</span>._extendPlugins(<span class="keyword">this</span>.allPlugins, eggPlugins);</span><br><span class="line">    <span class="keyword">this</span>._extendPlugins(<span class="keyword">this</span>.allPlugins, appPlugins);</span><br><span class="line">    <span class="keyword">this</span>._extendPlugins(<span class="keyword">this</span>.allPlugins, customPlugins);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> enabledPluginNames = []; <span class="comment">// enabled plugins that configured explicitly</span></span><br><span class="line">    <span class="keyword">const</span> plugins = &#123;&#125;;</span><br><span class="line">    <span class="keyword">const</span> env = <span class="keyword">this</span>.serverEnv;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> name <span class="keyword">in</span> <span class="keyword">this</span>.allPlugins) &#123;</span><br><span class="line">      <span class="keyword">const</span> plugin = <span class="keyword">this</span>.allPlugins[name];</span><br><span class="line">      <span class="comment">//plugin的path可能是直接指定的，也有可能指定了一个package的name，然后从node_modules中查找</span></span><br><span class="line">      <span class="comment">//从node_modules中查找的顺序是：&#123;APP_PATH&#125;/node_modules -&gt; &#123;EGG_PATH&#125;/node_modules -&gt; $CWD/node_modules</span></span><br><span class="line">      plugin.path = <span class="keyword">this</span>.getPluginPath(plugin, <span class="keyword">this</span>.options.baseDir);</span><br><span class="line">      <span class="comment">//这个函数会读取每个plugin.path路径下的package.json,获取plugin的version，并会使用package.json中的dependencies，optionalDependencies, env变量作覆盖</span></span><br><span class="line">      <span class="keyword">this</span>.mergePluginConfig(plugin);</span><br><span class="line">      <span class="comment">// 有些plugin只有在某些环境（serverEnv）下才能使用，否则改成enable=false</span></span><br><span class="line">      <span class="keyword">if</span> (env &amp;&amp; plugin.env.length &amp;&amp; !plugin.env.includes(env)) &#123;</span><br><span class="line">        plugin.enable = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//获取enable=true的所有pluginnName</span></span><br><span class="line">      plugins[name] = plugin;</span><br><span class="line">      <span class="keyword">if</span> (plugin.enable) &#123;</span><br><span class="line">        enabledPluginNames.push(name);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这个函数会检查插件的依赖关系，插件的依赖关系在dependencies中定义，最后返回所有需要的插件</span></span><br><span class="line">    <span class="comment">//如果enable=true的插件依赖的插件不在已有的插件中，或者插件的依赖关系存在循环引用，则会抛出异常</span></span><br><span class="line">    <span class="comment">//如果enable=true的依赖插件为enable=false，那么该被依赖的插件会被改为enable=true</span></span><br><span class="line">    <span class="keyword">this</span>.orderPlugins = <span class="keyword">this</span>.getOrderPlugins(plugins, enabledPluginNames, appPlugins);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//最后我们以对象的方式将enable=true的插件挂载在this对象上</span></span><br><span class="line">    <span class="keyword">const</span> enablePlugins = &#123;&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> plugin <span class="keyword">of</span> <span class="keyword">this</span>.orderPlugins) &#123;</span><br><span class="line">      enablePlugins[plugin.name] = plugin;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.plugins = enablePlugins;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="loadConfig函数"><a href="#loadConfig函数" class="headerlink" title="loadConfig函数"></a>loadConfig函数</h4><p>配置信息的管理对于一个应用来说非常重要，我们需要对不同的部署环境的配置进行管理，Egg就是针对环境加载不同的配置文件，然后将配置挂载在app上，</p>
<p>加载config的逻辑相对简单，就是按照顺序加载所有loadUnit目录下的config文件内容，进行合并，最后将config信息挂载在this对象上，整个加载函数请看下面源码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//egg-core源码 -&gt; loadConfig函数分析</span></span><br><span class="line"></span><br><span class="line">loadConfig() &#123;</span><br><span class="line">    <span class="keyword">this</span>.configMeta = &#123;&#125;;</span><br><span class="line">    <span class="keyword">const</span> target = &#123;&#125;;</span><br><span class="line">    <span class="comment">//这里之所以先加载app相关的config，是因为在加载plugin和framework的config时会使用到app的config</span></span><br><span class="line">    <span class="keyword">const</span> appConfig = <span class="keyword">this</span>._preloadAppConfig();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//config的加载顺序为：plugin config.default -&gt; framework config.default -&gt; app config.default -&gt; plugin config.&#123;env&#125; -&gt; framework config.&#123;env&#125; -&gt; app config.&#123;env&#125;</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> filename <span class="keyword">of</span> <span class="keyword">this</span>.getTypeFiles(<span class="string">'config'</span>)) &#123;</span><br><span class="line">    <span class="comment">// getLoadUnits函数前面有介绍，获取loadUnit目录集合</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">const</span> unit <span class="keyword">of</span> <span class="keyword">this</span>.getLoadUnits()) &#123;</span><br><span class="line">        <span class="keyword">const</span> isApp = unit.type === <span class="string">'app'</span>;</span><br><span class="line">        <span class="comment">//如果是加载插件和框架下面的config，那么会将appConfig当作参数传入</span></span><br><span class="line">        <span class="comment">//这里appConfig已经加载了一遍了，又重复加载了，不知道处于什么原因，下面会有_loadConfig函数源码分析</span></span><br><span class="line">        <span class="keyword">const</span> config = <span class="keyword">this</span>._loadConfig(unit.path, filename, isApp ? <span class="literal">undefined</span> : appConfig, unit.type);</span><br><span class="line">        <span class="keyword">if</span> (!config) &#123;</span><br><span class="line">          <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//config进行覆盖</span></span><br><span class="line">        extend(<span class="literal">true</span>, target, config);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.config = target;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">_loadConfig(dirpath, filename, extraInject, type) &#123;</span><br><span class="line">    <span class="keyword">const</span> isPlugin = type === <span class="string">'plugin'</span>;</span><br><span class="line">    <span class="keyword">const</span> isApp = type === <span class="string">'app'</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> filepath = <span class="keyword">this</span>.resolveModule(path.join(dirpath, <span class="string">'config'</span>, filename));</span><br><span class="line">    <span class="comment">//如果没有config.default文件，则用config.js文件替代，隐藏逻辑</span></span><br><span class="line">    <span class="keyword">if</span> (filename === <span class="string">'config.default'</span> &amp;&amp; !filepath) &#123;</span><br><span class="line">      filepath = <span class="keyword">this</span>.resolveModule(path.join(dirpath, <span class="string">'config/config'</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//loadFile函数我们在EggLoader中讲到过，如果config导出的是一个函数会先执行这个函数，将函数的返回结果导出，函数的参数也就是[this.appInfo extraInject]</span></span><br><span class="line">    <span class="keyword">const</span> config = <span class="keyword">this</span>.loadFile(filepath, <span class="keyword">this</span>.appInfo, extraInject);</span><br><span class="line">    <span class="keyword">if</span> (!config) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//框架使用哪些中间件也是在config里作配置的，后面关于loadMiddleware函数实现中有说明</span></span><br><span class="line">    <span class="comment">//coreMiddleware只能在框架里使用</span></span><br><span class="line">    <span class="keyword">if</span> (isPlugin || isApp) &#123;</span><br><span class="line">      assert(!config.coreMiddleware, <span class="string">'Can not define coreMiddleware in app or plugin'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//middleware只能在应用里定义</span></span><br><span class="line">    <span class="keyword">if</span> (!isApp) &#123;</span><br><span class="line">      assert(!config.middleware, <span class="string">'Can not define middleware in '</span> + filepath);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//这里是为了设置configMeta，表示每个配置项是从哪里来的</span></span><br><span class="line">    <span class="keyword">this</span>[SET_CONFIG_META](config, filepath);</span><br><span class="line">    <span class="keyword">return</span> config;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h4 id="loadExtend相关函数"><a href="#loadExtend相关函数" class="headerlink" title="loadExtend相关函数"></a>loadExtend相关函数</h4><p>这里的loadExtend是一个笼统的概念，其实是针对koa中的app.response，app.respond，app.context以及app本身进行扩展，同样是根据所有loadUnits下的配置顺序进行加载</p>
<p>下面看一下loadExtend这个函数的实现，一个通用的加载函数</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//egg-core -&gt; loadExtend函数实现</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//name输入是"response"/"respond"/"context"/"app"中的一个，proto是被扩展的对象</span></span><br><span class="line">loadExtend(name, proto) &#123;</span><br><span class="line">    <span class="comment">//获取指定name所有loadUnits下的配置文件路径</span></span><br><span class="line">    <span class="keyword">const</span> filepaths = <span class="keyword">this</span>.getExtendFilePaths(name);</span><br><span class="line">    <span class="keyword">const</span> isAddUnittest = <span class="string">'EGG_MOCK_SERVER_ENV'</span> <span class="keyword">in</span> process.env &amp;&amp; <span class="keyword">this</span>.serverEnv !== <span class="string">'unittest'</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, l = filepaths.length; i &lt; l; i++) &#123;</span><br><span class="line">      <span class="keyword">const</span> filepath = filepaths[i];</span><br><span class="line">      filepaths.push(filepath + <span class="string">`.<span class="subst">$&#123;<span class="keyword">this</span>.serverEnv&#125;</span>`</span>);</span><br><span class="line">      <span class="keyword">if</span> (isAddUnittest) filepaths.push(filepath + <span class="string">'.unittest'</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这里并没有对属性的直接覆盖，而是对原先的PropertyDescriptor的get和set进行合并</span></span><br><span class="line">    <span class="keyword">const</span> mergeRecord = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> filepath <span class="keyword">of</span> filepaths) &#123;</span><br><span class="line">      filepath = <span class="keyword">this</span>.resolveModule(filepath);</span><br><span class="line">      <span class="keyword">const</span> ext = <span class="keyword">this</span>.requireFile(filepath);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">const</span> properties = <span class="built_in">Object</span>.getOwnPropertyNames(ext)</span><br><span class="line">        .concat(<span class="built_in">Object</span>.getOwnPropertySymbols(ext));</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">const</span> property <span class="keyword">of</span> properties) &#123;</span><br><span class="line">        <span class="keyword">let</span> descriptor = <span class="built_in">Object</span>.getOwnPropertyDescriptor(ext, property);</span><br><span class="line">        <span class="keyword">let</span> originalDescriptor = <span class="built_in">Object</span>.getOwnPropertyDescriptor(proto, property);</span><br><span class="line">        <span class="keyword">if</span> (!originalDescriptor) &#123;</span><br><span class="line">          <span class="keyword">const</span> originalProto = originalPrototypes[name];</span><br><span class="line">          <span class="keyword">if</span> (originalProto) &#123;</span><br><span class="line">            originalDescriptor = <span class="built_in">Object</span>.getOwnPropertyDescriptor(originalProto, property);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果原始对象上已经存在相关属性的Descriptor，那么对其set和get方法进行合并</span></span><br><span class="line">        <span class="keyword">if</span> (originalDescriptor) &#123;</span><br><span class="line">          <span class="comment">// don't override descriptor</span></span><br><span class="line">          descriptor = <span class="built_in">Object</span>.assign(&#123;&#125;, descriptor);</span><br><span class="line">          <span class="keyword">if</span> (!descriptor.set &amp;&amp; originalDescriptor.set) &#123;</span><br><span class="line">            descriptor.set = originalDescriptor.set;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">if</span> (!descriptor.get &amp;&amp; originalDescriptor.get) &#123;</span><br><span class="line">            descriptor.get = originalDescriptor.get;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//否则直接覆盖</span></span><br><span class="line">        <span class="built_in">Object</span>.defineProperty(proto, property, descriptor);</span><br><span class="line">        mergeRecord.set(property, filepath);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h4 id="loadService函数"><a href="#loadService函数" class="headerlink" title="loadService函数"></a>loadService函数</h4><h5 id="如何在egg框架中使用service"><a href="#如何在egg框架中使用service" class="headerlink" title="如何在egg框架中使用service"></a>如何在egg框架中使用service</h5><p>loadService函数的实现是所有load函数中最复杂的一个，我们不着急看源码，先看一下service在egg框架中如何使用</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//egg-core源码 -&gt; 如何在egg框架中使用service</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//方式1：app/service/user1.js</span></span><br><span class="line"><span class="comment">//这个是最标准的做法，导出一个class，这个class继承了require('egg').Service，其实也就是我们上文提到的eggCore导出的BaseContextClass</span></span><br><span class="line"><span class="comment">//最终我们在业务逻辑中获取到的是这个class的一个实例，在load的时候是将app.context当作新建实例的参数</span></span><br><span class="line"><span class="comment">//在controller中调用方式：this.ctx.service.user1.find(1)</span></span><br><span class="line"><span class="keyword">const</span> Service = <span class="built_in">require</span>(<span class="string">'egg'</span>).Service;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserService</span> <span class="keyword">extends</span> <span class="title">Service</span> </span>&#123;</span><br><span class="line">  <span class="keyword">async</span> find(uid) &#123;</span><br><span class="line">    <span class="comment">//此时我们可以通过this.ctx,this.app,this.config,this.service获取到有用的信息，尤其是this.ctx非常重要，每个请求对应一个ctx，我们可以查询到当前请求的所有信息</span></span><br><span class="line">    <span class="keyword">const</span> user = <span class="keyword">await</span> <span class="keyword">this</span>.ctx.db.query(<span class="string">'select * from user where uid = ?'</span>, uid);</span><br><span class="line">    <span class="keyword">return</span> user;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">module</span>.exports = UserService;</span><br><span class="line"></span><br><span class="line"><span class="comment">//方式2：app/service/user2.js</span></span><br><span class="line"><span class="comment">//这个做法是我模拟了一个BaseContextClass，当然也就可以实现方法1的目的，但是不推荐</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(ctx) &#123;</span><br><span class="line">    <span class="keyword">this</span>.ctx = ctx;</span><br><span class="line">    <span class="keyword">this</span>.app = ctx.app;</span><br><span class="line">    <span class="keyword">this</span>.config = ctx.app.config;</span><br><span class="line">    <span class="keyword">this</span>.service = ctx.service;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">async</span> find(uid) &#123;</span><br><span class="line">    <span class="keyword">const</span> user = <span class="keyword">await</span> <span class="keyword">this</span>.ctx.db.query(<span class="string">'select * from user where uid = ?'</span>, uid);</span><br><span class="line">    <span class="keyword">return</span> user;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">module</span>.exports = UserService;</span><br><span class="line"></span><br><span class="line"><span class="comment">//方式3：app/service/user3.js</span></span><br><span class="line"><span class="comment">//service中也可以export函数，在load的时候会主动调用这个函数，把appInfo参数传入，最终获取到的是函数返回结果</span></span><br><span class="line"><span class="comment">//在controller中调用方式：this.ctx.service.user3.getAppName(1)，这个时候在service中获取不到当前请求的上下文ctx</span></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function">(<span class="params">appInfo</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="keyword">async</span> getAppName(uid)&#123;</span><br><span class="line">            <span class="keyword">return</span> appInfo.name;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//方式4：app/service/user4.js</span></span><br><span class="line"><span class="comment">//service也可以直接export普通的原生对象，load的时候会将该普通对象返回，同样获取不到当前请求的上下文ctx</span></span><br><span class="line"><span class="comment">//在controller中调用方式：this.ctx.service.user4.getAppName(1)</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    <span class="keyword">async</span> getAppName(uid)&#123;</span><br><span class="line">        <span class="keyword">return</span> appInfo.name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>我们上面列举了service下的js文件的四种写法，都是从每次请求的上下文this.ctx获取到service对象，然后就可以使用到每个service文件导出的对象了，这里主要有两个地方需要注意：</p>
<ol>
<li><p>为什么我们可以从每个请求的this.ctx上获取到service对象呢：</p>
<p>看过koa源码的同学知道，this.ctx其实是从app.context继承而来，所以我们只要把service绑定到app.context上，那么当前请求的上下文ctx自然可以拿到service对象，eggLoader也是这样做的</p>
</li>
<li><p>针对上述四种使用场景，具体导出实例是怎么处理的呢？</p>
<ul>
<li>如果导出的是一个类，EggLoader会主动以ctx对象去初始化这个实例并导出，所以我们就可以直接在该类中使用this.ctx获取当前请求的上下文了</li>
<li>如果导出的是一个函数，那么EggLoader会以app作为参数运行这个函数并将结果导出</li>
<li>如果是一个普通的对象，直接导出</li>
</ul>
</li>
</ol>
<h5 id="FileLoader类的实现分析"><a href="#FileLoader类的实现分析" class="headerlink" title="FileLoader类的实现分析"></a>FileLoader类的实现分析</h5><p>在实现loadService函数时，有一个基础类就是FileLoader，它同时也是loadMiddleware，loadController实现的基础，这个类提供一个load函数根据目录结构和文件内容进行解析，返回一个target对象，我们可以根据文件名以及子文件名以及函数名称获取到service里导出的内容，target结构类似这样：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"file1"</span>: &#123;</span><br><span class="line">        <span class="attr">"file11"</span>: &#123;</span><br><span class="line">            <span class="attr">"function1"</span>: a =&gt; a</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"file2"</span>: &#123;</span><br><span class="line">        <span class="attr">"function2"</span>: a =&gt; a</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面我们先看一下fileLoader这个类的实现</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//egg-core源码 -&gt; FileLoader实现</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FileLoader</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(options) &#123;</span><br><span class="line">    <span class="comment">/*options里几个重要参数的含义:</span></span><br><span class="line"><span class="comment">    1.directory: 需要加载文件的所有目录</span></span><br><span class="line"><span class="comment">    2.target: 最终加载成功后的目标对象</span></span><br><span class="line"><span class="comment">    3.initializer：一个初始化函数，对文件导出内容进行初始化，这个在loadController实现时会用到</span></span><br><span class="line"><span class="comment">    4.inject：如果某个文件的导出对象是一个函数，那么将该值传入函数并执行导出，一般都是this.app</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">this</span>.options = <span class="built_in">Object</span>.assign(&#123;&#125;, defaults, options);</span><br><span class="line">  &#125;</span><br><span class="line">  load() &#123;</span><br><span class="line">    <span class="comment">//解析directory下的文件，下面有parse函数的部分实现</span></span><br><span class="line">    <span class="keyword">const</span> items = <span class="keyword">this</span>.parse();</span><br><span class="line">    <span class="keyword">const</span> target = <span class="keyword">this</span>.options.target;</span><br><span class="line">    <span class="comment">//item1 = &#123; properties: [ 'a', 'b', 'c'], exports1 &#125;,item2 = &#123; properties: [ 'a', 'b', 'd'], exports2 &#125;</span></span><br><span class="line">    <span class="comment">// =&gt; target = &#123;a: &#123;b: &#123;c: exports1, d: exports2&#125;&#125;&#125;</span></span><br><span class="line">    <span class="comment">//根据文件路径名称递归生成一个大的对象target，我们通过target.file1.file2就可以获取到对应的导出内容</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> item <span class="keyword">of</span> items) &#123;</span><br><span class="line">      item.properties.reduce(<span class="function">(<span class="params">target, property, index</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> obj;</span><br><span class="line">        <span class="keyword">const</span> properties = item.properties.slice(<span class="number">0</span>, index + <span class="number">1</span>).join(<span class="string">'.'</span>);</span><br><span class="line">        <span class="keyword">if</span> (index === item.properties.length - <span class="number">1</span>) &#123;</span><br><span class="line">          obj = item.exports;</span><br><span class="line">          <span class="keyword">if</span> (obj &amp;&amp; !is.primitive(obj)) &#123;</span><br><span class="line">            <span class="comment">//这步骤很重要，确定这个target是不是一个exports，有可能只是一个路径而已</span></span><br><span class="line">            obj[FULLPATH] = item.fullpath;</span><br><span class="line">            obj[EXPORTS] = <span class="literal">true</span>;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          obj = target[property] || &#123;&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        target[property] = obj;</span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">      &#125;, target);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> target;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//最终生成[&#123; properties: [ 'a', 'b', 'c'], exports，fullpath&#125;]形式，properties文件路径名称的数组，exports是导出对象，fullpath是文件的绝对路径</span></span><br><span class="line">  parse() &#123;</span><br><span class="line">    <span class="comment">//文件目录转换为数组</span></span><br><span class="line">    <span class="keyword">let</span> directories = <span class="keyword">this</span>.options.directory;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">Array</span>.isArray(directories)) &#123;</span><br><span class="line">      directories = [ directories ];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//遍历所有文件路径</span></span><br><span class="line">    <span class="keyword">const</span> items = [];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> directory <span class="keyword">of</span> directories) &#123;</span><br><span class="line">      <span class="comment">//每个文件目录下面可能还会有子文件夹，所以globby.sync函数是获取所有文件包括子文件下的文件的路径</span></span><br><span class="line">      <span class="keyword">const</span> filepaths = globby.sync(files, &#123; <span class="attr">cwd</span>: directory &#125;);</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">const</span> filepath <span class="keyword">of</span> filepaths) &#123;</span><br><span class="line">        <span class="keyword">const</span> fullpath = path.join(directory, filepath);</span><br><span class="line">        <span class="keyword">if</span> (!fs.statSync(fullpath).isFile()) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="comment">//获取文件路径上的以"/"分割的所有文件名，foo/bar.js =&gt; [ 'foo', 'bar' ]，这个函数会对propertie同一格式，默认为驼峰</span></span><br><span class="line">        <span class="keyword">const</span> properties = getProperties(filepath, <span class="keyword">this</span>.options);</span><br><span class="line">        <span class="comment">//app/service/foo/bar.js =&gt; service.foo.bar</span></span><br><span class="line">        <span class="keyword">const</span> pathName = directory.split(<span class="regexp">/[/\\]/</span>).slice(<span class="number">-1</span>) + <span class="string">'.'</span> + properties.join(<span class="string">'.'</span>);</span><br><span class="line">        <span class="comment">//getExports函数获取文件内容，并将结果做一些处理，看下面实现</span></span><br><span class="line">        <span class="keyword">const</span> exports = getExports(fullpath, <span class="keyword">this</span>.options, pathName);</span><br><span class="line">        <span class="comment">//如果导出的是class，会设置一些属性，这个属性下文中对于class的特殊处理地方会用到</span></span><br><span class="line">        <span class="keyword">if</span> (is.class(exports)) &#123;</span><br><span class="line">          exports.prototype.pathName = pathName;</span><br><span class="line">          exports.prototype.fullPath = fullpath;</span><br><span class="line">        &#125;</span><br><span class="line">        items.push(&#123; fullpath, properties, exports &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> items;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//根据指定路径获取导出对象并作预处理</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getExports</span>(<span class="params">fullpath, &#123; initializer, call, inject &#125;, pathName</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> exports = utils.loadFile(fullpath);</span><br><span class="line">  <span class="comment">//用initializer函数对exports结果做预处理</span></span><br><span class="line">  <span class="keyword">if</span> (initializer) &#123;</span><br><span class="line">    exports = initializer(exports, &#123; <span class="attr">path</span>: fullpath, pathName &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//如果exports是class，generatorFunction，asyncFunction则直接返回    </span></span><br><span class="line">  <span class="keyword">if</span> (is.class(exports) || is.generatorFunction(exports) || is.asyncFunction(exports)) &#123;</span><br><span class="line">    <span class="keyword">return</span> exports;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//如果导出的是一个普通函数，并且设置了call=true，默认是true，会将inject传入并调用该函数，上文中提到过好几次，就是在这里实现的</span></span><br><span class="line">  <span class="keyword">if</span> (call &amp;&amp; is<span class="function">.<span class="keyword">function</span>(<span class="params">exports</span>)) </span>&#123;</span><br><span class="line">    exports = exports(inject);</span><br><span class="line">    <span class="keyword">if</span> (exports != <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> exports;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//其它情况直接返回</span></span><br><span class="line">  <span class="keyword">return</span> exports;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="ContextLoader类的实现分析"><a href="#ContextLoader类的实现分析" class="headerlink" title="ContextLoader类的实现分析"></a>ContextLoader类的实现分析</h5><p>上文中说道loadService函数其实最终把service对象挂载在了app.context上，所以为此提供了ContextLoader这个类，继承了FileLoader类，用于将FileLoader解析出来的target挂载在app.context上，下面是其实现：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//egg-core -&gt; ContextLoader类的源码实现</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ContextLoader</span> <span class="keyword">extends</span> <span class="title">FileLoader</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(options) &#123;</span><br><span class="line">    <span class="keyword">const</span> target = options.target = &#123;&#125;;</span><br><span class="line">    <span class="keyword">super</span>(options);</span><br><span class="line">    <span class="comment">//FileLoader已经讲过inject就是app</span></span><br><span class="line">    <span class="keyword">const</span> app = <span class="keyword">this</span>.options.inject;</span><br><span class="line">    <span class="comment">//property就是要挂载的属性，比如"service"</span></span><br><span class="line">    <span class="keyword">const</span> property = options.property;</span><br><span class="line">    <span class="comment">//将service属性挂载在app.context上</span></span><br><span class="line">    <span class="built_in">Object</span>.defineProperty(app.context, property, &#123;</span><br><span class="line">      <span class="keyword">get</span>() &#123;</span><br><span class="line">        <span class="comment">//做缓存，由于不同的请求ctx不一样，这里是针对同一个请求的内容进行缓存</span></span><br><span class="line">        <span class="keyword">if</span> (!<span class="keyword">this</span>[CLASSLOADER]) &#123;</span><br><span class="line">          <span class="keyword">this</span>[CLASSLOADER] = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">const</span> classLoader = <span class="keyword">this</span>[CLASSLOADER];</span><br><span class="line">        <span class="comment">//获取导出实例，这里就是上文用例中获取this.ctx.service.file1.fun1的实现，这里的实例就是this.ctx.service,实现逻辑请看下面的getInstance的实现</span></span><br><span class="line">        <span class="keyword">let</span> instance = classLoader.get(property);</span><br><span class="line">        <span class="keyword">if</span> (!instance) &#123;</span><br><span class="line">          <span class="comment">//这里传入的this就是为了初始化require('egg').Service实例时当作参数传入</span></span><br><span class="line">          <span class="comment">//this会根据调用者的不同而改变，比如是app.context的实例调用那么就是app.context，如果是app.context子类的实例调用，那么就是其子类的实例</span></span><br><span class="line">          <span class="comment">//就是因为这个this，我们service里继承require('egg').Service，才可以通过this.ctx获取到当前请求的上下文</span></span><br><span class="line">          instance = getInstance(target, <span class="keyword">this</span>);</span><br><span class="line">          classLoader.set(property, instance);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//values是FileLoader/load函数生成target对象</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getInstance</span>(<span class="params">values, ctx</span>) </span>&#123;</span><br><span class="line">  <span class="comment">//上文FileLoader里实现中我们讲过，target对象是一个由路径和exports组装成的一个大对象，这里Class是为了确定其是不是一个exports，有可能是一个路径名</span></span><br><span class="line">  <span class="keyword">const</span> Class = values[EXPORTS] ? values : <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">let</span> instance;</span><br><span class="line">  <span class="keyword">if</span> (Class) &#123;</span><br><span class="line">    <span class="keyword">if</span> (is.class(Class)) &#123;</span><br><span class="line">        <span class="comment">//这一步很重要，如果是类，就用ctx进行初始化获取实例</span></span><br><span class="line">      instance = <span class="keyword">new</span> Class(ctx);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">//普通对象直接导出，这里要注意的是如果是exports函数，在FileLoader实现中已经将其执行并转换为了对象</span></span><br><span class="line">      <span class="comment">//function和class分别在子类和父类的处理的原因是，function的处理逻辑loadMiddleware,loadService,loadController公用，而class的处理逻辑loadService使用</span></span><br><span class="line">      instance = Class;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (is.primitive(values)) &#123;</span><br><span class="line">    <span class="comment">//原生类型直接导出</span></span><br><span class="line">    instance = values;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//如果目前的target部分是一个路径，那么会新建一个ClassLoader实例，这个ClassLoader中又会递归的调用getInstance</span></span><br><span class="line">    <span class="comment">//这里之所以新建一个类，一是为了做缓存，二是为了在每个节点获取到的都是一个类的实例</span></span><br><span class="line">    instance = <span class="keyword">new</span> ClassLoader(&#123; ctx, <span class="attr">properties</span>: values &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="loadService的实现"><a href="#loadService的实现" class="headerlink" title="loadService的实现"></a>loadService的实现</h5><p>有了ContextLoader类，那实现loadService函数就非常容易了，如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//egg-core -&gt; loadService函数实现源码</span></span><br><span class="line"><span class="comment">//loadService函数调用loadToContext函数</span></span><br><span class="line">loadService(opt) &#123;</span><br><span class="line">    opt = <span class="built_in">Object</span>.assign(&#123;</span><br><span class="line">      call: <span class="literal">true</span>,</span><br><span class="line">      caseStyle: <span class="string">'lower'</span>,</span><br><span class="line">      fieldClass: <span class="string">'serviceClasses'</span>,</span><br><span class="line">      directory: <span class="keyword">this</span>.getLoadUnits().map(<span class="function"><span class="params">unit</span> =&gt;</span> path.join(unit.path, <span class="string">'app/service'</span>)), <span class="comment">//所有加载单元目录下的service</span></span><br><span class="line">    &#125;, opt);</span><br><span class="line">    <span class="keyword">const</span> servicePaths = opt.directory;</span><br><span class="line">    <span class="keyword">this</span>.loadToContext(servicePaths, <span class="string">'service'</span>, opt);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//loadToContext函数直接新建ContextLoader实例，调用load函数实现加载</span></span><br><span class="line">loadToContext(directory, property, opt) &#123;</span><br><span class="line">    opt = <span class="built_in">Object</span>.assign(&#123;&#125;, &#123;</span><br><span class="line">      directory,</span><br><span class="line">      property,</span><br><span class="line">      inject: <span class="keyword">this</span>.app,</span><br><span class="line">    &#125;, opt);</span><br><span class="line">    <span class="keyword">new</span> ContextLoader(opt).load();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="loadMiddleware函数"><a href="#loadMiddleware函数" class="headerlink" title="loadMiddleware函数"></a>loadMiddleware函数</h4><p>中间件是koa框架中很重要的一个环节，通过app.use引入中间件，使用洋葱圈模型，所以中间件加载的顺序很重要。</p>
<ul>
<li>如果在上文中的config中配置的中间件，系统会自动用app.use函数使用该中间件</li>
<li>所有的中间件我们都可以在app.middleware中通过中间件name获取到，便于在业务中动态使用</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//egg-core -&gt; loadMiddleware函数实现源码</span></span><br><span class="line"></span><br><span class="line">loadMiddleware(opt) &#123;</span><br><span class="line">    <span class="keyword">const</span> app = <span class="keyword">this</span>.app;</span><br><span class="line">    <span class="comment">// load middleware to app.middleware</span></span><br><span class="line">    opt = <span class="built_in">Object</span>.assign(&#123;</span><br><span class="line">      call: <span class="literal">false</span>,   <span class="comment">//call=false表示如果中间件导出是函数，不会主动调用函数做转换</span></span><br><span class="line">      override: <span class="literal">true</span>,</span><br><span class="line">      caseStyle: <span class="string">'lower'</span>,</span><br><span class="line">      directory: <span class="keyword">this</span>.getLoadUnits().map(<span class="function"><span class="params">unit</span> =&gt;</span> join(unit.path, <span class="string">'app/middleware'</span>)) <span class="comment">//所有加载单元目录下的middleware</span></span><br><span class="line">    &#125;, opt);</span><br><span class="line">    <span class="keyword">const</span> middlewarePaths = opt.directory;</span><br><span class="line">    <span class="comment">//将所有中间件middlewares挂载在app上，这个函数在loadController实现中也用到了，看下文的实现</span></span><br><span class="line">    <span class="keyword">this</span>.loadToApp(middlewarePaths, <span class="string">'middlewares'</span>, opt);</span><br><span class="line">    <span class="comment">//将app.middlewares中的每个中间件重新绑定在app.middleware上，每个中间件的属性不可配置，不可枚举</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> name <span class="keyword">in</span> app.middlewares) &#123;</span><br><span class="line">      <span class="built_in">Object</span>.defineProperty(app.middleware, name, &#123;</span><br><span class="line">        <span class="keyword">get</span>() &#123;</span><br><span class="line">          <span class="keyword">return</span> app.middlewares[name];</span><br><span class="line">        &#125;,</span><br><span class="line">        enumerable: <span class="literal">false</span>,</span><br><span class="line">        configurable: <span class="literal">false</span>,</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//只有在config中配置了appMiddleware和coreMiddleware才会直接在app.use中使用，其它中间件只是挂载在app上，开发人员可以动态使用</span></span><br><span class="line">    <span class="keyword">const</span> middlewareNames = <span class="keyword">this</span>.config.coreMiddleware.concat(<span class="keyword">this</span>.config.appMiddleware);</span><br><span class="line">    <span class="keyword">const</span> middlewaresMap = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> name <span class="keyword">of</span> middlewareNames) &#123;</span><br><span class="line">      <span class="comment">//如果config中定义middleware在app.middlewares中找不到或者重复定义，都会报错</span></span><br><span class="line">      <span class="keyword">if</span> (!app.middlewares[name]) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">`Middleware <span class="subst">$&#123;name&#125;</span> not found`</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (middlewaresMap.has(name)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">`Middleware <span class="subst">$&#123;name&#125;</span> redefined`</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      middlewaresMap.set(name, <span class="literal">true</span>);</span><br><span class="line">      <span class="keyword">const</span> options = <span class="keyword">this</span>.config[name] || &#123;&#125;;</span><br><span class="line">      <span class="keyword">let</span> mw = app.middlewares[name];</span><br><span class="line">      <span class="comment">//中间件的文件定义必须exports一个普通function，并且接受两个参数：</span></span><br><span class="line">      <span class="comment">//options: 中间件的配置项，框架会将 app.config[$&#123;middlewareName&#125;] 传递进来, app: 当前应用 Application 的实例</span></span><br><span class="line">      <span class="comment">//执行exports的函数，生成最终要的中间件</span></span><br><span class="line">      mw = mw(options, app);</span><br><span class="line">      mw._name = name;</span><br><span class="line">      <span class="comment">//包装中间件，最终转换成async function(ctx, next)形式</span></span><br><span class="line">      mw = wrapMiddleware(mw, options);</span><br><span class="line">      <span class="keyword">if</span> (mw) &#123;</span><br><span class="line">        app.use(mw);</span><br><span class="line">        <span class="keyword">this</span>.options.logger.info(<span class="string">'[egg:loader] Use middleware: %s'</span>, name);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.options.logger.info(<span class="string">'[egg:loader] Disable middleware: %s'</span>, name);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过FileLoader实例加载指定属性的所有文件并导出，然后将该属性挂载在app上</span></span><br><span class="line">loadToApp(directory, property, opt) &#123;</span><br><span class="line">    <span class="keyword">const</span> target = <span class="keyword">this</span>.app[property] = &#123;&#125;;</span><br><span class="line">    opt = <span class="built_in">Object</span>.assign(&#123;&#125;, &#123;</span><br><span class="line">      directory,</span><br><span class="line">      target,</span><br><span class="line">      inject: <span class="keyword">this</span>.app,</span><br><span class="line">    &#125;, opt);</span><br><span class="line">    <span class="keyword">new</span> FileLoader(opt).load();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="loadController函数"><a href="#loadController函数" class="headerlink" title="loadController函数"></a>loadController函数</h4><p>controller中生成的函数最终还是在router.js中当作一个中间件使用，所以我们需要将controller中内容转换为中间件形式async function(ctx, next)，其中initializer这个函数就是用来针对不同的情况将controller中的内容转换为中间件的，下面是loadController的实现逻辑：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//egg-core源码 -&gt; loadController函数实现源码</span></span><br><span class="line"></span><br><span class="line">loadController(opt) &#123;</span><br><span class="line">    opt = <span class="built_in">Object</span>.assign(&#123;</span><br><span class="line">      caseStyle: <span class="string">'lower'</span>,</span><br><span class="line">      directory: path.join(<span class="keyword">this</span>.options.baseDir, <span class="string">'app/controller'</span>),</span><br><span class="line">      <span class="comment">//这个配置，上文有提到，是为了对导出对象做预处理的函数</span></span><br><span class="line">      initializer: <span class="function">(<span class="params">obj, opt</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">//如果是普通函数，依然直接调用它生成新的对象</span></span><br><span class="line">        <span class="keyword">if</span> (is<span class="function">.<span class="keyword">function</span>(<span class="params">obj</span>) &amp;&amp; !<span class="title">is</span>.<span class="title">generatorFunction</span>(<span class="params">obj</span>) &amp;&amp; !<span class="title">is</span>.<span class="title">class</span>(<span class="params">obj</span>) &amp;&amp; !<span class="title">is</span>.<span class="title">asyncFunction</span>(<span class="params">obj</span>)) </span>&#123;</span><br><span class="line">          obj = obj(<span class="keyword">this</span>.app);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (is.class(obj)) &#123;</span><br><span class="line">          obj.prototype.pathName = opt.pathName;</span><br><span class="line">          obj.prototype.fullPath = opt.path;</span><br><span class="line">          <span class="comment">//如果是一个class，class中的函数转换成async function(ctx, next)中间件形式，并用ctx去初始化该class，所以在controller里我们也可以使用this.ctx.xxx形式</span></span><br><span class="line">          <span class="keyword">return</span> wrapClass(obj);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (is.object(obj)) &#123;</span><br><span class="line">          <span class="comment">//如果是一个Object，会递归的将该Object中每个属性对应的函数转换成async function(ctx, next)中间件形式形式</span></span><br><span class="line">          <span class="keyword">return</span> wrapObject(obj, opt.path);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// support generatorFunction for forward compatbility</span></span><br><span class="line">        <span class="keyword">if</span> (is.generatorFunction(obj) || is.asyncFunction(obj)) &#123;</span><br><span class="line">          <span class="keyword">return</span> wrapObject(&#123; <span class="string">'module.exports'</span>: obj &#125;, opt.path)[<span class="string">'module.exports'</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;, opt);</span><br><span class="line">    <span class="comment">//loadController函数同样是通过loadToApp函数将其导出对象挂载在app下，controller里的内容在loadRouter时会将其载入</span></span><br><span class="line">    <span class="keyword">const</span> controllerBase = opt.directory;</span><br><span class="line">    <span class="keyword">this</span>.loadToApp(controllerBase, <span class="string">'controller'</span>, opt);</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure>
<h4 id="loadRouter函数"><a href="#loadRouter函数" class="headerlink" title="loadRouter函数"></a>loadRouter函数</h4><p>loadRouter函数特别简单，只是require加载一下app/router目录下的文件而已，而所有的事情都交给了EggCore类上的router属性去实现</p>
<p>而router又是Router类的实例，Router类是基于koa-router实现的</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//egg-core源码 -&gt; loadRouter函数源码实现</span></span><br><span class="line"></span><br><span class="line">loadRouter() &#123;</span><br><span class="line">    <span class="keyword">this</span>.loadFile(<span class="keyword">this</span>.resolveModule(path.join(<span class="keyword">this</span>.options.baseDir, <span class="string">'app/router'</span>)));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置router属性的get方法</span></span><br><span class="line"><span class="keyword">get</span> router() &#123;</span><br><span class="line">    <span class="comment">//缓存设置</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>[ROUTER]) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>[ROUTER];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//新建Router实例，其中Router类是继承koa-router实现的</span></span><br><span class="line">    <span class="keyword">const</span> router = <span class="keyword">this</span>[ROUTER] = <span class="keyword">new</span> Router(&#123; <span class="attr">sensitive</span>: <span class="literal">true</span> &#125;, <span class="keyword">this</span>);</span><br><span class="line">    <span class="comment">//在启动前将router中间件载入引用</span></span><br><span class="line">    <span class="keyword">this</span>.beforeStart(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.use(router.middleware());</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> router;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="comment">//将router上所有的method函数代理到EggCore上，这样我们就可以通过app.get('/async', ...asyncMiddlewares, 'subController.subHome.async1')的方式配置路由</span></span><br><span class="line">utils.methods.concat([ <span class="string">'all'</span>, <span class="string">'resources'</span>, <span class="string">'register'</span>, <span class="string">'redirect'</span> ]).forEach(<span class="function"><span class="params">method</span> =&gt;</span> &#123;</span><br><span class="line">  EggCore.prototype[method] = <span class="function"><span class="keyword">function</span>(<span class="params">...args</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.router[method](...args);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>Router类继承了KoaRouter类，并对其的method相关函数做了扩展，解析controller的写法，同时提供了resources方法，为了兼容restAPI的方式</p>
<p>关于restAPI的使用方式和实现源码我们这里就不介绍了，可以看官方文档，有具体的格式要求，下面看一下Router类的部分实现逻辑：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//egg-core源码 -&gt; Router类实现源码</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Router</span> <span class="keyword">extends</span> <span class="title">KoaRouter</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(opts, app) &#123;</span><br><span class="line">    <span class="keyword">super</span>(opts);</span><br><span class="line">    <span class="keyword">this</span>.app = app;</span><br><span class="line">    <span class="comment">//对method方法进行扩展</span></span><br><span class="line">    <span class="keyword">this</span>.patchRouterMethod();</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  patchRouterMethod() &#123;</span><br><span class="line">    <span class="comment">//为了支持generator函数类型，以及获取controller类中导出的中间件</span></span><br><span class="line">    methods.concat([ <span class="string">'all'</span> ]).forEach(<span class="function"><span class="params">method</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>[method] = <span class="function">(<span class="params">...args</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">//spliteAndResolveRouterParams主要是为了拆分router.js中的路由规则，将其拆分成普通中间件和controller生成的中间件部分，请看下文源码</span></span><br><span class="line">        <span class="keyword">const</span> splited = spliteAndResolveRouterParams(&#123; args, <span class="attr">app</span>: <span class="keyword">this</span>.app &#125;);</span><br><span class="line">        args = splited.prefix.concat(splited.middlewares);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>[method](...args);</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//返回router里每个路由规则的前缀和中间件部分</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">spliteAndResolveRouterParams</span>(<span class="params">&#123; args, app &#125;</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> prefix;</span><br><span class="line">    <span class="keyword">let</span> middlewares;</span><br><span class="line">    <span class="keyword">if</span> (args.length &gt;= <span class="number">3</span> &amp;&amp; (is.string(args[<span class="number">1</span>]) || is.regExp(args[<span class="number">1</span>]))) &#123;</span><br><span class="line">        <span class="comment">// app.get(name, url, [...middleware], controller)的形式</span></span><br><span class="line">        prefix = args.slice(<span class="number">0</span>, <span class="number">2</span>);</span><br><span class="line">        middlewares = args.slice(<span class="number">2</span>);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// app.get(url, [...middleware], controller)的形式</span></span><br><span class="line">        prefix = args.slice(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">        middlewares = args.slice(<span class="number">1</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//controller部分肯定是最后一个</span></span><br><span class="line">      <span class="keyword">const</span> controller = middlewares.pop();</span><br><span class="line">      <span class="comment">//resolveController函数主要是为了处理router.js中关于controller的两种写法：</span></span><br><span class="line">      <span class="comment">//写法1：app.get('/async', ...asyncMiddlewares, 'subController.subHome.async1')</span></span><br><span class="line">      <span class="comment">//写法2：app.get('/async', ...asyncMiddlewares, subController.subHome.async1)</span></span><br><span class="line">      <span class="comment">//最终从app.controller上获取到真正的controller中间件，resolveController具体函数实现就不介绍了</span></span><br><span class="line">      middlewares.push(resolveController(controller, app));</span><br><span class="line">      <span class="keyword">return</span> &#123; prefix, middlewares &#125;;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>以上便是对EggCore的大部分源码的实现的学习总结，其中关于源码中一些debug代码以及timing运行时间记录的代码都删掉了，关于app的生命周期管理的那部分代码和loadUnits加载逻辑关系不大，所以没有讲到。EggCore的核心在于EggLoader，也就是plugin，config, extend, service, middleware, controller, router的加载函数，而这几个内容加载必须按照顺序进行加载，存在依赖关系，比如：</p>
<ul>
<li>加载middleware时会用到config关于应用中间件的配置</li>
<li>加载router时会用到关于controller的配置</li>
<li>而config，extend，service，middleware，controller的加载都必须依赖于plugin，通过plugin配置获取插件目录</li>
<li>service，middleware，controller，router的加载又必须依赖于extend（对app进行扩展），因为如果exports是函数的情况下，会将app作为参数执行函数</li>
</ul>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li><a href="https://www.npmjs.com/package/egg-cool-router" target="_blank" rel="noopener">https://www.npmjs.com/package/egg-cool-router</a></li>
<li>摘抄自：<a href="https://cnodejs.org/topic/5bc933129545eaf107b9cc84" target="_blank" rel="noopener">https://cnodejs.org/topic/5bc933129545eaf107b9cc84</a></li>
</ul>

      
    </div>

    

    
    
    

    

    
      <div>
        <div style="padding: 10px 0; margin: 20px auto; width: 90%; text-align: center;">
  <div>坚持技术分享，您的支持将鼓励我继续创作！</div>
  <button id="rewardButton" disable="enable" onclick="var qr = document.getElementById('QR'); if (qr.style.display === 'none') {qr.style.display='block';} else {qr.style.display='none'}">
    <span>打赏</span>
  </button>
  <div id="QR" style="display: none;">

    
      <div id="wechat" style="display: inline-block">
        <img id="wechat_qr" src="/images/wechatpay.png" alt="hackycy 微信支付">
        <p>微信支付</p>
      </div>
    

    
      <div id="alipay" style="display: inline-block">
        <img id="alipay_qr" src="/images/alipay.jpg" alt="hackycy 支付宝">
        <p>支付宝</p>
      </div>
    

    

  </div>
</div>

      </div>
    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/NodeJS/" rel="tag"><i class="fa fa-tag"></i> NodeJS</a>
          
            <a href="/tags/Egg/" rel="tag"><i class="fa fa-tag"></i> Egg</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2020/08/25/Typescript装饰器讲解/" rel="next" title="Typescript装饰器讲解">
                <i class="fa fa-chevron-left"></i> Typescript装饰器讲解
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2020/09/15/解决Element-UI-el-tree有关子、父节点选中问题/" rel="prev" title="解决Element-UI el-tree有关子、父节点选中问题">
                解决Element-UI el-tree有关子、父节点选中问题 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>


  </div>


          </div>
          

  
    <div class="comments" id="comments">
      <div id="disqus_thread">
        <noscript>
          Please enable JavaScript to view the
          <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a>
        </noscript>
      </div>
    </div>

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="https://tvax3.sinaimg.cn/crop.0.0.1006.1006.180/006oXysjly8g5r75wnp14j30ry0rydi1.jpg" alt="hackycy">
            
              <p class="site-author-name" itemprop="name">hackycy</p>
              <p class="site-description motion-element" itemprop="description">“被窝是天堂开设在人间的分店。”</p>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">141</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  <a href="/categories/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">27</span>
                    <span class="site-state-item-name">分类</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  <a href="/tags/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">65</span>
                    <span class="site-state-item-name">标签</span>
                  </a>
                </div>
              
            </nav>
          

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          
            <div class="links-of-author motion-element">
              
                <span class="links-of-author-item">
                  <a href="https://github.com/hackycy" target="_blank" title="GitHub" rel="external nofollow"><i class="fa fa-fw fa-github"></i>GitHub</a>
                  
                </span>
              
                <span class="links-of-author-item">
                  <a href="mailto:qa894178522@qq.com" target="_blank" title="E-Mail" rel="external nofollow"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  
                </span>
              
                <span class="links-of-author-item">
                  <a href="https://plus.google.com/101705678931630585525" target="_blank" title="Google" rel="external nofollow"><i class="fa fa-fw fa-google"></i>Google</a>
                  
                </span>
              
            </div>
          

          
          

          
          
            <div class="links-of-blogroll motion-element links-of-blogroll-block">
              <div class="links-of-blogroll-title">
                <i class="fa  fa-fw fa-link"></i>
                推荐
              </div>
              <ul class="links-of-blogroll-list">
                
                  <li class="links-of-blogroll-item">
                    <a href="http://www.si-yee.com" title="思忆技术" target="_blank">思忆技术</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="https://lover.si-yee.com" title="我与她的爱情计时器" target="_blank">我与她的爱情计时器</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="https://www.aliyun.com" title="阿里云" target="_blank">阿里云</a>
                  </li>
                
              </ul>
            </div>
          

          
            
          
          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#前言"><span class="nav-number">1.</span> <span class="nav-text">前言</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#egg-core是什么"><span class="nav-number">2.</span> <span class="nav-text">egg-core是什么</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#应用、框架、插件之间的关系"><span class="nav-number">2.1.</span> <span class="nav-text">应用、框架、插件之间的关系</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#eggCore的主要工作"><span class="nav-number">2.2.</span> <span class="nav-text">eggCore的主要工作</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#EggLoader的具体实现源码学习"><span class="nav-number">2.2.1.</span> <span class="nav-text">EggLoader的具体实现源码学习</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#EggCore类源码学习"><span class="nav-number">2.2.1.1.</span> <span class="nav-text">EggCore类源码学习</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#EggLoader类源码学习"><span class="nav-number">2.2.1.2.</span> <span class="nav-text">EggLoader类源码学习</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#各种loader函数的实现源码分析"><span class="nav-number">2.2.2.</span> <span class="nav-text">各种loader函数的实现源码分析</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#loadPlugin函数"><span class="nav-number">2.2.2.1.</span> <span class="nav-text">loadPlugin函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#loadConfig函数"><span class="nav-number">2.2.2.2.</span> <span class="nav-text">loadConfig函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#loadExtend相关函数"><span class="nav-number">2.2.2.3.</span> <span class="nav-text">loadExtend相关函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#loadService函数"><span class="nav-number">2.2.2.4.</span> <span class="nav-text">loadService函数</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#如何在egg框架中使用service"><span class="nav-number">2.2.2.4.1.</span> <span class="nav-text">如何在egg框架中使用service</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#FileLoader类的实现分析"><span class="nav-number">2.2.2.4.2.</span> <span class="nav-text">FileLoader类的实现分析</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#ContextLoader类的实现分析"><span class="nav-number">2.2.2.4.3.</span> <span class="nav-text">ContextLoader类的实现分析</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#loadService的实现"><span class="nav-number">2.2.2.4.4.</span> <span class="nav-text">loadService的实现</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#loadMiddleware函数"><span class="nav-number">2.2.2.5.</span> <span class="nav-text">loadMiddleware函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#loadController函数"><span class="nav-number">2.2.2.6.</span> <span class="nav-text">loadController函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#loadRouter函数"><span class="nav-number">2.2.2.7.</span> <span class="nav-text">loadRouter函数</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#总结"><span class="nav-number">3.</span> <span class="nav-text">总结</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#参考资料"><span class="nav-number">4.</span> <span class="nav-text">参考资料</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<div class="copyright">&copy; 2018 – <span itemprop="copyrightYear">2021</span>
  <span class="with-love" id="animate">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">hackycy <a class="theme-link" target="_blank" rel="external nofollow" href="http://beian.miit.gov.cn/">粤ICP备19140352号-1</a></span>

  

  
</div>


  



  <div class="powered-by">
    <span id="busuanzi_container_site_uv">
    本站访客数:<span id="busuanzi_value_site_uv"></span>次
    </span>
    &nbsp|&nbsp
  </div>
  <div class="powered-by">
    <span>
    本站总字数:<span>322.9k</span>字
    </span>
    &nbsp|&nbsp
  </div>
  <div class="powered-by">由 <a class="theme-link" target="_blank" rel="external nofollow" href="https://hexo.io">Hexo</a> 强力驱动 v3.9.0</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 – <a class="theme-link" target="_blank" rel="external nofollow" href="https://theme-next.org">NexT.Mist</a> v6.4.1</div>




        
<div class="busuanzi-count">
  <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  

  
</div>









        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    
	
    

    
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>












  













  



  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.js"></script>
  

  
  
    <script type="text/javascript" src="/lib/reading_progress/reading_progress.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=6.4.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=6.4.1"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=6.4.1"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=6.4.1"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=6.4.1"></script>



  

  
    <script id="dsq-count-scr" src="https://zjyzy.disqus.com/count.js" async></script>
  

  
    <script type="text/javascript">
      var disqus_config = function () {
        this.page.url = 'http://hackycy.github.io/2020/08/26/egg-core源码分析/';
        this.page.identifier = '2020/08/26/egg-core源码分析/';
        this.page.title = 'egg-core源码分析';
        };
      function loadComments () {
        var d = document, s = d.createElement('script');
        s.src = 'https://zjyzy.disqus.com/embed.js';
        s.setAttribute('data-timestamp', '' + +new Date());
        (d.head || d.body).appendChild(s);
      }
      
        loadComments();
      
    </script>
  












  





  

  

  

  
  

  
  

  


  
  

  

  

  

  

  
  <style>
    .copy-btn {
      display: inline-block;
      padding: 6px 12px;
      font-size: 13px;
      font-weight: 700;
      line-height: 20px;
      color: #333;
      white-space: nowrap;
      vertical-align: middle;
      cursor: pointer;
      background-color: #eee;
      background-image: linear-gradient(#fcfcfc, #eee);
      border: 1px solid #d5d5d5;
      border-radius: 3px;
      user-select: none;
      outline: 0;
    }

    .highlight-wrap .copy-btn {
      transition: opacity .3s ease-in-out;
      opacity: 0;
      padding: 2px 6px;
      position: absolute;
      right: 4px;
      top: 8px;
    }

    .highlight-wrap:hover .copy-btn,
    .highlight-wrap .copy-btn:focus {
      opacity: 1
    }

    .highlight-wrap {
      position: relative;
    }
  </style>
  <script>
    $('.highlight').each(function (i, e) {
      var $wrap = $('<div>').addClass('highlight-wrap')
      $(e).after($wrap)
      $wrap.append($('<button>').addClass('copy-btn').append('复制').on('click', function (e) {
        var code = $(this).parent().find('.code').find('.line').map(function (i, e) {
          return $(e).text()
        }).toArray().join('\n')
        var ta = document.createElement('textarea')
        document.body.appendChild(ta)
        ta.style.position = 'absolute'
        ta.style.top = '0px'
        ta.style.left = '0px'
        ta.value = code
        ta.select()
        ta.focus()
        var result = document.execCommand('copy')
        document.body.removeChild(ta)
        
          if(result)$(this).text('复制成功')
          else $(this).text('复制失败')
        
        $(this).blur()
      })).on('mouseleave', function (e) {
        var $b = $(this).find('.copy-btn')
        setTimeout(function () {
          $b.text('复制')
        }, 300)
      }).append(e)
    })
  </script>


<!-- ҳ����С���� --> 
<script type="text/javascript" src="/js/src/love.js"></script>
</body>
</html>
